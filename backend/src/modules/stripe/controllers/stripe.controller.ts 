// src/modules/stripe/controllers/stripe.controller.ts
// backend/src/modules/stripe/controllers/stripe.controller.ts
import { 
  Controller, 
  Post, 
  Get, 
  Body, 
  Param, 
  UseGuards,
  Logger,
  BadRequestException 
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../../auth/decorators/current-user.decorator';
import { StripeService } from '../stripe.service';

// ‚úÖ DTOs para los nuevos endpoints
interface CreatePaymentIntentDto {
  amount: number;
  currency: string;
  cartItems: any[];
  customerInfo: {
    email: string;
    name: string;
    address?: any;
  };
}

interface PaymentDetailsResponse {
  paymentId: string;
  amount: number;
  status: string;
  orderItems: any[];
  customerEmail: string;
}

@ApiTags('stripe')
@Controller('api/payments/stripe')
export class StripeController {
  private readonly logger = new Logger(StripeController.name);

  constructor(private readonly stripeService: StripeService) {}

  /**
   * üÜï ENDPOINT CR√çTICO: Crear Payment Intent para el checkout
   */
  @Post('create-intent')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'Create payment intent for checkout',
    description: 'Creates a Stripe payment intent for processing card payments'
  })
  @ApiResponse({ status: 201, description: 'Payment intent created successfully' })
  @ApiResponse({ status: 400, description: 'Invalid request data' })
  async createPaymentIntent(
    @Body() createIntentDto: CreatePaymentIntentDto,
    @CurrentUser() user: any,
  ) {
    try {
      this.logger.log(`Creating payment intent for user ${user.id}, amount: ${createIntentDto.amount}`);

      // Validaciones b√°sicas
      if (!createIntentDto.amount || createIntentDto.amount <= 0) {
        throw new BadRequestException('Amount must be greater than 0');
      }

      if (!createIntentDto.cartItems || createIntentDto.cartItems.length === 0) {
        throw new BadRequestException('Cart items are required');
      }

      // Crear el Payment Intent
      const paymentIntent = await this.stripeService.stripe.paymentIntents.create({
        amount: Math.round(createIntentDto.amount * 100), // Convertir a centavos
        currency: createIntentDto.currency.toLowerCase(),
        customer_email: createIntentDto.customerInfo.email,
        metadata: {
          userId: user.id,
          customerName: createIntentDto.customerInfo.name,
          itemCount: createIntentDto.cartItems.length.toString(),
        },
        // Configurar para que se confirme autom√°ticamente
        confirmation_method: 'manual',
        confirm: false,
      });

      this.logger.log(`Payment intent created: ${paymentIntent.id}`);

      return {
        success: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
      };

    } catch (error) {
      this.logger.error(`Failed to create payment intent: ${error.message}`);
      throw new BadRequestException(`Failed to create payment intent: ${error.message}`);
    }
  }

  /**
   * üÜï ENDPOINT CR√çTICO: Obtener detalles de pago para p√°gina de √©xito
   */
  @Get('payment-details/:paymentId')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'Get payment details',
    description: 'Retrieves payment details for confirmation page'
  })
  @ApiResponse({ status: 200, description: 'Payment details retrieved successfully' })
  @ApiResponse({ status: 404, description: 'Payment not found' })
  async getPaymentDetails(
    @Param('paymentId') paymentId: string,
    @CurrentUser() user: any,
  ): Promise<PaymentDetailsResponse> {
    try {
      this.logger.log(`Getting payment details for ${paymentId}`);

      // Recuperar el Payment Intent de Stripe
      const paymentIntent = await this.stripeService.retrievePaymentIntent(paymentId);

      if (!paymentIntent) {
        throw new BadRequestException('Payment intent not found');
      }

      // Verificar que el payment intent pertenece al usuario
      if (paymentIntent.metadata?.userId !== user.id) {
        throw new BadRequestException('Unauthorized access to payment details');
      }

      // Construir respuesta
      const response: PaymentDetailsResponse = {
        paymentId: paymentIntent.id,
        amount: paymentIntent.amount / 100, // Convertir de centavos
        status: paymentIntent.status,
        customerEmail: paymentIntent.metadata?.customerEmail || user.email,
        orderItems: [
          // Por ahora datos mock, en producci√≥n deber√≠as obtener esto de la base de datos
          {
            productTitle: `Compra de ${paymentIntent.metadata?.itemCount || '1'} producto(s)`,
            seller: 'Varios vendedores',
            price: paymentIntent.amount / 100,
          }
        ],
      };

      return response;

    } catch (error) {
      this.logger.error(`Failed to get payment details: ${error.message}`);
      throw new BadRequestException(`Failed to get payment details: ${error.message}`);
    }
  }

  /**
   * üîß Test endpoint para verificar conectividad con Stripe
   */
  @Get('test')
  @ApiOperation({ 
    summary: 'Test Stripe connectivity',
    description: 'Tests connection to Stripe API'
  })
  async testStripeConnection() {
    try {
      // Hacer una llamada simple a Stripe para verificar conectividad
      const balance = await this.stripeService.stripe.balance.retrieve();
      
      return {
        success: true,
        message: 'Stripe connection successful',
        balance: balance.available[0]?.amount || 0,
        currency: balance.available[0]?.currency || 'usd',
        timestamp: new Date().toISOString(),
      };

    } catch (error) {
      this.logger.error(`Stripe connection test failed: ${error.message}`);
      return {
        success: false,
        message: 'Stripe connection failed',
        error: error.message,
        timestamp: new Date().toISOString(),
      };
    }
  }
}