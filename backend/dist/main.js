/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core_1 = __webpack_require__(1);
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const swagger_1 = __webpack_require__(4);
const helmet_1 = __importDefault(__webpack_require__(5));
const app_module_1 = __webpack_require__(6);
const compression = __webpack_require__(306);
const cookieParser = __webpack_require__(307);
async function bootstrap() {
    const app = await core_1.NestFactory.create(app_module_1.AppModule);
    const configService = app.get(config_1.ConfigService);
    const logger = new common_1.Logger('Bootstrap');
    const port = configService.get('PORT', 3002);
    app.use((0, helmet_1.default)({
        crossOriginEmbedderPolicy: false,
    }));
    app.use(compression());
    app.use(cookieParser());
    const getCodespaceUrl = (portNumber) => {
        if (process.env.CODESPACE_NAME && process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN) {
            return `https://${process.env.CODESPACE_NAME}-${portNumber}.${process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN}`;
        }
        return `http://localhost:${portNumber}`;
    };
    const backendUrl = getCodespaceUrl(port);
    const frontendUrl = getCodespaceUrl(3000);
    const corsOrigin = configService.get('CORS_ORIGIN');
    logger.debug('üîç CORS Debug:');
    logger.debug(`Environment CORS_ORIGIN: ${corsOrigin}`);
    logger.debug(`Calculated Frontend URL: ${frontendUrl}`);
    logger.debug(`Backend URL: ${backendUrl}`);
    logger.debug(`NODE_ENV: ${configService.get('NODE_ENV')}`);
    const allowedOrigins = [
        frontendUrl,
        'http://localhost:3000',
        'https://localhost:3000',
        'http://localhost:3001',
        'https://localhost:3001',
    ];
    if (corsOrigin) {
        allowedOrigins.push(corsOrigin);
    }
    logger.debug(`üåê Allowed CORS origins: ${JSON.stringify(allowedOrigins)}`);
    app.enableCors({
        origin: [
            'http://localhost:3000',
            'https://probable-barnacle-65pw9jg5qwxc5w6-3000.app.github.dev',
            configService.get('CORS_ORIGIN', 'https://probable-barnacle-65pw9jg5qwxc5w6-3000.app.github.dev')
        ],
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
        allowedHeaders: [
            'Origin',
            'X-Requested-With',
            'Content-Type',
            'Accept',
            'Authorization',
            'Cache-Control',
        ],
    });
    const apiPrefix = configService.get('API_PREFIX', 'api');
    app.setGlobalPrefix(apiPrefix);
    app.useGlobalPipes(new common_1.ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
        transformOptions: {
            enableImplicitConversion: true,
        },
        disableErrorMessages: configService.get('NODE_ENV') === 'production',
    }));
    if (configService.get('NODE_ENV') === 'development') {
        app.use((req, res, next) => {
            const origin = req.get('Origin') || 'None';
            const method = req.method;
            const url = req.url;
            logger.debug(`üì° ${method} ${url} - Origin: ${origin}`);
            if (method === 'OPTIONS') {
                logger.debug(`üîç PREFLIGHT REQUEST detected for ${url}`);
                logger.debug(`üîç Access-Control-Request-Method: ${req.get('Access-Control-Request-Method')}`);
                logger.debug(`üîç Access-Control-Request-Headers: ${req.get('Access-Control-Request-Headers')}`);
            }
            next();
        });
    }
    if (configService.get('NODE_ENV') !== 'production') {
        const config = new swagger_1.DocumentBuilder()
            .setTitle('Furnibles API')
            .setDescription('Marketplace C2C de planos digitales de muebles')
            .setVersion('1.0')
            .addServer(backendUrl, 'Development Server')
            .addBearerAuth({
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT',
            name: 'JWT',
            description: 'Enter JWT token',
            in: 'header',
        }, 'JWT-auth')
            .addTag('auth', 'Authentication endpoints')
            .addTag('users', 'User management')
            .addTag('products', 'Product management')
            .addTag('orders', 'Order management')
            .addTag('payments', 'Payment processing')
            .addTag('downloads', 'File downloads')
            .addTag('reviews', 'Product reviews')
            .addTag('admin', 'Admin functions')
            .build();
        const document = swagger_1.SwaggerModule.createDocument(app, config);
        swagger_1.SwaggerModule.setup(`${apiPrefix}/docs`, app, document, {
            swaggerOptions: {
                persistAuthorization: true,
                tryItOutEnabled: true,
            },
            customSiteTitle: 'Furnibles API Documentation',
        });
        logger.log(`üìö Swagger documentation available at ${backendUrl}/${apiPrefix}/docs`);
    }
    logger.log('üß™ PRUEBA: Este es el c√≥digo que se est√° ejecutando');
    await app.listen(port, '0.0.0.0');
    logger.log(`üöÄ Furnibles API running on ${backendUrl}`);
    logger.log(`üìö API documentation: ${backendUrl}/${apiPrefix}/docs`);
    logger.log(`üåç Environment: ${configService.get('NODE_ENV', 'development')}`);
    logger.log(`üîó Frontend URL: ${frontendUrl}`);
    if (process.env.CODESPACE_NAME) {
        logger.log(`üöÄ Codespace detected: ${process.env.CODESPACE_NAME}`);
        logger.log(`üåê Port forwarding domain: ${process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN}`);
        logger.log(`‚úÖ CORS configured for Codespace subdomain matching`);
    }
    logger.log(`üíö Health check: ${backendUrl}/${apiPrefix}/health`);
    logger.log(`üè† Root endpoint: ${backendUrl}/`);
}
bootstrap().catch((error) => {
    console.error('Error starting application:', error);
    process.exit(1);
});


/***/ }),
/* 1 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/core");

/***/ }),
/* 2 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/common");

/***/ }),
/* 3 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/config");

/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/swagger");

/***/ }),
/* 5 */
/***/ ((module) => {

"use strict";
module.exports = require("helmet");

/***/ }),
/* 6 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppModule = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const core_1 = __webpack_require__(1);
const throttler_1 = __webpack_require__(7);
const schedule_1 = __webpack_require__(8);
const prisma_module_1 = __webpack_require__(9);
const auth_module_1 = __webpack_require__(12);
const users_module_1 = __webpack_require__(28);
const products_module_1 = __webpack_require__(36);
const files_module_1 = __webpack_require__(44);
const cart_module_1 = __webpack_require__(211);
const fees_module_1 = __webpack_require__(219);
const orders_module_1 = __webpack_require__(221);
const checkout_module_1 = __webpack_require__(240);
const downloads_module_1 = __webpack_require__(247);
const notifications_module_1 = __webpack_require__(235);
const webhook_module_1 = __webpack_require__(251);
const stripe_module_1 = __webpack_require__(246);
const websocket_module_1 = __webpack_require__(239);
const email_module_1 = __webpack_require__(238);
const cron_module_1 = __webpack_require__(261);
const admin_module_1 = __webpack_require__(263);
const payments_module_1 = __webpack_require__(255);
const payouts_module_1 = __webpack_require__(272);
const transactions_module_1 = __webpack_require__(278);
const invoices_module_1 = __webpack_require__(282);
const analytics_module_1 = __webpack_require__(286);
const health_controller_1 = __webpack_require__(302);
const sellers_module_1 = __webpack_require__(303);
let AppModule = class AppModule {
};
exports.AppModule = AppModule;
exports.AppModule = AppModule = __decorate([
    (0, common_1.Module)({
        imports: [
            config_1.ConfigModule.forRoot({
                isGlobal: true,
                envFilePath: ['.env.local', '.env'],
            }),
            throttler_1.ThrottlerModule.forRoot([
                {
                    ttl: 60000,
                    limit: 100,
                },
            ]),
            schedule_1.ScheduleModule.forRoot(),
            prisma_module_1.PrismaModule,
            auth_module_1.AuthModule,
            users_module_1.UsersModule,
            products_module_1.ProductsModule,
            files_module_1.FilesModule,
            cart_module_1.CartModule,
            fees_module_1.FeesModule,
            orders_module_1.OrdersModule,
            checkout_module_1.CheckoutModule,
            downloads_module_1.DownloadsModule,
            notifications_module_1.NotificationModule,
            webhook_module_1.WebhookModule,
            stripe_module_1.StripeModule,
            websocket_module_1.WebSocketModule,
            email_module_1.EmailModule,
            cron_module_1.CronModule,
            admin_module_1.AdminModule,
            payments_module_1.PaymentsModule,
            payouts_module_1.PayoutsModule,
            transactions_module_1.TransactionsModule,
            invoices_module_1.InvoicesModule,
            analytics_module_1.AnalyticsModule,
            sellers_module_1.SellersModule,
        ],
        controllers: [health_controller_1.HealthController],
        providers: [
            {
                provide: core_1.APP_GUARD,
                useClass: throttler_1.ThrottlerGuard,
            },
        ],
    })
], AppModule);


/***/ }),
/* 7 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/throttler");

/***/ }),
/* 8 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/schedule");

/***/ }),
/* 9 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrismaModule = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
let PrismaModule = class PrismaModule {
};
exports.PrismaModule = PrismaModule;
exports.PrismaModule = PrismaModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        providers: [prisma_service_1.PrismaService],
        exports: [prisma_service_1.PrismaService],
    })
], PrismaModule);


/***/ }),
/* 10 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrismaService = void 0;
const common_1 = __webpack_require__(2);
const client_1 = __webpack_require__(11);
let PrismaService = class PrismaService extends client_1.PrismaClient {
    async onModuleInit() {
        await this.$connect();
    }
    async onModuleDestroy() {
        await this.$disconnect();
    }
};
exports.PrismaService = PrismaService;
exports.PrismaService = PrismaService = __decorate([
    (0, common_1.Injectable)()
], PrismaService);


/***/ }),
/* 11 */
/***/ ((module) => {

"use strict";
module.exports = require("@prisma/client");

/***/ }),
/* 12 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthModule = void 0;
const common_1 = __webpack_require__(2);
const jwt_1 = __webpack_require__(13);
const passport_1 = __webpack_require__(14);
const config_1 = __webpack_require__(3);
const core_1 = __webpack_require__(1);
const auth_service_1 = __webpack_require__(15);
const auth_controller_1 = __webpack_require__(21);
const token_blacklist_service_1 = __webpack_require__(20);
const token_blacklist_interceptor_1 = __webpack_require__(27);
const users_module_1 = __webpack_require__(28);
const jwt_strategy_1 = __webpack_require__(32);
const local_strategy_1 = __webpack_require__(34);
let AuthModule = class AuthModule {
};
exports.AuthModule = AuthModule;
exports.AuthModule = AuthModule = __decorate([
    (0, common_1.Module)({
        imports: [
            passport_1.PassportModule,
            jwt_1.JwtModule.registerAsync({
                imports: [config_1.ConfigModule],
                useFactory: async (configService) => ({
                    secret: configService.get('JWT_SECRET'),
                    signOptions: {
                        expiresIn: configService.get('JWT_EXPIRES_IN', '7d'),
                    },
                }),
                inject: [config_1.ConfigService],
            }),
            users_module_1.UsersModule,
        ],
        controllers: [auth_controller_1.AuthController],
        providers: [
            auth_service_1.AuthService,
            token_blacklist_service_1.TokenBlacklistService,
            jwt_strategy_1.JwtStrategy,
            local_strategy_1.LocalStrategy,
            {
                provide: core_1.APP_INTERCEPTOR,
                useClass: token_blacklist_interceptor_1.TokenBlacklistInterceptor,
            },
        ],
        exports: [auth_service_1.AuthService, token_blacklist_service_1.TokenBlacklistService],
    })
], AuthModule);


/***/ }),
/* 13 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/jwt");

/***/ }),
/* 14 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/passport");

/***/ }),
/* 15 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthService = void 0;
const common_1 = __webpack_require__(2);
const jwt_1 = __webpack_require__(13);
const config_1 = __webpack_require__(3);
const users_service_1 = __webpack_require__(16);
const bcrypt = __importStar(__webpack_require__(18));
const uuid_1 = __webpack_require__(19);
const token_blacklist_service_1 = __webpack_require__(20);
let AuthService = class AuthService {
    constructor(usersService, jwtService, configService, tokenBlacklistService) {
        this.usersService = usersService;
        this.jwtService = jwtService;
        this.configService = configService;
        this.tokenBlacklistService = tokenBlacklistService;
    }
    async validateUser(email, password) {
        const user = await this.usersService.findByEmailWithPassword(email);
        if (user && await bcrypt.compare(password, user.password)) {
            const { password, ...result } = user;
            return result;
        }
        return null;
    }
    async login(loginDto) {
        const user = await this.validateUser(loginDto.email, loginDto.password);
        if (!user) {
            throw new common_1.UnauthorizedException('Invalid credentials');
        }
        if (!user.emailVerified) {
            throw new common_1.UnauthorizedException('Please verify your email');
        }
        if (!user.isActive) {
            throw new common_1.UnauthorizedException('Account is inactive');
        }
        const fullUser = await this.usersService.findById(user.id);
        await this.usersService.updateLastLogin(fullUser.id);
        const payload = {
            sub: fullUser.id,
            email: fullUser.email,
            role: fullUser.role,
        };
        return {
            success: true,
            message: 'Login successful',
            data: {
                token: this.jwtService.sign(payload),
                refreshToken: this.jwtService.sign(payload, {
                    expiresIn: this.configService.get('REFRESH_TOKEN_EXPIRES_IN', '7d'),
                }),
                expiresIn: 24 * 60 * 60,
                user: {
                    id: fullUser.id,
                    email: fullUser.email,
                    firstName: fullUser.firstName,
                    lastName: fullUser.lastName,
                    role: fullUser.role,
                    status: fullUser.isActive ? 'ACTIVE' : 'INACTIVE',
                },
            },
        };
    }
    async register(registerDto) {
        const hashedPassword = await bcrypt.hash(registerDto.password, 12);
        const emailVerificationToken = (0, uuid_1.v4)();
        const createdUser = await this.usersService.create({
            ...registerDto,
            password: hashedPassword,
            emailVerificationToken,
        });
        const fullUser = await this.usersService.findByEmail(registerDto.email);
        console.log(`Verification token for ${registerDto.email}: ${emailVerificationToken}`);
        return {
            message: 'User registered successfully. Check console for verification token.',
            userId: fullUser.id,
        };
    }
    async changePassword(userId, changePasswordDto) {
        const user = await this.usersService.findById(userId);
        if (!user) {
            throw new common_1.UnauthorizedException('Usuario no encontrado');
        }
        const isCurrentPasswordValid = await bcrypt.compare(changePasswordDto.currentPassword, user.password);
        if (!isCurrentPasswordValid) {
            throw new common_1.BadRequestException('Contrase√±a actual incorrecta');
        }
        const hashedNewPassword = await bcrypt.hash(changePasswordDto.newPassword, 12);
        await this.usersService.updatePassword(userId, hashedNewPassword);
    }
    async refreshToken(user) {
        const fullUser = await this.usersService.findById(user.id);
        const payload = {
            sub: fullUser.id,
            email: fullUser.email,
            role: fullUser.role,
        };
        return {
            access_token: this.jwtService.sign(payload),
        };
    }
    async logout(token, userId) {
        if (token) {
            await this.tokenBlacklistService.blacklistToken(token, userId);
        }
        return {
            message: 'Sesi√≥n cerrada exitosamente',
        };
    }
    async forgotPassword(email) {
        const user = await this.usersService.findByEmail(email);
        if (!user) {
            return {
                message: 'Si el email existe, recibir√°s instrucciones para restablecer tu contrase√±a',
            };
        }
        const resetToken = (0, uuid_1.v4)();
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + 1);
        await this.usersService.savePasswordResetToken(user.id, resetToken, expiresAt);
        console.log(`Password reset token for ${user.email}: ${resetToken}`);
        return {
            message: 'Si el email existe, recibir√°s instrucciones para restablecer tu contrase√±a',
        };
    }
    async resetPassword(token, newPassword) {
        const user = await this.usersService.findByResetToken(token);
        if (!user) {
            throw new common_1.BadRequestException('Token de recuperaci√≥n inv√°lido o expirado');
        }
        if (user.resetPasswordExpiresAt && user.resetPasswordExpiresAt < new Date()) {
            throw new common_1.BadRequestException('Token de recuperaci√≥n expirado');
        }
        const hashedPassword = await bcrypt.hash(newPassword, 12);
        await this.usersService.resetUserPassword(user.id, hashedPassword);
        return {
            message: 'Contrase√±a restablecida exitosamente',
        };
    }
    async verifyEmail(token) {
        const user = await this.usersService.findByVerificationToken(token);
        if (!user) {
            throw new common_1.BadRequestException('Token de verificaci√≥n inv√°lido o expirado');
        }
        await this.usersService.verifyEmail(user.id);
        return {
            message: 'Email verificado exitosamente',
        };
    }
    async isTokenBlacklisted(token) {
        return this.tokenBlacklistService.isTokenBlacklisted(token);
    }
};
exports.AuthService = AuthService;
exports.AuthService = AuthService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _a : Object, typeof (_b = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object, typeof (_d = typeof token_blacklist_service_1.TokenBlacklistService !== "undefined" && token_blacklist_service_1.TokenBlacklistService) === "function" ? _d : Object])
], AuthService);


/***/ }),
/* 16 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(17);
const client_1 = __webpack_require__(11);
const bcrypt = __importStar(__webpack_require__(18));
let UsersService = class UsersService {
    constructor(prisma) {
        this.prisma = prisma;
    }
    excludeFields(user, keys) {
        const result = { ...user };
        keys.forEach(key => delete result[key]);
        return result;
    }
    async create(createUserData) {
        const existingUser = await this.prisma.user.findUnique({
            where: { email: createUserData.email },
        });
        if (existingUser) {
            throw new common_1.ConflictException('El email ya est√° registrado');
        }
        const user = await this.prisma.user.create({
            data: {
                email: createUserData.email,
                password: createUserData.password,
                firstName: createUserData.firstName,
                lastName: createUserData.lastName,
                role: createUserData.role || client_1.UserRole.BUYER,
                emailVerificationToken: createUserData.emailVerificationToken,
                ...(createUserData.role === client_1.UserRole.SELLER || createUserData.role === client_1.UserRole.ADMIN ? {
                    sellerProfile: {
                        create: {
                            storeName: `${createUserData.firstName} ${createUserData.lastName} Store`,
                            slug: `${createUserData.firstName.toLowerCase()}-${createUserData.lastName.toLowerCase()}-${Date.now()}`,
                        }
                    }
                } : {}),
                ...(createUserData.role === client_1.UserRole.BUYER || createUserData.role === client_1.UserRole.ADMIN ? {
                    buyerProfile: {
                        create: {
                            preferences: {}
                        }
                    }
                } : {}),
            },
            include: {
                sellerProfile: true,
                buyerProfile: true,
            }
        });
        return this.excludeFields(user, ['password', 'emailVerificationToken', 'resetPasswordToken']);
    }
    async findAll(options = {}) {
        const { page = 1, limit = 10, role, isActive } = options;
        const where = {};
        if (role)
            where.role = role;
        if (isActive !== undefined)
            where.isActive = isActive;
        const skip = (page - 1) * limit;
        const [users, total] = await Promise.all([
            this.prisma.user.findMany({
                where,
                skip,
                take: limit,
                orderBy: { createdAt: 'desc' },
                include: {
                    sellerProfile: true,
                    buyerProfile: true,
                },
            }),
            this.prisma.user.count({ where }),
        ]);
        const safeUsers = users.map(user => this.excludeFields(user, ['password', 'emailVerificationToken', 'resetPasswordToken']));
        return {
            data: safeUsers,
            meta: {
                total,
                page,
                limit,
                totalPages: Math.ceil(total / limit),
            },
        };
    }
    async findOne(id) {
        const user = await this.prisma.user.findUnique({
            where: { id },
            include: {
                sellerProfile: true,
                buyerProfile: true,
            },
        });
        if (!user) {
            return null;
        }
        return this.excludeFields(user, ['password', 'emailVerificationToken', 'resetPasswordToken']);
    }
    async findById(id) {
        return this.prisma.user.findUnique({
            where: { id },
        });
    }
    async findByEmail(email) {
        return this.prisma.user.findUnique({
            where: { email },
        });
    }
    async findByEmailWithPassword(email) {
        return this.prisma.user.findUnique({
            where: { email },
        });
    }
    async findByVerificationToken(token) {
        return this.prisma.user.findUnique({
            where: { emailVerificationToken: token },
        });
    }
    async update(id, updateData) {
        const user = await this.prisma.user.findUnique({
            where: { id },
        });
        if (!user) {
            throw new common_1.NotFoundException('Usuario no encontrado');
        }
        const updatedUser = await this.prisma.user.update({
            where: { id },
            data: updateData,
            include: {
                sellerProfile: true,
                buyerProfile: true,
            },
        });
        return this.excludeFields(updatedUser, ['password', 'emailVerificationToken', 'resetPasswordToken']);
    }
    async updatePassword(id, hashedPassword) {
        await this.prisma.user.update({
            where: { id },
            data: { password: hashedPassword },
        });
    }
    async updateLastLogin(id) {
        await this.prisma.user.update({
            where: { id },
            data: { lastLoginAt: new Date() },
        });
    }
    async verifyEmail(id) {
        await this.prisma.user.update({
            where: { id },
            data: {
                emailVerified: true,
                emailVerifiedAt: new Date(),
                emailVerificationToken: null,
                isActive: true,
            },
        });
    }
    async updateStatus(id, isActive) {
        const user = await this.prisma.user.findUnique({
            where: { id },
        });
        if (!user) {
            throw new common_1.NotFoundException('Usuario no encontrado');
        }
        const updatedUser = await this.prisma.user.update({
            where: { id },
            data: { isActive },
            include: {
                sellerProfile: true,
                buyerProfile: true,
            },
        });
        return this.excludeFields(updatedUser, ['password', 'emailVerificationToken', 'resetPasswordToken']);
    }
    async remove(id) {
        const user = await this.prisma.user.findUnique({
            where: { id },
        });
        if (!user) {
            throw new common_1.NotFoundException('Usuario no encontrado');
        }
        await this.prisma.user.delete({
            where: { id },
        });
    }
    async savePasswordResetToken(userId, token, expiresAt) {
        await this.prisma.user.update({
            where: { id: userId },
            data: {
                resetPasswordToken: token,
                resetPasswordExpiresAt: expiresAt,
            },
        });
    }
    async findByResetToken(token) {
        return this.prisma.user.findUnique({
            where: { resetPasswordToken: token },
        });
    }
    async resetUserPassword(userId, hashedPassword) {
        await this.prisma.user.update({
            where: { id: userId },
            data: {
                password: hashedPassword,
                resetPasswordToken: null,
                resetPasswordExpiresAt: null,
            },
        });
    }
    async validateUserPassword(email, password) {
        const user = await this.findByEmailWithPassword(email);
        if (!user) {
            return null;
        }
        const isPasswordValid = await bcrypt.compare(password, user.password);
        if (!isPasswordValid) {
            return null;
        }
        return this.excludeFields(user, ['password', 'emailVerificationToken', 'resetPasswordToken']);
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object])
], UsersService);


/***/ }),
/* 17 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrismaService = void 0;
const common_1 = __webpack_require__(2);
const client_1 = __webpack_require__(11);
let PrismaService = class PrismaService extends client_1.PrismaClient {
    async onModuleInit() {
        await this.$connect();
    }
};
exports.PrismaService = PrismaService;
exports.PrismaService = PrismaService = __decorate([
    (0, common_1.Injectable)()
], PrismaService);


/***/ }),
/* 18 */
/***/ ((module) => {

"use strict";
module.exports = require("bcryptjs");

/***/ }),
/* 19 */
/***/ ((module) => {

"use strict";
module.exports = require("uuid");

/***/ }),
/* 20 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenBlacklistService = void 0;
const common_1 = __webpack_require__(2);
const jwt_1 = __webpack_require__(13);
let TokenBlacklistService = class TokenBlacklistService {
    constructor(jwtService) {
        this.jwtService = jwtService;
        this.blacklistedTokens = new Map();
        setInterval(() => this.cleanupExpiredTokens(), 60 * 60 * 1000);
    }
    async blacklistToken(token, userId) {
        try {
            const decoded = this.jwtService.decode(token);
            const expiresAt = new Date(decoded.exp * 1000);
            this.blacklistedTokens.set(token, { userId, expiresAt });
            const timeUntilExpiration = expiresAt.getTime() - Date.now();
            if (timeUntilExpiration > 0) {
                setTimeout(() => {
                    this.blacklistedTokens.delete(token);
                }, timeUntilExpiration);
            }
        }
        catch (error) {
            console.error('Error blacklisting token:', error);
        }
    }
    async isTokenBlacklisted(token) {
        try {
            const blacklistedData = this.blacklistedTokens.get(token);
            if (!blacklistedData) {
                return false;
            }
            if (blacklistedData.expiresAt < new Date()) {
                this.blacklistedTokens.delete(token);
                return false;
            }
            return true;
        }
        catch (error) {
            console.error('Error checking blacklist:', error);
            return false;
        }
    }
    cleanupExpiredTokens() {
        try {
            const now = new Date();
            const expiredTokens = [];
            for (const [token, data] of this.blacklistedTokens.entries()) {
                if (data.expiresAt < now) {
                    expiredTokens.push(token);
                }
            }
            expiredTokens.forEach(token => {
                this.blacklistedTokens.delete(token);
            });
            if (expiredTokens.length > 0) {
                console.log(`Cleaned up ${expiredTokens.length} expired tokens`);
            }
        }
        catch (error) {
            console.error('Error cleaning up expired tokens:', error);
        }
    }
    getBlacklistSize() {
        return this.blacklistedTokens.size;
    }
    clearBlacklist() {
        this.blacklistedTokens.clear();
    }
};
exports.TokenBlacklistService = TokenBlacklistService;
exports.TokenBlacklistService = TokenBlacklistService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object])
], TokenBlacklistService);


/***/ }),
/* 21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const auth_service_1 = __webpack_require__(15);
const auth_dto_1 = __webpack_require__(22);
const auth_dto_2 = __webpack_require__(22);
const auth_dto_3 = __webpack_require__(22);
const jwt_auth_guard_1 = __webpack_require__(24);
const public_decorator_1 = __webpack_require__(25);
const current_user_decorator_1 = __webpack_require__(26);
let AuthController = class AuthController {
    constructor(authService) {
        this.authService = authService;
    }
    async login(loginDto) {
        return this.authService.login(loginDto);
    }
    async register(registerDto) {
        return this.authService.register(registerDto);
    }
    async changePassword(userId, changePasswordDto) {
        await this.authService.changePassword(userId, changePasswordDto);
        return { message: 'Contrase√±a cambiada exitosamente' };
    }
    async refresh(user) {
        return this.authService.refreshToken(user);
    }
    async getProfile(user) {
        return user;
    }
    async logout(userId, req) {
        const token = req.headers.authorization?.replace('Bearer ', '');
        return this.authService.logout(token, userId);
    }
    async forgotPassword(email) {
        return this.authService.forgotPassword(email);
    }
    async resetPassword(token, newPassword) {
        return this.authService.resetPassword(token, newPassword);
    }
    async verifyEmail(token) {
        return this.authService.verifyEmail(token);
    }
};
exports.AuthController = AuthController;
__decorate([
    (0, public_decorator_1.Public)(),
    (0, common_1.Post)('login'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'User login' }),
    (0, swagger_1.ApiBody)({ type: auth_dto_1.LoginDto }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Login successful',
        schema: {
            type: 'object',
            properties: {
                token: { type: 'string' },
                user: {
                    type: 'object',
                    properties: {
                        id: { type: 'string' },
                        email: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        role: { type: 'string' },
                        status: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Invalid credentials' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof auth_dto_1.LoginDto !== "undefined" && auth_dto_1.LoginDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "login", null);
__decorate([
    (0, public_decorator_1.Public)(),
    (0, common_1.Post)('register'),
    (0, swagger_1.ApiOperation)({ summary: 'User registration' }),
    (0, swagger_1.ApiBody)({ type: auth_dto_2.RegisterDto }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Registration successful',
        schema: {
            type: 'object',
            properties: {
                access_token: { type: 'string' },
                user: {
                    type: 'object',
                    properties: {
                        id: { type: 'number' },
                        email: { type: 'string' },
                        firstName: { type: 'string' },
                        lastName: { type: 'string' },
                        role: { type: 'string' },
                        status: { type: 'string' },
                    },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Email already exists' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof auth_dto_2.RegisterDto !== "undefined" && auth_dto_2.RegisterDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "register", null);
__decorate([
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, common_1.Post)('change-password'),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Change user password' }),
    (0, swagger_1.ApiBody)({ type: auth_dto_3.ChangePasswordDto }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Password changed successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid current password' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_d = typeof auth_dto_3.ChangePasswordDto !== "undefined" && auth_dto_3.ChangePasswordDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "changePassword", null);
__decorate([
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, common_1.Post)('refresh'),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Refresh access token' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Token refreshed successfully',
        schema: {
            type: 'object',
            properties: {
                access_token: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "refresh", null);
__decorate([
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, common_1.Get)('profile'),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Get current user profile' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Profile retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                id: { type: 'number' },
                email: { type: 'string' },
                firstName: { type: 'string' },
                lastName: { type: 'string' },
                role: { type: 'string' },
                status: { type: 'string' },
                phone: { type: 'string' },
                address: { type: 'string' },
                avatar: { type: 'string' },
                createdAt: { type: 'string' },
                updatedAt: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "getProfile", null);
__decorate([
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, common_1.Post)('logout'),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'User logout' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Logout successful' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('id')),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "logout", null);
__decorate([
    (0, public_decorator_1.Public)(),
    (0, common_1.Post)('forgot-password'),
    (0, swagger_1.ApiOperation)({ summary: 'Request password reset' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                email: { type: 'string', format: 'email' },
            },
            required: ['email'],
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Password reset email sent' }),
    __param(0, (0, common_1.Body)('email')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "forgotPassword", null);
__decorate([
    (0, public_decorator_1.Public)(),
    (0, common_1.Post)('reset-password'),
    (0, swagger_1.ApiOperation)({ summary: 'Reset password with token' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                token: { type: 'string' },
                newPassword: { type: 'string', minLength: 8 },
            },
            required: ['token', 'newPassword'],
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Password reset successful' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid or expired token' }),
    __param(0, (0, common_1.Body)('token')),
    __param(1, (0, common_1.Body)('newPassword')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "resetPassword", null);
__decorate([
    (0, public_decorator_1.Public)(),
    (0, common_1.Post)('verify-email'),
    (0, swagger_1.ApiOperation)({ summary: 'Verify email with token' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                token: { type: 'string' },
            },
            required: ['token'],
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Email verified successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid or expired token' }),
    __param(0, (0, common_1.Body)('token')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AuthController.prototype, "verifyEmail", null);
exports.AuthController = AuthController = __decorate([
    (0, swagger_1.ApiTags)('auth'),
    (0, common_1.Controller)('auth'),
    __metadata("design:paramtypes", [typeof (_a = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _a : Object])
], AuthController);


/***/ }),
/* 22 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserDto = exports.CreateUserDto = exports.ChangePasswordDto = exports.RegisterDto = exports.LoginDto = exports.PasswordDto = exports.EmailDto = void 0;
const swagger_1 = __webpack_require__(4);
const class_validator_1 = __webpack_require__(23);
const client_1 = __webpack_require__(11);
class EmailDto {
}
exports.EmailDto = EmailDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User email address', example: 'user@example.com' }),
    (0, class_validator_1.IsEmail)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], EmailDto.prototype, "email", void 0);
class PasswordDto {
}
exports.PasswordDto = PasswordDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User password', example: 'StrongPassword123!', minLength: 8 }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8),
    __metadata("design:type", String)
], PasswordDto.prototype, "password", void 0);
class LoginDto extends EmailDto {
}
exports.LoginDto = LoginDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User password', example: 'password123' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], LoginDto.prototype, "password", void 0);
class RegisterDto extends EmailDto {
}
exports.RegisterDto = RegisterDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User password', example: 'StrongPassword123!', minLength: 8 }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8),
    __metadata("design:type", String)
], RegisterDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User first name', example: 'John' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], RegisterDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User last name', example: 'Doe' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], RegisterDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'User role',
        enum: client_1.UserRole,
        default: client_1.UserRole.BUYER,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.UserRole),
    __metadata("design:type", typeof (_a = typeof client_1.UserRole !== "undefined" && client_1.UserRole) === "function" ? _a : Object)
], RegisterDto.prototype, "role", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'User phone number', example: '+1234567890' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsPhoneNumber)(),
    __metadata("design:type", String)
], RegisterDto.prototype, "phone", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'User address', example: '123 Main St, City, Country' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(500),
    __metadata("design:type", String)
], RegisterDto.prototype, "address", void 0);
class ChangePasswordDto {
}
exports.ChangePasswordDto = ChangePasswordDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Current password', example: 'currentPassword123' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ChangePasswordDto.prototype, "currentPassword", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'New password', example: 'newPassword123!', minLength: 8 }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8),
    __metadata("design:type", String)
], ChangePasswordDto.prototype, "newPassword", void 0);
class CreateUserDto extends RegisterDto {
}
exports.CreateUserDto = CreateUserDto;
class UpdateUserDto extends (0, swagger_1.PartialType)((0, swagger_1.OmitType)(RegisterDto, ['email', 'password'])) {
}
exports.UpdateUserDto = UpdateUserDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'User avatar URL', example: 'https://example.com/avatar.jpg' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUserDto.prototype, "avatar", void 0);


/***/ }),
/* 23 */
/***/ ((module) => {

"use strict";
module.exports = require("class-validator");

/***/ }),
/* 24 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtAuthGuard = void 0;
const common_1 = __webpack_require__(2);
const passport_1 = __webpack_require__(14);
const core_1 = __webpack_require__(1);
const public_decorator_1 = __webpack_require__(25);
let JwtAuthGuard = class JwtAuthGuard extends (0, passport_1.AuthGuard)('jwt') {
    constructor(reflector) {
        super();
        this.reflector = reflector;
    }
    canActivate(context) {
        const request = context.switchToHttp().getRequest();
        if (request.method === 'OPTIONS') {
            return true;
        }
        const isPublic = this.reflector.getAllAndOverride(public_decorator_1.IS_PUBLIC_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (isPublic) {
            return true;
        }
        return super.canActivate(context);
    }
    handleRequest(err, user, info) {
        if (err || !user) {
            throw err || new common_1.UnauthorizedException('Token inv√°lido o expirado');
        }
        return user;
    }
};
exports.JwtAuthGuard = JwtAuthGuard;
exports.JwtAuthGuard = JwtAuthGuard = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object])
], JwtAuthGuard);


/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Public = exports.IS_PUBLIC_KEY = void 0;
const common_1 = __webpack_require__(2);
exports.IS_PUBLIC_KEY = 'isPublic';
const Public = () => (0, common_1.SetMetadata)(exports.IS_PUBLIC_KEY, true);
exports.Public = Public;


/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurrentUser = void 0;
const common_1 = __webpack_require__(2);
exports.CurrentUser = (0, common_1.createParamDecorator)((data, ctx) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;
    return data ? user?.[data] : user;
});


/***/ }),
/* 27 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenBlacklistInterceptor = void 0;
const common_1 = __webpack_require__(2);
const core_1 = __webpack_require__(1);
const token_blacklist_service_1 = __webpack_require__(20);
const public_decorator_1 = __webpack_require__(25);
let TokenBlacklistInterceptor = class TokenBlacklistInterceptor {
    constructor(tokenBlacklistService, reflector) {
        this.tokenBlacklistService = tokenBlacklistService;
        this.reflector = reflector;
    }
    async intercept(context, next) {
        const request = context.switchToHttp().getRequest();
        if (request.method === 'OPTIONS') {
            return next.handle();
        }
        const isPublic = this.reflector.getAllAndOverride(public_decorator_1.IS_PUBLIC_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (isPublic) {
            return next.handle();
        }
        const authHeader = request.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const token = authHeader.replace('Bearer ', '');
            const isBlacklisted = await this.tokenBlacklistService.isTokenBlacklisted(token);
            if (isBlacklisted) {
                throw new common_1.UnauthorizedException('Token ha sido revocado');
            }
        }
        return next.handle();
    }
};
exports.TokenBlacklistInterceptor = TokenBlacklistInterceptor;
exports.TokenBlacklistInterceptor = TokenBlacklistInterceptor = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof token_blacklist_service_1.TokenBlacklistService !== "undefined" && token_blacklist_service_1.TokenBlacklistService) === "function" ? _a : Object, typeof (_b = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _b : Object])
], TokenBlacklistInterceptor);


/***/ }),
/* 28 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersModule = void 0;
const common_1 = __webpack_require__(2);
const users_service_1 = __webpack_require__(16);
const users_controller_1 = __webpack_require__(29);
const prisma_service_1 = __webpack_require__(17);
let UsersModule = class UsersModule {
};
exports.UsersModule = UsersModule;
exports.UsersModule = UsersModule = __decorate([
    (0, common_1.Module)({
        controllers: [users_controller_1.UsersController],
        providers: [users_service_1.UsersService, prisma_service_1.PrismaService],
        exports: [users_service_1.UsersService],
    })
], UsersModule);


/***/ }),
/* 29 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const users_service_1 = __webpack_require__(16);
const auth_dto_1 = __webpack_require__(22);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const public_decorator_1 = __webpack_require__(25);
const prisma_service_1 = __webpack_require__(10);
const client_1 = __webpack_require__(11);
let UsersController = class UsersController {
    constructor(usersService, prisma) {
        this.usersService = usersService;
        this.prisma = prisma;
    }
    create(createUserDto) {
        return this.usersService.create(createUserDto);
    }
    findAll(page, limit, role, isActive) {
        return this.usersService.findAll({
            page: page || 1,
            limit: limit || 10,
            role,
            isActive,
        });
    }
    getProfile(req) {
        return this.usersService.findOne(req.user.id);
    }
    findOne(id) {
        return this.usersService.findOne(id);
    }
    updateProfile(req, updateUserDto) {
        return this.usersService.update(req.user.id, updateUserDto);
    }
    update(id, updateUserDto) {
        return this.usersService.update(id, updateUserDto);
    }
    remove(id) {
        return this.usersService.remove(id);
    }
    updateStatus(id, statusDto) {
        return this.usersService.updateStatus(id, statusDto.isActive);
    }
    async getFeaturedSellers() {
        try {
            const sellers = await this.prisma.user.findMany({
                where: {
                    role: 'SELLER',
                    sellerProfile: {
                        isVerified: true,
                    }
                },
                include: {
                    sellerProfile: {
                        select: {
                            storeName: true,
                            slug: true,
                            description: true,
                            avatar: true,
                            isVerified: true,
                        }
                    },
                    _count: {
                        select: {
                            products: {
                                where: { status: 'APPROVED' }
                            }
                        }
                    }
                },
                take: 8,
                orderBy: {
                    createdAt: 'desc'
                }
            });
            return {
                success: true,
                data: sellers.map(seller => ({
                    id: seller.id,
                    firstName: seller.firstName,
                    lastName: seller.lastName,
                    avatar: seller.avatar,
                    sellerProfile: seller.sellerProfile,
                    productCount: seller._count.products,
                }))
            };
        }
        catch (error) {
            return {
                success: false,
                data: []
            };
        }
    }
};
exports.UsersController = UsersController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new user' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'User created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Email already exists' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof auth_dto_1.CreateUserDto !== "undefined" && auth_dto_1.CreateUserDto) === "function" ? _c : Object]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all users (Admin only)' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number, description: 'Page number' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Items per page' }),
    (0, swagger_1.ApiQuery)({ name: 'role', required: false, enum: client_1.UserRole, description: 'Filter by role' }),
    (0, swagger_1.ApiQuery)({ name: 'isActive', required: false, type: Boolean, description: 'Filter by status' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Users retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden - Admin access required' }),
    __param(0, (0, common_1.Query)('page')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('role')),
    __param(3, (0, common_1.Query)('isActive')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number, typeof (_d = typeof client_1.UserRole !== "undefined" && client_1.UserRole) === "function" ? _d : Object, Boolean]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('profile'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Get current user profile' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Profile retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "getProfile", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'User ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User found successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User not found' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)('profile'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Update current user profile' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Profile updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_e = typeof auth_dto_1.UpdateUserDto !== "undefined" && auth_dto_1.UpdateUserDto) === "function" ? _e : Object]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "updateProfile", null);
__decorate([
    (0, common_1.Patch)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user by ID (Admin only)' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'User ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User not found' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden - Admin access required' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof auth_dto_1.UpdateUserDto !== "undefined" && auth_dto_1.UpdateUserDto) === "function" ? _f : Object]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user by ID (Admin only)' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'User ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User deleted successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User not found' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden - Admin access required' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "remove", null);
__decorate([
    (0, common_1.Patch)(':id/status'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)('JWT-auth'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user status (Admin only)' }),
    (0, swagger_1.ApiParam)({ name: 'id', type: String, description: 'User ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User status updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User not found' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Forbidden - Admin access required' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], UsersController.prototype, "updateStatus", null);
__decorate([
    (0, common_1.Get)('sellers/featured'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get featured sellers' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "getFeaturedSellers", null);
exports.UsersController = UsersController = __decorate([
    (0, swagger_1.ApiTags)('users'),
    (0, common_1.Controller)('users'),
    __metadata("design:paramtypes", [typeof (_a = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _a : Object, typeof (_b = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _b : Object])
], UsersController);


/***/ }),
/* 30 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesGuard = void 0;
const common_1 = __webpack_require__(2);
const core_1 = __webpack_require__(1);
const roles_decorator_1 = __webpack_require__(31);
let RolesGuard = class RolesGuard {
    constructor(reflector) {
        this.reflector = reflector;
    }
    canActivate(context) {
        const request = context.switchToHttp().getRequest();
        if (request.method === 'OPTIONS') {
            return true;
        }
        const requiredRoles = this.reflector.getAllAndOverride(roles_decorator_1.ROLES_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (!requiredRoles) {
            return true;
        }
        const user = request.user;
        if (!user) {
            return false;
        }
        return requiredRoles.some((role) => user.role === role);
    }
};
exports.RolesGuard = RolesGuard;
exports.RolesGuard = RolesGuard = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object])
], RolesGuard);


/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Roles = exports.ROLES_KEY = void 0;
const common_1 = __webpack_require__(2);
exports.ROLES_KEY = 'roles';
const Roles = (...roles) => (0, common_1.SetMetadata)(exports.ROLES_KEY, roles);
exports.Roles = Roles;


/***/ }),
/* 32 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JwtStrategy = void 0;
const common_1 = __webpack_require__(2);
const passport_1 = __webpack_require__(14);
const passport_jwt_1 = __webpack_require__(33);
const config_1 = __webpack_require__(3);
const users_service_1 = __webpack_require__(16);
let JwtStrategy = class JwtStrategy extends (0, passport_1.PassportStrategy)(passport_jwt_1.Strategy) {
    constructor(configService, usersService) {
        super({
            jwtFromRequest: passport_jwt_1.ExtractJwt.fromAuthHeaderAsBearerToken(),
            ignoreExpiration: false,
            secretOrKey: configService.get('JWT_SECRET'),
        });
        this.configService = configService;
        this.usersService = usersService;
    }
    async validate(payload) {
        const user = await this.usersService.findById(payload.sub);
        if (!user) {
            throw new common_1.UnauthorizedException('Usuario no encontrado');
        }
        if (!user.isActive) {
            throw new common_1.UnauthorizedException('Usuario inactivo');
        }
        return {
            id: user.id,
            email: user.email,
            role: user.role,
            isActive: user.isActive,
        };
    }
};
exports.JwtStrategy = JwtStrategy;
exports.JwtStrategy = JwtStrategy = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object])
], JwtStrategy);


/***/ }),
/* 33 */
/***/ ((module) => {

"use strict";
module.exports = require("passport-jwt");

/***/ }),
/* 34 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalStrategy = void 0;
const passport_local_1 = __webpack_require__(35);
const passport_1 = __webpack_require__(14);
const common_1 = __webpack_require__(2);
const auth_service_1 = __webpack_require__(15);
let LocalStrategy = class LocalStrategy extends (0, passport_1.PassportStrategy)(passport_local_1.Strategy) {
    constructor(authService) {
        super({ usernameField: 'email' });
        this.authService = authService;
    }
    async validate(email, password) {
        const user = await this.authService.validateUser(email, password);
        if (!user) {
            throw new common_1.UnauthorizedException('Credenciales inv√°lidas');
        }
        return user;
    }
};
exports.LocalStrategy = LocalStrategy;
exports.LocalStrategy = LocalStrategy = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof auth_service_1.AuthService !== "undefined" && auth_service_1.AuthService) === "function" ? _a : Object])
], LocalStrategy);


/***/ }),
/* 35 */
/***/ ((module) => {

"use strict";
module.exports = require("passport-local");

/***/ }),
/* 36 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProductsModule = void 0;
const common_1 = __webpack_require__(2);
const products_service_1 = __webpack_require__(37);
const products_controller_1 = __webpack_require__(38);
const prisma_service_1 = __webpack_require__(17);
let ProductsModule = class ProductsModule {
};
exports.ProductsModule = ProductsModule;
exports.ProductsModule = ProductsModule = __decorate([
    (0, common_1.Module)({
        controllers: [products_controller_1.ProductsController],
        providers: [products_service_1.ProductsService, prisma_service_1.PrismaService],
        exports: [products_service_1.ProductsService],
    })
], ProductsModule);


/***/ }),
/* 37 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProductsService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(17);
const client_1 = __webpack_require__(11);
let ProductsService = class ProductsService {
    constructor(prisma) {
        this.prisma = prisma;
    }
    prepareArrayFields(data) {
        return {
            imageFileIds: data.imageFileIds ? JSON.stringify(data.imageFileIds) : "[]",
            thumbnailFileIds: data.thumbnailFileIds ? JSON.stringify(data.thumbnailFileIds) : "[]",
            tags: data.tags ? JSON.stringify(data.tags) : "[]",
            toolsRequired: data.toolsRequired ? JSON.stringify(data.toolsRequired) : "[]",
            materials: data.materials ? JSON.stringify(data.materials) : "[]",
        };
    }
    async create(sellerId, createProductDto) {
        const sellerProductCount = await this.prisma.product.count({
            where: { sellerId, status: { not: 'REJECTED' } },
        });
        if (sellerProductCount >= 50) {
            throw new common_1.BadRequestException('Maximum products limit reached (50)');
        }
        const slug = await this.generateUniqueSlug(createProductDto.title);
        const product = await this.prisma.product.create({
            data: {
                title: createProductDto.title,
                description: createProductDto.description,
                slug,
                price: createProductDto.price,
                category: createProductDto.category,
                difficulty: createProductDto.difficulty,
                status: client_1.ProductStatus.DRAFT,
                sellerId,
                estimatedTime: createProductDto.estimatedTime || null,
                dimensions: createProductDto.dimensions || null,
                specifications: createProductDto.specifications || null,
                ...this.prepareArrayFields(createProductDto),
            },
            include: {
                seller: {
                    select: {
                        id: true,
                        avatar: true,
                        createdAt: true,
                    },
                },
            },
        });
        return product;
    }
    async findAll(filters) {
        const { q, category, difficulty, priceMin, priceMax, tags, sortBy, page = 1, limit = 12, status, featured, } = filters;
        const where = {
            status: status || client_1.ProductStatus.APPROVED,
            publishedAt: { not: null },
        };
        if (featured === true) {
            where.featured = true;
        }
        if (q) {
            where.OR = [
                { title: { contains: q } },
                { description: { contains: q } },
                { tags: { contains: q } },
            ];
        }
        if (category)
            where.category = category;
        if (difficulty)
            where.difficulty = difficulty;
        if (priceMin !== undefined || priceMax !== undefined) {
            where.price = {};
            if (priceMin !== undefined)
                where.price.gte = priceMin;
            if (priceMax !== undefined)
                where.price.lte = priceMax;
        }
        if (tags && tags.length > 0) {
            where.tags = { contains: tags.join('|') };
        }
        const orderBy = this.buildOrderBy(filters.sortBy, filters.sortOrder);
        const skip = (page - 1) * limit;
        const [products, total] = await Promise.all([
            this.prisma.product.findMany({
                where,
                include: {
                    seller: {
                        select: {
                            id: true,
                            firstName: true,
                            lastName: true,
                            email: true,
                            sellerProfile: {
                                select: {
                                    id: true,
                                    storeName: true,
                                    slug: true,
                                    description: true,
                                    avatar: true,
                                    createdAt: true,
                                },
                            },
                        },
                    },
                },
                orderBy,
                skip,
                take: limit,
            }),
            this.prisma.product.count({ where }),
        ]);
        const totalPages = Math.ceil(total / limit);
        return {
            data: products,
            total,
            page,
            limit,
            totalPages,
            hasNext: page < totalPages,
            hasPrev: page > 1,
        };
    }
    async findOne(id, userId) {
        const product = await this.prisma.product.findUnique({
            where: { id },
            include: {
                seller: {
                    select: {
                        id: true,
                        avatar: true,
                        createdAt: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        sellerProfile: {
                            select: {
                                id: true,
                                storeName: true,
                                slug: true,
                                description: true,
                                avatar: true,
                                isVerified: true,
                                createdAt: true,
                            },
                        },
                    },
                },
            },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (product.status !== client_1.ProductStatus.APPROVED &&
            product.sellerId !== userId) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (userId !== product.sellerId) {
            await this.prisma.product.update({
                where: { id },
                data: { viewCount: { increment: 1 } },
            });
            product.viewCount += 1;
        }
        return product;
    }
    async findMyProducts(sellerId, filters) {
        const { page = 1, limit = 12, status } = filters;
        const where = {
            sellerId,
        };
        if (status)
            where.status = status;
        const skip = (page - 1) * limit;
        const [products, total] = await Promise.all([
            this.prisma.product.findMany({
                where,
                include: {
                    seller: {
                        select: {
                            id: true,
                            firstName: true,
                            lastName: true,
                            sellerProfile: {
                                select: {
                                    id: true,
                                    storeName: true,
                                    slug: true,
                                    description: true,
                                    avatar: true,
                                },
                            },
                        },
                    },
                },
                orderBy: this.buildOrderBy(filters.sortBy, filters.sortOrder),
                skip,
                take: limit,
            }),
            this.prisma.product.count({ where }),
        ]);
        const totalPages = Math.ceil(total / limit);
        return {
            data: products,
            total,
            page,
            limit,
            totalPages,
            hasNext: page < totalPages,
            hasPrev: page > 1,
        };
    }
    async findBySlug(slug, userId) {
        const product = await this.prisma.product.findFirst({
            where: { slug: slug },
            include: {
                seller: {
                    select: {
                        id: true,
                        avatar: true,
                        createdAt: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        sellerProfile: {
                            select: {
                                id: true,
                                storeName: true,
                                slug: true,
                                description: true,
                                avatar: true,
                                isVerified: true,
                                createdAt: true,
                            },
                        },
                    },
                },
            },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (product.status !== client_1.ProductStatus.APPROVED &&
            product.sellerId !== userId) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (userId !== product.sellerId) {
            await this.prisma.product.update({
                where: { id: product.id },
                data: { viewCount: { increment: 1 } },
            });
            product.viewCount += 1;
        }
        return product;
    }
    async update(id, updateProductDto, userId, userRole) {
        const product = await this.prisma.product.findUnique({
            where: { id },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (product.sellerId !== userId && userRole !== client_1.UserRole.ADMIN) {
            throw new common_1.ForbiddenException('You are not the owner of this product');
        }
        let slug = product.slug;
        if (updateProductDto.title && updateProductDto.title !== product.title) {
            slug = await this.generateUniqueSlug(updateProductDto.title, id);
        }
        let status = product.status;
        const criticalFields = ['title', 'description', 'category', 'price'];
        const hasCriticalChanges = criticalFields.some(field => updateProductDto[field] !== undefined);
        if (product.status === client_1.ProductStatus.APPROVED &&
            hasCriticalChanges &&
            userRole !== client_1.UserRole.ADMIN) {
            status = client_1.ProductStatus.PENDING;
        }
        const updatedProduct = await this.prisma.product.update({
            where: { id },
            data: {
                ...(updateProductDto.title && { title: updateProductDto.title }),
                ...(updateProductDto.description && { description: updateProductDto.description }),
                ...(updateProductDto.price !== undefined && { price: updateProductDto.price }),
                ...(updateProductDto.category && { category: updateProductDto.category }),
                ...(updateProductDto.difficulty && { difficulty: updateProductDto.difficulty }),
                ...(updateProductDto.estimatedTime !== undefined && { estimatedTime: updateProductDto.estimatedTime }),
                ...(updateProductDto.dimensions !== undefined && { dimensions: updateProductDto.dimensions }),
                ...(updateProductDto.specifications !== undefined && { specifications: updateProductDto.specifications }),
                slug,
                status,
                ...this.prepareArrayFields(updateProductDto),
            },
            include: {
                seller: {
                    select: {
                        id: true,
                        avatar: true,
                    },
                },
            },
        });
        return updatedProduct;
    }
    async remove(id, userId, userRole) {
        const product = await this.prisma.product.findUnique({
            where: { id },
            include: {
                orderItems: true,
            },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (product.sellerId !== userId && userRole !== client_1.UserRole.ADMIN) {
            throw new common_1.ForbiddenException('You are not the owner of this product');
        }
        if (product.orderItems.length > 0) {
            throw new common_1.ConflictException('Cannot delete product with associated orders');
        }
        await this.prisma.product.delete({
            where: { id },
        });
        return { message: 'Product deleted successfully' };
    }
    async approve(id) {
        const product = await this.prisma.product.findUnique({
            where: { id },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (product.status !== client_1.ProductStatus.PENDING) {
            throw new common_1.BadRequestException('Product cannot be approved');
        }
        const updatedProduct = await this.prisma.product.update({
            where: { id },
            data: {
                status: client_1.ProductStatus.APPROVED,
                publishedAt: new Date(),
            },
            include: {
                seller: {
                    select: {
                        id: true,
                    },
                },
            },
        });
        return updatedProduct;
    }
    async reject(id, reason) {
        const product = await this.prisma.product.findUnique({
            where: { id },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (product.status !== client_1.ProductStatus.PENDING) {
            throw new common_1.BadRequestException('Product cannot be rejected');
        }
        const updatedProduct = await this.prisma.product.update({
            where: { id },
            data: {
                status: client_1.ProductStatus.REJECTED,
                specifications: reason
                    ? {
                        ...(product.specifications || {}),
                        rejectionReason: reason
                    }
                    : product.specifications,
            },
            include: {
                seller: {
                    select: {
                        id: true,
                        email: true,
                    },
                },
            },
        });
        return updatedProduct;
    }
    async getProductStats(id) {
        const product = await this.prisma.product.findUnique({
            where: { id },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        return {
            viewCount: product.viewCount,
            downloadCount: product.downloadCount,
            favoriteCount: product.favoriteCount,
            rating: product.rating,
            reviewCount: product.reviewCount,
        };
    }
    async publish(id, userId) {
        const product = await this.prisma.product.findUnique({
            where: { id },
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        if (product.sellerId !== userId) {
            throw new common_1.ForbiddenException('You are not the owner of this product');
        }
        if (product.status !== client_1.ProductStatus.DRAFT) {
            throw new common_1.BadRequestException('Product cannot be published');
        }
        const imageFileIds = JSON.parse(product.imageFileIds || "[]");
        if (!imageFileIds || imageFileIds.length === 0) {
            throw new common_1.BadRequestException('Product must have at least one image');
        }
        const updatedProduct = await this.prisma.product.update({
            where: { id },
            data: {
                status: client_1.ProductStatus.PENDING,
            },
        });
        return updatedProduct;
    }
    async generateUniqueSlug(title, excludeId) {
        let baseSlug = title
            .toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '')
            .replace(/\s+/g, '-')
            .replace(/-+/g, '-')
            .trim();
        if (baseSlug.length > 100) {
            baseSlug = baseSlug.substring(0, 100);
        }
        let slug = baseSlug;
        let counter = 1;
        while (true) {
            const existing = await this.prisma.product.findFirst({
                where: { slug },
            });
            if (!existing || existing.id === excludeId) {
                break;
            }
            slug = `${baseSlug}-${counter}`;
            counter++;
        }
        return slug;
    }
    buildOrderBy(sortBy, sortOrder) {
        const order = (sortOrder === 'asc') ? 'asc' : 'desc';
        switch (sortBy) {
            case 'createdAt':
                return { createdAt: order };
            case 'updatedAt':
                return { updatedAt: order };
            case 'price':
                return { price: order };
            case 'rating':
                return { rating: order };
            case 'viewCount':
                return { viewCount: order };
            case 'downloadCount':
                return { downloadCount: order };
            case 'favoriteCount':
                return { favoriteCount: order };
            case 'reviewCount':
                return { reviewCount: order };
            case 'title':
                return { title: order };
            case 'newest':
                return { createdAt: 'desc' };
            case 'oldest':
                return { createdAt: 'asc' };
            case 'popular':
                return { viewCount: 'desc' };
            case 'rating':
                return { rating: 'desc' };
            case 'price_asc':
                return { price: 'asc' };
            case 'price_desc':
                return { price: 'desc' };
            default:
                return { createdAt: 'desc' };
        }
    }
    async getGeneralStats() {
        try {
            const [totalProducts, totalSellers, totalDownloads, featuredProducts] = await Promise.all([
                this.prisma.product.count({
                    where: { status: client_1.ProductStatus.APPROVED }
                }),
                this.prisma.user.count({
                    where: { role: 'SELLER' }
                }),
                this.prisma.download.count(),
                this.prisma.product.count({
                    where: {
                        status: client_1.ProductStatus.APPROVED,
                        featured: true
                    }
                }),
            ]);
            return {
                totalProducts,
                totalSellers,
                totalDownloads,
                featuredProducts,
                timestamp: new Date().toISOString(),
            };
        }
        catch (error) {
            const [totalProducts, totalSellers, featuredProducts] = await Promise.all([
                this.prisma.product.count({
                    where: { status: client_1.ProductStatus.APPROVED }
                }),
                this.prisma.user.count({
                    where: { role: 'SELLER' }
                }),
                this.prisma.product.count({
                    where: {
                        status: client_1.ProductStatus.APPROVED,
                        featured: true
                    }
                }),
            ]);
            return {
                totalProducts,
                totalSellers,
                totalDownloads: 0,
                featuredProducts,
                timestamp: new Date().toISOString(),
            };
        }
    }
    async getCategories() {
        try {
            const categories = await this.prisma.product.groupBy({
                by: ['category'],
                where: {
                    status: client_1.ProductStatus.APPROVED
                },
                _count: {
                    category: true
                },
                orderBy: {
                    _count: {
                        category: 'desc'
                    }
                }
            });
            return categories.map(cat => ({
                category: cat.category,
                count: cat._count.category,
                displayName: this.getCategoryDisplayName(cat.category),
            }));
        }
        catch (error) {
            return [
                { category: 'FURNITURE', count: 0, displayName: 'Muebles' },
                { category: 'DECORATION', count: 0, displayName: 'Decoraci√≥n' },
                { category: 'STORAGE', count: 0, displayName: 'Almacenamiento' },
                { category: 'OUTDOOR', count: 0, displayName: 'Exterior' },
            ];
        }
    }
    getCategoryDisplayName(category) {
        const categoryNames = {
            'FURNITURE': 'Muebles',
            'DECORATION': 'Decoraci√≥n',
            'STORAGE': 'Almacenamiento',
            'OUTDOOR': 'Exterior',
            'KITCHEN': 'Cocina',
            'BEDROOM': 'Dormitorio',
            'LIVING_ROOM': 'Sala de estar',
            'BATHROOM': 'Ba√±o',
            'OFFICE': 'Oficina',
            'KIDS': 'Infantil',
        };
        return categoryNames[category] || category;
    }
    async findProductsForHomepage() {
        try {
            const [featured, latest, popular, topRated] = await Promise.all([
                this.prisma.product.findMany({
                    where: {
                        status: client_1.ProductStatus.APPROVED,
                        featured: true,
                    },
                    include: {
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                        slug: true,
                                        avatar: true,
                                    },
                                },
                            },
                        },
                    },
                    orderBy: { createdAt: 'desc' },
                    take: 8,
                }),
                this.prisma.product.findMany({
                    where: {
                        status: client_1.ProductStatus.APPROVED,
                    },
                    include: {
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                        slug: true,
                                        avatar: true,
                                    },
                                },
                            },
                        },
                    },
                    orderBy: { publishedAt: 'desc' },
                    take: 12,
                }),
                this.prisma.product.findMany({
                    where: {
                        status: client_1.ProductStatus.APPROVED,
                        viewCount: { gt: 0 },
                    },
                    include: {
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                        slug: true,
                                        avatar: true,
                                    },
                                },
                            },
                        },
                    },
                    orderBy: { viewCount: 'desc' },
                    take: 8,
                }),
                this.prisma.product.findMany({
                    where: {
                        status: client_1.ProductStatus.APPROVED,
                        rating: { gt: 4.0 },
                    },
                    include: {
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                        slug: true,
                                        avatar: true,
                                    },
                                },
                            },
                        },
                    },
                    orderBy: { rating: 'desc' },
                    take: 8,
                }),
            ]);
            return {
                featured,
                latest,
                popular,
                topRated,
            };
        }
        catch (error) {
            return {
                featured: [],
                latest: [],
                popular: [],
                topRated: [],
            };
        }
    }
};
exports.ProductsService = ProductsService;
exports.ProductsService = ProductsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object])
], ProductsService);


/***/ }),
/* 38 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProductsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const products_service_1 = __webpack_require__(37);
const create_product_dto_1 = __webpack_require__(39);
const update_product_dto_1 = __webpack_require__(41);
const product_filters_dto_1 = __webpack_require__(42);
const product_response_dto_1 = __webpack_require__(43);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const current_user_decorator_1 = __webpack_require__(26);
const roles_decorator_1 = __webpack_require__(31);
const public_decorator_1 = __webpack_require__(25);
const client_1 = __webpack_require__(11);
const class_transformer_1 = __webpack_require__(40);
let ProductsController = class ProductsController {
    constructor(productsService) {
        this.productsService = productsService;
    }
    async create(createProductDto, user) {
        const product = await this.productsService.create(user.id, createProductDto);
        return (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
            excludeExtraneousValues: false,
        });
    }
    async findAll(filters, user) {
        const result = await this.productsService.findAll(filters);
        return {
            ...result,
            data: result.data.map(product => (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
                excludeExtraneousValues: false,
            })),
        };
    }
    async search(filters) {
        const result = await this.productsService.findAll(filters);
        return {
            ...result,
            data: result.data.map(product => (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
                excludeExtraneousValues: false,
            })),
        };
    }
    async findMyProducts(filters, user) {
        const result = await this.productsService.findMyProducts(user.id, filters);
        return result;
    }
    async findPendingProducts(filters) {
        const pendingFilters = { ...filters, status: 'PENDING' };
        const result = await this.productsService.findAll(pendingFilters);
        return result;
    }
    async findOne(id, user) {
        const product = await this.productsService.findOne(id, user?.id);
        return (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
            excludeExtraneousValues: false,
        });
    }
    async findBySlug(slug, user) {
        const product = await this.productsService.findBySlug(slug, user?.id);
        return (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
            excludeExtraneousValues: false,
        });
    }
    async update(id, updateProductDto, user) {
        const product = await this.productsService.update(id, updateProductDto, user.id, user.role);
        return (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
            excludeExtraneousValues: false,
        });
    }
    async remove(id, user) {
        await this.productsService.remove(id, user.id, user.role);
    }
    async publish(id, user) {
        const product = await this.productsService.publish(id, user.id);
        return (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
            excludeExtraneousValues: false,
        });
    }
    async approve(id) {
        const product = await this.productsService.approve(id);
        return (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
            excludeExtraneousValues: false,
        });
    }
    async reject(id, reason) {
        const product = await this.productsService.reject(id, reason);
        return (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
            excludeExtraneousValues: false,
        });
    }
    async getStats(id) {
        return this.productsService.getProductStats(id);
    }
    async getFeaturedProducts() {
        const filters = {
            status: client_1.ProductStatus.APPROVED,
            featured: true,
            limit: 8,
            page: 1,
            sortBy: 'createdAt',
            sortOrder: 'desc',
        };
        const result = await this.productsService.findAll(filters);
        return {
            success: true,
            ...result,
            data: result.data.map(product => (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
                excludeExtraneousValues: false,
            })),
        };
    }
    async getLatestProducts() {
        const filters = {
            status: client_1.ProductStatus.APPROVED,
            limit: 12,
            page: 1,
            sortBy: 'createdAt',
            sortOrder: 'desc',
        };
        const result = await this.productsService.findAll(filters);
        return {
            success: true,
            ...result,
            data: result.data.map(product => (0, class_transformer_1.plainToClass)(product_response_dto_1.ProductResponseDto, product, {
                excludeExtraneousValues: false,
            })),
        };
    }
    async getGeneralStats() {
        try {
            const stats = await this.productsService.getGeneralStats();
            return {
                success: true,
                data: stats,
            };
        }
        catch (error) {
            return {
                success: false,
                error: error.message,
                data: {
                    totalProducts: 0,
                    totalSellers: 0,
                    totalDownloads: 0,
                    featuredProducts: 0,
                    timestamp: new Date().toISOString(),
                },
            };
        }
    }
    async getCategories() {
        try {
            const categories = await this.productsService.getCategories();
            return {
                success: true,
                data: categories,
            };
        }
        catch (error) {
            return {
                success: false,
                error: error.message,
                data: [],
            };
        }
    }
};
exports.ProductsController = ProductsController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Crear un nuevo producto' }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Producto creado exitosamente',
        type: product_response_dto_1.ProductResponseDto,
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Datos inv√°lidos' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'No autorizado' }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof create_product_dto_1.CreateProductDto !== "undefined" && create_product_dto_1.CreateProductDto) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Listar productos p√∫blicos (aprobados)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Lista de productos',
        type: product_response_dto_1.PaginatedProductsDto,
    }),
    (0, swagger_1.ApiQuery)({ name: 'q', required: false, description: 'B√∫squeda en t√≠tulo y descripci√≥n' }),
    (0, swagger_1.ApiQuery)({ name: 'category', required: false, description: 'Filtrar por categor√≠a' }),
    (0, swagger_1.ApiQuery)({ name: 'difficulty', required: false, description: 'Filtrar por dificultad' }),
    (0, swagger_1.ApiQuery)({ name: 'priceMin', required: false, description: 'Precio m√≠nimo' }),
    (0, swagger_1.ApiQuery)({ name: 'priceMax', required: false, description: 'Precio m√°ximo' }),
    (0, swagger_1.ApiQuery)({ name: 'tags', required: false, description: 'Filtrar por tags' }),
    (0, swagger_1.ApiQuery)({ name: 'sortBy', required: false, description: 'Ordenar por' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, description: 'N√∫mero de p√°gina' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, description: 'Elementos por p√°gina' }),
    __param(0, (0, common_1.Query)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof product_filters_dto_1.ProductFiltersDto !== "undefined" && product_filters_dto_1.ProductFiltersDto) === "function" ? _c : Object, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'B√∫squeda avanzada de productos' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Resultados de b√∫squeda',
        type: product_response_dto_1.PaginatedProductsDto,
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof product_filters_dto_1.ProductFiltersDto !== "undefined" && product_filters_dto_1.ProductFiltersDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('my'),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener mis productos (seller)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Lista de productos del usuario',
        type: product_response_dto_1.PaginatedProductsDto,
    }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    __param(0, (0, common_1.Query)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof product_filters_dto_1.ProductFiltersDto !== "undefined" && product_filters_dto_1.ProductFiltersDto) === "function" ? _e : Object, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "findMyProducts", null);
__decorate([
    (0, common_1.Get)('pending'),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener productos pendientes de moderaci√≥n (admin)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Lista de productos pendientes',
        type: product_response_dto_1.PaginatedProductsDto,
    }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof product_filters_dto_1.ProductFiltersDto !== "undefined" && product_filters_dto_1.ProductFiltersDto) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "findPendingProducts", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener producto por ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Detalle del producto',
        type: product_response_dto_1.ProductResponseDto,
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Producto no encontrado' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('slug/:slug'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener producto por slug' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Detalle del producto',
        type: product_response_dto_1.ProductResponseDto,
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Producto no encontrado' }),
    __param(0, (0, common_1.Param)('slug')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "findBySlug", null);
__decorate([
    (0, common_1.Patch)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Actualizar producto' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto actualizado',
        type: product_response_dto_1.ProductResponseDto,
    }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'No autorizado para editar' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Producto no encontrado' }),
    (0, swagger_1.ApiBearerAuth)(),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_g = typeof update_product_dto_1.UpdateProductDto !== "undefined" && update_product_dto_1.UpdateProductDto) === "function" ? _g : Object, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, swagger_1.ApiOperation)({ summary: 'Eliminar producto' }),
    (0, swagger_1.ApiResponse)({ status: 204, description: 'Producto eliminado' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'No autorizado para eliminar' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Producto no encontrado' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Producto tiene √≥rdenes asociadas' }),
    (0, swagger_1.ApiBearerAuth)(),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)(':id/publish'),
    (0, swagger_1.ApiOperation)({ summary: 'Publicar producto (DRAFT -> PENDING)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto enviado para moderaci√≥n',
        type: product_response_dto_1.ProductResponseDto,
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'No se puede publicar el producto' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'No autorizado' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Producto no encontrado' }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "publish", null);
__decorate([
    (0, common_1.Post)(':id/approve'),
    (0, swagger_1.ApiOperation)({ summary: 'Aprobar producto (admin)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto aprobado',
        type: product_response_dto_1.ProductResponseDto,
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'No se puede aprobar el producto' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Producto no encontrado' }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "approve", null);
__decorate([
    (0, common_1.Post)(':id/reject'),
    (0, swagger_1.ApiOperation)({ summary: 'Rechazar producto (admin)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto rechazado',
        type: product_response_dto_1.ProductResponseDto,
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'No se puede rechazar el producto' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Producto no encontrado' }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Body)('reason')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "reject", null);
__decorate([
    (0, common_1.Get)(':id/stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener estad√≠sticas del producto' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Estad√≠sticas del producto',
        schema: {
            type: 'object',
            properties: {
                viewCount: { type: 'number' },
                downloadCount: { type: 'number' },
                favoriteCount: { type: 'number' },
                rating: { type: 'number' },
                reviewCount: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiBearerAuth)(),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "getStats", null);
__decorate([
    (0, common_1.Get)('featured'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener productos destacados para homepage' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Productos destacados obtenidos exitosamente',
        type: product_response_dto_1.PaginatedProductsDto,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "getFeaturedProducts", null);
__decorate([
    (0, common_1.Get)('latest'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener productos m√°s recientes para homepage' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Productos recientes obtenidos exitosamente',
        type: product_response_dto_1.PaginatedProductsDto,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "getLatestProducts", null);
__decorate([
    (0, common_1.Get)('general-stats'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener estad√≠sticas generales para homepage' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Estad√≠sticas generales obtenidas exitosamente',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'object',
                    properties: {
                        totalProducts: { type: 'number' },
                        totalSellers: { type: 'number' },
                        totalDownloads: { type: 'number' },
                        featuredProducts: { type: 'number' },
                        timestamp: { type: 'string' },
                    },
                },
            },
        },
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "getGeneralStats", null);
__decorate([
    (0, common_1.Get)('categories'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener categor√≠as disponibles' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Categor√≠as obtenidas exitosamente',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ProductsController.prototype, "getCategories", null);
exports.ProductsController = ProductsController = __decorate([
    (0, swagger_1.ApiTags)('Products'),
    (0, common_1.Controller)('products'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    __metadata("design:paramtypes", [typeof (_a = typeof products_service_1.ProductsService !== "undefined" && products_service_1.ProductsService) === "function" ? _a : Object])
], ProductsController);


/***/ }),
/* 39 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateProductDto = void 0;
const swagger_1 = __webpack_require__(4);
const class_transformer_1 = __webpack_require__(40);
const class_validator_1 = __webpack_require__(23);
const client_1 = __webpack_require__(11);
class CreateProductDto {
    constructor() {
        this.price = 5.00;
    }
}
exports.CreateProductDto = CreateProductDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'T√≠tulo del producto',
        example: 'Mesa de Comedor Moderna',
        minLength: 10,
        maxLength: 100,
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(10, { message: 'auth.validation.title_min_length' }),
    (0, class_validator_1.MaxLength)(100, { message: 'auth.validation.title_max_length' }),
    __metadata("design:type", String)
], CreateProductDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Descripci√≥n detallada del producto',
        example: 'Plano detallado para construir una elegante mesa de comedor...',
        minLength: 50,
        maxLength: 2000,
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MinLength)(50, { message: 'auth.validation.description_min_length' }),
    (0, class_validator_1.MaxLength)(2000, { message: 'auth.validation.description_max_length' }),
    __metadata("design:type", String)
], CreateProductDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Precio del producto en USD',
        example: 5.00,
        minimum: 1,
        maximum: 100,
    }),
    (0, class_validator_1.IsNumber)({}, { message: 'auth.validation.price_number' }),
    (0, class_validator_1.Min)(1, { message: 'auth.validation.price_min' }),
    (0, class_validator_1.Max)(100, { message: 'auth.validation.price_max' }),
    __metadata("design:type", Number)
], CreateProductDto.prototype, "price", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Categor√≠a del producto',
        enum: client_1.ProductCategory,
        example: client_1.ProductCategory.LIVING_DINING,
    }),
    (0, class_validator_1.IsEnum)(client_1.ProductCategory, { message: 'auth.validation.invalid_category' }),
    __metadata("design:type", typeof (_a = typeof client_1.ProductCategory !== "undefined" && client_1.ProductCategory) === "function" ? _a : Object)
], CreateProductDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Nivel de dificultad',
        enum: client_1.Difficulty,
        example: client_1.Difficulty.INTERMEDIATE,
    }),
    (0, class_validator_1.IsEnum)(client_1.Difficulty, { message: 'auth.validation.invalid_difficulty' }),
    __metadata("design:type", typeof (_b = typeof client_1.Difficulty !== "undefined" && client_1.Difficulty) === "function" ? _b : Object)
], CreateProductDto.prototype, "difficulty", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Tags del producto',
        example: ['mesa', 'comedor', 'madera', 'moderno'],
        maxItems: 10,
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ArrayMaxSize)(10, { message: 'auth.validation.tags_max_size' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.map((tag) => tag.toLowerCase().trim())),
    __metadata("design:type", Array)
], CreateProductDto.prototype, "tags", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Tiempo estimado de construcci√≥n',
        example: '4-6 horas',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(50),
    __metadata("design:type", String)
], CreateProductDto.prototype, "estimatedTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Herramientas requeridas',
        example: ['sierra', 'taladro', 'lijadora'],
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ArrayMaxSize)(20),
    __metadata("design:type", Array)
], CreateProductDto.prototype, "toolsRequired", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Materiales necesarios',
        example: ['madera de roble', 'tornillos', 'barniz'],
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ArrayMaxSize)(30),
    __metadata("design:type", Array)
], CreateProductDto.prototype, "materials", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Dimensiones del mueble',
        example: '120cm x 80cm x 75cm',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(100),
    __metadata("design:type", String)
], CreateProductDto.prototype, "dimensions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Especificaciones adicionales en JSON',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], CreateProductDto.prototype, "specifications", void 0);


/***/ }),
/* 40 */
/***/ ((module) => {

"use strict";
module.exports = require("class-transformer");

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateProductDto = void 0;
const swagger_1 = __webpack_require__(4);
const create_product_dto_1 = __webpack_require__(39);
class UpdateProductDto extends (0, swagger_1.PartialType)(create_product_dto_1.CreateProductDto) {
}
exports.UpdateProductDto = UpdateProductDto;


/***/ }),
/* 42 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProductFiltersDto = void 0;
const swagger_1 = __webpack_require__(4);
const class_transformer_1 = __webpack_require__(40);
const class_validator_1 = __webpack_require__(23);
const client_1 = __webpack_require__(11);
class ProductFiltersDto {
    constructor() {
        this.sortBy = 'newest';
        this.sortOrder = 'desc';
        this.page = 1;
        this.limit = 12;
    }
}
exports.ProductFiltersDto = ProductFiltersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'B√∫squeda en t√≠tulo y descripci√≥n',
        example: 'mesa comedor',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProductFiltersDto.prototype, "q", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filtrar por categor√≠a',
        enum: client_1.ProductCategory,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.ProductCategory),
    __metadata("design:type", typeof (_a = typeof client_1.ProductCategory !== "undefined" && client_1.ProductCategory) === "function" ? _a : Object)
], ProductFiltersDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filtrar por dificultad',
        enum: client_1.Difficulty,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.Difficulty),
    __metadata("design:type", typeof (_b = typeof client_1.Difficulty !== "undefined" && client_1.Difficulty) === "function" ? _b : Object)
], ProductFiltersDto.prototype, "difficulty", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Precio m√≠nimo',
        minimum: 0,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Transform)(({ value }) => parseFloat(value)),
    __metadata("design:type", Number)
], ProductFiltersDto.prototype, "priceMin", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Precio m√°ximo',
        maximum: 1000,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Max)(1000),
    (0, class_transformer_1.Transform)(({ value }) => parseFloat(value)),
    __metadata("design:type", Number)
], ProductFiltersDto.prototype, "priceMax", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filtrar por tags',
        example: ['mesa', 'moderno'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_transformer_1.Transform)(({ value }) => Array.isArray(value) ? value : [value]),
    __metadata("design:type", Array)
], ProductFiltersDto.prototype, "tags", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Ordenar por',
        enum: ['newest', 'oldest', 'popular', 'rating', 'price_asc', 'price_desc', 'createdAt', 'publishedAt'],
        default: 'newest',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProductFiltersDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Direcci√≥n del ordenamiento',
        enum: ['asc', 'desc'],
        default: 'desc',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProductFiltersDto.prototype, "sortOrder", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filtrar solo productos destacados',
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    __metadata("design:type", Boolean)
], ProductFiltersDto.prototype, "featured", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'N√∫mero de p√°gina',
        minimum: 1,
        default: 1,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value) || 1),
    __metadata("design:type", Number)
], ProductFiltersDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Elementos por p√°gina',
        minimum: 1,
        maximum: 50,
        default: 12,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(50),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value) || 12),
    __metadata("design:type", Number)
], ProductFiltersDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filtrar por estado (solo admin)',
        enum: client_1.ProductStatus,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.ProductStatus),
    __metadata("design:type", typeof (_c = typeof client_1.ProductStatus !== "undefined" && client_1.ProductStatus) === "function" ? _c : Object)
], ProductFiltersDto.prototype, "status", void 0);


/***/ }),
/* 43 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginatedProductsDto = exports.ProductResponseDto = void 0;
const swagger_1 = __webpack_require__(4);
const client_1 = __webpack_require__(11);
class ProductResponseDto {
}
exports.ProductResponseDto = ProductResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ProductResponseDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ProductResponseDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ProductResponseDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], ProductResponseDto.prototype, "slug", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductResponseDto.prototype, "price", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.ProductCategory }),
    __metadata("design:type", typeof (_a = typeof client_1.ProductCategory !== "undefined" && client_1.ProductCategory) === "function" ? _a : Object)
], ProductResponseDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.Difficulty }),
    __metadata("design:type", typeof (_b = typeof client_1.Difficulty !== "undefined" && client_1.Difficulty) === "function" ? _b : Object)
], ProductResponseDto.prototype, "difficulty", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.ProductStatus }),
    __metadata("design:type", typeof (_c = typeof client_1.ProductStatus !== "undefined" && client_1.ProductStatus) === "function" ? _c : Object)
], ProductResponseDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductResponseDto.prototype, "viewCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductResponseDto.prototype, "downloadCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductResponseDto.prototype, "favoriteCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductResponseDto.prototype, "rating", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductResponseDto.prototype, "reviewCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], ProductResponseDto.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_e = typeof Date !== "undefined" && Date) === "function" ? _e : Object)
], ProductResponseDto.prototype, "publishedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_f = typeof Date !== "undefined" && Date) === "function" ? _f : Object)
], ProductResponseDto.prototype, "updatedAt", void 0);
class PaginatedProductsDto {
}
exports.PaginatedProductsDto = PaginatedProductsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ type: [ProductResponseDto] }),
    __metadata("design:type", Array)
], PaginatedProductsDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedProductsDto.prototype, "total", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedProductsDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedProductsDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedProductsDto.prototype, "totalPages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], PaginatedProductsDto.prototype, "hasNext", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], PaginatedProductsDto.prototype, "hasPrev", void 0);


/***/ }),
/* 44 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilesModule = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const platform_express_1 = __webpack_require__(45);
const files_service_1 = __webpack_require__(46);
const files_controller_1 = __webpack_require__(51);
const prisma_service_1 = __webpack_require__(17);
let FilesModule = class FilesModule {
};
exports.FilesModule = FilesModule;
exports.FilesModule = FilesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            config_1.ConfigModule,
            platform_express_1.MulterModule.register({
                limits: {
                    fileSize: 10 * 1024 * 1024,
                },
            }),
        ],
        controllers: [files_controller_1.FilesController],
        providers: [files_service_1.FilesService, prisma_service_1.PrismaService],
        exports: [files_service_1.FilesService],
    })
], FilesModule);


/***/ }),
/* 45 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/platform-express");

/***/ }),
/* 46 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilesService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(17);
const config_1 = __webpack_require__(3);
const sharp_1 = __importDefault(__webpack_require__(47));
const fs = __importStar(__webpack_require__(48));
const path = __importStar(__webpack_require__(49));
const crypto = __importStar(__webpack_require__(50));
const client_1 = __webpack_require__(11);
let FilesService = class FilesService {
    constructor(prisma, config) {
        this.prisma = prisma;
        this.config = config;
        this.mapFileToResponse = (file) => {
            return {
                id: file.id,
                filename: file.filename,
                key: file.key,
                url: file.url,
                type: file.type,
                size: file.size,
                mimeType: file.mimeType,
                width: file.width,
                height: file.height,
                createdAt: file.createdAt,
            };
        };
        this.uploadPath = this.config.get('UPLOAD_PATH', './uploads');
        this.maxFileSize = parseInt(this.config.get('MAX_FILE_SIZE', '10485760'));
        this.allowedMimeTypes = this.config.get('ALLOWED_FILE_TYPES', 'pdf,jpg,jpeg,png,webp').split(',');
        this.baseUrl = this.config.get('BASE_URL', 'https://probable-barnacle-65wp9jg5qwxc5w6-3000.app.github.dev');
        this.ensureUploadDirectory();
    }
    validateFile(file, expectedType) {
        if (file.size > this.maxFileSize) {
            throw new common_1.BadRequestException(`File too large. Maximum size allowed: ${this.formatFileSize(this.maxFileSize)}`);
        }
        const fileExtension = this.getFileExtension(file.originalname);
        if (!this.allowedMimeTypes.includes(fileExtension)) {
            throw new common_1.BadRequestException(`Invalid file type. Allowed types: ${this.allowedMimeTypes.join(', ')}`);
        }
        if (expectedType === client_1.FileType.PDF && file.mimetype !== 'application/pdf') {
            throw new common_1.BadRequestException('File must be a PDF');
        }
        if (expectedType === client_1.FileType.IMAGE && !file.mimetype.startsWith('image/')) {
            throw new common_1.BadRequestException('File must be an image');
        }
        this.validateFileSignature(file.buffer, file.mimetype);
    }
    async getStorageStats() {
        const [totalFiles, totalSize, filesByType, recentUploads] = await Promise.all([
            this.prisma.file.count({
                where: { status: client_1.FileStatus.ACTIVE }
            }),
            this.prisma.file.aggregate({
                where: { status: client_1.FileStatus.ACTIVE },
                _sum: { size: true }
            }),
            this.prisma.file.groupBy({
                by: ['type'],
                where: { status: client_1.FileStatus.ACTIVE },
                _count: { type: true },
                _sum: { size: true }
            }),
            this.prisma.file.count({
                where: {
                    status: client_1.FileStatus.ACTIVE,
                    createdAt: {
                        gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
                    }
                }
            })
        ]);
        return {
            total: {
                files: totalFiles,
                size: totalSize._sum.size || 0,
                sizeFormatted: this.formatFileSize(totalSize._sum.size || 0)
            },
            byType: filesByType.map(type => ({
                type: type.type,
                count: type._count.type,
                size: type._sum.size || 0,
                sizeFormatted: this.formatFileSize(type._sum.size || 0)
            })),
            recent: {
                uploadsLast30Days: recentUploads
            },
            storage: {
                maxFileSize: this.maxFileSize,
                maxFileSizeFormatted: this.formatFileSize(this.maxFileSize),
                allowedTypes: this.allowedMimeTypes,
                uploadPath: this.uploadPath
            }
        };
    }
    async uploadPdf(file, userId) {
        this.validateFile(file, client_1.FileType.PDF);
        const fileKey = this.generateFileKey(file.originalname, 'pdf');
        const filePath = path.join(this.uploadPath, 'pdfs', fileKey);
        await this.ensureDirectoryExists(path.dirname(filePath));
        await fs.writeFile(filePath, file.buffer);
        const checksum = this.calculateChecksum(file.buffer);
        const metadata = await this.extractPdfMetadata(file.buffer);
        const fileRecord = await this.prisma.file.create({
            data: {
                filename: file.originalname,
                key: fileKey,
                url: `${this.baseUrl}/api/files/pdf/${fileKey}`,
                mimeType: file.mimetype,
                size: file.size,
                type: client_1.FileType.PDF,
                status: client_1.FileStatus.ACTIVE,
                checksum,
                metadata,
                uploadedById: userId,
            },
        });
        return {
            id: fileRecord.id,
            key: fileRecord.key,
            url: fileRecord.url,
            type: fileRecord.type,
            size: fileRecord.size,
            mimeType: fileRecord.mimeType,
        };
    }
    async uploadImages(files, userId) {
        if (files.length > 5) {
            throw new common_1.BadRequestException('Too many images. Maximum 5 images allowed');
        }
        const processedFiles = [];
        for (const file of files) {
            this.validateFile(file, client_1.FileType.IMAGE);
            const processed = await this.processImage(file, userId);
            processedFiles.push(processed);
        }
        return processedFiles;
    }
    async processImage(file, userId) {
        const fileKey = this.generateFileKey(file.originalname, 'image');
        const filePath = path.join(this.uploadPath, 'images', fileKey);
        const thumbnailKey = `thumb_${fileKey}`;
        const thumbnailPath = path.join(this.uploadPath, 'thumbnails', thumbnailKey);
        await this.ensureDirectoryExists(path.dirname(filePath));
        await this.ensureDirectoryExists(path.dirname(thumbnailPath));
        const processedImage = await (0, sharp_1.default)(file.buffer)
            .resize(1200, 1200, {
            fit: 'inside',
            withoutEnlargement: true
        })
            .jpeg({ quality: 85 })
            .toBuffer();
        const thumbnail = await (0, sharp_1.default)(file.buffer)
            .resize(300, 300, {
            fit: 'cover',
            position: 'center'
        })
            .jpeg({ quality: 80 })
            .toBuffer();
        await fs.writeFile(filePath, processedImage);
        await fs.writeFile(thumbnailPath, thumbnail);
        const { width, height } = await (0, sharp_1.default)(processedImage).metadata();
        const checksum = this.calculateChecksum(processedImage);
        const thumbnailChecksum = this.calculateChecksum(thumbnail);
        const imageRecord = await this.prisma.file.create({
            data: {
                filename: file.originalname,
                key: fileKey,
                url: `${this.baseUrl}/api/files/image/${fileKey}`,
                mimeType: 'image/jpeg',
                size: processedImage.length,
                type: client_1.FileType.IMAGE,
                status: client_1.FileStatus.ACTIVE,
                width,
                height,
                checksum,
                uploadedById: userId,
            },
        });
        await this.prisma.file.create({
            data: {
                filename: `thumb_${file.originalname}`,
                key: thumbnailKey,
                url: `${this.baseUrl}/api/files/thumbnail/${thumbnailKey}`,
                mimeType: 'image/jpeg',
                size: thumbnail.length,
                type: client_1.FileType.THUMBNAIL,
                status: client_1.FileStatus.ACTIVE,
                width: 300,
                height: 300,
                checksum: thumbnailChecksum,
                uploadedById: userId,
            },
        });
        return {
            id: imageRecord.id,
            key: imageRecord.key,
            url: imageRecord.url,
            type: imageRecord.type,
            size: imageRecord.size,
            mimeType: imageRecord.mimeType,
            width,
            height,
        };
    }
    async getFileByKey(key) {
        const file = await this.prisma.file.findUnique({
            where: { key },
        });
        if (!file || file.status !== client_1.FileStatus.ACTIVE) {
            throw new common_1.NotFoundException('File not found');
        }
        let filePath;
        switch (file.type) {
            case client_1.FileType.PDF:
                filePath = path.join(this.uploadPath, 'pdfs', key);
                break;
            case client_1.FileType.IMAGE:
                filePath = path.join(this.uploadPath, 'images', key);
                break;
            case client_1.FileType.THUMBNAIL:
                filePath = path.join(this.uploadPath, 'thumbnails', key);
                break;
            default:
                throw new common_1.NotFoundException('Invalid file type');
        }
        try {
            await fs.access(filePath);
        }
        catch {
            throw new common_1.NotFoundException('File not found');
        }
        return { file, filePath };
    }
    async deleteFile(fileId, userId, userRole) {
        const file = await this.prisma.file.findUnique({
            where: { id: fileId },
        });
        if (!file) {
            throw new common_1.NotFoundException('File not found');
        }
        if (file.uploadedById !== userId && userRole !== 'ADMIN') {
            throw new common_1.ForbiddenException('You are not the owner of this file');
        }
        await this.prisma.file.update({
            where: { id: fileId },
            data: { status: client_1.FileStatus.DELETED },
        });
        try {
            let filePath;
            switch (file.type) {
                case client_1.FileType.PDF:
                    filePath = path.join(this.uploadPath, 'pdfs', file.key);
                    break;
                case client_1.FileType.IMAGE:
                    filePath = path.join(this.uploadPath, 'images', file.key);
                    break;
                case client_1.FileType.THUMBNAIL:
                    filePath = path.join(this.uploadPath, 'thumbnails', file.key);
                    break;
            }
            await fs.unlink(filePath);
        }
        catch (error) {
            console.error('Error deleting physical file:', error);
        }
    }
    async getUserFiles(userId, type) {
        const where = {
            uploadedById: userId,
            status: client_1.FileStatus.ACTIVE,
        };
        if (type) {
            where.type = type;
        }
        return this.prisma.file.findMany({
            where,
            orderBy: { createdAt: 'desc' },
            select: {
                id: true,
                filename: true,
                key: true,
                url: true,
                type: true,
                size: true,
                mimeType: true,
                width: true,
                height: true,
                createdAt: true,
            },
        });
    }
    async getFileMetadata(fileId, userId) {
        const file = await this.prisma.file.findUnique({
            where: { id: fileId },
            include: {
                uploadedBy: {
                    select: { id: true }
                }
            }
        });
        if (!file) {
            throw new common_1.NotFoundException('File not found');
        }
        if (file.uploadedById !== userId && !this.isAdmin(userId)) {
            throw new common_1.ForbiddenException('Not authorized to access this file');
        }
        return {
            id: file.id,
            filename: file.filename,
            key: file.key,
            url: file.url,
            type: file.type,
            size: file.size,
            mimeType: file.mimeType,
            width: file.width,
            height: file.height,
            checksum: file.checksum,
            metadata: file.metadata,
            status: file.status,
            uploadedById: file.uploadedById,
            createdAt: file.createdAt,
        };
    }
    async cleanupOrphanedFiles() {
        const usedFileIds = new Set();
        const productsWithPdf = await this.prisma.product.findMany({
            where: { pdfFileId: { not: null } },
            select: { pdfFileId: true }
        });
        productsWithPdf.forEach(p => {
            if (p.pdfFileId)
                usedFileIds.add(p.pdfFileId);
        });
        const productsWithImages = await this.prisma.product.findMany({
            where: { imageFileIds: { not: null } },
            select: { imageFileIds: true }
        });
        productsWithImages.forEach(p => {
            try {
                if (p.imageFileIds) {
                    const imageIds = JSON.parse(p.imageFileIds);
                    if (Array.isArray(imageIds)) {
                        imageIds.forEach(id => usedFileIds.add(id));
                    }
                }
            }
            catch (error) {
                console.warn('Error parsing imageFileIds:', error);
            }
        });
        const productsWithThumbnails = await this.prisma.product.findMany({
            where: { thumbnailFileIds: { not: null } },
            select: { thumbnailFileIds: true }
        });
        productsWithThumbnails.forEach(p => {
            try {
                if (p.thumbnailFileIds) {
                    const thumbnailIds = JSON.parse(p.thumbnailFileIds);
                    if (Array.isArray(thumbnailIds)) {
                        thumbnailIds.forEach(id => usedFileIds.add(id));
                    }
                }
            }
            catch (error) {
                console.warn('Error parsing thumbnailFileIds:', error);
            }
        });
        const orphanedFiles = await this.prisma.file.findMany({
            where: {
                status: client_1.FileStatus.ACTIVE,
                id: { notIn: Array.from(usedFileIds) },
                createdAt: {
                    lt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
                }
            }
        });
        let totalSize = 0;
        let deletedCount = 0;
        for (const file of orphanedFiles) {
            try {
                await this.prisma.file.update({
                    where: { id: file.id },
                    data: { status: client_1.FileStatus.DELETED }
                });
                let filePath;
                switch (file.type) {
                    case client_1.FileType.PDF:
                        filePath = path.join(this.uploadPath, 'pdfs', file.key);
                        break;
                    case client_1.FileType.IMAGE:
                        filePath = path.join(this.uploadPath, 'images', file.key);
                        break;
                    case client_1.FileType.THUMBNAIL:
                        filePath = path.join(this.uploadPath, 'thumbnails', file.key);
                        break;
                    default:
                        continue;
                }
                try {
                    await fs.unlink(filePath);
                    totalSize += file.size;
                    deletedCount++;
                }
                catch (error) {
                    console.error(`Error deleting file ${filePath}:`, error);
                    await this.prisma.file.update({
                        where: { id: file.id },
                        data: { status: client_1.FileStatus.ACTIVE }
                    });
                }
            }
            catch (error) {
                console.error(`Error processing orphaned file ${file.id}:`, error);
            }
        }
        return {
            deletedFiles: deletedCount,
            freedSpace: this.formatFileSize(totalSize)
        };
    }
    async getProductFiles(productId) {
        const product = await this.prisma.product.findUnique({
            where: { id: productId },
            select: {
                pdfFileId: true,
                imageFileIds: true,
                thumbnailFileIds: true
            }
        });
        if (!product) {
            throw new common_1.NotFoundException('Product not found');
        }
        const fileInfo = {
            pdf: null,
            images: [],
            thumbnails: []
        };
        if (product.pdfFileId) {
            const pdfFile = await this.prisma.file.findUnique({
                where: {
                    id: product.pdfFileId,
                    status: client_1.FileStatus.ACTIVE
                }
            });
            if (pdfFile) {
                fileInfo.pdf = this.mapFileToResponse(pdfFile);
            }
        }
        if (product.imageFileIds) {
            try {
                const imageIds = JSON.parse(product.imageFileIds);
                if (Array.isArray(imageIds) && imageIds.length > 0) {
                    const imageFiles = await this.prisma.file.findMany({
                        where: {
                            id: { in: imageIds },
                            status: client_1.FileStatus.ACTIVE,
                            type: client_1.FileType.IMAGE
                        }
                    });
                    fileInfo.images = imageFiles.map(this.mapFileToResponse);
                }
            }
            catch (error) {
                console.warn('Error parsing imageFileIds:', error);
            }
        }
        if (product.thumbnailFileIds) {
            try {
                const thumbnailIds = JSON.parse(product.thumbnailFileIds);
                if (Array.isArray(thumbnailIds) && thumbnailIds.length > 0) {
                    const thumbnailFiles = await this.prisma.file.findMany({
                        where: {
                            id: { in: thumbnailIds },
                            status: client_1.FileStatus.ACTIVE,
                            type: client_1.FileType.THUMBNAIL
                        }
                    });
                    fileInfo.thumbnails = thumbnailFiles.map(this.mapFileToResponse);
                }
            }
            catch (error) {
                console.warn('Error parsing thumbnailFileIds:', error);
            }
        }
        return fileInfo;
    }
    async ensureUploadDirectory() {
        try {
            await fs.mkdir(this.uploadPath, { recursive: true });
            await fs.mkdir(path.join(this.uploadPath, 'pdfs'), { recursive: true });
            await fs.mkdir(path.join(this.uploadPath, 'images'), { recursive: true });
            await fs.mkdir(path.join(this.uploadPath, 'thumbnails'), { recursive: true });
        }
        catch (error) {
            console.error('Error creating upload directories:', error);
        }
    }
    async ensureDirectoryExists(dirPath) {
        try {
            await fs.mkdir(dirPath, { recursive: true });
        }
        catch (error) {
            console.error('Error creating directory:', error);
        }
    }
    generateFileKey(originalname, prefix) {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2);
        const extension = path.extname(originalname);
        return `${prefix}_${timestamp}_${random}${extension}`;
    }
    calculateChecksum(buffer) {
        return crypto.createHash('sha256').update(buffer).digest('hex');
    }
    getFileExtension(filename) {
        return path.extname(filename).toLowerCase().substring(1);
    }
    formatFileSize(bytes) {
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        if (bytes === 0)
            return '0 Bytes';
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + ' ' + sizes[i];
    }
    validateFileSignature(buffer, mimeType) {
        const signatures = {
            'application/pdf': [0x25, 0x50, 0x44, 0x46],
            'image/jpeg': [0xFF, 0xD8, 0xFF],
            'image/png': [0x89, 0x50, 0x4E, 0x47],
            'image/webp': [0x52, 0x49, 0x46, 0x46]
        };
        const signature = signatures[mimeType];
        if (signature) {
            for (let i = 0; i < signature.length; i++) {
                if (buffer[i] !== signature[i]) {
                    throw new common_1.BadRequestException('File signature does not match MIME type');
                }
            }
        }
    }
    async extractPdfMetadata(buffer) {
        return {
            extractedAt: new Date().toISOString(),
            size: buffer.length
        };
    }
    isAdmin(userId) {
        return false;
    }
};
exports.FilesService = FilesService;
exports.FilesService = FilesService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _b : Object])
], FilesService);


/***/ }),
/* 47 */
/***/ ((module) => {

"use strict";
module.exports = require("sharp");

/***/ }),
/* 48 */
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),
/* 49 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 50 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),
/* 51 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilesController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const platform_express_1 = __webpack_require__(45);
const express_1 = __webpack_require__(52);
const fs = __importStar(__webpack_require__(48));
const files_service_1 = __webpack_require__(46);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const current_user_decorator_1 = __webpack_require__(26);
const roles_decorator_1 = __webpack_require__(31);
const public_decorator_1 = __webpack_require__(25);
const client_1 = __webpack_require__(11);
var FileType;
(function (FileType) {
    FileType["PDF"] = "PDF";
    FileType["IMAGE"] = "IMAGE";
    FileType["THUMBNAIL"] = "THUMBNAIL";
})(FileType || (FileType = {}));
let FilesController = class FilesController {
    constructor(filesService) {
        this.filesService = filesService;
    }
    async uploadPdf(file, user) {
        if (!file) {
            throw new Error('No file uploaded');
        }
        const uploadedFile = {
            fieldname: file.fieldname,
            originalname: file.originalname,
            encoding: file.encoding,
            mimetype: file.mimetype,
            size: file.size,
            buffer: file.buffer,
        };
        return this.filesService.uploadPdf(uploadedFile, user.id);
    }
    async uploadImages(files, user) {
        if (!files || files.length === 0) {
            throw new Error('No files uploaded');
        }
        const uploadedFiles = files.map(file => ({
            fieldname: file.fieldname,
            originalname: file.originalname,
            encoding: file.encoding,
            mimetype: file.mimetype,
            size: file.size,
            buffer: file.buffer,
        }));
        return this.filesService.uploadImages(uploadedFiles, user.id);
    }
    async getMyFiles(user, type) {
        return this.filesService.getUserFiles(user.id, type);
    }
    async downloadPdf(key, res) {
        const { file, filePath } = await this.filesService.getFileByKey(key);
        const fileBuffer = await fs.readFile(filePath);
        res.set({
            'Content-Type': 'application/pdf',
            'Content-Disposition': `attachment; filename="${file.filename}"`,
            'Content-Length': file.size,
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0',
        });
        res.send(fileBuffer);
    }
    async getImage(key, res) {
        const { file, filePath } = await this.filesService.getFileByKey(key);
        const fileBuffer = await fs.readFile(filePath);
        res.set({
            'Content-Type': file.mimeType,
            'Content-Length': file.size,
            'Cache-Control': 'public, max-age=86400',
            'ETag': file.checksum,
        });
        res.send(fileBuffer);
    }
    async getThumbnail(key, res) {
        const { file, filePath } = await this.filesService.getFileByKey(key);
        const fileBuffer = await fs.readFile(filePath);
        res.set({
            'Content-Type': 'image/jpeg',
            'Content-Length': file.size,
            'Cache-Control': 'public, max-age=86400',
            'ETag': file.checksum,
        });
        res.send(fileBuffer);
    }
    async getFileMetadata(id, user) {
        return this.filesService.getFileMetadata(id, user.id);
    }
    async deleteFile(id, user) {
        await this.filesService.deleteFile(id, user.id, user.role);
    }
    async cleanupOrphanedFiles(user) {
        return this.filesService.cleanupOrphanedFiles();
    }
    async getStorageStats() {
        return this.filesService.getStorageStats();
    }
};
exports.FilesController = FilesController;
__decorate([
    (0, common_1.Post)('upload/pdf'),
    (0, common_1.UseInterceptors)((0, platform_express_1.FileInterceptor)('pdf', {
        limits: {
            fileSize: 10 * 1024 * 1024,
        },
        fileFilter: (req, file, cb) => {
            if (file.mimetype === 'application/pdf') {
                cb(null, true);
            }
            else {
                cb(new Error('Only PDF files are allowed'), false);
            }
        },
    })),
    (0, swagger_1.ApiOperation)({ summary: 'Subir archivo PDF' }),
    (0, swagger_1.ApiConsumes)('multipart/form-data'),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'PDF subido exitosamente',
        schema: {
            type: 'object',
            properties: {
                id: { type: 'string' },
                key: { type: 'string' },
                url: { type: 'string' },
                type: { type: 'string' },
                size: { type: 'number' },
                mimeType: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Archivo inv√°lido' }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    __param(0, (0, common_1.UploadedFile)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof Express !== "undefined" && (_b = Express.Multer) !== void 0 && _b.File) === "function" ? _c : Object, Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "uploadPdf", null);
__decorate([
    (0, common_1.Post)('upload/images'),
    (0, common_1.UseInterceptors)((0, platform_express_1.FilesInterceptor)('images', 5, {
        limits: {
            fileSize: 5 * 1024 * 1024,
        },
        fileFilter: (req, file, cb) => {
            if (file.mimetype.startsWith('image/')) {
                cb(null, true);
            }
            else {
                cb(new Error('Only image files are allowed'), false);
            }
        },
    })),
    (0, swagger_1.ApiOperation)({ summary: 'Subir m√∫ltiples im√°genes (m√°ximo 5)' }),
    (0, swagger_1.ApiConsumes)('multipart/form-data'),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Im√°genes subidas exitosamente',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    key: { type: 'string' },
                    url: { type: 'string' },
                    type: { type: 'string' },
                    size: { type: 'number' },
                    mimeType: { type: 'string' },
                    width: { type: 'number' },
                    height: { type: 'number' },
                },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Archivos inv√°lidos' }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    __param(0, (0, common_1.UploadedFiles)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "uploadImages", null);
__decorate([
    (0, common_1.Get)('my'),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener mis archivos subidos' }),
    (0, swagger_1.ApiQuery)({
        name: 'type',
        required: false,
        enum: FileType,
        description: 'Filtrar por tipo de archivo'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Lista de archivos del usuario',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    filename: { type: 'string' },
                    key: { type: 'string' },
                    url: { type: 'string' },
                    type: { type: 'string' },
                    size: { type: 'number' },
                    mimeType: { type: 'string' },
                    width: { type: 'number' },
                    height: { type: 'number' },
                    createdAt: { type: 'string' },
                },
            },
        },
    }),
    (0, swagger_1.ApiBearerAuth)(),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)('type')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "getMyFiles", null);
__decorate([
    (0, common_1.Get)('pdf/:key'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Descargar archivo PDF' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'Clave √∫nica del archivo' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Archivo PDF' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Archivo no encontrado' }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_d = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "downloadPdf", null);
__decorate([
    (0, common_1.Get)('image/:key'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Ver imagen' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'Clave √∫nica de la imagen' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Imagen' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Imagen no encontrada' }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_e = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "getImage", null);
__decorate([
    (0, common_1.Get)('thumbnail/:key'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Ver thumbnail' }),
    (0, swagger_1.ApiParam)({ name: 'key', description: 'Clave √∫nica del thumbnail' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Thumbnail' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Thumbnail no encontrado' }),
    __param(0, (0, common_1.Param)('key')),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "getThumbnail", null);
__decorate([
    (0, common_1.Get)(':id/metadata'),
    (0, swagger_1.ApiOperation)({ summary: 'Obtener metadata de un archivo' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID del archivo' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Metadata del archivo',
        schema: {
            type: 'object',
            properties: {
                id: { type: 'string' },
                filename: { type: 'string' },
                key: { type: 'string' },
                url: { type: 'string' },
                type: { type: 'string' },
                size: { type: 'number' },
                mimeType: { type: 'string' },
                width: { type: 'number' },
                height: { type: 'number' },
                checksum: { type: 'string' },
                metadata: { type: 'object' },
                createdAt: { type: 'string' },
            },
        },
    }),
    (0, swagger_1.ApiBearerAuth)(),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "getFileMetadata", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, swagger_1.ApiOperation)({ summary: 'Eliminar archivo' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID del archivo' }),
    (0, swagger_1.ApiResponse)({ status: 204, description: 'Archivo eliminado' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'No autorizado' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Archivo no encontrado' }),
    (0, swagger_1.ApiBearerAuth)(),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "deleteFile", null);
__decorate([
    (0, common_1.Post)('cleanup'),
    (0, swagger_1.ApiOperation)({ summary: 'Limpiar archivos hu√©rfanos (admin)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Limpieza completada',
        schema: {
            type: 'object',
            properties: {
                deletedFiles: { type: 'number' },
                freedSpace: { type: 'string' },
            }
        }
    }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "cleanupOrphanedFiles", null);
__decorate([
    (0, common_1.Get)('stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Estad√≠sticas de almacenamiento (admin)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Estad√≠sticas de archivos',
        schema: {
            type: 'object',
            properties: {
                totalFiles: { type: 'number' },
                totalSize: { type: 'string' },
                filesByType: { type: 'object' },
                storageUsage: { type: 'object' },
            }
        }
    }),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], FilesController.prototype, "getStorageStats", null);
exports.FilesController = FilesController = __decorate([
    (0, swagger_1.ApiTags)('Files'),
    (0, common_1.Controller)('files'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    __metadata("design:paramtypes", [typeof (_a = typeof files_service_1.FilesService !== "undefined" && files_service_1.FilesService) === "function" ? _a : Object])
], FilesController);


/***/ }),
/* 52 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



module.exports = __webpack_require__(53);


/***/ }),
/* 53 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var bodyParser = __webpack_require__(54)
var EventEmitter = (__webpack_require__(164).EventEmitter);
var mixin = __webpack_require__(165);
var proto = __webpack_require__(166);
var Router = __webpack_require__(188);
var req = __webpack_require__(193);
var res = __webpack_require__(203);

/**
 * Expose `createApplication()`.
 */

exports = module.exports = createApplication;

/**
 * Create an express application.
 *
 * @return {Function}
 * @api public
 */

function createApplication() {
  var app = function(req, res, next) {
    app.handle(req, res, next);
  };

  mixin(app, EventEmitter.prototype, false);
  mixin(app, proto, false);

  // expose the prototype that will get set on requests
  app.request = Object.create(req, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  // expose the prototype that will get set on responses
  app.response = Object.create(res, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  app.init();
  return app;
}

/**
 * Expose the prototypes.
 */

exports.application = proto;
exports.request = req;
exports.response = res;

/**
 * Expose constructors.
 */

exports.Route = Router.Route;
exports.Router = Router;

/**
 * Expose middleware
 */

exports.json = bodyParser.json
exports.raw = bodyParser.raw
exports["static"] = __webpack_require__(210);
exports.text = bodyParser.text
exports.urlencoded = bodyParser.urlencoded


/***/ }),
/* 54 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * @typedef Parsers
 * @type {function}
 * @property {function} json
 * @property {function} raw
 * @property {function} text
 * @property {function} urlencoded
 */

/**
 * Module exports.
 * @type {Parsers}
 */

exports = module.exports = bodyParser

/**
 * JSON parser.
 * @public
 */

Object.defineProperty(exports, "json", ({
  configurable: true,
  enumerable: true,
  get: () => __webpack_require__(55)
}))

/**
 * Raw parser.
 * @public
 */

Object.defineProperty(exports, "raw", ({
  configurable: true,
  enumerable: true,
  get: () => __webpack_require__(115)
}))

/**
 * Text parser.
 * @public
 */

Object.defineProperty(exports, "text", ({
  configurable: true,
  enumerable: true,
  get: () => __webpack_require__(116)
}))

/**
 * URL-encoded parser.
 * @public
 */

Object.defineProperty(exports, "urlencoded", ({
  configurable: true,
  enumerable: true,
  get: () => __webpack_require__(117)
}))

/**
 * Create a middleware to parse json and urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @deprecated
 * @public
 */

function bodyParser () {
  throw new Error('The bodyParser() generic has been split into individual middleware to use instead.')
}


/***/ }),
/* 55 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(56)
var debug = __webpack_require__(65)('body-parser:json')
var isFinished = (__webpack_require__(74).isFinished)
var read = __webpack_require__(77)
var typeis = __webpack_require__(107)
var { getCharset, normalizeOptions } = __webpack_require__(114)

/**
 * Module exports.
 */

module.exports = json

/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */

var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/ // eslint-disable-line no-control-regex

var JSON_SYNTAX_CHAR = '#'
var JSON_SYNTAX_REGEXP = /#+/g

/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function json (options) {
  var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'application/json')

  var reviver = options?.reviver
  var strict = options?.strict !== false

  function parse (body) {
    if (body.length === 0) {
      // special-case empty json body, as it's a common client-side mistake
      // TODO: maybe make this configurable or part of "strict" option
      return {}
    }

    if (strict) {
      var first = firstchar(body)

      if (first !== '{' && first !== '[') {
        debug('strict violation')
        throw createStrictSyntaxError(body, first)
      }
    }

    try {
      debug('parse json')
      return JSON.parse(body, reviver)
    } catch (e) {
      throw normalizeJsonSyntaxError(e, {
        message: e.message,
        stack: e.stack
      })
    }
  }

  return function jsonParser (req, res, next) {
    if (isFinished(req)) {
      debug('body already parsed')
      next()
      return
    }

    if (!('body' in req)) {
      req.body = undefined
    }

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset per RFC 7159 sec 8.1
    var charset = getCharset(req) || 'utf-8'
    if (charset.slice(0, 4) !== 'utf-') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate,
      limit,
      verify
    })
  }
}

/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */

function createStrictSyntaxError (str, char) {
  var index = str.indexOf(char)
  var partial = ''

  if (index !== -1) {
    partial = str.substring(0, index) + JSON_SYNTAX_CHAR

    for (var i = index + 1; i < str.length; i++) {
      partial += JSON_SYNTAX_CHAR
    }
  }

  try {
    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')
  } catch (e) {
    return normalizeJsonSyntaxError(e, {
      message: e.message.replace(JSON_SYNTAX_REGEXP, function (placeholder) {
        return str.substring(index, index + placeholder.length)
      }),
      stack: e.stack
    })
  }
}

/**
 * Get the first non-whitespace character in a string.
 *
 * @param {string} str
 * @return {function}
 * @private
 */

function firstchar (str) {
  var match = FIRST_CHAR_REGEXP.exec(str)

  return match
    ? match[1]
    : undefined
}

/**
 * Normalize a SyntaxError for JSON.parse.
 *
 * @param {SyntaxError} error
 * @param {object} obj
 * @return {SyntaxError}
 */

function normalizeJsonSyntaxError (error, obj) {
  var keys = Object.getOwnPropertyNames(error)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    if (key !== 'stack' && key !== 'message') {
      delete error[key]
    }
  }

  // replace stack before message for Node.js 0.10 and below
  error.stack = obj.stack.replace(error.message, obj.message)
  error.message = obj.message

  return error
}


/***/ }),
/* 56 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var deprecate = __webpack_require__(57)('http-errors')
var setPrototypeOf = __webpack_require__(58)
var statuses = __webpack_require__(59)
var inherits = __webpack_require__(61)
var toIdentifier = __webpack_require__(64)

/**
 * Module exports.
 * @public
 */

module.exports = createError
module.exports.HttpError = createHttpErrorConstructor()
module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError)

// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)

/**
 * Get the code class of a status code.
 * @private
 */

function codeClass (status) {
  return Number(String(status).charAt(0) + '00')
}

/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */

function createError () {
  // so much arity going on ~_~
  var err
  var msg
  var status = 500
  var props = {}
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i]
    var type = typeof arg
    if (type === 'object' && arg instanceof Error) {
      err = arg
      status = err.status || err.statusCode || status
    } else if (type === 'number' && i === 0) {
      status = arg
    } else if (type === 'string') {
      msg = arg
    } else if (type === 'object') {
      props = arg
    } else {
      throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type)
    }
  }

  if (typeof status === 'number' && (status < 400 || status >= 600)) {
    deprecate('non-error status code; use only 4xx or 5xx status codes')
  }

  if (typeof status !== 'number' ||
    (!statuses.message[status] && (status < 400 || status >= 600))) {
    status = 500
  }

  // constructor
  var HttpError = createError[status] || createError[codeClass(status)]

  if (!err) {
    // create error
    err = HttpError
      ? new HttpError(msg)
      : new Error(msg || statuses.message[status])
    Error.captureStackTrace(err, createError)
  }

  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
    // add properties to generic error
    err.expose = status < 500
    err.status = err.statusCode = status
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key]
    }
  }

  return err
}

/**
 * Create HTTP error abstract base class.
 * @private
 */

function createHttpErrorConstructor () {
  function HttpError () {
    throw new TypeError('cannot construct abstract class')
  }

  inherits(HttpError, Error)

  return HttpError
}

/**
 * Create a constructor for a client error.
 * @private
 */

function createClientErrorConstructor (HttpError, name, code) {
  var className = toClassName(name)

  function ClientError (message) {
    // create the error object
    var msg = message != null ? message : statuses.message[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ClientError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ClientError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ClientError, HttpError)
  nameFunc(ClientError, className)

  ClientError.prototype.status = code
  ClientError.prototype.statusCode = code
  ClientError.prototype.expose = true

  return ClientError
}

/**
 * Create function to test is a value is a HttpError.
 * @private
 */

function createIsHttpErrorFunction (HttpError) {
  return function isHttpError (val) {
    if (!val || typeof val !== 'object') {
      return false
    }

    if (val instanceof HttpError) {
      return true
    }

    return val instanceof Error &&
      typeof val.expose === 'boolean' &&
      typeof val.statusCode === 'number' && val.status === val.statusCode
  }
}

/**
 * Create a constructor for a server error.
 * @private
 */

function createServerErrorConstructor (HttpError, name, code) {
  var className = toClassName(name)

  function ServerError (message) {
    // create the error object
    var msg = message != null ? message : statuses.message[code]
    var err = new Error(msg)

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ServerError)

    // adjust the [[Prototype]]
    setPrototypeOf(err, ServerError.prototype)

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    })

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    })

    return err
  }

  inherits(ServerError, HttpError)
  nameFunc(ServerError, className)

  ServerError.prototype.status = code
  ServerError.prototype.statusCode = code
  ServerError.prototype.expose = false

  return ServerError
}

/**
 * Set the name of a function, if possible.
 * @private
 */

function nameFunc (func, name) {
  var desc = Object.getOwnPropertyDescriptor(func, 'name')

  if (desc && desc.configurable) {
    desc.value = name
    Object.defineProperty(func, 'name', desc)
  }
}

/**
 * Populate the exports object with constructors for every error class.
 * @private
 */

function populateConstructorExports (exports, codes, HttpError) {
  codes.forEach(function forEachCode (code) {
    var CodeError
    var name = toIdentifier(statuses.message[code])

    switch (codeClass(code)) {
      case 400:
        CodeError = createClientErrorConstructor(HttpError, name, code)
        break
      case 500:
        CodeError = createServerErrorConstructor(HttpError, name, code)
        break
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError
      exports[name] = CodeError
    }
  })
}

/**
 * Get a class name from a name identifier.
 * @private
 */

function toClassName (name) {
  return name.substr(-5) !== 'Error'
    ? name + 'Error'
    : name
}


/***/ }),
/* 57 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var relative = (__webpack_require__(49).relative)

/**
 * Module exports.
 */

module.exports = depd

/**
 * Get the path to base files on.
 */

var basePath = process.cwd()

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace (str, namespace) {
  var vals = str.split(/[ ,]+/)
  var ns = String(namespace).toLowerCase()

  for (var i = 0; i < vals.length; i++) {
    var val = vals[i]

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true
    }
  }

  return false
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor (obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
  var value = descriptor.value

  descriptor.get = function getter () { return value }

  if (descriptor.writable) {
    descriptor.set = function setter (val) { return (value = val) }
  }

  delete descriptor.value
  delete descriptor.writable

  Object.defineProperty(obj, prop, descriptor)

  return descriptor
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString (arity) {
  var str = ''

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i
  }

  return str.substr(2)
}

/**
 * Create stack string from stack.
 */

function createStackString (stack) {
  var str = this.name + ': ' + this.namespace

  if (this.message) {
    str += ' deprecated ' + this.message
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + stack[i].toString()
  }

  return str
}

/**
 * Create deprecate for namespace in caller.
 */

function depd (namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required')
  }

  var stack = getStack()
  var site = callSiteLocation(stack[1])
  var file = site[0]

  function deprecate (message) {
    // call to self as log
    log.call(deprecate, message)
  }

  deprecate._file = file
  deprecate._ignored = isignored(namespace)
  deprecate._namespace = namespace
  deprecate._traced = istraced(namespace)
  deprecate._warned = Object.create(null)

  deprecate.function = wrapfunction
  deprecate.property = wrapproperty

  return deprecate
}

/**
 * Determine if event emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function eehaslisteners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Determine if namespace is ignored.
 */

function isignored (namespace) {
  if (process.noDeprecation) {
    // --no-deprecation support
    return true
  }

  var str = process.env.NO_DEPRECATION || ''

  // namespace ignored
  return containsNamespace(str, namespace)
}

/**
 * Determine if namespace is traced.
 */

function istraced (namespace) {
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true
  }

  var str = process.env.TRACE_DEPRECATION || ''

  // namespace traced
  return containsNamespace(str, namespace)
}

/**
 * Display deprecation message.
 */

function log (message, site) {
  var haslisteners = eehaslisteners(process, 'deprecation')

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return
  }

  var caller
  var callFile
  var callSite
  var depSite
  var i = 0
  var seen = false
  var stack = getStack()
  var file = this._file

  if (site) {
    // provided site
    depSite = site
    callSite = callSiteLocation(stack[1])
    callSite.name = depSite.name
    file = callSite[0]
  } else {
    // get call site
    i = 2
    depSite = callSiteLocation(stack[i])
    callSite = depSite
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i])
    callFile = caller[0]

    if (callFile === file) {
      seen = true
    } else if (callFile === this._file) {
      file = this._file
    } else if (seen) {
      break
    }
  }

  var key = caller
    ? depSite.join(':') + '__' + caller.join(':')
    : undefined

  if (key !== undefined && key in this._warned) {
    // already warned
    return
  }

  this._warned[key] = true

  // generate automatic message from call site
  var msg = message
  if (!msg) {
    msg = callSite === depSite || !callSite.name
      ? defaultMessage(depSite)
      : defaultMessage(callSite)
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i))
    process.emit('deprecation', err)
    return
  }

  // format and write message
  var format = process.stderr.isTTY
    ? formatColor
    : formatPlain
  var output = format.call(this, msg, caller, stack.slice(i))
  process.stderr.write(output + '\n', 'utf8')
}

/**
 * Get call site location as array.
 */

function callSiteLocation (callSite) {
  var file = callSite.getFileName() || '<anonymous>'
  var line = callSite.getLineNumber()
  var colm = callSite.getColumnNumber()

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file
  }

  var site = [file, line, colm]

  site.callSite = callSite
  site.name = callSite.getFunctionName()

  return site
}

/**
 * Generate a default message from the site.
 */

function defaultMessage (site) {
  var callSite = site.callSite
  var funcName = site.name

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>'
  }

  var context = callSite.getThis()
  var typeName = context && callSite.getTypeName()

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName
  }

  return typeName && callSite.getMethodName()
    ? typeName + '.' + funcName
    : funcName
}

/**
 * Format deprecation message without color.
 */

function formatPlain (msg, caller, stack) {
  var timestamp = new Date().toUTCString()

  var formatted = timestamp +
    ' ' + this._namespace +
    ' deprecated ' + msg

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + stack[i].toString()
    }

    return formatted
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller)
  }

  return formatted
}

/**
 * Format deprecation message with color.
 */

function formatColor (msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
    ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
    ' \x1b[0m' + msg + '\x1b[39m' // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m' // cyan
    }

    return formatted
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
  }

  return formatted
}

/**
 * Format call site location.
 */

function formatLocation (callSite) {
  return relative(basePath, callSite[0]) +
    ':' + callSite[1] +
    ':' + callSite[2]
}

/**
 * Get the stack as array of call sites.
 */

function getStack () {
  var limit = Error.stackTraceLimit
  var obj = {}
  var prep = Error.prepareStackTrace

  Error.prepareStackTrace = prepareObjectStackTrace
  Error.stackTraceLimit = Math.max(10, limit)

  // capture the stack
  Error.captureStackTrace(obj)

  // slice this function off the top
  var stack = obj.stack.slice(1)

  Error.prepareStackTrace = prep
  Error.stackTraceLimit = limit

  return stack
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace (obj, stack) {
  return stack
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction (fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  var args = createArgumentsString(fn.length)
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  site.name = fn.name

  // eslint-disable-next-line no-new-func
  var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site',
    '"use strict"\n' +
    'return function (' + args + ') {' +
    'log.call(deprecate, message, site)\n' +
    'return fn.apply(this, arguments)\n' +
    '}')(fn, log, this, message, site)

  return deprecatedfn
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty (obj, prop, message) {
  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
    throw new TypeError('argument obj must be object')
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

  if (!descriptor) {
    throw new TypeError('must call property on owner object')
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable')
  }

  var deprecate = this
  var stack = getStack()
  var site = callSiteLocation(stack[1])

  // set site name
  site.name = prop

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
  }

  var get = descriptor.get
  var set = descriptor.set

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter () {
      log.call(deprecate, message, site)
      return get.apply(this, arguments)
    }
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter () {
      log.call(deprecate, message, site)
      return set.apply(this, arguments)
    }
  }

  Object.defineProperty(obj, prop, descriptor)
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError (namespace, message, stack) {
  var error = new Error()
  var stackString

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  })

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  })

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  })

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  })

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString
      }

      // prepare stack trace
      return (stackString = createStackString.call(this, stack))
    },
    set: function setter (val) {
      stackString = val
    }
  })

  return error
}


/***/ }),
/* 58 */
/***/ ((module) => {

"use strict";

/* eslint no-proto: 0 */
module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties)

function setProtoOf (obj, proto) {
  obj.__proto__ = proto
  return obj
}

function mixinProperties (obj, proto) {
  for (var prop in proto) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto[prop]
    }
  }
  return obj
}


/***/ }),
/* 59 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var codes = __webpack_require__(60)

/**
 * Module exports.
 * @public
 */

module.exports = status

// status code to message map
status.message = codes

// status message (lower-case) to code map
status.code = createMessageToStatusCodeMap(codes)

// array of status codes
status.codes = createStatusCodeList(codes)

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
}

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
}

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
}

/**
 * Create a map of message to status code.
 * @private
 */

function createMessageToStatusCodeMap (codes) {
  var map = {}

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code]
    var status = Number(code)

    // populate map
    map[message.toLowerCase()] = status
  })

  return map
}

/**
 * Create a list of all status codes.
 * @private
 */

function createStatusCodeList (codes) {
  return Object.keys(codes).map(function mapCode (code) {
    return Number(code)
  })
}

/**
 * Get the status code for given message.
 * @private
 */

function getStatusCode (message) {
  var msg = message.toLowerCase()

  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"')
  }

  return status.code[msg]
}

/**
 * Get the status message for given code.
 * @private
 */

function getStatusMessage (code) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
    throw new Error('invalid status code: ' + code)
  }

  return status.message[code]
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    return getStatusMessage(code)
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10)
  if (!isNaN(n)) {
    return getStatusMessage(n)
  }

  return getStatusCode(code)
}


/***/ }),
/* 60 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a Teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Too Early","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');

/***/ }),
/* 61 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(62);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(63);
}


/***/ }),
/* 62 */
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),
/* 63 */
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),
/* 64 */
/***/ ((module) => {

"use strict";
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = toIdentifier

/**
 * Trasform the given string into a JavaScript identifier
 *
 * @param {string} str
 * @returns {string}
 * @public
 */

function toIdentifier (str) {
  return str
    .split(' ')
    .map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1)
    })
    .join('')
    .replace(/[^ _0-9a-z]/gi, '')
}


/***/ }),
/* 65 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(66);
} else {
	module.exports = __webpack_require__(69);
}


/***/ }),
/* 66 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(67)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),
/* 67 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(68);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(/\s+/g, ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),
/* 68 */
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 69 */
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(70);
const util = __webpack_require__(62);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(71);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(67)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),
/* 70 */
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),
/* 71 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(72);
const tty = __webpack_require__(70);
const hasFlag = __webpack_require__(73);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),
/* 72 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),
/* 73 */
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),
/* 74 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = onFinished
module.exports.isFinished = isFinished

/**
 * Module dependencies.
 * @private
 */

var asyncHooks = tryRequireAsyncHooks()
var first = __webpack_require__(75)

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished (msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg)
    return msg
  }

  // attach the listener to the message
  attachListener(msg, wrap(listener))

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished (msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener (msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish (error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket (socket) {
    // remove listener
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket)
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // istanbul ignore next: node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener (msg, listener) {
  var attached = msg.__onFinished

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener (msg) {
  function listener (err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

// istanbul ignore next: node.js 0.8 patch
function patchAssignSocket (res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket (socket) {
    assignSocket.call(this, socket)
    callback(socket)
  }
}

/**
 * Try to require async_hooks
 * @private
 */

function tryRequireAsyncHooks () {
  try {
    return __webpack_require__(76)
  } catch (e) {
    return {}
  }
}

/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */

function wrap (fn) {
  var res

  // create anonymous resource
  if (asyncHooks.AsyncResource) {
    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')
  }

  // incompatible node.js
  if (!res || !res.runInAsyncScope) {
    return fn
  }

  // return bound function
  return res.runInAsyncScope.bind(res, fn, null)
}


/***/ }),
/* 75 */
/***/ ((module) => {

"use strict";
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = first

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = []

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i]

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0]

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j]
      var fn = listener(event, callback)

      // listen to the event
      ee.on(event, fn)
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      })
    }
  }

  function callback() {
    cleanup()
    done.apply(null, arguments)
  }

  function cleanup() {
    var x
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i]
      x.ee.removeListener(x.event, x.fn)
    }
  }

  function thunk(fn) {
    done = fn
  }

  thunk.cancel = cleanup

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length)
    var ee = this
    var err = event === 'error'
      ? arg1
      : null

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    done(err, ee, event, args)
  }
}


/***/ }),
/* 76 */
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),
/* 77 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(56)
var getBody = __webpack_require__(78)
var iconv = __webpack_require__(80)
var onFinished = __webpack_require__(74)
var zlib = __webpack_require__(106)

/**
 * Module exports.
 */

module.exports = read

/**
 * Read a request into a buffer and parse.
 *
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @param {function} parse
 * @param {function} debug
 * @param {object} options
 * @private
 */

function read (req, res, next, parse, debug, options) {
  var length
  var opts = options
  var stream

  // read options
  var encoding = opts.encoding !== null
    ? opts.encoding
    : null
  var verify = opts.verify

  try {
    // get the content stream
    stream = contentstream(req, debug, opts.inflate)
    length = stream.length
    stream.length = undefined
  } catch (err) {
    return next(err)
  }

  // set raw-body options
  opts.length = length
  opts.encoding = verify
    ? null
    : encoding

  // assert charset is supported
  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
    return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
      charset: encoding.toLowerCase(),
      type: 'charset.unsupported'
    }))
  }

  // read body
  debug('read body')
  getBody(stream, opts, function (error, body) {
    if (error) {
      var _error

      if (error.type === 'encoding.unsupported') {
        // echo back charset
        _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: 'charset.unsupported'
        })
      } else {
        // set status code on error
        _error = createError(400, error)
      }

      // unpipe from stream and destroy
      if (stream !== req) {
        req.unpipe()
        stream.destroy()
      }

      // read off entire request
      dump(req, function onfinished () {
        next(createError(400, _error))
      })
      return
    }

    // verify
    if (verify) {
      try {
        debug('verify body')
        verify(req, res, body, encoding)
      } catch (err) {
        next(createError(403, err, {
          body: body,
          type: err.type || 'entity.verify.failed'
        }))
        return
      }
    }

    // parse
    var str = body
    try {
      debug('parse body')
      str = typeof body !== 'string' && encoding !== null
        ? iconv.decode(body, encoding)
        : body
      req.body = parse(str, encoding)
    } catch (err) {
      next(createError(400, err, {
        body: str,
        type: err.type || 'entity.parse.failed'
      }))
      return
    }

    next()
  })
}

/**
 * Get the content stream of the request.
 *
 * @param {object} req
 * @param {function} debug
 * @param {boolean} [inflate=true]
 * @return {object}
 * @api private
 */

function contentstream (req, debug, inflate) {
  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()
  var length = req.headers['content-length']

  debug('content-encoding "%s"', encoding)

  if (inflate === false && encoding !== 'identity') {
    throw createError(415, 'content encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }

  if (encoding === 'identity') {
    req.length = length
    return req
  }

  var stream = createDecompressionStream(encoding, debug)
  req.pipe(stream)
  return stream
}

/**
 * Create a decompression stream for the given encoding.
 * @param {string} encoding
 * @param {function} debug
 * @return {object}
 * @api private
 */
function createDecompressionStream (encoding, debug) {
  switch (encoding) {
    case 'deflate':
      debug('inflate body')
      return zlib.createInflate()
    case 'gzip':
      debug('gunzip body')
      return zlib.createGunzip()
    case 'br':
      debug('brotli decompress body')
      return zlib.createBrotliDecompress()
    default:
      throw createError(415, 'unsupported content encoding "' + encoding + '"', {
        encoding: encoding,
        type: 'encoding.unsupported'
      })
  }
}

/**
 * Dump the contents of a request.
 *
 * @param {object} req
 * @param {function} callback
 * @api private
 */

function dump (req, callback) {
  if (onFinished.isFinished(req)) {
    callback(null)
  } else {
    onFinished(req, callback)
    req.resume()
  }
}


/***/ }),
/* 78 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var asyncHooks = tryRequireAsyncHooks()
var bytes = __webpack_require__(79)
var createError = __webpack_require__(56)
var iconv = __webpack_require__(80)
var unpipe = __webpack_require__(105)

/**
 * Module exports.
 * @public
 */

module.exports = getRawBody

/**
 * Module variables.
 * @private
 */

var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /

/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */

function getDecoder (encoding) {
  if (!encoding) return null

  try {
    return iconv.getDecoder(encoding)
  } catch (e) {
    // error getting decoder
    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

    // the encoding was not found
    throw createError(415, 'specified encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
  }
}

/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */

function getRawBody (stream, options, callback) {
  var done = callback
  var opts = options || {}

  // light validation
  if (stream === undefined) {
    throw new TypeError('argument stream is required')
  } else if (typeof stream !== 'object' || stream === null || typeof stream.on !== 'function') {
    throw new TypeError('argument stream must be a stream')
  }

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    }
  }

  if (typeof options === 'function') {
    done = options
    opts = {}
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!done && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  // get encoding
  var encoding = opts.encoding !== true
    ? opts.encoding
    : 'utf-8'

  // convert the limit to an integer
  var limit = bytes.parse(opts.limit)

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length)
    ? parseInt(opts.length, 10)
    : null

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, wrap(done))
  }

  return new Promise(function executor (resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead (err, buf) {
      if (err) return reject(err)
      resolve(buf)
    })
  })
}

/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */

function halt (stream) {
  // unpipe everything from the stream
  unpipe(stream)

  // pause stream
  if (typeof stream.pause === 'function') {
    stream.pause()
  }
}

/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */

function readStream (stream, encoding, length, limit, callback) {
  var complete = false
  var sync = true

  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit) {
    return done(createError(413, 'request entity too large', {
      expected: length,
      length: length,
      limit: limit,
      type: 'entity.too.large'
    }))
  }

  // streams1: assert request encoding is buffer.
  // streams2+: assert the stream encoding is buffer.
  //   stream._decoder: streams1
  //   state.encoding: streams2
  //   state.decoder: streams2, specifically < 0.10.6
  var state = stream._readableState
  if (stream._decoder || (state && (state.encoding || state.decoder))) {
    // developer error
    return done(createError(500, 'stream encoding should not be set', {
      type: 'stream.encoding.set'
    }))
  }

  if (typeof stream.readable !== 'undefined' && !stream.readable) {
    return done(createError(500, 'stream is not readable', {
      type: 'stream.not.readable'
    }))
  }

  var received = 0
  var decoder

  try {
    decoder = getDecoder(encoding)
  } catch (err) {
    return done(err)
  }

  var buffer = decoder
    ? ''
    : []

  // attach listeners
  stream.on('aborted', onAborted)
  stream.on('close', cleanup)
  stream.on('data', onData)
  stream.on('end', onEnd)
  stream.on('error', onEnd)

  // mark sync section complete
  sync = false

  function done () {
    var args = new Array(arguments.length)

    // copy arguments
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    // mark complete
    complete = true

    if (sync) {
      process.nextTick(invokeCallback)
    } else {
      invokeCallback()
    }

    function invokeCallback () {
      cleanup()

      if (args[0]) {
        // halt the stream on error
        halt(stream)
      }

      callback.apply(null, args)
    }
  }

  function onAborted () {
    if (complete) return

    done(createError(400, 'request aborted', {
      code: 'ECONNABORTED',
      expected: length,
      length: length,
      received: received,
      type: 'request.aborted'
    }))
  }

  function onData (chunk) {
    if (complete) return

    received += chunk.length

    if (limit !== null && received > limit) {
      done(createError(413, 'request entity too large', {
        limit: limit,
        received: received,
        type: 'entity.too.large'
      }))
    } else if (decoder) {
      buffer += decoder.write(chunk)
    } else {
      buffer.push(chunk)
    }
  }

  function onEnd (err) {
    if (complete) return
    if (err) return done(err)

    if (length !== null && received !== length) {
      done(createError(400, 'request size did not match content length', {
        expected: length,
        length: length,
        received: received,
        type: 'request.size.invalid'
      }))
    } else {
      var string = decoder
        ? buffer + (decoder.end() || '')
        : Buffer.concat(buffer)
      done(null, string)
    }
  }

  function cleanup () {
    buffer = null

    stream.removeListener('aborted', onAborted)
    stream.removeListener('data', onData)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onEnd)
    stream.removeListener('close', cleanup)
  }
}

/**
 * Try to require async_hooks
 * @private
 */

function tryRequireAsyncHooks () {
  try {
    return __webpack_require__(76)
  } catch (e) {
    return {}
  }
}

/**
 * Wrap function with async resource, if possible.
 * AsyncResource.bind static method backported.
 * @private
 */

function wrap (fn) {
  var res

  // create anonymous resource
  if (asyncHooks.AsyncResource) {
    res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')
  }

  // incompatible node.js
  if (!res || !res.runInAsyncScope) {
    return fn
  }

  // return bound function
  return res.runInAsyncScope.bind(res, fn, null)
}


/***/ }),
/* 79 */
/***/ ((module) => {

"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b:  1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5),
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = (options && options.thousandsSeparator) || '';
  var unitSeparator = (options && options.unitSeparator) || '';
  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = (options && options.unit) || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.pb) {
      unit = 'PB';
    } else if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.split('.').map(function (s, i) {
      return i === 0
        ? s.replace(formatThousandsRegExp, thousandsSeparator)
        : s
    }).join('.');
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b'
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  if (isNaN(floatValue)) {
    return null;
  }

  return Math.floor(map[unit] * floatValue);
}


/***/ }),
/* 80 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Buffer = (__webpack_require__(81).Buffer);

var bomHandling = __webpack_require__(83),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = 'ÔøΩ';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = __webpack_require__(84); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}

// Streaming API
// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
// If you would like to enable it explicitly, please add the following code to your app:
// > iconv.enableStreamingAPI(require('stream'));
iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
    if (iconv.supportsStreams)
        return;

    // Dependency-inject stream module to create IconvLite stream classes.
    var streams = __webpack_require__(103)(stream_module);

    // Not public API yet, but expose the stream classes.
    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;

    // Streaming API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    }

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    }

    iconv.supportsStreams = true;
}

// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
var stream_module;
try {
    stream_module = __webpack_require__(104);
} catch (e) {}

if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);

} else {
    // In rare cases where 'stream' module is not available by default, throw a helpful exception.
    iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
}

if (false) {}


/***/ }),
/* 81 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(82)
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),
/* 82 */
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}



/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    __webpack_require__(85),
    __webpack_require__(87),
    __webpack_require__(88),
    __webpack_require__(89),
    __webpack_require__(90),
    __webpack_require__(91),
    __webpack_require__(92),
    __webpack_require__(93),
    __webpack_require__(94),
];

// Put all encoding/alias/codec definitions to single object and export it.
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}


/***/ }),
/* 85 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(81).Buffer);

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'üí©') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = (__webpack_require__(86).StringDecoder);

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
}

InternalDecoder.prototype.write = function(buf) {
    if (!Buffer.isBuffer(buf)) {
        buf = Buffer.from(buf);
    }

    return this.decoder.write(buf);
}

InternalDecoder.prototype.end = function() {
    return this.decoder.end();
}


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}


/***/ }),
/* 86 */
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Buffer = (__webpack_require__(81).Buffer);

// == UTF32-LE/BE codec. ==========================================================

exports._utf32 = Utf32Codec;

function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
}

exports.utf32le = { type: '_utf32', isLE: true };
exports.utf32be = { type: '_utf32', isLE: false };

// Aliases
exports.ucs4le = 'utf32le';
exports.ucs4be = 'utf32be';

Utf32Codec.prototype.encoder = Utf32Encoder;
Utf32Codec.prototype.decoder = Utf32Decoder;

// -- Encoding

function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
}

Utf32Encoder.prototype.write = function(str) {
    var src = Buffer.from(str, 'ucs2');
    var dst = Buffer.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;

    for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = (0xD800 <= code && code < 0xDC00);
        var isLowSurrogate = (0xDC00 <= code && code < 0xE000);

        if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
                // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
                // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
                // (technically wrong, but expected by some applications, like Windows file names).
                write32.call(dst, this.highSurrogate, offset);
                offset += 4;
            }
            else {
                // Create 32-bit value from high and low surrogates;
                var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000;

                write32.call(dst, codepoint, offset);
                offset += 4;
                this.highSurrogate = 0;

                continue;
            }
        }

        if (isHighSurrogate)
            this.highSurrogate = code;
        else {
            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
            // unpaired high surrogates.
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
        }
    }

    if (offset < dst.length)
        dst = dst.slice(0, offset);

    return dst;
};

Utf32Encoder.prototype.end = function() {
    // Treat any leftover high surrogate as a semi-valid independent character.
    if (!this.highSurrogate)
        return;

    var buf = Buffer.alloc(4);

    if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
    else
        buf.writeUInt32BE(this.highSurrogate, 0);

    this.highSurrogate = 0;

    return buf;
};

// -- Decoding

function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
}

Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
        return '';

    var i = 0;
    var codepoint = 0;
    var dst = Buffer.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;

    if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
            overflow.push(src[i]);
        
        if (overflow.length === 4) {
            // NOTE: codepoint is a signed int32 and can be negative.
            // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
            if (isLE) {
                codepoint = overflow[i] | (overflow[i+1] << 8) | (overflow[i+2] << 16) | (overflow[i+3] << 24);
            } else {
                codepoint = overflow[i+3] | (overflow[i+2] << 8) | (overflow[i+1] << 16) | (overflow[i] << 24);
            }
            overflow.length = 0;

            offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
    }

    // Main loop. Should be as optimized as possible.
    for (; i < src.length - 3; i += 4) {
        // NOTE: codepoint is a signed int32 and can be negative.
        if (isLE) {
            codepoint = src[i] | (src[i+1] << 8) | (src[i+2] << 16) | (src[i+3] << 24);
        } else {
            codepoint = src[i+3] | (src[i+2] << 8) | (src[i+1] << 16) | (src[i] << 24);
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }

    // Keep overflowing bytes.
    for (; i < src.length; i++) {
        overflow.push(src[i]);
    }

    return dst.slice(0, offset).toString('ucs2');
};

function _writeCodepoint(dst, offset, codepoint, badChar) {
    // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
    if (codepoint < 0 || codepoint > 0x10FFFF) {
        // Not a valid Unicode codepoint
        codepoint = badChar;
    } 

    // Ephemeral Planes: Write high surrogate.
    if (codepoint >= 0x10000) {
        codepoint -= 0x10000;

        var high = 0xD800 | (codepoint >> 10);
        dst[offset++] = high & 0xff;
        dst[offset++] = high >> 8;

        // Low surrogate is written below.
        var codepoint = 0xDC00 | (codepoint & 0x3FF);
    }

    // Write BMP char or low surrogate.
    dst[offset++] = codepoint & 0xff;
    dst[offset++] = codepoint >> 8;

    return offset;
};

Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
};

// == UTF-32 Auto codec =============================================================
// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

// Encoder prepends BOM (which can be overridden with (addBOM: false}).

exports.utf32 = Utf32AutoCodec;
exports.ucs4 = 'utf32';

function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
}

Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

// -- Encoding

function Utf32AutoEncoder(options, codec) {
    options = options || {};

    if (options.addBOM === undefined)
        options.addBOM = true;

    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
}

Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
};

Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
};

// -- Decoding

function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) { 
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;

        if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }

    return this.decoder.write(buf);
};

Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        var trail = this.decoder.end();
        if (trail)
            resStr += trail;

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }

    return this.decoder.end();
};

function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;   // Number of invalid chars when decoded as LE or BE.
    var bmpCharsLE = 0, bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.

    outer_loop:
    for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
                if (charsProcessed === 0) {
                    // Check BOM first.
                    if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
                        return 'utf-32le';
                    }
                    if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
                        return 'utf-32be';
                    }
                }

                if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
                if (b[3] !== 0 || b[2] > 0x10) invalidLE++;

                if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
                if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;

                b.length = 0;
                charsProcessed++;

                if (charsProcessed >= 100) {
                    break outer_loop;
                }
            }
        }
    }

    // Make decisions.
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)  return 'utf-32be';
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)  return 'utf-32le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-32le';
}


/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(81).Buffer);

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        
        if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var resStr = '';
        for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);

        var trail = this.decoder.end();
        if (trail)
            resStr += trail;

        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
    }
    return this.decoder.end();
}

function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.

    outer_loop:
    for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
                if (charsProcessed === 0) {
                    // Check BOM first.
                    if (b[0] === 0xFF && b[1] === 0xFE) return 'utf-16le';
                    if (b[0] === 0xFE && b[1] === 0xFF) return 'utf-16be';
                }

                if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
                if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;

                b.length = 0;
                charsProcessed++;

                if (charsProcessed >= 100) {
                    break outer_loop;
                }
            }
        }
    }

    // Make decisions.
    // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
    // So, we count ASCII as if it was LE or BE, and decide from that.
    if (asciiCharsBE > asciiCharsLE) return 'utf-16be';
    if (asciiCharsBE < asciiCharsLE) return 'utf-16le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-16le';
}




/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(81).Buffer);

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}




/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(81).Buffer);

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}


/***/ }),
/* 91 */
/***/ ((module) => {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": "√ÑƒÄƒÅ√âƒÑ√ñ√ú√°ƒÖƒå√§ƒçƒÜƒá√©≈π≈∫ƒé√≠ƒèƒíƒìƒñ√≥ƒó√¥√∂√µ√∫ƒöƒõ√º‚Ä†¬∞ƒò¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢ƒô¬®‚â†ƒ£ƒÆƒØƒ™‚â§‚â•ƒ´ƒ∂‚àÇ‚àë≈ÇƒªƒºƒΩƒæƒπƒ∫≈Ö≈Ü≈É¬¨‚àö≈Ñ≈á‚àÜ¬´¬ª‚Ä¶¬†≈à≈ê√ï≈ë≈å‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä≈ç≈î≈ï≈ò‚Äπ‚Ä∫≈ô≈ñ≈ó≈†‚Äö‚Äû≈°≈ö≈õ√Å≈§≈•√ç≈Ω≈æ≈™√ì√î≈´≈Æ√ö≈Ø≈∞≈±≈≤≈≥√ù√Ωƒ∑≈ª≈Å≈ºƒ¢Àá"
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ‚Ç¨‚ñ†¬†"
    },

    "mik": {
        "type": "_sbcs",
        "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ï£‚ïë‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚îê‚ñë‚ñí‚ñì‚îÇ‚î§‚Ññ¬ß‚ïó‚ïù‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
    },

    "cp720": {
        "type": "_sbcs",
        "chars": "\x80\x81√©√¢\x84√†\x86√ß√™√´√®√Ø√Æ\x8d\x8e\x8f\x90\u0651\u0652√¥¬§ŸÄ√ª√πÿ°ÿ¢ÿ£ÿ§¬£ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄÿ∂ÿ∑ÿ∏ÿπÿ∫ŸÅ¬µŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸä‚â°\u064b\u064c\u064d\u064e\u064f\u0650‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†\u00a0"
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};



/***/ }),
/* 92 */
/***/ ((module) => {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩÔøΩÔøΩÔøΩ‚Ä¶ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞≈†‚Äπ≈ö≈§≈Ω≈πÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢≈°‚Ä∫≈õ≈•≈æ≈∫¬†ÀáÀò≈Å¬§ƒÑ¬¶¬ß¬®¬©≈û¬´¬¨¬≠¬Æ≈ª¬∞¬±Àõ≈Ç¬¥¬µ¬∂¬∑¬∏ƒÖ≈ü¬ªƒΩÀùƒæ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä–å–ã–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö—ú—õ—ü¬†–é—û–à¬§“ê¬¶¬ß–Å¬©–Ñ¬´¬¨¬≠¬Æ–á¬∞¬±–Ü—ñ“ë¬µ¬∂¬∑—ë‚Ññ—î¬ª—ò–Ö—ï—ó–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩ≈ΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩ≈æ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†ŒÖŒÜ¬£¬§¬•¬¶¬ß¬®¬©ÔøΩ¬´¬¨¬≠¬Æ‚Äï¬∞¬±¬≤¬≥ŒÑ¬µ¬∂¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚ÄπÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩ¬†¬°¬¢¬£‚Ç™¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æ¬ø÷∞÷±÷≤÷≥÷¥÷µ÷∂÷∑÷∏÷π÷∫÷ª÷º÷Ω÷æ÷ø◊Ä◊Å◊Ç◊É◊∞◊±◊≤◊≥◊¥ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": "‚Ç¨Ÿæ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞Ÿπ‚Äπ≈í⁄Ü⁄ò⁄à⁄Ø‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî⁄©‚Ñ¢⁄ë‚Ä∫≈ì‚Äå‚Äç⁄∫¬†ÿå¬¢¬£¬§¬•¬¶¬ß¬®¬©⁄æ¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬πÿõ¬ª¬º¬Ω¬æÿü€Åÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂√óÿ∑ÿ∏ÿπÿ∫ŸÄŸÅŸÇŸÉ√†ŸÑ√¢ŸÖŸÜŸáŸà√ß√®√©√™√´ŸâŸä√Æ√ØŸãŸåŸçŸé√¥ŸèŸê√∑Ÿë√πŸí√ª√º‚Äé‚Äè€í"
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚ÄöÔøΩ‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞ÔøΩ‚ÄπÔøΩ¬®Àá¬∏ÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩ¬ØÀõÔøΩ¬†ÔøΩ¬¢¬£¬§ÔøΩ¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æÀô"
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": "‚Ç¨ÔøΩ‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞ÔøΩ‚Äπ≈íÔøΩÔøΩÔøΩÔøΩ‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢ÔøΩ‚Ä∫≈ìÔøΩÔøΩ≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑÀò≈Å¬§ƒΩ≈ö¬ß¬®≈†≈û≈§≈π¬≠≈Ω≈ª¬∞ƒÖÀõ≈Ç¬¥ƒæ≈õÀá¬∏≈°≈ü≈•≈∫Àù≈æ≈º≈î√Å√ÇƒÇ√ÑƒπƒÜ√áƒå√âƒò√ãƒö√ç√éƒéƒê≈É≈á√ì√î≈ê√ñ√ó≈ò≈Æ√ö≈∞√ú√ù≈¢√ü≈ï√°√¢ƒÉ√§ƒ∫ƒá√ßƒç√©ƒô√´ƒõ√≠√Æƒèƒë≈Ñ≈à√≥√¥≈ë√∂√∑≈ô≈Ø√∫≈±√º√Ω≈£Àô"
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒ¶Àò¬£¬§ÔøΩƒ§¬ß¬®ƒ∞≈ûƒûƒ¥¬≠ÔøΩ≈ª¬∞ƒß¬≤¬≥¬¥¬µƒ•¬∑¬∏ƒ±≈üƒüƒµ¬ΩÔøΩ≈º√Ä√Å√ÇÔøΩ√Ñƒäƒà√á√à√â√ä√ã√å√ç√é√èÔøΩ√ë√í√ì√îƒ†√ñ√óƒú√ô√ö√õ√ú≈¨≈ú√ü√†√°√¢ÔøΩ√§ƒãƒâ√ß√®√©√™√´√¨√≠√Æ√ØÔøΩ√±√≤√≥√¥ƒ°√∂√∑ƒù√π√∫√ª√º≈≠≈ùÀô"
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒ∏≈ñ¬§ƒ®ƒª¬ß¬®≈†ƒíƒ¢≈¶¬≠≈Ω¬Ø¬∞ƒÖÀõ≈ó¬¥ƒ©ƒºÀá¬∏≈°ƒìƒ£≈ß≈ä≈æ≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√éƒ™ƒê≈Ö≈åƒ∂√î√ï√ñ√ó√ò≈≤√ö√õ√ú≈®≈™√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æƒ´ƒë≈Ü≈çƒ∑√¥√µ√∂√∑√∏≈≥√∫√ª√º≈©≈´Àô"
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩÔøΩÔøΩ¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿå¬≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÿõÔøΩÔøΩÔøΩÿüÔøΩÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ÔøΩÔøΩÔøΩÔøΩÔøΩŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äò‚Äô¬£‚Ç¨‚ÇØ¬¶¬ß¬®¬©Õ∫¬´¬¨¬≠ÔøΩ‚Äï¬∞¬±¬≤¬≥ŒÑŒÖŒÜ¬∑ŒàŒâŒä¬ªŒå¬ΩŒéŒèŒêŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°ÔøΩŒ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´Œ¨Œ≠ŒÆŒØŒ∞Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÇœÉœÑœÖœÜœáœàœâœäœãœåœçœéÔøΩ"
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ¬¢¬£¬§¬•¬¶¬ß¬®¬©√ó¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π√∑¬ª¬º¬Ω¬æÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚Äó◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩÔøΩ‚Äé‚ÄèÔøΩ"
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√èƒû√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√úƒ∞≈û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Øƒü√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√ºƒ±≈ü√ø"
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒíƒ¢ƒ™ƒ®ƒ∂¬ßƒªƒê≈†≈¶≈Ω¬≠≈™≈ä¬∞ƒÖƒìƒ£ƒ´ƒ©ƒ∑¬∑ƒºƒë≈°≈ß≈æ‚Äï≈´≈ãƒÄ√Å√Ç√É√Ñ√Ö√ÜƒÆƒå√âƒò√ãƒñ√ç√é√è√ê≈Ö≈å√ì√î√ï√ñ≈®√ò≈≤√ö√õ√ú√ù√û√üƒÅ√°√¢√£√§√•√¶ƒØƒç√©ƒô√´ƒó√≠√Æ√Ø√∞≈Ü≈ç√≥√¥√µ√∂≈©√∏≈≥√∫√ª√º√Ω√æƒ∏"
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‚Äù¬¢¬£¬§‚Äû¬¶¬ß√ò¬©≈ñ¬´¬¨¬≠¬Æ√Ü¬∞¬±¬≤¬≥‚Äú¬µ¬∂¬∑√∏¬π≈ó¬ª¬º¬Ω¬æ√¶ƒÑƒÆƒÄƒÜ√Ñ√Öƒòƒíƒå√â≈πƒñƒ¢ƒ∂ƒ™ƒª≈†≈É≈Ö√ì≈å√ï√ñ√ó≈≤≈Å≈ö≈™√ú≈ª≈Ω√üƒÖƒØƒÅƒá√§√•ƒôƒìƒç√©≈∫ƒóƒ£ƒ∑ƒ´ƒº≈°≈Ñ≈Ü√≥≈ç√µ√∂√∑≈≥≈Ç≈õ≈´√º≈º≈æ‚Äô"
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†·∏Ç·∏É¬£ƒäƒã·∏ä¬ß·∫Ä¬©·∫Ç·∏ã·ª≤¬≠¬Æ≈∏·∏û·∏üƒ†ƒ°·πÄ·πÅ¬∂·πñ·∫Å·πó·∫É·π†·ª≥·∫Ñ·∫Ö·π°√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈¥√ë√í√ì√î√ï√ñ·π™√ò√ô√ö√õ√ú√ù≈∂√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈µ√±√≤√≥√¥√µ√∂·π´√∏√π√∫√ª√º√Ω≈∑√ø"
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•≈†¬ß≈°¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈Ω¬µ¬∂¬∑≈æ¬π¬∫¬ª≈í≈ì≈∏¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ƒÑƒÖ≈Å‚Ç¨‚Äû≈†¬ß≈°¬©»ò¬´≈π¬≠≈∫≈ª¬∞¬±ƒå≈Ç≈Ω‚Äù¬∂¬∑≈æƒç»ô¬ª≈í≈ì≈∏≈º√Ä√Å√ÇƒÇ√ÑƒÜ√Ü√á√à√â√ä√ã√å√ç√é√èƒê≈É√í√ì√î≈ê√ñ≈ö≈∞√ô√ö√õ√úƒò»ö√ü√†√°√¢ƒÉ√§ƒá√¶√ß√®√©√™√´√¨√≠√Æ√Øƒë≈Ñ√≤√≥√¥≈ë√∂≈õ≈±√π√∫√ª√ºƒô»õ√ø"
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": "ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑœÖœÜœáœà‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄœâŒ¨Œ≠ŒÆœäŒØœåœçœãœéŒÜŒàŒâŒäŒåŒéŒè¬±‚â•‚â§Œ™Œ´√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": "ƒÜ√º√©ƒÅ√§ƒ£√•ƒá≈Çƒì≈ñ≈óƒ´≈π√Ñ√Ö√â√¶√Ü≈ç√∂ƒ¢¬¢≈ö≈õ√ñ√ú√∏¬£√ò√ó¬§ƒÄƒ™√≥≈ª≈º≈∫‚Äù¬¶¬©¬Æ¬¨¬Ω¬º≈Å¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ƒÑƒåƒòƒñ‚ï£‚ïë‚ïó‚ïùƒÆ≈†‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº≈≤≈™‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨≈ΩƒÖƒçƒôƒóƒØ≈°≈≥≈´≈æ‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ√ì√ü≈å≈É√µ√ï¬µ≈Ñƒ∂ƒ∑ƒªƒº≈Üƒí≈Ö‚Äô¬≠¬±‚Äú¬æ¬∂¬ß√∑‚Äû¬∞‚àô¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√àƒ±√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§≈Øƒá√ß≈Ç√´≈ê≈ë√Æ≈π√ÑƒÜ√âƒπƒ∫√¥√∂ƒΩƒæ≈ö≈õ√ñ√ú≈§≈•≈Å√óƒç√°√≠√≥√∫ƒÑƒÖ≈Ω≈æƒòƒô¬¨≈∫ƒå≈ü¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Çƒö≈û‚ï£‚ïë‚ïó‚ïù≈ª≈º‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºƒÇƒÉ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ƒëƒêƒé√ãƒè≈á√ç√éƒõ‚îò‚îå‚ñà‚ñÑ≈¢≈Æ‚ñÄ√ì√ü√î≈É≈Ñ≈à≈†≈°≈î√ö≈ï≈∞√Ω√ù≈£¬¥¬≠ÀùÀõÀáÀò¬ß√∑¬∏¬∞¬®Àô≈±≈ò≈ô‚ñ†¬†"
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": "—í–Ç—ì–É—ë–Å—î–Ñ—ï–Ö—ñ–Ü—ó–á—ò–à—ô–â—ö–ä—õ–ã—ú–å—û–é—ü–è—é–Æ—ä–™–∞–ê–±–ë—Ü–¶–¥–î–µ–ï—Ñ–§–≥–ì¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§—Ö–•–∏–ò‚ï£‚ïë‚ïó‚ïù–π–ô‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº–∫–ö‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§–ª–õ–º–ú–Ω–ù–æ–û–ø‚îò‚îå‚ñà‚ñÑ–ü—è‚ñÄ–Ø—Ä–†—Å–°—Ç–¢—É–£–∂–ñ–≤–í—å–¨‚Ññ¬≠—ã–´–∑–ó—à–®—ç–≠—â–©—á–ß¬ß‚ñ†¬†"
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™ÔøΩ¬£ÔøΩ√óÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Æ¬¨¬Ω¬ºÔøΩ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ÔøΩÔøΩÔøΩ¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºÔøΩÔøΩ‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‚îò‚îå‚ñà‚ñÑ¬¶ÔøΩ‚ñÄÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬µÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æƒ±√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√πƒ∞√ñ√ú√∏¬£√ò≈û≈ü√°√≠√≥√∫√±√ëƒûƒü¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§¬∫¬™√ä√ã√àÔøΩ√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µÔøΩ√ó√ö√õ√ô√¨√ø¬Ø¬¥¬≠¬±ÔøΩ¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò√ó∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø¬Æ¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§√Å√Ç√Ä¬©‚ï£‚ïë‚ïó‚ïù¬¢¬•‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº√£√É‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨¬§√∞√ê√ä√ã√à‚Ç¨√ç√é√è‚îò‚îå‚ñà‚ñÑ¬¶√å‚ñÄ√ì√ü√î√í√µ√ï¬µ√æ√û√ö√õ√ô√Ω√ù¬Ø¬¥¬≠¬±‚Äó¬æ¬∂¬ß√∑¬∏¬∞¬®¬∑¬π¬≥¬≤‚ñ†¬†"
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√£√†√Å√ß√™√ä√®√ç√î√¨√É√Ç√â√Ä√à√¥√µ√≤√ö√π√å√ï√ú¬¢¬£√ô‚Çß√ì√°√≠√≥√∫√±√ë¬™¬∫¬ø√í¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√ê√∞√û√Ñ√Ö√â√¶√Ü√¥√∂√æ√ª√ù√Ω√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√Å√ç√ì√ö¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": "◊ê◊ë◊í◊ì◊î◊ï◊ñ◊ó◊ò◊ô◊ö◊õ◊ú◊ù◊û◊ü◊†◊°◊¢◊£◊§◊•◊¶◊ß◊®◊©◊™¬¢¬£¬•‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√Ç√†¬∂√ß√™√´√®√Ø√Æ‚Äó√Ä¬ß√â√à√ä√¥√ã√è√ª√π¬§√î√ú¬¢¬£√ô√õ∆í¬¶¬¥√≥√∫¬®¬∏¬≥¬Ø√é‚åê¬¨¬Ω¬º¬æ¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$Ÿ™&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~¬∞¬∑‚àô‚àö‚ñí‚îÄ‚îÇ‚îº‚î§‚î¨‚îú‚î¥‚îê‚îå‚îî‚îòŒ≤‚àûœÜ¬±¬Ω¬º‚âà¬´¬ªÔª∑Ôª∏ÔøΩÔøΩÔªªÔªºÔøΩ¬†¬≠Ô∫Ç¬£¬§Ô∫ÑÔøΩÔøΩÔ∫éÔ∫èÔ∫ïÔ∫ôÿåÔ∫ùÔ∫°Ô∫•Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©ÔªëÿõÔ∫±Ô∫µÔ∫πÿü¬¢Ô∫ÄÔ∫ÅÔ∫ÉÔ∫ÖÔªäÔ∫ãÔ∫çÔ∫ëÔ∫ìÔ∫óÔ∫õÔ∫üÔ∫£Ô∫ßÔ∫©Ô∫´Ô∫≠Ô∫ØÔ∫≥Ô∫∑Ô∫ªÔ∫øÔªÅÔªÖÔªãÔªè¬¶¬¨√∑√óÔªâŸÄÔªìÔªóÔªõÔªüÔª£ÔªßÔª´Ôª≠ÔªØÔª≥Ô∫ΩÔªåÔªéÔªçÔª°ÔπΩŸëÔª•Ôª©Ôª¨Ôª∞Ôª≤ÔªêÔªïÔªµÔª∂ÔªùÔªôÔª±‚ñ†ÔøΩ"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": "√á√º√©√¢√§√†√•√ß√™√´√®√Ø√Æ√¨√Ñ√Ö√â√¶√Ü√¥√∂√≤√ª√π√ø√ñ√ú√∏¬£√ò‚Çß∆í√°√≠√≥√∫√±√ë¬™¬∫¬ø‚åê¬¨¬Ω¬º¬°¬´¬§‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄŒ±√üŒìœÄŒ£œÉ¬µœÑŒ¶ŒòŒ©Œ¥‚àûœÜŒµ‚à©‚â°¬±‚â•‚â§‚å†‚å°√∑‚âà¬∞‚àô¬∑‚àö‚Åø¬≤‚ñ†¬†"
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë–Ñ—î–á—ó–é—û¬∞‚àô¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩŒÜÔøΩ¬∑¬¨¬¶‚Äò‚ÄôŒà‚ÄïŒâŒäŒ™ŒåÔøΩÔøΩŒéŒ´¬©Œè¬≤¬≥Œ¨¬£Œ≠ŒÆŒØœäŒêœåœçŒëŒíŒìŒîŒïŒñŒó¬ΩŒòŒô¬´¬ª‚ñë‚ñí‚ñì‚îÇ‚î§ŒöŒõŒúŒù‚ï£‚ïë‚ïó‚ïùŒûŒü‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îºŒ†Œ°‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ±Œ≤Œ≥‚îò‚îå‚ñà‚ñÑŒ¥Œµ‚ñÄŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÇœÑŒÑ¬≠¬±œÖœÜœá¬ßœàŒÖ¬∞¬®œâœãŒ∞œé‚ñ†¬†"
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ‚Äæ¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è≈†√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù≈Ω√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø≈°√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω≈æ√ø"
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": "Ô∫à√ó√∑Ô£∂Ô£µÔ£¥Ô£∑Ôπ±¬à‚ñ†‚îÇ‚îÄ‚îê‚îå‚îî‚îòÔππÔπªÔπΩÔπøÔπ∑Ô∫äÔª∞Ôª≥Ôª≤ÔªéÔªèÔªêÔª∂Ôª∏Ôª∫Ôªº¬†Ô£∫Ô£πÔ£∏¬§Ô£ªÔ∫ãÔ∫ëÔ∫óÔ∫õÔ∫üÔ∫£ÿå¬≠Ô∫ßÔ∫≥Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ô∫∑ÿõÔ∫ªÔ∫øÔªäÿüÔªãÿ°ÿ¢ÿ£ÿ§ÿ•ÿ¶ÿßÿ®ÿ©ÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑Ôªáÿπÿ∫ÔªåÔ∫ÇÔ∫ÑÔ∫éÔªìŸÄŸÅŸÇŸÉŸÑŸÖŸÜŸáŸàŸâŸäŸãŸåŸçŸéŸèŸêŸëŸíÔªóÔªõÔªüÔ£ºÔªµÔª∑ÔªπÔªªÔª£ÔªßÔª¨Ôª©ÔøΩ"
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†–Å–Ç“ê–Ñ–Ö–Ü–á–à–â–ä–ã–å¬≠–é–è–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è‚Ññ—ë—í“ë—î—ï—ñ—ó—ò—ô—ö—õ—ú¬ß—û—ü"
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø‚ñë‚ñí‚ñì‚îÇ‚î§‚ï°‚ï¢‚ïñ‚ïï‚ï£‚ïë‚ïó‚ïù‚ïú‚ïõ‚îê‚îî‚î¥‚î¨‚îú‚îÄ‚îº‚ïû‚ïü‚ïö‚ïî‚ï©‚ï¶‚ï†‚ïê‚ï¨‚ïß‚ï®‚ï§‚ï•‚ïô‚ïò‚ïí‚ïì‚ï´‚ï™‚îò‚îå‚ñà‚ñÑ‚ñå‚ñê‚ñÄ—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è–Å—ë“ê“ë–Ñ—î–Ü—ñ–á—ó¬∑‚àö‚Ññ¬§‚ñ†¬†"
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∫Å‡∫Ç‡∫Ñ‡∫á‡∫à‡∫™‡∫ä‡∫ç‡∫î‡∫ï‡∫ñ‡∫ó‡∫ô‡∫ö‡∫õ‡∫ú‡∫ù‡∫û‡∫ü‡∫°‡∫¢‡∫£‡∫•‡∫ß‡∫´‡∫≠‡∫ÆÔøΩÔøΩÔøΩ‡∫Ø‡∫∞‡∫≤‡∫≥‡∫¥‡∫µ‡∫∂‡∫∑‡∫∏‡∫π‡∫º‡∫±‡∫ª‡∫ΩÔøΩÔøΩÔøΩ‡ªÄ‡ªÅ‡ªÇ‡ªÉ‡ªÑ‡ªà‡ªâ‡ªä‡ªã‡ªå‡ªç‡ªÜÔøΩ‡ªú‡ªù‚Ç≠ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡ªê‡ªë‡ªí‡ªì‡ªî‡ªï‡ªñ‡ªó‡ªò‡ªôÔøΩÔøΩ¬¢¬¨¬¶ÔøΩ"
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡πà‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫‡πâ‡πä‡πã‚Ç¨‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõ¬¢¬¨¬¶¬†"
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": "‚Ç¨¬Å¬Ç¬É¬Ñ‚Ä¶¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£‚Ç¨¬•¬¶¬ß≈ì¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥≈∏¬µ¬∂¬∑≈í¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√ÇƒÇ√Ñ√Ö√Ü√á√à√â√ä√ãÃÄ√ç√é√èƒê√ëÃâ√ì√î∆†√ñ√ó√ò√ô√ö√õ√ú∆ØÃÉ√ü√†√°√¢ƒÉ√§√•√¶√ß√®√©√™√´ÃÅ√≠√Æ√Øƒë√±Ã£√≥√¥∆°√∂√∑√∏√π√∫√ª√º∆∞‚Ç´√ø"
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ≈†‚Ñ¢¬¥¬®‚â†≈Ω√ò‚àû¬±‚â§‚â•‚àÜ¬µ‚àÇ‚àë‚àè≈°‚à´¬™¬∫‚Ñ¶≈æ√∏¬ø¬°¬¨‚àö∆í‚âàƒÜ¬´ƒå‚Ä¶¬†√Ä√É√ï≈í≈ìƒê‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óäÔøΩ¬©‚ÅÑ¬§‚Äπ‚Ä∫√Ü¬ª‚Äì¬∑‚Äö‚Äû‚Ä∞√Çƒá√Åƒç√à√ç√é√è√å√ì√îƒë√í√ö√õ√ôƒ±ÀÜÀú¬ØœÄ√ãÀö¬∏√ä√¶Àá"
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ‚àÇ–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": "√Ñ¬π¬≤√â¬≥√ñ√úŒÖ√†√¢√§ŒÑ¬®√ß√©√®√™√´¬£‚Ñ¢√Æ√Ø‚Ä¢¬Ω‚Ä∞√¥√∂¬¶¬≠√π√ª√º‚Ä†ŒìŒîŒòŒõŒûŒ†√ü¬Æ¬©Œ£Œ™¬ß‚â†¬∞ŒáŒë¬±‚â§‚â•¬•ŒíŒïŒñŒóŒôŒöŒúŒ¶Œ´Œ®Œ©Œ¨Œù¬¨ŒüŒ°‚âàŒ§¬´¬ª‚Ä¶¬†Œ•ŒßŒÜŒà≈ì‚Äì‚Äï‚Äú‚Äù‚Äò‚Äô√∑ŒâŒäŒåŒéŒ≠ŒÆŒØœåŒèœçŒ±Œ≤œàŒ¥ŒµœÜŒ≥Œ∑ŒπŒæŒ∫ŒªŒºŒΩŒøœÄœéœÅœÉœÑŒ∏œâœÇœáœÖŒ∂œäœãŒêŒ∞ÔøΩ"
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º√ù¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§√ê√∞√û√æ√Ω¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macroman": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macromania": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†ƒÇ≈û‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶ƒÉ≈ü¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫≈¢≈£‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macthai": {
    "type": "_sbcs",
    "chars": "¬´¬ª‚Ä¶Ô¢åÔ¢èÔ¢íÔ¢ïÔ¢òÔ¢ãÔ¢éÔ¢ëÔ¢îÔ¢ó‚Äú‚ÄùÔ¢ôÔøΩ‚Ä¢Ô¢ÑÔ¢âÔ¢ÖÔ¢ÜÔ¢áÔ¢àÔ¢äÔ¢çÔ¢êÔ¢ìÔ¢ñ‚Äò‚ÄôÔøΩ¬†‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫Ôªø‚Äã‚Äì‚Äî‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‚Ñ¢‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô¬Æ¬©ÔøΩÔøΩÔøΩÔøΩ"
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏ƒûƒüƒ∞ƒ±≈û≈ü‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôÔøΩÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": "–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø‚Ä†¬∞“ê¬£¬ß‚Ä¢¬∂–Ü¬Æ¬©‚Ñ¢–Ç—í‚â†–É—ì‚àû¬±‚â§‚â•—ñ¬µ“ë–à–Ñ—î–á—ó–â—ô–ä—ö—ò–Ö¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†–ã—õ–å—ú—ï‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚Äû–é—û–è—ü‚Ññ–Å—ë—è–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é¬§"
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë‚ïì‚ïî‚ïï‚ïñ‚ïó‚ïò‚ïô‚ïö‚ïõ‚ïú‚ïù‚ïû‚ïü‚ï†‚ï°–Å‚ï¢‚ï£‚ï§‚ï•‚ï¶‚ïß‚ï®‚ï©‚ï™‚ï´‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë‚ïù‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê‚ï¨¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": "‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ñÄ‚ñÑ‚ñà‚ñå‚ñê‚ñë‚ñí‚ñì‚å†‚ñ†‚àô‚àö‚âà‚â§‚â•¬†‚å°¬∞¬≤¬∑√∑‚ïê‚ïë‚ïí—ë—î‚ïî—ñ—ó‚ïó‚ïò‚ïô‚ïö‚ïõ“ë—û‚ïû‚ïü‚ï†‚ï°–Å–Ñ‚ï£–Ü–á‚ï¶‚ïß‚ï®‚ï©‚ï™“ê–é¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": "“õ“ì‚Äö“í‚Äû‚Ä¶‚Ä†‚Ä°ÔøΩ‚Ä∞“≥‚Äπ“≤“∑“∂ÔøΩ“ö‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢ÔøΩ‚Ä∫ÔøΩÔøΩÔøΩÔøΩÔøΩ”Ø”Æ—ë¬§”£¬¶¬ßÔøΩÔøΩÔøΩ¬´¬¨¬≠¬ÆÔøΩ¬∞¬±¬≤–ÅÔøΩ”¢¬∂¬∑ÔøΩ‚ÑñÔøΩ¬ªÔøΩÔøΩÔøΩ¬©—é–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø—è—Ä—Å—Ç—É–∂–≤—å—ã–∑—à—ç—â—á—ä–Æ–ê–ë–¶–î–ï–§–ì–•–ò–ô–ö–õ–ú–ù–û–ü–Ø–†–°–¢–£–ñ–í–¨–´–ó–®–≠–©–ß–™"
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†ÔøΩ÷á÷â)(¬ª¬´‚Äî.’ù,-÷ä‚Ä¶’ú’õ’û‘±’°‘≤’¢‘≥’£‘¥’§‘µ’•‘∂’¶‘∑’ß‘∏’®‘π’©‘∫’™‘ª’´‘º’¨‘Ω’≠‘æ’Æ‘ø’Ø’Ä’∞’Å’±’Ç’≤’É’≥’Ñ’¥’Ö’µ’Ü’∂’á’∑’à’∏’â’π’ä’∫’ã’ª’å’º’ç’Ω’é’æ’è’ø’ê÷Ä’ë÷Å’í÷Ç’ì÷É’î÷Ñ’ï÷Ö’ñ÷Ü’öÔøΩ"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": "–Ç–É‚Äö—ì‚Äû‚Ä¶‚Ä†‚Ä°‚Ç¨‚Ä∞–â‚Äπ–ä“ö“∫–è—í‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÔøΩ‚Ñ¢—ô‚Ä∫—ö“õ“ª—ü¬†“∞“±”ò¬§”®¬¶¬ß–Å¬©“í¬´¬¨¬≠¬Æ“Æ¬∞¬±–Ü—ñ”©¬µ¬∂¬∑—ë‚Ññ“ì¬ª”ô“¢“£“Ø–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000√ö·ª§\u0003·ª™·ª¨·ªÆ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010·ª®·ª∞·ª≤·ª∂·ª∏√ù·ª¥\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~√Ä·∫¢√É√Å·∫†·∫∂·∫¨√à·∫∫·∫º√â·∫∏·ªÜ√å·ªàƒ®√ç·ªä√í·ªé√ï√ì·ªå·ªò·ªú·ªû·ª†·ªö·ª¢√ô·ª¶≈®¬†ƒÇ√Ç√ä√î∆†∆ØƒêƒÉ√¢√™√¥∆°∆∞ƒë·∫∞ÃÄÃâÃÉÃÅÃ£√†·∫£√£√°·∫°·∫≤·∫±·∫≥·∫µ·∫Ø·∫¥·∫Æ·∫¶·∫®·∫™·∫§·ªÄ·∫∑·∫ß·∫©·∫´·∫•·∫≠√®·ªÇ·∫ª·∫Ω√©·∫π·ªÅ·ªÉ·ªÖ·∫ø·ªá√¨·ªâ·ªÑ·∫æ·ªíƒ©√≠·ªã√≤·ªî·ªè√µ√≥·ªç·ªì·ªï·ªó·ªë·ªô·ªù·ªü·ª°·ªõ·ª£√π·ªñ·ªß≈©√∫·ª•·ª´·ª≠·ªØ·ª©·ª±·ª≥·ª∑·ªπ√Ω·ªµ·ªê"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·É∂√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í¬ç¬é¬è¬ê‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì¬ù¬û≈∏¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·É±·Éó·Éò·Éô·Éö·Éõ·Éú·É≤·Éù·Éû·Éü·É†·É°·É¢·É≥·É£·É§·É•·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·É¥·ÉØ·É∞·Éµ√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø"
  },
  "pt154": {
    "type": "_sbcs",
    "chars": "“ñ“í”Æ“ì‚Äû‚Ä¶“∂“Æ“≤“Ø“†”¢“¢“ö“∫“∏“ó‚Äò‚Äô‚Äú‚Äù‚Ä¢‚Äì‚Äî“≥“∑“°”£“£“õ“ª“π¬†–é—û–à”®“ò“∞¬ß–Å¬©”ò¬´¬¨”Ø¬Æ“ú¬∞“±–Ü—ñ“ô”©¬∂¬∑—ë‚Ññ”ô¬ª—ò“™“´“ù–ê–ë–í–ì–î–ï–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–∞–±–≤–≥–¥–µ–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001·∫≤\u0003\u0004·∫¥·∫™\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013·ª∂\u0015\u0016\u0017\u0018·ª∏\u001a\u001b\u001c\u001d·ª¥\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~·∫†·∫Æ·∫∞·∫∂·∫§·∫¶·∫®·∫¨·∫º·∫∏·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªê·ªí·ªî·ªñ·ªò·ª¢·ªö·ªú·ªû·ªä·ªé·ªå·ªà·ª¶≈®·ª§·ª≤√ï·∫Ø·∫±·∫∑·∫•·∫ß·∫©·∫≠·∫Ω·∫π·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªë·ªì·ªï·ªó·ª†∆†·ªô·ªù·ªü·ªã·ª∞·ª®·ª™·ª¨∆°·ªõ∆Ø√Ä√Å√Ç√É·∫¢ƒÇ·∫≥·∫µ√à√â√ä·∫∫√å√çƒ®·ª≥ƒê·ª©√í√ì√î·∫°·ª∑·ª´·ª≠√ô√ö·ªπ·ªµ√ù·ª°∆∞√†√°√¢√£·∫£ƒÉ·ªØ·∫´√®√©√™·∫ª√¨√≠ƒ©·ªâƒë·ª±√≤√≥√¥√µ·ªè·ªç·ª•√π√∫≈©·ªß√Ω·ª£·ªÆ"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#¬•%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¬•]^_`abcdefghijklmnopqrstuvwxyz{|}‚ÄæÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": "¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†√Ä√Ç√à√ä√ã√é√è¬¥ÀãÀÜ¬®Àú√ô√õ‚Ç§¬Ø√ù√Ω¬∞√á√ß√ë√±¬°¬ø¬§¬£¬•¬ß∆í¬¢√¢√™√¥√ª√°√©√≥√∫√†√®√≤√π√§√´√∂√º√Ö√Æ√ò√Ü√•√≠√∏√¶√Ñ√¨√ñ√ú√â√Ø√ü√î√Å√É√£√ê√∞√ç√å√ì√í√ï√µ≈†≈°√ö≈∏√ø√û√æ¬∑¬µ¬∂¬æ‚Äî¬º¬Ω¬™¬∫¬´‚ñ†¬ª¬±ÔøΩ"
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": "√Ñ√Ö√á√â√ë√ñ√ú√°√†√¢√§√£√•√ß√©√®√™√´√≠√¨√Æ√Ø√±√≥√≤√¥√∂√µ√∫√π√ª√º‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë‚àèœÄ‚à´¬™¬∫‚Ñ¶√¶√∏¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´¬ª‚Ä¶¬†√Ä√É√ï≈í≈ì‚Äì‚Äî‚Äú‚Äù‚Äò‚Äô√∑‚óä√ø≈∏‚ÅÑ¬§‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å√ã√à√ç√é√è√å√ì√îÔøΩ√í√ö√õ√ôƒ±ÀÜÀú¬ØÀòÀôÀö¬∏ÀùÀõÀá"
  },
  "ascii": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ"
  },
  "tis620": {
    "type": "_sbcs",
    "chars": "ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ‡∏Å‡∏Ç‡∏É‡∏Ñ‡∏Ö‡∏Ü‡∏á‡∏à‡∏â‡∏ä‡∏ã‡∏å‡∏ç‡∏é‡∏è‡∏ê‡∏ë‡∏í‡∏ì‡∏î‡∏ï‡∏ñ‡∏ó‡∏ò‡∏ô‡∏ö‡∏õ‡∏ú‡∏ù‡∏û‡∏ü‡∏†‡∏°‡∏¢‡∏£‡∏§‡∏•‡∏¶‡∏ß‡∏®‡∏©‡∏™‡∏´‡∏¨‡∏≠‡∏Æ‡∏Ø‡∏∞‡∏±‡∏≤‡∏≥‡∏¥‡∏µ‡∏∂‡∏∑‡∏∏‡∏π‡∏∫ÔøΩÔøΩÔøΩÔøΩ‡∏ø‡πÄ‡πÅ‡πÇ‡πÉ‡πÑ‡πÖ‡πÜ‡πá‡πà‡πâ‡πä‡πã‡πå‡πç‡πé‡πè‡πê‡πë‡πí‡πì‡πî‡πï‡πñ‡πó‡πò‡πô‡πö‡πõÔøΩÔøΩÔøΩÔøΩ"
  }
}

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(81).Buffer);

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 common decode nodes.
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

        // Fill out the tree
        var firstByteNode = this.decodeTables[0];
        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
            for (var j = 0x30; j <= 0x39; j++) {
                if (secondByteNode[j] === UNASSIGNED) {
                    secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
                } else if (secondByteNode[j] > NODE_START) {
                    throw new Error("gb18030 decode tables conflict at byte 2");
                }

                var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
                for (var k = 0x81; k <= 0xFE; k++) {
                    if (thirdByteNode[k] === UNASSIGNED) {
                        thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
                    } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                        continue;
                    } else if (thirdByteNode[k] > NODE_START) {
                        throw new Error("gb18030 decode tables conflict at byte 3");
                    }

                    var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
                    for (var l = 0x30; l <= 0x39; l++) {
                        if (fourthByteNode[l] === UNASSIGNED)
                            fourthByteNode[l] = GB18030_CODE;
                    }
                }
            }
        }
    }

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0) {
            this._setEncodeChar(uCode, mbCode);
            hasValues = true;
        } else if (uCode <= NODE_START) {
            var subNodeIdx = NODE_START - uCode;
            if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).
                var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.
                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
                    hasValues = true;
                else
                    subNodeEmpty[subNodeIdx] = true;
            }
        } else if (uCode <= SEQ_START) {
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
            hasValues = true;
        }
    }
    return hasValues;
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else if (dbcsCode < 0x1000000) {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        } else {
            newBuf[j++] = dbcsCode >>> 24;
            newBuf[j++] = (dbcsCode >>> 16) & 0xFF;
            newBuf[j++] = (dbcsCode >>> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBytes = [];

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBytes = this.prevBytes, prevOffset = this.prevBytes.length,
        seqStart = -this.prevBytes.length, // idx of the start of current parsed sequence.
        uCode;

    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            uCode = this.defaultCharUnicode.charCodeAt(0);
            i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
        }
        else if (uCode === GB18030_CODE) {
            if (i >= 3) {
                var ptr = (buf[i-3]-0x81)*12600 + (buf[i-2]-0x30)*1260 + (buf[i-1]-0x81)*10 + (curByte-0x30);
            } else {
                var ptr = (prevBytes[i-3+prevOffset]-0x81)*12600 + 
                          (((i-2 >= 0) ? buf[i-2] : prevBytes[i-2+prevOffset])-0x30)*1260 + 
                          (((i-1 >= 0) ? buf[i-1] : prevBytes[i-1+prevOffset])-0x81)*10 + 
                          (curByte-0x30);
            }
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode >= 0x10000) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 | (uCode >> 10);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 | (uCode & 0x3FF);
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBytes = (seqStart >= 0)
        ? Array.prototype.slice.call(buf, seqStart)
        : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));

    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBytes.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);

        // Parse remaining as usual.
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
            ret += this.write(bytesArr);
    }

    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + ((r-l+1) >> 1);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}



/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + ¬• + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return __webpack_require__(95) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return __webpack_require__(96) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return __webpack_require__(97) },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return (__webpack_require__(97).concat)(__webpack_require__(98)) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return (__webpack_require__(97).concat)(__webpack_require__(98)) },
        gb18030: function() { return __webpack_require__(99) },
        encodeSkipVals: [0x80],
        encodeAdd: {'‚Ç¨': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return __webpack_require__(100) },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return __webpack_require__(101) },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return (__webpack_require__(101).concat)(__webpack_require__(102)) },
        encodeSkipVals: [
            // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
            // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
            // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
            0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe,
            0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca,
            0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62,
            0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef,
            0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,

            // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
            0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce,
        ],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};


/***/ }),
/* 95 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",128],["a1","ÔΩ°",62],["8140","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó"],["8180","√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["81b8","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["81c8","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["81da","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["81f0","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["81fc","‚óØ"],["824f","Ôºê",9],["8260","Ôº°",25],["8281","ÔΩÅ",25],["829f","„ÅÅ",82],["8340","„Ç°",62],["8380","„É†",22],["839f","Œë",16,"Œ£",6],["83bf","Œ±",16,"œÉ",6],["8440","–ê",5,"–Å–ñ",25],["8470","–∞",5,"—ë–∂",7],["8480","–æ",17],["849f","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["8740","‚ë†",19,"‚Ö†",9],["875f","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["877e","„çª"],["8780","„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["889f","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["8940","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜ"],["8980","ÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøúÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["8a40","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´"],["8a80","Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["8b40","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•Êïë"],["8b80","ÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["8c40","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®"],["8c80","ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["8d40","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§Èôç"],["8d80","È†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæºÊ≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["8e40","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢"],["8e80","Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇÊ¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["8f40","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥"],["8f80","Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑüÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["9040","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®"],["9080","ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["9140","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéª"],["9180","ÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜéËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["9240","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑ"],["9280","ÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµÂ∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["9340","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨"],["9380","ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["9440","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢Ö"],["9480","Ê•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["9540","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑"],["9580","ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúçÁ¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["9640","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜ"],["9680","Êë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫ÄÊº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["9740","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤"],["9780","Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉÁó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["9840","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["989f","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["9940","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠"],["9980","Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["9a40","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏"],["9a80","Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["9b40","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄ"],["9b80","ÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ìÂ±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["9c40","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†"],["9c80","ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇöÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["9d40","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´"],["9d80","Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíºÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["9e40","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°é"],["9e80","Ê¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£çÊ£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["9f40","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØ"],["9f80","È∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æÊ≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["e040","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉù"],["e080","ÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáºÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e140","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóø"],["e180","ÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e240","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞"],["e280","Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠êÁ≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e340","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑"],["e380","Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e440","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§"],["e480","Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãôËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e540","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨"],["e580","ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùôËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["e640","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ß"],["e680","Ë´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["e740","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩú"],["e780","ËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["e840","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñô"],["e880","Èñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôûÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["e940","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©É"],["e980","È®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["ea40","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØ"],["ea80","Èª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["ed40","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®è"],["ed80","Ô®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["ee40","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïô"],["ee80","Ëï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["eeef","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["f040","ÓÄÄ",62],["f080","ÓÄø",124],["f140","ÓÇº",62],["f180","ÓÉª",124],["f240","ÓÖ∏",62],["f280","ÓÜ∑",124],["f340","Óà¥",62],["f380","Óâ≥",124],["f440","Óã∞",62],["f480","ÓåØ",124],["f540","Óé¨",62],["f580","Óè´",124],["f640","Óë®",62],["f680","Óíß",124],["f740","Óî§",62],["f780","Óï£",124],["f840","Óó†",62],["f880","Óòü",124],["f940","Óöú"],["fa40","‚Ö∞",9,"‚Ö†",9,"Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°‚àµÁ∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖä"],["fa80","ÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØ"],["fb40","Ê∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ô"],["fb80","Ô®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáöÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ô"],["fc40","È´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"]]');

/***/ }),
/* 96 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8ea1","ÔΩ°",62],["a1a1","„ÄÄ„ÄÅ„ÄÇÔºåÔºé„ÉªÔºöÔºõÔºüÔºÅ„Çõ„Çú¬¥ÔΩÄ¬®ÔºæÔø£Ôºø„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„Éº‚Äï‚ÄêÔºèÔººÔΩû‚à•ÔΩú‚Ä¶‚Ä•‚Äò‚Äô‚Äú‚ÄùÔºàÔºâ„Äî„ÄïÔºªÔºΩÔΩõÔΩù„Äà",9,"ÔºãÔºç¬±√ó√∑Ôºù‚â†ÔºúÔºû‚â¶‚âß‚àû‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔø•ÔºÑÔø†Ôø°ÔºÖÔºÉÔºÜÔºäÔº†¬ß‚òÜ‚òÖ‚óã‚óè‚óé‚óá"],["a2a1","‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Äª„Äí‚Üí‚Üê‚Üë‚Üì„Äì"],["a2ba","‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©"],["a2ca","‚àß‚à®Ôø¢‚áí‚áî‚àÄ‚àÉ"],["a2dc","‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨"],["a2f2","‚Ñ´‚Ä∞‚ôØ‚ô≠‚ô™‚Ä†‚Ä°¬∂"],["a2fe","‚óØ"],["a3b0","Ôºê",9],["a3c1","Ôº°",25],["a3e1","ÔΩÅ",25],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a8a1","‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ"],["ada1","‚ë†",19,"‚Ö†",9],["adc0","„çâ„åî„å¢„çç„åò„åß„åÉ„å∂„çë„çó„åç„å¶„å£„å´„çä„åª„éú„éù„éû„éé„éè„èÑ„é°"],["addf","„çª„Äù„Äü‚Ññ„èç‚Ñ°„ä§",4,"„à±„à≤„àπ„çæ„çΩ„çº‚âí‚â°‚à´‚àÆ‚àë‚àö‚ä•‚à†‚àü‚äø‚àµ‚à©‚à™"],["b0a1","‰∫úÂîñÂ®ÉÈòøÂìÄÊÑõÊå®Âß∂ÈÄ¢ËëµËåúÁ©êÊÇ™Êè°Ê∏•Êó≠Ëë¶Ëä¶ÈØµÊ¢ìÂúßÊñ°Êâ±ÂÆõÂßêËôªÈ£¥Áµ¢Á∂æÈÆéÊàñÁ≤üË¢∑ÂÆâÂ∫µÊåâÊöóÊ°àÈóáÈûçÊùè‰ª•‰ºä‰Ωç‰æùÂÅâÂõ≤Â§∑ÂßîÂ®ÅÂ∞âÊÉüÊÑèÊÖ∞ÊòìÊ§ÖÁÇ∫ÁïèÁï∞ÁßªÁ∂≠Á∑ØËÉÉËêéË°£Ë¨ÇÈÅïÈÅ∫Âåª‰∫ï‰∫•ÂüüËÇ≤ÈÉÅÁ£Ø‰∏ÄÂ£±Ê∫¢ÈÄ∏Á®≤Ëå®ËäãÈ∞ØÂÖÅÂç∞ÂíΩÂì°Âõ†ÂßªÂºïÈ£≤Ê∑´ËÉ§Ëî≠"],["b1a1","Èô¢Èô∞Èö†ÈüªÂêãÂè≥ÂÆáÁÉèÁæΩËøÇÈõ®ÂçØÈµúÁ™∫‰∏ëÁ¢ìËáºÊ∏¶ÂòòÂîÑÊ¨ùËîöÈ∞ªÂß•Âé©Êµ¶ÁìúÈñèÂôÇ‰∫ëÈÅãÈõ≤ËçèÈ§åÂè°Âñ∂Â¨∞ÂΩ±Êò†Êõ≥Ê†ÑÊ∞∏Ê≥≥Ê¥©ÁëõÁõàÁ©éÈ†¥Ëã±Ë°õË©†Èã≠Ê∂≤Áñ´ÁõäÈßÖÊÇ¶Ë¨ÅË∂äÈñ≤Ê¶éÂé≠ÂÜÜÂúíÂ†∞Â•ÑÂÆ¥Âª∂ÊÄ®Êé©Êè¥Ê≤øÊºîÁÇéÁÑîÁÖôÁáïÁåøÁ∏ÅËâ∂ËãëËñóÈÅ†ÈâõÈ¥õÂ°©ÊñºÊ±öÁî•ÂáπÂ§ÆÂ••ÂæÄÂøú"],["b2a1","ÊäºÊó∫Ê®™Ê¨ßÊÆ¥ÁéãÁøÅË•ñÈ¥¨È¥éÈªÑÂ≤°Ê≤ñËçªÂÑÑÂ±ãÊÜ∂ËáÜÊ°∂Áâ°‰πô‰ø∫Âç∏ÊÅ©Ê∏©Á©èÈü≥‰∏ãÂåñ‰ªÆ‰Ωï‰ºΩ‰æ°‰Ω≥Âä†ÂèØÂòâÂ§èÂ´ÅÂÆ∂ÂØ°ÁßëÊöáÊûúÊû∂Ê≠åÊ≤≥ÁÅ´ÁèÇÁ¶çÁ¶æÁ®ºÁÆáËä±ËãõËåÑËç∑ËèØËèìËù¶Ë™≤Âò©Ë≤®Ëø¶ÈÅéÈúûËöä‰øÑÂ≥®ÊàëÁâôÁîªËá•ËäΩËõæË≥ÄÈõÖÈ§ìÈßï‰ªã‰ºöËß£ÂõûÂ°äÂ£äÂªªÂø´ÊÄ™ÊÇîÊÅ¢ÊáêÊàíÊãêÊîπ"],["b3a1","È≠ÅÊô¶Ê¢∞Êµ∑ÁÅ∞ÁïåÁöÜÁµµËä•ËüπÈñãÈöéË≤ùÂá±ÂäæÂ§ñÂí≥ÂÆ≥Â¥ñÊÖ®Ê¶ÇÊ∂ØÁ¢çËìãË°óË©≤ÈéßÈ™∏Êµ¨È¶®ËõôÂû£ÊüøËõéÈàéÂäÉÂöáÂêÑÂªìÊã°ÊíπÊ†ºÊ†∏ÊÆªÁç≤Á¢∫Á©´Ë¶öËßíËµ´ËºÉÈÉ≠Èñ£ÈöîÈù©Â≠¶Â≤≥Ê•ΩÈ°çÈ°éÊéõÁ¨†Ê®´Ê©øÊ¢∂È∞çÊΩüÂâ≤ÂñùÊÅ∞Êã¨Ê¥ªÊ∏áÊªëËëõË§êËΩÑ‰∏îÈ∞πÂè∂Ê§õÊ®∫ÈûÑÊ†™ÂÖúÁ´ÉËí≤ÈáúÈéåÂôõÈ¥®Ê†¢ËåÖËê±"],["b4a1","Á≤•ÂààËãÖÁì¶‰πæ‰æÉÂÜ†ÂØíÂàäÂãòÂãßÂ∑ªÂñöÂ†™Âß¶ÂÆåÂÆòÂØõÂπ≤ÂππÊÇ£ÊÑüÊÖ£ÊÜæÊèõÊï¢ÊüëÊ°ìÊ£∫Ê¨æÊ≠ìÊ±óÊº¢ÊæóÊΩÖÁí∞ÁîòÁõ£ÁúãÁ´øÁÆ°Á∞°Á∑©Áº∂Áø∞ËÇùËâ¶ËéûË¶≥Ë´åË≤´ÈÇÑÈëëÈñìÈñëÈñ¢Èô•ÈüìÈ§®Ëàò‰∏∏Âê´Â≤∏Â∑åÁé©ÁôåÁúºÂ≤©Áø´Ë¥ãÈõÅÈ†ëÈ°îÈ°ò‰ºÅ‰ºéÂç±ÂñúÂô®Âü∫Â•áÂ¨âÂØÑÂ≤êÂ∏åÂπæÂøåÊèÆÊú∫ÊóóÊó¢ÊúüÊ£ãÊ£Ñ"],["b5a1","Ê©üÂ∏∞ÊØÖÊ∞óÊ±ΩÁïøÁ•àÂ≠£Á®ÄÁ¥ÄÂæΩË¶èË®òË≤¥Ëµ∑ËªåËºùÈ£¢È®éÈ¨º‰∫ÄÂÅΩÂÑÄÂ¶ìÂÆúÊàØÊäÄÊì¨Ê¨∫Áä†ÁñëÁ•áÁæ©ËüªË™ºË≠∞Êé¨ËèäÈû†ÂêâÂêÉÂñ´Ê°îÊ©òË©∞Á†ßÊùµÈªçÂç¥ÂÆ¢ËÑöËôêÈÄÜ‰∏ò‰πÖ‰ªá‰ºëÂèäÂê∏ÂÆÆÂºìÊÄ•ÊïëÊúΩÊ±ÇÊ±≤Ê≥£ÁÅ∏ÁêÉÁ©∂Á™ÆÁ¨àÁ¥öÁ≥æÁµ¶ÊóßÁâõÂéªÂ±ÖÂ∑®ÊãíÊã†ÊåôÊ∏†ËôöË®±Ë∑ùÈã∏ÊºÅÁ¶¶È≠ö‰∫®‰∫´‰∫¨"],["b6a1","‰æõ‰æ†ÂÉëÂÖáÁ´∂ÂÖ±Âá∂ÂçîÂå°ÂçøÂè´Âñ¨Â¢ÉÂ≥°Âº∑ÂΩäÊÄØÊÅêÊÅ≠ÊåüÊïôÊ©ãÊ≥ÅÁãÇÁã≠ÁüØËÉ∏ËÑÖËààËïéÈÉ∑Èè°ÈüøÈ•óÈ©ö‰ª∞ÂáùÂ∞≠ÊöÅÊ•≠Â±ÄÊõ≤Ê•µÁéâÊ°êÁ≤ÅÂÉÖÂã§ÂùáÂ∑æÈå¶Êñ§Ê¨£Ê¨ΩÁê¥Á¶ÅÁ¶ΩÁ≠ãÁ∑äËäπËèåË°øË•üË¨πËøëÈáëÂêüÈäÄ‰πùÂÄ∂Âè•Âå∫ÁãóÁéñÁü©Ëã¶Ë∫ØÈßÜÈßàÈßíÂÖ∑ÊÑöËôûÂñ∞Á©∫ÂÅ∂ÂØìÈÅáÈöÖ‰∏≤Ê´õÈáßÂ±ëÂ±à"],["b7a1","ÊéòÁ™üÊ≤ìÈù¥ËΩ°Á™™ÁÜäÈöàÁ≤ÇÊ†óÁπ∞Ê°ëÈç¨Âã≤ÂêõËñ´Ë®ìÁæ§ËªçÈÉ°Âç¶Ë¢àÁ•Å‰øÇÂÇæÂàëÂÖÑÂïìÂú≠Áè™ÂûãÂ•ëÂΩ¢ÂæÑÊÅµÊÖ∂ÊÖßÊÜ©Êé≤Êê∫Êï¨ÊôØÊ°ÇÊ∏ìÁï¶Á®ΩÁ≥ªÁµåÁ∂ôÁπãÁΩ´ËåéËçäËõçË®àË©£Ë≠¶ËªΩÈ†öÈ∂èËä∏ËøéÈØ®ÂäáÊàüÊíÉÊøÄÈöôÊ°ÅÂÇëÊ¨†Ê±∫ÊΩîÁ©¥ÁµêË°ÄË®£Êúà‰ª∂ÂÄπÂÄ¶ÂÅ•ÂÖºÂà∏Ââ£ÂñßÂúèÂ†ÖÂ´åÂª∫ÊÜ≤Êá∏Êã≥Êç≤"],["b8a1","Ê§úÊ®©ÁâΩÁä¨ÁåÆÁ†îÁ°ØÁµπÁúåËÇ©Ë¶ãË¨ôË≥¢ËªíÈÅ£ÈçµÈô∫È°ïÈ®ìÈπ∏ÂÖÉÂéüÂé≥ÂπªÂº¶Ê∏õÊ∫êÁéÑÁèæÁµÉËà∑Ë®ÄË´∫Èôê‰πéÂÄãÂè§ÂëºÂõ∫ÂßëÂ≠§Â∑±Â∫´ÂºßÊà∏ÊïÖÊûØÊπñÁãêÁ≥äË¢¥ËÇ°ËÉ°Ëè∞ËôéË™áË∑®Èà∑ÈõáÈ°ßÈºì‰∫î‰∫í‰ºçÂçàÂëâÂêæÂ®ØÂæåÂæ°ÊÇüÊ¢ßÊ™éÁëöÁ¢ÅË™ûË™§Ë≠∑ÈÜê‰πûÈØâ‰∫§‰Ωº‰æØÂÄôÂÄñÂÖâÂÖ¨ÂäüÂäπÂãæÂéöÂè£Âêë"],["b9a1","ÂêéÂñâÂùëÂû¢Â•ΩÂ≠îÂ≠ùÂÆèÂ∑•Â∑ßÂ∑∑Âπ∏Â∫ÉÂ∫öÂ∫∑ÂºòÊÅíÊÖåÊäóÊãòÊéßÊîªÊòÇÊôÉÊõ¥Êù≠Ê†°Ê¢óÊßãÊ±üÊ¥™Êµ©Ê∏ØÊ∫ùÁî≤ÁöáÁ°¨Á®øÁ≥†Á¥ÖÁ¥òÁµûÁ∂±ËÄïËÄÉËÇØËÇ±ËÖîËÜèËà™ËçíË°åË°°Ë¨õË≤¢Ë≥ºÈÉäÈÖµÈâ±Á†øÈãºÈñ§ÈôçÈ†ÖÈ¶ôÈ´òÈ¥ªÂâõÂä´Âè∑ÂêàÂ£ïÊã∑Êø†Ë±™ËΩüÈ∫πÂÖãÂàªÂëäÂõΩÁ©ÄÈÖ∑Èµ†ÈªíÁçÑÊºâËÖ∞ÁîëÂøΩÊÉöÈ™®ÁãõËæº"],["baa1","Ê≠§È†É‰ªäÂõ∞Âù§Â¢æÂ©öÊÅ®ÊááÊòèÊòÜÊ†πÊ¢±Ê∑∑ÁóïÁ¥∫ËâÆÈ≠Ç‰∫õ‰ΩêÂèâÂîÜÂµØÂ∑¶Â∑ÆÊüªÊ≤ôÁë≥Á†ÇË©êÈéñË£üÂùêÂ∫ßÊå´ÂÇµÂÇ¨ÂÜçÊúÄÂìâÂ°ûÂ¶ªÂÆ∞ÂΩ©ÊâçÊé°Ê†ΩÊ≠≥Ê∏àÁÅΩÈááÁäÄÁ†ïÁ†¶Á•≠ÊñéÁ¥∞ËèúË£ÅËºâÈöõÂâ§Âú®ÊùêÁΩ™Ë≤°ÂÜ¥ÂùÇÈò™Â†∫Ê¶äËÇ¥Âí≤Â¥éÂüºÁ¢ïÈ∑∫‰ΩúÂâäÂíãÊêæÊò®ÊúîÊüµÁ™ÑÁ≠ñÁ¥¢ÈåØÊ°úÈÆ≠Á¨πÂåôÂÜäÂà∑"],["bba1","ÂØüÊã∂ÊíÆÊì¶Êú≠ÊÆ∫Ëñ©ÈõëÁöêÈØñÊçåÈåÜÈÆ´ÁöøÊôí‰∏âÂÇòÂèÇÂ±±ÊÉ®ÊííÊï£Ê°üÁá¶ÁèäÁî£ÁÆóÁ∫ÇËöïËÆÉË≥õÈÖ∏È§êÊñ¨Êö´ÊÆã‰ªï‰ªî‰º∫‰ΩøÂà∫Âè∏Âè≤Âó£ÂõõÂ£´ÂßãÂßâÂßøÂ≠êÂ±çÂ∏ÇÂ∏´ÂøóÊÄùÊåáÊîØÂ≠úÊñØÊñΩÊó®ÊûùÊ≠¢Ê≠ªÊ∞èÁçÖÁ•âÁßÅÁ≥∏Á¥ôÁ¥´ËÇ¢ËÑÇËá≥Ë¶ñË©ûË©©Ë©¶Ë™åË´ÆË≥áË≥úÈõåÈ£ºÊ≠Ø‰∫ã‰ºº‰æçÂÖêÂ≠óÂØ∫ÊÖàÊåÅÊôÇ"],["bca1","Ê¨°ÊªãÊ≤ªÁàæÁíΩÁóîÁ£ÅÁ§∫ËÄåËÄ≥Ëá™ËíîËæûÊ±êÈπøÂºèË≠òÈ¥´Á´∫Ëª∏ÂÆçÈõ´‰∏ÉÂè±Âü∑Â§±Â´âÂÆ§ÊÇâÊπøÊºÜÁñæË≥™ÂÆüËîÄÁØ†ÂÅ≤Êü¥ËäùÂ±°ËïäÁ∏ûËàéÂÜôÂ∞ÑÊç®Ëµ¶ÊñúÁÖÆÁ§æÁ¥óËÄÖË¨ùËªäÈÅÆËõáÈÇ™ÂÄüÂã∫Â∞∫ÊùìÁÅºÁàµÈÖåÈáàÈå´Ëã•ÂØÇÂº±ÊÉπ‰∏ªÂèñÂÆàÊâãÊú±ÊÆäÁã©Áè†Á®ÆËÖ´Ë∂£ÈÖíÈ¶ñÂÑíÂèóÂë™ÂØøÊéàÊ®πÁ∂¨ÈúÄÂõöÂèéÂë®"],["bda1","ÂÆóÂ∞±Â∑û‰øÆÊÑÅÊãæÊ¥≤ÁßÄÁßãÁµÇÁπçÁøíËá≠ËàüËíêË°ÜË•≤ËÆêËπ¥ËºØÈÄ±ÈÖãÈÖ¨ÈõÜÈÜú‰ªÄ‰ΩèÂÖÖÂçÅÂæìÊàéÊüîÊ±ÅÊ∏ãÁç£Á∏¶ÈáçÈäÉÂèîÂ§ôÂÆøÊ∑ëÁ•ùÁ∏ÆÁ≤õÂ°æÁÜüÂá∫Ë°ìËø∞‰øäÂ≥ªÊò•Áû¨Á´£ËàúÈßøÂáÜÂæ™Êó¨Ê•ØÊÆâÊ∑≥Ê∫ñÊΩ§ÁõæÁ¥îÂ∑°ÈÅµÈÜáÈ†ÜÂá¶ÂàùÊâÄÊöëÊõôÊ∏öÂ∫∂Á∑íÁΩ≤Êõ∏ËñØËó∑Ë´∏Âä©ÂèôÂ•≥Â∫èÂæêÊÅïÈã§Èô§ÂÇ∑ÂÑü"],["bea1","ÂãùÂå†ÂçáÂè¨Âì®ÂïÜÂî±ÂòóÂ•®Â¶æÂ®ºÂÆµÂ∞ÜÂ∞èÂ∞ëÂ∞öÂ∫ÑÂ∫äÂª†ÂΩ∞ÊâøÊäÑÊãõÊéåÊç∑ÊòáÊòåÊò≠Êô∂ÊùæÊ¢¢Ê®üÊ®µÊ≤ºÊ∂àÊ∏âÊπòÁÑºÁÑ¶ÁÖßÁóáÁúÅÁ°ùÁ§ÅÁ••Áß∞Á´†Á¨ëÁ≤ßÁ¥πËÇñËèñËíãËïâË°ùË£≥Ë®üË®ºË©îË©≥Ë±°Ë≥ûÈÜ§Èâ¶ÈçæÈêòÈöúÈûò‰∏ä‰∏à‰∏û‰πóÂÜóÂâ∞ÂüéÂ†¥Â£åÂ¨¢Â∏∏ÊÉÖÊìæÊù°ÊùñÊµÑÁä∂Áï≥Á©£Ëí∏Ë≠≤ÈÜ∏Èå†Âò±Âü¥È£æ"],["bfa1","Êã≠Ê§çÊÆñÁá≠ÁπîËÅ∑Ëâ≤Ëß¶È£üËùïËæ±Â∞ª‰º∏‰ø°‰æµÂîáÂ®†ÂØùÂØ©ÂøÉÊÖéÊåØÊñ∞ÊôãÊ£ÆÊ¶õÊµ∏Ê∑±Áî≥ÁñπÁúüÁ•ûÁß¶Á¥≥Ëá£ËäØËñ™Ë¶™Ë®∫Ë∫´ËæõÈÄ≤ÈáùÈúá‰∫∫‰ªÅÂàÉÂ°µÂ£¨Â∞ãÁîöÂ∞ΩËÖéË®äËøÖÈô£Èù≠Á¨•Ë´èÈ†àÈÖ¢Âõ≥Âé®ÈÄóÂêπÂûÇÂ∏•Êé®Ê∞¥ÁÇäÁù°Á≤ãÁø†Ë°∞ÈÅÇÈÖîÈåêÈåòÈöèÁëûÈ´ÑÂ¥áÂµ©Êï∞Êû¢Ë∂®ÈõõÊçÆÊùâÊ§ôËèÖÈ†óÈõÄË£æ"],["c0a1","ÊæÑÊë∫ÂØ∏‰∏ñÁÄ¨ÁïùÊòØÂáÑÂà∂Âã¢ÂßìÂæÅÊÄßÊàêÊîøÊï¥ÊòüÊô¥Ê£≤Ê†ñÊ≠£Ê∏ÖÁâ≤ÁîüÁõõÁ≤æËÅñÂ£∞Ë£ΩË•øË™†Ë™ìË´ãÈÄùÈÜíÈùíÈùôÊñâÁ®éËÑÜÈöªÂ∏≠ÊÉúÊàöÊñ•ÊòîÊûêÁü≥Á©çÁ±çÁ∏æËÑäË≤¨Ëµ§Ë∑°ËπüÁ¢©ÂàáÊãôÊé•ÊëÇÊäòË®≠Á™ÉÁØÄË™¨Èõ™Áµ∂ËàåËùâ‰ªôÂÖàÂçÉÂç†ÂÆ£Â∞ÇÂ∞ñÂ∑ùÊà¶ÊâáÊí∞Ê†ìÊ†¥Ê≥âÊµÖÊ¥óÊüìÊΩúÁÖéÁÖΩÊóãÁ©øÁÆ≠Á∑ö"],["c1a1","ÁπäÁæ®ËÖ∫ËàõËàπËñ¶Ë©ÆË≥éË∑µÈÅ∏ÈÅ∑Èä≠ÈäëÈñÉÈÆÆÂâçÂñÑÊº∏ÁÑ∂ÂÖ®Á¶ÖÁπïËÜ≥Á≥éÂôåÂ°ëÂ≤®Êé™ÊõæÊõΩÊ•öÁãôÁñèÁñéÁ§éÁ•ñÁßüÁ≤óÁ¥†ÁµÑËòáË®¥ÈòªÈÅ°Èº†ÂÉßÂâµÂèåÂè¢ÂÄâÂñ™Â£ÆÂ•èÁàΩÂÆãÂ±§ÂåùÊÉ£ÊÉ≥ÊçúÊéÉÊåøÊéªÊìçÊó©ÊõπÂ∑£ÊßçÊßΩÊºïÁá•‰∫âÁó©Áõ∏Á™ìÁ≥üÁ∑èÁ∂úËÅ°ËçâËçòËë¨ËíºËóªË£ÖËµ∞ÈÄÅÈÅ≠ÈéóÈúúÈ®íÂÉèÂ¢óÊÜé"],["c2a1","ËáìËîµË¥àÈÄ†‰øÉÂÅ¥ÂâáÂç≥ÊÅØÊçâÊùüÊ∏¨Ë∂≥ÈÄü‰øóÂ±ûË≥äÊóèÁ∂öÂçíË¢ñÂÖ∂ÊèÉÂ≠òÂ≠´Â∞äÊêçÊùëÈÅú‰ªñÂ§öÂ§™Ê±∞Ë©ëÂîæÂ†ïÂ¶•ÊÉ∞ÊâìÊüÅËàµÊ•ïÈôÄÈßÑÈ®®‰ΩìÂ†ÜÂØæËÄêÂ≤±Â∏ØÂæÖÊÄ†ÊÖãÊà¥ÊõøÊ≥∞ÊªûËÉéËÖøËãîË¢ãË≤∏ÈÄÄÈÄÆÈöäÈªõÈØõ‰ª£Âè∞Â§ßÁ¨¨ÈÜçÈ°åÈ∑πÊªùÁÄßÂçìÂïÑÂÆÖÊâòÊäûÊãìÊ≤¢ÊøØÁê¢Ë®óÈê∏ÊøÅË´æËå∏ÂáßËõ∏Âè™"],["c3a1","Âè©‰ΩÜÈÅîËæ∞Â•™ËÑ±Â∑ΩÁ´™ËæøÊ£öË∞∑Áã∏È±àÊ®ΩË™∞‰∏πÂçòÂòÜÂù¶ÊãÖÊé¢Êó¶Ê≠éÊ∑°ÊπõÁÇ≠Áü≠Á´ØÁÆ™Á∂ªËÄΩËÉÜËõãË™ïÈçõÂõ£Â£áÂºæÊñ≠ÊöñÊ™ÄÊÆµÁî∑Ë´áÂÄ§Áü•Âú∞ÂºõÊÅ•Êô∫Ê±†Áó¥Á®öÁΩÆËá¥ËúòÈÅÖÈ¶≥ÁØâÁïúÁ´πÁ≠ëËìÑÈÄêÁß©Á™íËå∂Â´°ÁùÄ‰∏≠‰ª≤ÂÆôÂø†ÊäΩÊòºÊü±Ê≥®Ëô´Ë°∑Ë®ªÈÖéÈã≥ÈßêÊ®óÁÄ¶Áå™ËãßËëóË≤Ø‰∏ÅÂÖÜÂáãÂñãÂØµ"],["c4a1","Â∏ñÂ∏≥Â∫ÅÂºîÂºµÂΩ´Âæ¥Êá≤ÊåëÊö¢ÊúùÊΩÆÁâíÁî∫Áú∫ËÅ¥ËÑπËÖ∏Ëù∂Ë™øË´úË∂ÖË∑≥ÈäöÈï∑È†ÇÈ≥•ÂãÖÊçóÁõ¥ÊúïÊ≤àÁèçË≥ÉÈéÆÈô≥Ê¥•Â¢úÊ§éÊßåËøΩÈéöÁóõÈÄöÂ°öÊ†ÇÊé¥Êßª‰ΩÉÊº¨ÊüòËæªËî¶Á∂¥ÈçîÊ§øÊΩ∞Âù™Â£∑Â¨¨Á¥¨Áà™ÂêäÈá£È∂¥‰∫≠‰ΩéÂÅúÂÅµÂâÉË≤ûÂëàÂ†§ÂÆöÂ∏ùÂ∫ïÂ∫≠Âª∑ÂºüÊÇåÊäµÊå∫ÊèêÊ¢ØÊ±ÄÁ¢áÁ¶éÁ®ãÁ∑†ËâáË®ÇË´¶ËπÑÈÄì"],["c5a1","ÈÇ∏ÈÑ≠ÈáòÈºéÊ≥•ÊëòÊì¢ÊïµÊª¥ÁöÑÁ¨õÈÅ©ÈèëÊ∫∫Âì≤ÂæπÊí§ËΩçËø≠ÈâÑÂÖ∏Â°´Â§©Â±ïÂ∫óÊ∑ªÁ∫èÁîúË≤ºËª¢È°õÁÇπ‰ºùÊÆøÊæ±Áî∞ÈõªÂÖéÂêêÂ†µÂ°óÂ¶¨Â±†ÂæíÊñóÊùúÊ∏°ÁôªËèüË≥≠ÈÄîÈÉΩÈççÁ†•Á†∫Âä™Â∫¶ÂúüÂ•¥ÊÄíÂÄíÂÖöÂÜ¨ÂáçÂàÄÂîêÂ°îÂ°òÂ•óÂÆïÂ≥∂Â∂ãÊÇºÊäïÊê≠Êù±Ê°ÉÊ¢ºÊ£üÁõóÊ∑òÊπØÊ∂õÁÅØÁáàÂΩìÁóòÁ•∑Á≠âÁ≠îÁ≠íÁ≥ñÁµ±Âà∞"],["c6a1","Ëë£Ëï©Ëó§Ë®éË¨ÑË±ÜË∏èÈÄÉÈÄèÈêôÈô∂È†≠È®∞ÈóòÂÉçÂãïÂêåÂ†ÇÂ∞éÊÜßÊíûÊ¥ûÁû≥Á´•ËÉ¥ËêÑÈÅìÈäÖÂ≥†È¥áÂåøÂæóÂæ≥Ê∂úÁâπÁù£Á¶øÁØ§ÊØíÁã¨Ë™≠Ê†ÉÊ©°Âá∏Á™ÅÊ§¥Â±äÈ≥∂Ëã´ÂØÖÈÖâÁÄûÂô∏Â±ØÊÉáÊï¶Ê≤åË±öÈÅÅÈ†ìÂëëÊõáÈàçÂ•àÈÇ£ÂÜÖ‰πçÂá™ËñôË¨éÁÅòÊç∫ÈçãÊ•¢È¶¥Á∏ÑÁï∑ÂçóÊ•†ËªüÈõ£Ê±ù‰∫åÂ∞ºÂºêËø©ÂåÇË≥ëËÇâËôπÂªøÊó•‰π≥ÂÖ•"],["c7a1","Â¶ÇÂ∞øÈüÆ‰ªªÂ¶äÂøçË™çÊø°Á¶∞Á•¢ÂØßËë±Áå´ÁÜ±Âπ¥ÂøµÊçªÊíöÁáÉÁ≤ò‰πÉÂªº‰πãÂüúÂö¢ÊÇ©ÊøÉÁ¥çËÉΩËÑ≥ËÜøËæ≤Ë¶óËö§Â∑¥ÊääÊí≠Ë¶áÊù∑Ê≥¢Ê¥æÁê∂Á†¥Â©ÜÁΩµËä≠È¶¨‰ø≥ÂªÉÊãùÊéíÊïóÊùØÁõÉÁâåËÉåËÇ∫Ëº©ÈÖçÂÄçÂüπÂ™íÊ¢ÖÊ•≥ÁÖ§ÁãΩË≤∑Â£≤Ë≥†Èô™ÈÄôËùøÁß§ÁüßËê©‰ºØÂâ•ÂçöÊãçÊüèÊ≥äÁôΩÁÆîÁ≤ïËà∂ËñÑËø´ÊõùÊº†ÁàÜÁ∏õËé´ÈßÅÈ∫¶"],["c8a1","ÂáΩÁÆ±Á°≤ÁÆ∏ËÇáÁ≠àÊ´®Âπ°ËÇåÁïëÁï†ÂÖ´Èâ¢Ê∫åÁô∫ÈÜóÈ´™‰ºêÁΩ∞ÊäúÁ≠èÈñ•È≥©Âô∫Â°ôËõ§Èöº‰º¥Âà§ÂçäÂèçÂèõÂ∏ÜÊê¨ÊñëÊùøÊ∞æÊ±éÁâàÁäØÁè≠ÁïîÁπÅËà¨Ëó©Ë≤©ÁØÑÈáÜÁÖ©È†íÈ£ØÊåΩÊô©Áï™Áõ§Á£êËïÉËõÆÂå™ÂçëÂê¶Â¶ÉÂ∫áÂΩºÊÇ≤ÊââÊâπÊä´ÊñêÊØîÊ≥åÁñ≤ÁöÆÁ¢ëÁßòÁ∑ãÁΩ∑ËÇ•Ë¢´Ë™πË≤ªÈÅøÈùûÈ£õÊ®ãÁ∞∏ÂÇôÂ∞æÂæÆÊûáÊØòÁêµÁúâÁæé"],["c9a1","ÈºªÊüäÁ®óÂåπÁñãÈ´≠ÂΩ¶ËÜùËè±ËÇòÂººÂøÖÁï¢Á≠ÜÈÄºÊ°ßÂß´Â™õÁ¥êÁôæË¨¨‰øµÂΩ™Ê®ôÊ∞∑ÊºÇÁì¢Á•®Ë°®Ë©ïË±πÂªüÊèèÁóÖÁßíËãóÈå®Èã≤ËíúËõ≠È∞≠ÂìÅÂΩ¨ÊñåÊµúÁÄïË≤ßË≥ìÈ†ªÊïèÁì∂‰∏ç‰ªòÂü†Â§´Â©¶ÂØåÂÜ®Â∏ÉÂ∫úÊÄñÊâ∂Êï∑ÊñßÊôÆÊµÆÁà∂Á¨¶ËÖêËÜöËäôË≠úË≤†Ë≥¶Ëµ¥ÈòúÈôÑ‰æÆÊí´Ê≠¶ËàûËë°Ëï™ÈÉ®Â∞ÅÊ•ìÈ¢®Ëë∫Ëïó‰ºèÂâØÂæ©ÂπÖÊúç"],["caa1","Á¶èËÖπË§áË¶ÜÊ∑µÂºóÊâïÊ≤∏‰ªèÁâ©ÈÆíÂàÜÂêªÂô¥Â¢≥ÊÜ§ÊâÆÁÑöÂ•ÆÁ≤âÁ≥ûÁ¥õÈõ∞ÊñáËÅû‰∏ô‰ΩµÂÖµÂ°ÄÂπ£Âπ≥ÂºäÊüÑ‰∏¶ËîΩÈñâÈôõÁ±≥È†ÅÂÉªÂ£ÅÁôñÁ¢ßÂà•Áû•ËîëÁÆÜÂÅèÂ§âÁâáÁØáÁ∑®Ëæ∫ËøîÈÅç‰æøÂãâÂ®©ÂºÅÈû≠‰øùËàóÈã™ÂúÉÊçïÊ≠©Áî´Ë£úËºîÁ©ÇÂãüÂ¢ìÊÖïÊàäÊöÆÊØçÁ∞øËè©ÂÄ£‰ø∏ÂåÖÂëÜÂ†±Â•âÂÆùÂ≥∞Â≥ØÂ¥©Â∫ñÊä±ÊçßÊîæÊñπÊúã"],["cba1","Ê≥ïÊ≥°ÁÉπÁ†≤Á∏´ËÉûËä≥ËêåËì¨ËúÇË§íË®™Ë±äÈÇ¶ÈãíÈ£ΩÈ≥≥Èµ¨‰πè‰∫°ÂÇçÂâñÂùäÂ¶®Â∏ΩÂøòÂøôÊàøÊö¥ÊúõÊüêÊ£íÂÜíÁ¥°ËÇ™ËÜ®Ë¨ÄË≤åË≤øÈâæÈò≤Âê†È†¨ÂåóÂÉïÂçúÂ¢®Êí≤Êú¥ÁâßÁù¶Á©ÜÈá¶ÂãÉÊ≤°ÊÆÜÂ†ÄÂπåÂ•îÊú¨ÁøªÂá°ÁõÜÊë©Á£®È≠îÈ∫ªÂüãÂ¶πÊòßÊûöÊØéÂì©ÊßôÂπïËÜúÊûïÈÆ™ÊüæÈ±íÊ°ù‰∫¶‰ø£ÂèàÊäπÊú´Ê≤´ËøÑ‰æ≠Áπ≠È∫ø‰∏áÊÖ¢Ê∫Ä"],["cca1","Êº´ËîìÂë≥Êú™È≠ÖÂ∑≥ÁÆïÂ≤¨ÂØÜËúúÊπäËìëÁ®îËÑàÂ¶ôÁ≤çÊ∞ëÁú†ÂãôÂ§¢ÁÑ°ÁâüÁüõÈúßÈµ°Ê§ãÂ©øÂ®òÂÜ•ÂêçÂëΩÊòéÁõüËø∑ÈäòÈ≥¥Âß™ÁâùÊªÖÂÖçÊ£âÁ∂øÁ∑¨Èù¢È∫∫Êë∏Ê®°ËåÇÂ¶ÑÂ≠üÊØõÁåõÁõ≤Á∂≤ËÄóËíôÂÑ≤Êú®ÈªôÁõÆÊù¢ÂãøÈ§ÖÂ∞§ÊàªÁ±æË≤∞ÂïèÊÇ∂Á¥ãÈñÄÂåÅ‰πüÂÜ∂Â§úÁà∫ËÄ∂ÈáéÂº•Áü¢ÂéÑÂΩπÁ¥ÑËñ¨Ë®≥Ë∫çÈùñÊü≥ËñÆÈëìÊÑâÊÑàÊ≤πÁôí"],["cda1","Ë´≠Ëº∏ÂîØ‰ΩëÂÑ™ÂãáÂèãÂÆ•ÂπΩÊÇ†ÊÜÇÊèñÊúâÊüöÊπßÊ∂åÁå∂Áå∑Áî±Á•êË£ïË™òÈÅäÈÇëÈÉµÈõÑËûçÂ§ï‰∫à‰Ωô‰∏éË™âËºøÈ†êÂÇ≠ÂπºÂ¶ñÂÆπÂ∫∏ÊèöÊè∫ÊìÅÊõúÊ•äÊßòÊ¥ãÊ∫∂ÁÜîÁî®Á™ØÁæäËÄÄËëâËìâË¶ÅË¨°Ë∏äÈÅ•ÈôΩÈ§äÊÖæÊäëÊ¨≤Ê≤ÉÊµ¥ÁøåÁøºÊ∑ÄÁæÖËû∫Ë£∏Êù•Ëé±È†ºÈõ∑Ê¥õÁµ°ËêΩÈÖ™‰π±ÂçµÂµêÊ¨ÑÊø´ËóçËò≠Ë¶ßÂà©ÂêèÂ±•ÊùéÊ¢®ÁêÜÁíÉ"],["cea1","Áó¢Ë£èË£°ÈáåÈõ¢Èô∏ÂæãÁéáÁ´ãËëéÊé†Áï•ÂäâÊµÅÊ∫úÁêâÁïôÁ°´Á≤íÈöÜÁ´úÈæç‰æ∂ÊÖÆÊóÖËôú‰∫Ü‰∫ÆÂÉö‰∏°ÂáåÂØÆÊñôÊ¢ÅÊ∂ºÁåüÁôÇÁû≠Á®úÁ≥ßËâØË´íÈÅºÈáèÈôµÈ†òÂäõÁ∑ëÂÄ´ÂéòÊûóÊ∑ãÁáêÁê≥Ëá®Ëº™Èö£È±óÈ∫üÁë†Â°ÅÊ∂ôÁ¥ØÈ°û‰ª§‰º∂‰æãÂÜ∑Âä±Â∂∫ÊÄúÁé≤Á§ºËãìÈà¥Èö∑Èõ∂ÈúäÈ∫óÈΩ¢Êö¶Ê≠¥ÂàóÂä£ÁÉàË£ÇÂªâÊÅãÊÜêÊº£ÁÖâÁ∞æÁ∑¥ËÅØ"],["cfa1","ËìÆÈÄ£Èå¨ÂëÇÈ≠ØÊ´ìÁÇâË≥ÇË∑ØÈú≤Âä¥Â©ÅÂªäÂºÑÊúóÊ•ºÊ¶îÊµ™ÊºèÁâ¢ÁãºÁØ≠ËÄÅËÅæËùãÈÉéÂÖ≠È∫ìÁ¶ÑËÇãÈå≤Ë´ñÂÄ≠ÂíåË©±Ê≠™Ë≥ÑËÑáÊÉëÊû†È∑≤‰∫ô‰∫òÈ∞êË©´ËóÅËï®Ê§ÄÊπæÁ¢óËÖï"],["d0a1","Âºå‰∏ê‰∏ï‰∏™‰∏±‰∏∂‰∏º‰∏ø‰πÇ‰πñ‰πò‰∫Ç‰∫ÖË±´‰∫äËàíÂºç‰∫é‰∫û‰∫ü‰∫†‰∫¢‰∫∞‰∫≥‰∫∂‰ªé‰ªç‰ªÑ‰ªÜ‰ªÇ‰ªó‰ªû‰ª≠‰ªü‰ª∑‰ºâ‰Ωö‰º∞‰Ωõ‰Ωù‰Ωó‰Ωá‰Ω∂‰æà‰æè‰æò‰Ωª‰Ω©‰Ω∞‰æë‰ΩØ‰æÜ‰æñÂÑò‰øî‰øü‰øé‰øò‰øõ‰øë‰øö‰øê‰ø§‰ø•ÂÄöÂÄ®ÂÄîÂÄ™ÂÄ•ÂÄÖ‰ºú‰ø∂ÂÄ°ÂÄ©ÂÄ¨‰øæ‰øØÂÄëÂÄÜÂÅÉÂÅáÊúÉÂÅïÂÅêÂÅàÂÅöÂÅñÂÅ¨ÂÅ∏ÂÇÄÂÇöÂÇÖÂÇ¥ÂÇ≤"],["d1a1","ÂÉâÂÉäÂÇ≥ÂÉÇÂÉñÂÉûÂÉ•ÂÉ≠ÂÉ£ÂÉÆÂÉπÂÉµÂÑâÂÑÅÂÑÇÂÑñÂÑïÂÑîÂÑöÂÑ°ÂÑ∫ÂÑ∑ÂÑºÂÑªÂÑøÂÖÄÂÖíÂÖåÂÖîÂÖ¢Á´∏ÂÖ©ÂÖ™ÂÖÆÂÜÄÂÜÇÂõòÂÜåÂÜâÂÜèÂÜëÂÜìÂÜïÂÜñÂÜ§ÂÜ¶ÂÜ¢ÂÜ©ÂÜ™ÂÜ´ÂÜ≥ÂÜ±ÂÜ≤ÂÜ∞ÂÜµÂÜΩÂáÖÂáâÂáõÂá†ËôïÂá©Âá≠Âá∞ÂáµÂáæÂàÑÂàãÂàîÂàéÂàßÂà™ÂàÆÂà≥ÂàπÂâèÂâÑÂâãÂâåÂâûÂâîÂâ™Ââ¥Ââ©Ââ≥ÂâøÂâΩÂäçÂäîÂäíÂâ±ÂäàÂäëËæ®"],["d2a1","ËæßÂä¨Âä≠ÂäºÂäµÂãÅÂãçÂãóÂãûÂã£Âã¶È£≠Âã†Âã≥ÂãµÂã∏ÂãπÂåÜÂåàÁî∏ÂåçÂåêÂåèÂåïÂåöÂå£ÂåØÂå±Âå≥Âå∏ÂçÄÂçÜÂçÖ‰∏óÂçâÂççÂáñÂçûÂç©ÂçÆÂ§òÂçªÂç∑ÂéÇÂéñÂé†Âé¶Âé•ÂéÆÂé∞Âé∂ÂèÉÁ∞íÈõôÂèüÊõºÁáÆÂèÆÂè®Âè≠Âè∫ÂêÅÂêΩÂëÄÂê¨Âê≠ÂêºÂêÆÂê∂Âê©ÂêùÂëéÂíèÂëµÂíéÂëüÂë±Âë∑Âë∞ÂííÂëªÂíÄÂë∂ÂíÑÂíêÂíÜÂìáÂí¢Âí∏Âí•Âí¨ÂìÑÂìàÂí®"],["d3a1","Âí´ÂìÇÂí§ÂíæÂíºÂìòÂì•Âì¶ÂîèÂîîÂìΩÂìÆÂì≠Âì∫Âì¢ÂîπÂïÄÂï£ÂïåÂîÆÂïúÂïÖÂïñÂïóÂî∏Âî≥ÂïùÂñôÂñÄÂíØÂñäÂñüÂïªÂïæÂñòÂñûÂñÆÂïºÂñÉÂñ©ÂñáÂñ®ÂóöÂóÖÂóüÂóÑÂóúÂó§ÂóîÂòîÂó∑ÂòñÂóæÂóΩÂòõÂóπÂôéÂôêÁáüÂò¥Âò∂Âò≤Âò∏Âô´Âô§ÂòØÂô¨Âô™ÂöÜÂöÄÂöäÂö†ÂöîÂöèÂö•ÂöÆÂö∂Âö¥ÂõÇÂöºÂõÅÂõÉÂõÄÂõàÂõéÂõëÂõìÂõóÂõÆÂõπÂúÄÂõøÂúÑÂúâ"],["d4a1","ÂúàÂúãÂúçÂúìÂúòÂúñÂóáÂúúÂú¶Âú∑Âú∏ÂùéÂúªÂùÄÂùèÂù©ÂüÄÂûàÂù°ÂùøÂûâÂûìÂû†Âû≥Âû§Âû™Âû∞ÂüÉÂüÜÂüîÂüíÂüìÂ†äÂüñÂü£Â†ãÂ†ôÂ†ùÂ°≤Â†°Â°¢Â°ãÂ°∞ÊØÄÂ°íÂ†ΩÂ°πÂ¢ÖÂ¢πÂ¢üÂ¢´Â¢∫Â£ûÂ¢ªÂ¢∏Â¢ÆÂ£ÖÂ£ìÂ£ëÂ£óÂ£ôÂ£òÂ£•Â£úÂ£§Â£üÂ£ØÂ£∫Â£πÂ£ªÂ£ºÂ£ΩÂ§ÇÂ§äÂ§êÂ§õÊ¢¶Â§•Â§¨Â§≠Â§≤Â§∏Â§æÁ´íÂ•ïÂ•êÂ•éÂ•öÂ•òÂ•¢Â•†Â•ßÂ•¨Â•©"],["d5a1","Â•∏Â¶ÅÂ¶ù‰Ωû‰æ´Â¶£Â¶≤ÂßÜÂß®ÂßúÂ¶çÂßôÂßöÂ®•Â®üÂ®ëÂ®úÂ®âÂ®öÂ©ÄÂ©¨Â©âÂ®µÂ®∂Â©¢Â©™Â™öÂ™ºÂ™æÂ´ãÂ´ÇÂ™ΩÂ´£Â´óÂ´¶Â´©Â´ñÂ´∫Â´ªÂ¨åÂ¨ãÂ¨ñÂ¨≤Â´êÂ¨™Â¨∂Â¨æÂ≠ÉÂ≠ÖÂ≠ÄÂ≠ëÂ≠ïÂ≠öÂ≠õÂ≠•Â≠©Â≠∞Â≠≥Â≠µÂ≠∏ÊñàÂ≠∫ÂÆÄÂÆÉÂÆ¶ÂÆ∏ÂØÉÂØáÂØâÂØîÂØêÂØ§ÂØ¶ÂØ¢ÂØûÂØ•ÂØ´ÂØ∞ÂØ∂ÂØ≥Â∞ÖÂ∞áÂ∞àÂ∞çÂ∞ìÂ∞†Â∞¢Â∞®Â∞∏Â∞πÂ±ÅÂ±ÜÂ±éÂ±ì"],["d6a1","Â±êÂ±èÂ≠±Â±¨Â±Æ‰π¢Â±∂Â±πÂ≤åÂ≤ëÂ≤îÂ¶õÂ≤´Â≤ªÂ≤∂Â≤ºÂ≤∑Â≥ÖÂ≤æÂ≥áÂ≥ôÂ≥©Â≥ΩÂ≥∫Â≥≠Â∂åÂ≥™Â¥ãÂ¥ïÂ¥óÂµúÂ¥üÂ¥õÂ¥ëÂ¥îÂ¥¢Â¥öÂ¥ôÂ¥òÂµåÂµíÂµéÂµãÂµ¨Âµ≥Âµ∂Â∂áÂ∂ÑÂ∂ÇÂ∂¢Â∂ùÂ∂¨Â∂ÆÂ∂ΩÂ∂êÂ∂∑Â∂ºÂ∑âÂ∑çÂ∑ìÂ∑íÂ∑ñÂ∑õÂ∑´Â∑≤Â∑µÂ∏ãÂ∏öÂ∏ôÂ∏ëÂ∏õÂ∏∂Â∏∑ÂπÑÂπÉÂπÄÂπéÂπóÂπîÂπüÂπ¢Âπ§ÂπáÂπµÂπ∂Âπ∫È∫ºÂπøÂ∫†ÂªÅÂªÇÂªàÂªêÂªè"],["d7a1","ÂªñÂª£ÂªùÂªöÂªõÂª¢Âª°Âª®Âª©Âª¨Âª±Âª≥Âª∞Âª¥Âª∏ÂªæÂºÉÂºâÂΩùÂΩúÂºãÂºëÂºñÂº©Âº≠Âº∏ÂΩÅÂΩàÂΩåÂΩéÂºØÂΩëÂΩñÂΩóÂΩôÂΩ°ÂΩ≠ÂΩ≥ÂΩ∑ÂæÉÂæÇÂΩøÂæäÂæàÂæëÂæáÂæûÂæôÂæòÂæ†Âæ®Âæ≠ÂæºÂøñÂøªÂø§Âø∏Âø±ÂøùÊÇ≥ÂøøÊÄ°ÊÅ†ÊÄôÊÄêÊÄ©ÊÄéÊÄ±ÊÄõÊÄïÊÄ´ÊÄ¶ÊÄèÊÄ∫ÊÅöÊÅÅÊÅ™ÊÅ∑ÊÅüÊÅäÊÅÜÊÅçÊÅ£ÊÅÉÊÅ§ÊÅÇÊÅ¨ÊÅ´ÊÅôÊÇÅÊÇçÊÉßÊÇÉÊÇö"],["d8a1","ÊÇÑÊÇõÊÇñÊÇóÊÇíÊÇßÊÇãÊÉ°ÊÇ∏ÊÉ†ÊÉìÊÇ¥Âø∞ÊÇΩÊÉÜÊÇµÊÉòÊÖçÊÑïÊÑÜÊÉ∂ÊÉ∑ÊÑÄÊÉ¥ÊÉ∫ÊÑÉÊÑ°ÊÉªÊÉ±ÊÑçÊÑéÊÖáÊÑæÊÑ®ÊÑßÊÖäÊÑøÊÑºÊÑ¨ÊÑ¥ÊÑΩÊÖÇÊÖÑÊÖ≥ÊÖ∑ÊÖòÊÖôÊÖöÊÖ´ÊÖ¥ÊÖØÊÖ•ÊÖ±ÊÖüÊÖùÊÖìÊÖµÊÜôÊÜñÊÜáÊÜ¨ÊÜîÊÜöÊÜäÊÜëÊÜ´ÊÜÆÊáåÊáäÊáâÊá∑ÊáàÊáÉÊáÜÊÜ∫ÊáãÁΩπÊáçÊá¶Êá£Êá∂Êá∫Êá¥ÊáøÊáΩÊáºÊáæÊàÄÊààÊàâÊàçÊàåÊàîÊàõ"],["d9a1","ÊàûÊà°Êà™ÊàÆÊà∞Êà≤Êà≥ÊâÅÊâéÊâûÊâ£ÊâõÊâ†Êâ®ÊâºÊäÇÊäâÊâæÊäíÊäìÊäñÊãîÊäÉÊäîÊãóÊãëÊäªÊãèÊãøÊãÜÊìîÊãàÊãúÊãåÊãäÊãÇÊãáÊäõÊãâÊååÊãÆÊã±ÊåßÊåÇÊåàÊãØÊãµÊçêÊåæÊççÊêúÊçèÊéñÊééÊéÄÊé´Êç∂Êé£ÊéèÊéâÊéüÊéµÊç´Êç©ÊéæÊè©ÊèÄÊèÜÊè£ÊèâÊèíÊè∂ÊèÑÊêñÊê¥ÊêÜÊêìÊê¶Êê∂ÊîùÊêóÊê®ÊêèÊëßÊëØÊë∂ÊëéÊî™ÊíïÊíìÊí•Êí©ÊíàÊíº"],["daa1","ÊìöÊìíÊìÖÊìáÊíªÊìòÊìÇÊì±ÊìßËàâÊì†Êì°Êä¨Êì£ÊìØÊî¨Êì∂Êì¥Êì≤Êì∫ÊîÄÊìΩÊîòÊîúÊîÖÊî§Êî£Êî´Êî¥ÊîµÊî∑Êî∂Êî∏ÁïãÊïàÊïñÊïïÊïçÊïòÊïûÊïùÊï≤Êï∏ÊñÇÊñÉËÆäÊñõÊñüÊñ´Êñ∑ÊóÉÊóÜÊóÅÊóÑÊóåÊóíÊóõÊóôÊó†Êó°Êó±Êù≤ÊòäÊòÉÊóªÊù≥ÊòµÊò∂Êò¥ÊòúÊôèÊôÑÊôâÊôÅÊôûÊôùÊô§ÊôßÊô®ÊôüÊô¢Êô∞ÊöÉÊöàÊöéÊöâÊöÑÊöòÊöùÊõÅÊöπÊõâÊöæÊöº"],["dba1","ÊõÑÊö∏ÊõñÊõöÊõ†ÊòøÊõ¶Êõ©Êõ∞ÊõµÊõ∑ÊúèÊúñÊúûÊú¶ÊúßÈú∏ÊúÆÊúøÊú∂ÊùÅÊú∏Êú∑ÊùÜÊùûÊù†ÊùôÊù£Êù§ÊûâÊù∞Êû©ÊùºÊù™ÊûåÊûãÊû¶Êû°ÊûÖÊû∑ÊüØÊû¥Êü¨Êû≥Êü©Êû∏Êü§ÊüûÊüùÊü¢ÊüÆÊûπÊüéÊüÜÊüßÊ™úÊ†ûÊ°ÜÊ†©Ê°ÄÊ°çÊ†≤Ê°éÊ¢≥Ê†´Ê°ôÊ°£Ê°∑Ê°øÊ¢üÊ¢èÊ¢≠Ê¢îÊ¢ùÊ¢õÊ¢ÉÊ™ÆÊ¢πÊ°¥Ê¢µÊ¢†Ê¢∫Ê§èÊ¢çÊ°æÊ§ÅÊ£äÊ§àÊ£òÊ§¢Ê§¶Ê£°Ê§åÊ£ç"],["dca1","Ê£îÊ£ßÊ£ïÊ§∂Ê§íÊ§ÑÊ£óÊ££Ê§•Ê£πÊ£†Ê£ØÊ§®Ê§™Ê§öÊ§£Ê§°Ê£ÜÊ•πÊ•∑Ê•úÊ•∏Ê•´Ê•îÊ•æÊ•ÆÊ§πÊ•¥Ê§ΩÊ•ôÊ§∞Ê•°Ê•ûÊ•ùÊ¶ÅÊ•™Ê¶≤Ê¶ÆÊßêÊ¶øÊßÅÊßìÊ¶æÊßéÂØ®ÊßäÊßùÊ¶ªÊßÉÊ¶ßÊ®ÆÊ¶ëÊ¶†Ê¶úÊ¶ïÊ¶¥ÊßûÊß®Ê®ÇÊ®õÊßøÊ¨äÊßπÊß≤ÊßßÊ®ÖÊ¶±Ê®ûÊß≠Ê®îÊß´Ê®äÊ®íÊ´ÅÊ®£Ê®ìÊ©ÑÊ®åÊ©≤Ê®∂Ê©∏Ê©áÊ©¢Ê©ôÊ©¶Ê©àÊ®∏Ê®¢Ê™êÊ™çÊ™†Ê™ÑÊ™¢Ê™£"],["dda1","Ê™óËòóÊ™ªÊ´ÉÊ´ÇÊ™∏Ê™≥Ê™¨Ê´ûÊ´ëÊ´üÊ™™Ê´öÊ´™Ê´ªÊ¨ÖËòñÊ´∫Ê¨íÊ¨ñÈ¨±Ê¨üÊ¨∏Ê¨∑ÁõúÊ¨πÈ£ÆÊ≠áÊ≠ÉÊ≠âÊ≠êÊ≠ôÊ≠îÊ≠õÊ≠üÊ≠°Ê≠∏Ê≠πÊ≠øÊÆÄÊÆÑÊÆÉÊÆçÊÆòÊÆïÊÆûÊÆ§ÊÆ™ÊÆ´ÊÆØÊÆ≤ÊÆ±ÊÆ≥ÊÆ∑ÊÆºÊØÜÊØãÊØìÊØüÊØ¨ÊØ´ÊØ≥ÊØØÈ∫æÊ∞àÊ∞ìÊ∞îÊ∞õÊ∞§Ê∞£Ê±ûÊ±ïÊ±¢Ê±™Ê≤ÇÊ≤çÊ≤öÊ≤ÅÊ≤õÊ±æÊ±®Ê±≥Ê≤íÊ≤êÊ≥ÑÊ≥±Ê≥ìÊ≤ΩÊ≥óÊ≥ÖÊ≥ùÊ≤ÆÊ≤±Ê≤æ"],["dea1","Ê≤∫Ê≥õÊ≥ØÊ≥ôÊ≥™Ê¥üË°çÊ¥∂Ê¥´Ê¥ΩÊ¥∏Ê¥ôÊ¥µÊ¥≥Ê¥íÊ¥åÊµ£Ê∂ìÊµ§ÊµöÊµπÊµôÊ∂éÊ∂ïÊø§Ê∂ÖÊ∑πÊ∏ïÊ∏äÊ∂µÊ∑áÊ∑¶Ê∂∏Ê∑ÜÊ∑¨Ê∑ûÊ∑åÊ∑®Ê∑íÊ∑ÖÊ∑∫Ê∑ôÊ∑§Ê∑ïÊ∑™Ê∑ÆÊ∏≠ÊπÆÊ∏ÆÊ∏ôÊπ≤ÊπüÊ∏æÊ∏£Êπ´Ê∏´Êπ∂ÊπçÊ∏üÊπÉÊ∏∫ÊπéÊ∏§ÊªøÊ∏ùÊ∏∏Ê∫ÇÊ∫™Ê∫òÊªâÊ∫∑ÊªìÊ∫ΩÊ∫ØÊªÑÊ∫≤ÊªîÊªïÊ∫èÊ∫•ÊªÇÊ∫üÊΩÅÊºëÁÅåÊª¨Êª∏ÊªæÊºøÊª≤Êº±ÊªØÊº≤Êªå"],["dfa1","ÊºæÊºìÊª∑ÊæÜÊΩ∫ÊΩ∏ÊæÅÊæÄÊΩØÊΩõÊø≥ÊΩ≠ÊæÇÊΩºÊΩòÊæéÊæëÊøÇÊΩ¶Êæ≥Êæ£Êæ°Êæ§ÊæπÊøÜÊæ™ÊøüÊøïÊø¨ÊøîÊøòÊø±ÊøÆÊøõÁÄâÁÄãÊø∫ÁÄëÁÄÅÁÄèÊøæÁÄõÁÄöÊΩ¥ÁÄùÁÄòÁÄüÁÄ∞ÁÄæÁÄ≤ÁÅëÁÅ£ÁÇôÁÇíÁÇØÁÉ±ÁÇ¨ÁÇ∏ÁÇ≥ÁÇÆÁÉüÁÉãÁÉùÁÉôÁÑâÁÉΩÁÑúÁÑôÁÖ•ÁÖïÁÜàÁÖ¶ÁÖ¢ÁÖåÁÖñÁÖ¨ÁÜèÁáªÁÜÑÁÜïÁÜ®ÁÜ¨ÁáóÁÜπÁÜæÁáíÁáâÁáîÁáéÁá†Áá¨ÁáßÁáµÁáº"],["e0a1","ÁáπÁáøÁàçÁàêÁàõÁà®Áà≠Áà¨Áà∞Áà≤ÁàªÁàºÁàøÁâÄÁâÜÁâãÁâòÁâ¥ÁâæÁäÇÁäÅÁäáÁäíÁäñÁä¢ÁäßÁäπÁä≤ÁãÉÁãÜÁãÑÁãéÁãíÁã¢Áã†Áã°ÁãπÁã∑ÂÄèÁåóÁåäÁåúÁåñÁåùÁå¥ÁåØÁå©Áå•ÁåæÁçéÁçèÈªòÁçóÁç™Áç®Áç∞Áç∏ÁçµÁçªÁç∫ÁèàÁé≥ÁèéÁéªÁèÄÁè•ÁèÆÁèûÁí¢ÁêÖÁëØÁê•Áè∏Áê≤Áê∫ÁëïÁêøÁëüÁëôÁëÅÁëúÁë©Áë∞Áë£Áë™Áë∂ÁëæÁíãÁíûÁíßÁìäÁìèÁìîÁè±"],["e1a1","Áì†Áì£ÁìßÁì©ÁìÆÁì≤Áì∞Áì±Áì∏Áì∑ÁîÑÁîÉÁîÖÁîåÁîéÁîçÁîïÁîìÁîûÁî¶Áî¨ÁîºÁïÑÁïçÁïäÁïâÁïõÁïÜÁïöÁï©Áï§ÁïßÁï´Áï≠Áï∏Áï∂ÁñÜÁñáÁï¥ÁñäÁñâÁñÇÁñîÁñöÁñùÁñ•Áñ£ÁóÇÁñ≥ÁóÉÁñµÁñΩÁñ∏ÁñºÁñ±ÁóçÁóäÁóíÁóôÁó£ÁóûÁóæÁóøÁóºÁòÅÁó∞Áó∫Áó≤Áó≥ÁòãÁòçÁòâÁòüÁòßÁò†Áò°Áò¢Áò§Áò¥Áò∞ÁòªÁôáÁôàÁôÜÁôúÁôòÁô°Áô¢Áô®Áô©Áô™ÁôßÁô¨Áô∞"],["e2a1","Áô≤Áô∂Áô∏ÁôºÁöÄÁöÉÁöàÁöãÁöéÁöñÁöìÁöôÁööÁö∞Áö¥Áö∏ÁöπÁö∫ÁõÇÁõçÁõñÁõíÁõûÁõ°Áõ•ÁõßÁõ™ËòØÁõªÁúàÁúáÁúÑÁú©Áú§ÁúûÁú•Áú¶ÁúõÁú∑Áú∏ÁùáÁùöÁù®Áù´ÁùõÁù•ÁùøÁùæÁùπÁûéÁûãÁûëÁû†ÁûûÁû∞Áû∂ÁûπÁûøÁûºÁûΩÁûªÁüáÁüçÁüóÁüöÁüúÁü£ÁüÆÁüºÁ†åÁ†íÁ§¶Á††Á§™Á°ÖÁ¢éÁ°¥Á¢ÜÁ°ºÁ¢öÁ¢åÁ¢£Á¢µÁ¢™Á¢ØÁ£ëÁ£ÜÁ£ãÁ£îÁ¢æÁ¢ºÁ£ÖÁ£äÁ£¨"],["e3a1","Á£ßÁ£öÁ£ΩÁ£¥Á§áÁ§íÁ§ëÁ§ôÁ§¨Á§´Á•ÄÁ•†Á•óÁ•üÁ•öÁ•ïÁ•ìÁ•∫Á•øÁ¶äÁ¶ùÁ¶ßÈΩãÁ¶™Á¶ÆÁ¶≥Á¶πÁ¶∫ÁßâÁßïÁßßÁß¨Áß°Áß£Á®àÁ®çÁ®òÁ®ôÁ®†Á®üÁ¶ÄÁ®±Á®ªÁ®æÁ®∑Á©ÉÁ©óÁ©âÁ©°Á©¢Á©©ÈæùÁ©∞Á©πÁ©ΩÁ™àÁ™óÁ™ïÁ™òÁ™ñÁ™©Á´àÁ™∞Á™∂Á´ÖÁ´ÑÁ™øÈÇÉÁ´áÁ´äÁ´çÁ´èÁ´ïÁ´ìÁ´ôÁ´öÁ´ùÁ´°Á´¢Á´¶Á´≠Á´∞Á¨ÇÁ¨èÁ¨äÁ¨ÜÁ¨≥Á¨òÁ¨ôÁ¨ûÁ¨µÁ¨®Á¨∂Á≠ê"],["e4a1","Á≠∫Á¨ÑÁ≠çÁ¨ãÁ≠åÁ≠ÖÁ≠µÁ≠•Á≠¥Á≠ßÁ≠∞Á≠±Á≠¨Á≠ÆÁÆùÁÆòÁÆüÁÆçÁÆúÁÆöÁÆãÁÆíÁÆèÁ≠ùÁÆôÁØãÁØÅÁØåÁØèÁÆ¥ÁØÜÁØùÁØ©Á∞ëÁ∞îÁØ¶ÁØ•Á±†Á∞ÄÁ∞áÁ∞ìÁØ≥ÁØ∑Á∞óÁ∞çÁØ∂Á∞£Á∞ßÁ∞™Á∞üÁ∞∑Á∞´Á∞ΩÁ±åÁ±ÉÁ±îÁ±èÁ±ÄÁ±êÁ±òÁ±üÁ±§Á±ñÁ±•Á±¨Á±µÁ≤ÉÁ≤êÁ≤§Á≤≠Á≤¢Á≤´Á≤°Á≤®Á≤≥Á≤≤Á≤±Á≤ÆÁ≤πÁ≤ΩÁ≥ÄÁ≥ÖÁ≥ÇÁ≥òÁ≥íÁ≥úÁ≥¢È¨ªÁ≥ØÁ≥≤Á≥¥Á≥∂Á≥∫Á¥Ü"],["e5a1","Á¥ÇÁ¥úÁ¥ïÁ¥äÁµÖÁµãÁ¥ÆÁ¥≤Á¥øÁ¥µÁµÜÁµ≥ÁµñÁµéÁµ≤Áµ®ÁµÆÁµèÁµ£Á∂ìÁ∂âÁµõÁ∂èÁµΩÁ∂õÁ∂∫Á∂ÆÁ∂£Á∂µÁ∑áÁ∂ΩÁ∂´Á∏ΩÁ∂¢Á∂ØÁ∑úÁ∂∏Á∂üÁ∂∞Á∑òÁ∑ùÁ∑§Á∑ûÁ∑ªÁ∑≤Á∑°Á∏ÖÁ∏äÁ∏£Á∏°Á∏íÁ∏±Á∏üÁ∏âÁ∏ãÁ∏¢ÁπÜÁπ¶Á∏ªÁ∏µÁ∏πÁπÉÁ∏∑Á∏≤Á∏∫ÁπßÁπùÁπñÁπûÁπôÁπöÁππÁπ™Áπ©ÁπºÁπªÁ∫ÉÁ∑ïÁπΩËæÆÁπøÁ∫àÁ∫âÁ∫åÁ∫íÁ∫êÁ∫ìÁ∫îÁ∫ñÁ∫éÁ∫õÁ∫úÁº∏Áº∫"],["e6a1","ÁΩÖÁΩåÁΩçÁΩéÁΩêÁΩëÁΩïÁΩîÁΩòÁΩüÁΩ†ÁΩ®ÁΩ©ÁΩßÁΩ∏ÁæÇÁæÜÁæÉÁæàÁæáÁæåÁæîÁæûÁæùÁæöÁæ£ÁæØÁæ≤ÁæπÁæÆÁæ∂Áæ∏Ë≠±ÁøÖÁøÜÁøäÁøïÁøîÁø°Áø¶Áø©Áø≥ÁøπÈ£úËÄÜËÄÑËÄãËÄíËÄòËÄôËÄúËÄ°ËÄ®ËÄøËÄªËÅäËÅÜËÅíËÅòËÅöËÅüËÅ¢ËÅ®ËÅ≥ËÅ≤ËÅ∞ËÅ∂ËÅπËÅΩËÅøËÇÑËÇÜËÇÖËÇõËÇìËÇöËÇ≠ÂÜêËÇ¨ËÉõËÉ•ËÉôËÉùËÉÑËÉöËÉñËÑâËÉØËÉ±ËÑõËÑ©ËÑ£ËÑØËÖã"],["e7a1","ÈöãËÖÜËÑæËÖìËÖëËÉºËÖ±ËÖÆËÖ•ËÖ¶ËÖ¥ËÜÉËÜàËÜäËÜÄËÜÇËÜ†ËÜïËÜ§ËÜ£ËÖüËÜìËÜ©ËÜ∞ËÜµËÜæËÜ∏ËÜΩËáÄËáÇËÜ∫ËáâËáçËáëËáôËáòËáàËáöËáüËá†ËáßËá∫ËáªËáæËàÅËàÇËàÖËàáËàäËàçËàêËàñËà©Ëà´Ëà∏Ëà≥ËâÄËâôËâòËâùËâöËâüËâ§Ëâ¢Ëâ®Ëâ™Ëâ´ËàÆËâ±Ëâ∑Ëâ∏ËâæËäçËäíËä´ËäüËäªËä¨Ëã°Ëã£ËãüËãíËã¥Ëã≥Ëã∫ËéìËåÉËãªËãπËãûËåÜËãúËåâËãô"],["e8a1","ËåµËå¥ËåñËå≤Ëå±ËçÄËåπËçêËçÖËåØËå´ËåóËåòËéÖËéöËé™ËéüËé¢ËéñËå£ËééËéáËéäËçºËéµËç≥ËçµËé†ËéâËé®Ëè¥ËêìËè´ËèéËèΩËêÉËèòËêãËèÅËè∑ËêáËè†Ëè≤ËêçËê¢Ëê†ËéΩËê∏ËîÜËèªËë≠Ëê™ËêºËïöËíÑËë∑Ëë´Ëí≠ËëÆËíÇËë©ËëÜËê¨ËëØËëπËêµËìäËë¢ËíπËíøËíüËìôËìçËíªËìöËìêËìÅËìÜËìñËí°Ëî°ËìøËì¥ËîóËîòËî¨ËîüËîïËîîËìºËïÄËï£ËïòËïà"],["e9a1","ËïÅËòÇËïãËïïËñÄËñ§ËñàËñëËñäËñ®Ëï≠ËñîËñõËó™ËñáËñúËï∑ËïæËñêËóâËñ∫ËóèËñπËóêËóïËóùËó•ËóúËóπËòäËòìËòãËóæËó∫ËòÜËò¢ËòöËò∞ËòøËôç‰πïËôîËôüËôßËô±ËöìËö£Ëö©Ëö™ËöãËöåËö∂ËöØËõÑËõÜËö∞ËõâË†£Ëö´ËõîËõûËõ©Ëõ¨ËõüËõõËõØËúíËúÜËúàËúÄËúÉËõªËúëËúâËúçËõπËúäËú¥ËúøËú∑ËúªËú•Ëú©ËúöËù†ËùüËù∏ËùåËùéËù¥ËùóËù®ËùÆËùô"],["eaa1","ËùìËù£Ëù™Ë†ÖËû¢ËûüËûÇËûØËüãËûΩËüÄËüêÈõñËû´ËüÑËû≥ËüáËüÜËûªËüØËü≤Ëü†Ë†èË†çËüæËü∂Ëü∑Ë†éËüíË†ëË†ñË†ïË†¢Ë†°Ë†±Ë†∂Ë†πË†ßË†ªË°ÑË°ÇË°íË°ôË°ûË°¢Ë°´Ë¢ÅË°æË¢ûË°µË°ΩË¢µË°≤Ë¢ÇË¢óË¢íË¢ÆË¢ôË¢¢Ë¢çË¢§Ë¢∞Ë¢øË¢±Ë£ÉË£ÑË£îË£òË£ôË£ùË£πË§ÇË£ºË£¥Ë£®Ë£≤Ë§ÑË§åË§äË§ìË•ÉË§ûË§•Ë§™Ë§´Ë•ÅË•ÑË§ªË§∂Ë§∏Ë•åË§ùË•†Ë•û"],["eba1","Ë•¶Ë•§Ë•≠Ë•™Ë•ØË•¥Ë•∑Ë•æË¶ÉË¶àË¶äË¶ìË¶òË¶°Ë¶©Ë¶¶Ë¶¨Ë¶ØË¶≤Ë¶∫Ë¶ΩË¶øËßÄËßöËßúËßùËßßËß¥Ëß∏Ë®ÉË®ñË®êË®åË®õË®ùË®•Ë®∂Ë©ÅË©õË©íË©ÜË©àË©ºË©≠Ë©¨Ë©¢Ë™ÖË™ÇË™ÑË™®Ë™°Ë™ëË™•Ë™¶Ë™öË™£Ë´ÑË´çË´ÇË´öË´´Ë´≥Ë´ßË´§Ë´±Ë¨îË´†Ë´¢Ë´∑Ë´ûË´õË¨åË¨áË¨öË´°Ë¨ñË¨êË¨óË¨†Ë¨≥Èû´Ë¨¶Ë¨´Ë¨æË¨®Ë≠ÅË≠åË≠èË≠éË≠âË≠ñË≠õË≠öË≠´"],["eca1","Ë≠üË≠¨Ë≠ØË≠¥Ë≠ΩËÆÄËÆåËÆéËÆíËÆìËÆñËÆôËÆöË∞∫Ë±ÅË∞øË±àË±åË±éË±êË±ïË±¢Ë±¨Ë±∏Ë±∫Ë≤ÇË≤âË≤ÖË≤äË≤çË≤éË≤îË±ºË≤òÊàùË≤≠Ë≤™Ë≤ΩË≤≤Ë≤≥Ë≤ÆË≤∂Ë≥àË≥ÅË≥§Ë≥£Ë≥öË≥ΩË≥∫Ë≥ªË¥ÑË¥ÖË¥äË¥áË¥èË¥çË¥êÈΩéË¥ìË≥çË¥îË¥ñËµßËµ≠Ëµ±Ëµ≥Ë∂ÅË∂ôË∑ÇË∂æË∂∫Ë∑èË∑öË∑ñË∑åË∑õË∑ãË∑™Ë∑´Ë∑üË∑£Ë∑ºË∏àË∏âË∑øË∏ùË∏ûË∏êË∏üËπÇË∏µË∏∞Ë∏¥Ëπä"],["eda1","ËπáËπâËπåËπêËπàËπôËπ§Ëπ†Ë∏™Ëπ£ËπïËπ∂Ëπ≤ËπºË∫ÅË∫áË∫ÖË∫ÑË∫ãË∫äË∫ìË∫ëË∫îË∫ôË∫™Ë∫°Ë∫¨Ë∫∞ËªÜË∫±Ë∫æËªÖËªàËªãËªõËª£ËªºËªªËª´ËªæËºäËºÖËºïËºíËºôËºìËºúËºüËºõËºåËº¶Ëº≥ËºªËºπËΩÖËΩÇËºæËΩåËΩâËΩÜËΩéËΩóËΩúËΩ¢ËΩ£ËΩ§ËæúËæüËæ£Ëæ≠ËæØËæ∑ËøöËø•Ëø¢Ëø™ËøØÈÇáËø¥ÈÄÖËøπËø∫ÈÄëÈÄïÈÄ°ÈÄçÈÄûÈÄñÈÄãÈÄßÈÄ∂ÈÄµÈÄπËø∏"],["eea1","ÈÅèÈÅêÈÅëÈÅíÈÄéÈÅâÈÄæÈÅñÈÅòÈÅûÈÅ®ÈÅØÈÅ∂Èö®ÈÅ≤ÈÇÇÈÅΩÈÇÅÈÇÄÈÇäÈÇâÈÇèÈÇ®ÈÇØÈÇ±ÈÇµÈÉ¢ÈÉ§ÊâàÈÉõÈÑÇÈÑíÈÑôÈÑ≤ÈÑ∞ÈÖäÈÖñÈÖòÈÖ£ÈÖ•ÈÖ©ÈÖ≥ÈÖ≤ÈÜãÈÜâÈÜÇÈÜ¢ÈÜ´ÈÜØÈÜ™ÈÜµÈÜ¥ÈÜ∫ÈáÄÈáÅÈáâÈáãÈáêÈáñÈáüÈá°ÈáõÈáºÈáµÈá∂ÈàûÈáøÈàîÈà¨ÈàïÈàëÈâûÈâóÈâÖÈââÈâ§ÈâàÈäïÈàøÈâãÈâêÈäúÈäñÈäìÈäõÈâöÈãèÈäπÈä∑Èã©ÈåèÈã∫ÈçÑÈåÆ"],["efa1","ÈåôÈå¢ÈåöÈå£Èå∫ÈåµÈåªÈçúÈç†ÈçºÈçÆÈçñÈé∞Èé¨Èé≠ÈéîÈéπÈèñÈèóÈè®Èè•ÈèòÈèÉÈèùÈèêÈèàÈè§ÈêöÈêîÈêìÈêÉÈêáÈêêÈê∂Èê´ÈêµÈê°Èê∫ÈëÅÈëíÈëÑÈëõÈë†Èë¢ÈëûÈë™Èà©Èë∞ÈëµÈë∑ÈëΩÈëöÈëºÈëæÈíÅÈëøÈñÇÈñáÈñäÈñîÈññÈñòÈñôÈñ†Èñ®ÈñßÈñ≠ÈñºÈñªÈñπÈñæÈóäÊø∂ÈóÉÈóçÈóåÈóïÈóîÈóñÈóúÈó°Èó•Èó¢Èò°Èò®ÈòÆÈòØÈôÇÈôåÈôèÈôãÈô∑ÈôúÈôû"],["f0a1","ÈôùÈôüÈô¶Èô≤Èô¨ÈöçÈöòÈöïÈöóÈö™ÈößÈö±Èö≤Èö∞Èö¥Èö∂Èö∏ÈöπÈõéÈõãÈõâÈõçË•çÈõúÈúçÈõïÈõπÈúÑÈúÜÈúàÈúìÈúéÈúëÈúèÈúñÈúôÈú§Èú™Èú∞ÈúπÈúΩÈúæÈùÑÈùÜÈùàÈùÇÈùâÈùúÈù†Èù§Èù¶Èù®ÂãíÈù´Èù±ÈùπÈûÖÈùºÈûÅÈù∫ÈûÜÈûãÈûèÈûêÈûúÈû®Èû¶Èû£Èû≥Èû¥ÈüÉÈüÜÈüàÈüãÈüúÈü≠ÈΩèÈü≤Á´üÈü∂ÈüµÈ†èÈ†åÈ†∏È†§È†°È†∑È†ΩÈ°ÜÈ°èÈ°ãÈ°´È°ØÈ°∞"],["f1a1","È°±È°¥È°≥È¢™È¢ØÈ¢±È¢∂È£ÑÈ£ÉÈ£ÜÈ£©È£´È§ÉÈ§âÈ§íÈ§îÈ§òÈ§°È§ùÈ§ûÈ§§È§†È§¨È§ÆÈ§ΩÈ§æÈ•ÇÈ•âÈ•ÖÈ•êÈ•ãÈ•ëÈ•íÈ•åÈ•ïÈ¶óÈ¶òÈ¶•È¶≠È¶ÆÈ¶ºÈßüÈßõÈßùÈßòÈßëÈß≠ÈßÆÈß±Èß≤ÈßªÈß∏È®ÅÈ®èÈ®ÖÈß¢È®ôÈ®´È®∑È©ÖÈ©ÇÈ©ÄÈ©ÉÈ®æÈ©ïÈ©çÈ©õÈ©óÈ©üÈ©¢È©•È©§È©©È©´È©™È™≠È™∞È™ºÈ´ÄÈ´èÈ´ëÈ´ìÈ´îÈ´ûÈ´üÈ´¢È´£È´¶È´ØÈ´´È´ÆÈ´¥È´±È´∑"],["f2a1","È´ªÈ¨ÜÈ¨òÈ¨öÈ¨üÈ¨¢È¨£È¨•È¨ßÈ¨®È¨©È¨™È¨ÆÈ¨ØÈ¨≤È≠ÑÈ≠ÉÈ≠èÈ≠çÈ≠éÈ≠ëÈ≠òÈ≠¥ÈÆìÈÆÉÈÆëÈÆñÈÆóÈÆüÈÆ†ÈÆ®ÈÆ¥ÈØÄÈØäÈÆπÈØÜÈØèÈØëÈØíÈØ£ÈØ¢ÈØ§ÈØîÈØ°È∞∫ÈØ≤ÈØ±ÈØ∞È∞ïÈ∞îÈ∞âÈ∞ìÈ∞åÈ∞ÜÈ∞àÈ∞íÈ∞äÈ∞ÑÈ∞ÆÈ∞õÈ∞•È∞§È∞°È∞∞È±áÈ∞≤È±ÜÈ∞æÈ±öÈ±†È±ßÈ±∂È±∏È≥ßÈ≥¨È≥∞È¥âÈ¥àÈ≥´È¥ÉÈ¥ÜÈ¥™È¥¶È∂ØÈ¥£È¥üÈµÑÈ¥ïÈ¥íÈµÅÈ¥øÈ¥æÈµÜÈµà"],["f3a1","ÈµùÈµûÈµ§ÈµëÈµêÈµôÈµ≤È∂âÈ∂áÈ∂´ÈµØÈµ∫È∂öÈ∂§È∂©È∂≤È∑ÑÈ∑ÅÈ∂ªÈ∂∏È∂∫È∑ÜÈ∑èÈ∑ÇÈ∑ôÈ∑ìÈ∑∏È∑¶È∑≠È∑ØÈ∑ΩÈ∏öÈ∏õÈ∏ûÈπµÈππÈπΩÈ∫ÅÈ∫àÈ∫ãÈ∫åÈ∫íÈ∫ïÈ∫ëÈ∫ùÈ∫•È∫©È∫∏È∫™È∫≠Èù°ÈªåÈªéÈªèÈªêÈªîÈªúÈªûÈªùÈª†Èª•Èª®ÈªØÈª¥Èª∂Èª∑ÈªπÈªªÈªºÈªΩÈºáÈºàÁö∑ÈºïÈº°Èº¨ÈºæÈΩäÈΩíÈΩîÈΩ£ÈΩüÈΩ†ÈΩ°ÈΩ¶ÈΩßÈΩ¨ÈΩ™ÈΩ∑ÈΩ≤ÈΩ∂ÈæïÈæúÈæ†"],["f4a1","Â†ØÊßáÈÅôÁë§ÂáúÁÜô"],["f9a1","Á∫äË§úÈçàÈäàËìú‰øâÁÇªÊò±Ê£àÈãπÊõªÂΩÖ‰∏®‰ª°‰ªº‰ºÄ‰ºÉ‰ºπ‰Ωñ‰æí‰æä‰æö‰æî‰øçÂÅÄÂÄ¢‰øøÂÄûÂÅÜÂÅ∞ÂÅÇÂÇîÂÉ¥ÂÉòÂÖäÂÖ§ÂÜùÂÜæÂá¨ÂàïÂäúÂä¶ÂãÄÂãõÂåÄÂåáÂå§Âç≤ÂéìÂé≤ÂèùÔ®éÂíúÂíäÂí©ÂìøÂñÜÂùôÂù•Âû¨ÂüàÂüáÔ®èÔ®êÂ¢ûÂ¢≤Â§ãÂ•ìÂ•õÂ•ùÂ•£Â¶§Â¶∫Â≠ñÂØÄÁîØÂØòÂØ¨Â∞ûÂ≤¶Â≤∫Â≥µÂ¥ßÂµìÔ®ëÂµÇÂµ≠Â∂∏Â∂πÂ∑êÂº°Âº¥ÂΩßÂæ∑"],["faa1","ÂøûÊÅùÊÇÖÊÇäÊÉûÊÉïÊÑ†ÊÉ≤ÊÑëÊÑ∑ÊÑ∞ÊÜòÊàìÊä¶ÊèµÊë†ÊíùÊìéÊïéÊòÄÊòïÊòªÊòâÊòÆÊòûÊò§Êô•ÊôóÊôôÔ®íÊô≥ÊöôÊö†Êö≤ÊöøÊõ∫ÊúéÔ§©Êù¶ÊûªÊ°íÊüÄÊ†ÅÊ°ÑÊ£èÔ®ìÊ•®Ô®îÊ¶òÊß¢Ê®∞Ê©´Ê©ÜÊ©≥Ê©æÊ´¢Ê´§ÊØñÊ∞øÊ±úÊ≤ÜÊ±ØÊ≥öÊ¥ÑÊ∂áÊµØÊ∂ñÊ∂¨Ê∑èÊ∑∏Ê∑≤Ê∑ºÊ∏πÊπúÊ∏ßÊ∏ºÊ∫øÊæàÊæµÊøµÁÄÖÁÄáÁÄ®ÁÇÖÁÇ´ÁÑèÁÑÑÁÖúÁÖÜÁÖáÔ®ïÁáÅÁáæÁä±"],["fba1","ÁäæÁå§Ô®ñÁç∑ÁéΩÁèâÁèñÁè£ÁèíÁêáÁèµÁê¶Áê™Áê©ÁêÆÁë¢ÁíâÁíüÁîÅÁïØÁöÇÁöúÁöûÁöõÁö¶Ô®óÁùÜÂäØÁ†°Á°éÁ°§Á°∫Á§∞Ô®òÔ®ôÔ®öÁ¶îÔ®õÁ¶õÁ´ëÁ´ßÔ®úÁ´´ÁÆûÔ®ùÁµàÁµúÁ∂∑Á∂†Á∑ñÁπíÁΩáÁæ°Ô®ûËåÅËç¢ËçøËèáËè∂ËëàËí¥ËïìËïôËï´Ô®üËñ∞Ô®†Ô®°Ë†áË£µË®íË®∑Ë©πË™ßË™æË´üÔ®¢Ë´∂Ë≠ìË≠øË≥∞Ë≥¥Ë¥íËµ∂Ô®£ËªèÔ®§Ô®•ÈÅßÈÉûÔ®¶ÈÑïÈÑßÈáö"],["fca1","ÈáóÈáûÈá≠ÈáÆÈá§Èá•ÈàÜÈàêÈàäÈà∫ÈâÄÈàºÈâéÈâôÈâëÈàπÈâßÈäßÈâ∑Èâ∏ÈãßÈãóÈãôÈãêÔ®ßÈãïÈã†ÈãìÈå•Èå°ÈãªÔ®®ÈåûÈãøÈåùÈåÇÈç∞ÈçóÈé§ÈèÜÈèûÈè∏Èê±ÈëÖÈëàÈñíÔßúÔ®©ÈöùÈöØÈú≥ÈúªÈùÉÈùçÈùèÈùëÈùïÈ°óÈ°•Ô®™Ô®´È§ßÔ®¨È¶ûÈ©éÈ´ôÈ´úÈ≠µÈ≠≤ÈÆèÈÆ±ÈÆªÈ∞ÄÈµ∞Èµ´Ô®≠È∏ôÈªë"],["fcf1","‚Ö∞",9,"Ôø¢Ôø§ÔºáÔºÇ"],["8fa2af","ÀòÀá¬∏ÀôÀù¬ØÀõÀöÔΩûŒÑŒÖ"],["8fa2c2","¬°¬¶¬ø"],["8fa2eb","¬∫¬™¬©¬Æ‚Ñ¢¬§‚Ññ"],["8fa6e1","ŒÜŒàŒâŒäŒ™"],["8fa6e7","Œå"],["8fa6e9","ŒéŒ´"],["8fa6ec","Œè"],["8fa6f1","Œ¨Œ≠ŒÆŒØœäŒêœåœÇœçœãŒ∞œé"],["8fa7c2","–Ç",10,"–é–è"],["8fa7f2","—í",10,"—û—ü"],["8fa9a1","√Üƒê"],["8fa9a4","ƒ¶"],["8fa9a6","ƒ≤"],["8fa9a8","≈Åƒø"],["8fa9ab","≈ä√ò≈í"],["8fa9af","≈¶√û"],["8fa9c1","√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ç≈Ä≈â≈ã√∏≈ì√ü≈ß√æ"],["8faaa1","√Å√Ä√Ñ√ÇƒÇ«çƒÄƒÑ√Ö√ÉƒÜƒàƒå√áƒäƒé√â√à√ã√äƒöƒñƒíƒò"],["8faaba","ƒúƒûƒ¢ƒ†ƒ§√ç√å√è√é«èƒ∞ƒ™ƒÆƒ®ƒ¥ƒ∂ƒπƒΩƒª≈É≈á≈Ö√ë√ì√í√ñ√î«ë≈ê≈å√ï≈î≈ò≈ñ≈ö≈ú≈†≈û≈§≈¢√ö√ô√ú√õ≈¨«ì≈∞≈™≈≤≈Æ≈®«ó«õ«ô«ï≈¥√ù≈∏≈∂≈π≈Ω≈ª"],["8faba1","√°√†√§√¢ƒÉ«éƒÅƒÖ√•√£ƒáƒâƒç√ßƒãƒè√©√®√´√™ƒõƒóƒìƒô«µƒùƒü"],["8fabbd","ƒ°ƒ•√≠√¨√Ø√Æ«ê"],["8fabc5","ƒ´ƒØƒ©ƒµƒ∑ƒ∫ƒæƒº≈Ñ≈à≈Ü√±√≥√≤√∂√¥«í≈ë≈ç√µ≈ï≈ô≈ó≈õ≈ù≈°≈ü≈•≈£√∫√π√º√ª≈≠«î≈±≈´≈≥≈Ø≈©«ò«ú«ö«ñ≈µ√Ω√ø≈∑≈∫≈æ≈º"],["8fb0a1","‰∏Ç‰∏Ñ‰∏Ö‰∏å‰∏í‰∏ü‰∏£‰∏§‰∏®‰∏´‰∏Æ‰∏Ø‰∏∞‰∏µ‰πÄ‰πÅ‰πÑ‰πá‰πë‰πö‰πú‰π£‰π®‰π©‰π¥‰πµ‰ππ‰πø‰∫ç‰∫ñ‰∫ó‰∫ù‰∫Ø‰∫π‰ªÉ‰ªê‰ªö‰ªõ‰ª†‰ª°‰ª¢‰ª®‰ªØ‰ª±‰ª≥‰ªµ‰ªΩ‰ªæ‰ªø‰ºÄ‰ºÇ‰ºÉ‰ºà‰ºã‰ºå‰ºí‰ºï‰ºñ‰ºó‰ºô‰ºÆ‰º±‰Ω†‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ‰ΩÄ‰ΩÇ‰Ωà‰Ωâ‰Ωã‰Ωå‰Ωí‰Ωî‰Ωñ‰Ωò‰Ωü‰Ω£‰Ω™‰Ω¨‰ΩÆ‰Ω±‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰Ωæ‰æÅ‰æÇ‰æÑ"],["8fb1a1","‰æÖ‰æâ‰æä‰æå‰æé‰æê‰æí‰æì‰æî‰æó‰æô‰æö‰æû‰æü‰æ≤‰æ∑‰æπ‰æª‰æº‰æΩ‰ææ‰øÄ‰øÅ‰øÖ‰øÜ‰øà‰øâ‰øã‰øå‰øç‰øè‰øí‰øú‰ø†‰ø¢‰ø∞‰ø≤‰øº‰øΩ‰øøÂÄÄÂÄÅÂÄÑÂÄáÂÄäÂÄåÂÄéÂÄêÂÄìÂÄóÂÄòÂÄõÂÄúÂÄùÂÄûÂÄ¢ÂÄßÂÄÆÂÄ∞ÂÄ≤ÂÄ≥ÂÄµÂÅÄÂÅÅÂÅÇÂÅÖÂÅÜÂÅäÂÅåÂÅéÂÅëÂÅíÂÅìÂÅóÂÅôÂÅüÂÅ†ÂÅ¢ÂÅ£ÂÅ¶ÂÅßÂÅ™ÂÅ≠ÂÅ∞ÂÅ±ÂÄªÂÇÅÂÇÉÂÇÑÂÇÜÂÇäÂÇéÂÇèÂÇê"],["8fb2a1","ÂÇíÂÇìÂÇîÂÇñÂÇõÂÇúÂÇû",4,"ÂÇ™ÂÇØÂÇ∞ÂÇπÂÇ∫ÂÇΩÂÉÄÂÉÉÂÉÑÂÉáÂÉåÂÉéÂÉêÂÉìÂÉîÂÉòÂÉúÂÉùÂÉüÂÉ¢ÂÉ§ÂÉ¶ÂÉ®ÂÉ©ÂÉØÂÉ±ÂÉ∂ÂÉ∫ÂÉæÂÑÉÂÑÜÂÑáÂÑàÂÑãÂÑåÂÑçÂÑéÂÉ≤ÂÑêÂÑóÂÑôÂÑõÂÑúÂÑùÂÑûÂÑ£ÂÑßÂÑ®ÂÑ¨ÂÑ≠ÂÑØÂÑ±ÂÑ≥ÂÑ¥ÂÑµÂÑ∏ÂÑπÂÖÇÂÖäÂÖèÂÖìÂÖïÂÖóÂÖòÂÖüÂÖ§ÂÖ¶ÂÖæÂÜÉÂÜÑÂÜãÂÜéÂÜòÂÜùÂÜ°ÂÜ£ÂÜ≠ÂÜ∏ÂÜ∫ÂÜºÂÜæÂÜøÂáÇ"],["8fb3a1","ÂáàÂáèÂáëÂáíÂáìÂáïÂáòÂáûÂá¢Âá•ÂáÆÂá≤Âá≥Âá¥Âá∑ÂàÅÂàÇÂàÖÂàíÂàìÂàïÂàñÂàòÂà¢Âà®Âà±Âà≤ÂàµÂàºÂâÖÂââÂâïÂâóÂâòÂâöÂâúÂâüÂâ†Ââ°Ââ¶ÂâÆÂâ∑Ââ∏ÂâπÂäÄÂäÇÂäÖÂääÂäåÂäìÂäïÂäñÂäóÂäòÂäöÂäúÂä§Âä•Âä¶ÂäßÂäØÂä∞Âä∂Âä∑Âä∏Âä∫ÂäªÂäΩÂãÄÂãÑÂãÜÂãàÂãåÂãèÂãëÂãîÂãñÂãõÂãúÂã°Âã•Âã®Âã©Âã™Âã¨Âã∞Âã±Âã¥Âã∂Âã∑ÂåÄÂåÉÂåäÂåã"],["8fb4a1","ÂååÂåëÂåìÂåòÂåõÂåúÂåûÂåüÂå•ÂåßÂå®Âå©Âå´Âå¨Âå≠Âå∞Âå≤ÂåµÂåºÂåΩÂåæÂçÇÂçåÂçãÂçôÂçõÂç°Âç£Âç•Âç¨Âç≠Âç≤ÂçπÂçæÂéÉÂéáÂéàÂééÂéìÂéîÂéôÂéùÂé°Âé§Âé™Âé´ÂéØÂé≤Âé¥ÂéµÂé∑Âé∏Âé∫ÂéΩÂèÄÂèÖÂèèÂèíÂèìÂèïÂèöÂèùÂèûÂè†Âè¶ÂèßÂèµÂêÇÂêìÂêöÂê°ÂêßÂê®Âê™ÂêØÂê±Âê¥ÂêµÂëÉÂëÑÂëáÂëçÂëèÂëûÂë¢Âë§Âë¶ÂëßÂë©Âë´Âë≠ÂëÆÂë¥Âëø"],["8fb5a1","ÂíÅÂíÉÂíÖÂíàÂíâÂíçÂíëÂíïÂíñÂíúÂíüÂí°Âí¶ÂíßÂí©Âí™Âí≠ÂíÆÂí±Âí∑ÂíπÂí∫ÂíªÂíøÂìÜÂìäÂìçÂìéÂì†Âì™Âì¨ÂìØÂì∂ÂìºÂìæÂìøÂîÄÂîÅÂîÖÂîàÂîâÂîåÂîçÂîéÂîïÂî™Âî´Âî≤ÂîµÂî∂ÂîªÂîºÂîΩÂïÅÂïáÂïâÂïäÂïçÂïêÂïëÂïòÂïöÂïõÂïûÂï†Âï°Âï§Âï¶ÂïøÂñÅÂñÇÂñÜÂñàÂñéÂñèÂñëÂñíÂñìÂñîÂñóÂñ£Âñ§Âñ≠Âñ≤ÂñøÂóÅÂóÉÂóÜÂóâÂóãÂóåÂóéÂóëÂóí"],["8fb6a1","ÂóìÂóóÂóòÂóõÂóûÂó¢Âó©Âó∂ÂóøÂòÖÂòàÂòäÂòç",5,"ÂòôÂò¨Âò∞Âò≥ÂòµÂò∑ÂòπÂòªÂòºÂòΩÂòøÂôÄÂôÅÂôÉÂôÑÂôÜÂôâÂôãÂôçÂôèÂôîÂôûÂô†Âô°Âô¢Âô£Âô¶Âô©Âô≠ÂôØÂô±Âô≤ÂôµÂöÑÂöÖÂöàÂöãÂöåÂöïÂöôÂööÂöùÂöûÂöüÂö¶ÂößÂö®Âö©Âö´Âö¨Âö≠Âö±Âö≥Âö∑ÂöæÂõÖÂõâÂõäÂõãÂõèÂõêÂõåÂõçÂõôÂõúÂõùÂõüÂõ°Âõ§",4,"Âõ±Âõ´Âõ≠"],["8fb7a1","Âõ∂Âõ∑ÂúÅÂúÇÂúáÂúäÂúåÂúëÂúïÂúöÂúõÂúùÂú†Âú¢Âú£Âú§Âú•Âú©Âú™Âú¨ÂúÆÂúØÂú≥Âú¥ÂúΩÂúæÂúøÂùÖÂùÜÂùåÂùçÂùíÂù¢Âù•ÂùßÂù®Âù´Âù≠",4,"Âù≥Âù¥ÂùµÂù∑ÂùπÂù∫ÂùªÂùºÂùæÂûÅÂûÉÂûåÂûîÂûóÂûôÂûöÂûúÂûùÂûûÂûüÂû°ÂûïÂûßÂû®Âû©Âû¨Âû∏ÂûΩÂüáÂüàÂüåÂüèÂüïÂüùÂüûÂü§Âü¶ÂüßÂü©Âü≠Âü∞ÂüµÂü∂Âü∏ÂüΩÂüæÂüøÂ†ÉÂ†ÑÂ†àÂ†âÂü°"],["8fb8a1","Â†åÂ†çÂ†õÂ†ûÂ†üÂ††Â†¶Â†ßÂ†≠Â†≤Â†πÂ†øÂ°âÂ°åÂ°çÂ°èÂ°êÂ°ïÂ°üÂ°°Â°§Â°ßÂ°®Â°∏Â°ºÂ°øÂ¢ÄÂ¢ÅÂ¢áÂ¢àÂ¢âÂ¢äÂ¢åÂ¢çÂ¢èÂ¢êÂ¢îÂ¢ñÂ¢ùÂ¢†Â¢°Â¢¢Â¢¶Â¢©Â¢±Â¢≤Â£ÑÂ¢ºÂ£ÇÂ£àÂ£çÂ£éÂ£êÂ£íÂ£îÂ£ñÂ£öÂ£ùÂ£°Â£¢Â£©Â£≥Â§ÖÂ§ÜÂ§ãÂ§åÂ§íÂ§ìÂ§îËôÅÂ§ùÂ§°Â§£Â§§Â§®Â§ØÂ§∞Â§≥Â§µÂ§∂Â§øÂ•ÉÂ•ÜÂ•íÂ•ìÂ•ôÂ•õÂ•ùÂ•ûÂ•üÂ•°Â•£Â•´Â•≠"],["8fb9a1","Â•ØÂ•≤Â•µÂ•∂Â•πÂ•ªÂ•ºÂ¶ãÂ¶åÂ¶éÂ¶íÂ¶ïÂ¶óÂ¶üÂ¶§Â¶ßÂ¶≠Â¶ÆÂ¶ØÂ¶∞Â¶≥Â¶∑Â¶∫Â¶ºÂßÅÂßÉÂßÑÂßàÂßäÂßçÂßíÂßùÂßûÂßüÂß£Âß§ÂßßÂßÆÂßØÂß±Âß≤Âß¥Âß∑Â®ÄÂ®ÑÂ®åÂ®çÂ®éÂ®íÂ®ìÂ®ûÂ®£Â®§Â®ßÂ®®Â®™Â®≠Â®∞Â©ÑÂ©ÖÂ©áÂ©àÂ©åÂ©êÂ©ïÂ©ûÂ©£Â©•Â©ßÂ©≠Â©∑Â©∫Â©ªÂ©æÂ™ãÂ™êÂ™ìÂ™ñÂ™ôÂ™úÂ™ûÂ™üÂ™†Â™¢Â™ßÂ™¨Â™±Â™≤Â™≥Â™µÂ™∏Â™∫Â™ªÂ™ø"],["8fbaa1","Â´ÑÂ´ÜÂ´àÂ´èÂ´öÂ´úÂ´†Â´•Â´™Â´ÆÂ´µÂ´∂Â´ΩÂ¨ÄÂ¨ÅÂ¨àÂ¨óÂ¨¥Â¨ôÂ¨õÂ¨ùÂ¨°Â¨•Â¨≠Â¨∏Â≠ÅÂ≠ãÂ≠åÂ≠íÂ≠ñÂ≠ûÂ≠®Â≠ÆÂ≠ØÂ≠ºÂ≠ΩÂ≠æÂ≠øÂÆÅÂÆÑÂÆÜÂÆäÂÆéÂÆêÂÆëÂÆìÂÆîÂÆñÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆºÂØÄÂØÅÂØçÂØèÂØñ",4,"ÂØ†ÂØØÂØ±ÂØ¥ÂØΩÂ∞åÂ∞óÂ∞ûÂ∞üÂ∞£Â∞¶Â∞©Â∞´Â∞¨Â∞ÆÂ∞∞Â∞≤Â∞µÂ∞∂Â±ôÂ±öÂ±úÂ±¢Â±£Â±ßÂ±®Â±©"],["8fbba1","Â±≠Â±∞Â±¥Â±µÂ±∫Â±ªÂ±ºÂ±ΩÂ≤áÂ≤àÂ≤äÂ≤èÂ≤íÂ≤ùÂ≤üÂ≤†Â≤¢Â≤£Â≤¶Â≤™Â≤≤Â≤¥Â≤µÂ≤∫Â≥âÂ≥ãÂ≥íÂ≥ùÂ≥óÂ≥ÆÂ≥±Â≥≤Â≥¥Â¥ÅÂ¥ÜÂ¥çÂ¥íÂ¥´Â¥£Â¥§Â¥¶Â¥ßÂ¥±Â¥¥Â¥πÂ¥ΩÂ¥øÂµÇÂµÉÂµÜÂµàÂµïÂµëÂµôÂµäÂµüÂµ†Âµ°Âµ¢Âµ§Âµ™Âµ≠Âµ∞ÂµπÂµ∫ÂµæÂµøÂ∂ÅÂ∂ÉÂ∂àÂ∂äÂ∂íÂ∂ìÂ∂îÂ∂ïÂ∂ôÂ∂õÂ∂üÂ∂†Â∂ßÂ∂´Â∂∞Â∂¥Â∂∏Â∂πÂ∑ÉÂ∑áÂ∑ãÂ∑êÂ∑éÂ∑òÂ∑ôÂ∑†Â∑§"],["8fbca1","Â∑©Â∑∏Â∑πÂ∏ÄÂ∏áÂ∏çÂ∏íÂ∏îÂ∏ïÂ∏òÂ∏üÂ∏†Â∏ÆÂ∏®Â∏≤Â∏µÂ∏æÂπãÂπêÂπâÂπëÂπñÂπòÂπõÂπúÂπûÂπ®Âπ™",4,"Âπ∞Â∫ÄÂ∫ãÂ∫éÂ∫¢Â∫§Â∫•Â∫®Â∫™Â∫¨Â∫±Â∫≥Â∫ΩÂ∫æÂ∫øÂªÜÂªåÂªãÂªéÂªëÂªíÂªîÂªïÂªúÂªûÂª•Âª´ÂºÇÂºÜÂºáÂºàÂºéÂºôÂºúÂºùÂº°Âº¢Âº£Âº§Âº®Âº´Âº¨ÂºÆÂº∞Âº¥Âº∂ÂºªÂºΩÂºøÂΩÄÂΩÑÂΩÖÂΩáÂΩçÂΩêÂΩîÂΩòÂΩõÂΩ†ÂΩ£ÂΩ§ÂΩß"],["8fbda1","ÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∏ÂΩ∫ÂΩΩÂΩæÂæâÂæçÂæèÂæñÂæúÂæùÂæ¢ÂæßÂæ´Âæ§Âæ¨ÂæØÂæ∞Âæ±Âæ∏ÂøÑÂøáÂøàÂøâÂøãÂøê",4,"ÂøûÂø°Âø¢Âø®Âø©Âø™Âø¨Âø≠ÂøÆÂøØÂø≤Âø≥Âø∂Âø∫ÂøºÊÄáÊÄäÊÄçÊÄìÊÄîÊÄóÊÄòÊÄöÊÄüÊÄ§ÊÄ≠ÊÄ≥ÊÄµÊÅÄÊÅáÊÅàÊÅâÊÅåÊÅëÊÅîÊÅñÊÅóÊÅùÊÅ°ÊÅßÊÅ±ÊÅæÊÅøÊÇÇÊÇÜÊÇàÊÇäÊÇéÊÇëÊÇìÊÇïÊÇòÊÇùÊÇûÊÇ¢ÊÇ§ÊÇ•ÊÇ®ÊÇ∞ÊÇ±ÊÇ∑"],["8fbea1","ÊÇªÊÇæÊÉÇÊÉÑÊÉàÊÉâÊÉäÊÉãÊÉéÊÉèÊÉîÊÉïÊÉôÊÉõÊÉùÊÉûÊÉ¢ÊÉ•ÊÉ≤ÊÉµÊÉ∏ÊÉºÊÉΩÊÑÇÊÑáÊÑäÊÑåÊÑê",4,"ÊÑñÊÑóÊÑôÊÑúÊÑûÊÑ¢ÊÑ™ÊÑ´ÊÑ∞ÊÑ±ÊÑµÊÑ∂ÊÑ∑ÊÑπÊÖÅÊÖÖÊÖÜÊÖâÊÖûÊÖ†ÊÖ¨ÊÖ≤ÊÖ∏ÊÖªÊÖºÊÖøÊÜÄÊÜÅÊÜÉÊÜÑÊÜãÊÜçÊÜíÊÜìÊÜóÊÜòÊÜúÊÜùÊÜüÊÜ†ÊÜ•ÊÜ®ÊÜ™ÊÜ≠ÊÜ∏ÊÜπÊÜºÊáÄÊáÅÊáÇÊáéÊáèÊáïÊáúÊáùÊáûÊáüÊá°Êá¢ÊáßÊá©Êá•"],["8fbfa1","Êá¨Êá≠ÊáØÊàÅÊàÉÊàÑÊàáÊàìÊàïÊàúÊà†Êà¢Êà£ÊàßÊà©Êà´ÊàπÊàΩÊâÇÊâÉÊâÑÊâÜÊâåÊâêÊâëÊâíÊâîÊâñÊâöÊâúÊâ§Êâ≠ÊâØÊâ≥Êâ∫ÊâΩÊäçÊäéÊäèÊäêÊä¶Êä®Êä≥Êä∂Êä∑Êä∫ÊäæÊäøÊãÑÊãéÊãïÊãñÊãöÊã™Êã≤Êã¥ÊãºÊãΩÊåÉÊåÑÊåäÊåãÊåçÊåêÊåìÊåñÊåòÊå©Êå™Êå≠ÊåµÊå∂ÊåπÊåºÊçÅÊçÇÊçÉÊçÑÊçÜÊçäÊçãÊçéÊçíÊçìÊçîÊçòÊçõÊç•Êç¶Êç¨Êç≠Êç±Êç¥Êçµ"],["8fc0a1","Êç∏ÊçºÊçΩÊçøÊéÇÊéÑÊéáÊéäÊéêÊéîÊéïÊéôÊéöÊéûÊé§Êé¶Êé≠ÊéÆÊéØÊéΩÊèÅÊèÖÊèàÊèéÊèëÊèìÊèîÊèïÊèúÊè†Êè•Êè™Êè¨Êè≤Êè≥ÊèµÊè∏ÊèπÊêâÊêäÊêêÊêíÊêîÊêòÊêûÊê†Êê¢Êê§Êê•Êê©Êê™ÊêØÊê∞ÊêµÊêΩÊêøÊëãÊëèÊëëÊëíÊëìÊëîÊëöÊëõÊëúÊëùÊëüÊë†Êë°Êë£Êë≠Êë≥Êë¥ÊëªÊëΩÊíÖÊíáÊíèÊíêÊíëÊíòÊíôÊíõÊíùÊíüÊí°Êí£Êí¶Êí®Êí¨Êí≥ÊíΩÊíæÊíø"],["8fc1a1","ÊìÑÊìâÊìäÊìãÊìåÊìéÊìêÊìëÊìïÊìóÊì§Êì•Êì©Êì™Êì≠Êì∞ÊìµÊì∑ÊìªÊìøÊîÅÊîÑÊîàÊîâÊîäÊîèÊîìÊîîÊîñÊîôÊîõÊîûÊîüÊî¢Êî¶Êî©ÊîÆÊî±Êî∫ÊîºÊîΩÊïÉÊïáÊïâÊïêÊïíÊïîÊïüÊï†ÊïßÊï´Êï∫ÊïΩÊñÅÊñÖÊñäÊñíÊñïÊñòÊñùÊñ†Êñ£Êñ¶ÊñÆÊñ≤Êñ≥Êñ¥ÊñøÊóÇÊóàÊóâÊóéÊóêÊóîÊóñÊóòÊóüÊó∞Êó≤Êó¥ÊóµÊóπÊóæÊóøÊòÄÊòÑÊòàÊòâÊòçÊòëÊòíÊòïÊòñÊòù"],["8fc2a1","ÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò±Êò≥ÊòπÊò∑ÊôÄÊôÖÊôÜÊôäÊôåÊôëÊôéÊôóÊôòÊôôÊôõÊôúÊô†Êô°ÊõªÊô™Êô´Êô¨ÊôæÊô≥ÊôµÊôøÊô∑Êô∏ÊôπÊôªÊöÄÊôºÊöãÊöåÊöçÊöêÊöíÊöôÊööÊöõÊöúÊöüÊö†Êö§Êö≠Êö±Êö≤ÊöµÊöªÊöøÊõÄÊõÇÊõÉÊõàÊõåÊõéÊõèÊõîÊõõÊõüÊõ®Êõ´Êõ¨ÊõÆÊõ∫ÊúÖÊúáÊúéÊúìÊúôÊúúÊú†Êú¢Êú≥ÊúæÊùÖÊùáÊùàÊùåÊùîÊùïÊùù"],["8fc3a1","Êù¶Êù¨ÊùÆÊù¥Êù∂ÊùªÊûÅÊûÑÊûéÊûèÊûëÊûìÊûñÊûòÊûôÊûõÊû∞Êû±Êû≤ÊûµÊûªÊûºÊûΩÊüπÊüÄÊüÇÊüÉÊüÖÊüàÊüâÊüíÊüóÊüôÊüúÊü°Êü¶Êü∞Êü≤Êü∂Êü∑Ê°íÊ†îÊ†ôÊ†ùÊ†üÊ†®Ê†ßÊ†¨Ê†≠Ê†ØÊ†∞Ê†±Ê†≥Ê†ªÊ†øÊ°ÑÊ°ÖÊ°äÊ°åÊ°ïÊ°óÊ°òÊ°õÊ°´Ê°Æ",4,"Ê°µÊ°πÊ°∫Ê°ªÊ°ºÊ¢ÇÊ¢ÑÊ¢ÜÊ¢àÊ¢ñÊ¢òÊ¢öÊ¢úÊ¢°Ê¢£Ê¢•Ê¢©Ê¢™Ê¢ÆÊ¢≤Ê¢ªÊ£ÖÊ£àÊ£åÊ£è"],["8fc4a1","Ê£êÊ£ëÊ£ìÊ£ñÊ£ôÊ£úÊ£ùÊ£•Ê£®Ê£™Ê£´Ê£¨Ê£≠Ê£∞Ê£±Ê£µÊ£∂Ê£ªÊ£ºÊ£ΩÊ§ÜÊ§âÊ§äÊ§êÊ§ëÊ§ìÊ§ñÊ§óÊ§±Ê§≥Ê§µÊ§∏Ê§ªÊ•ÇÊ•ÖÊ•âÊ•éÊ•óÊ•õÊ•£Ê•§Ê••Ê•¶Ê•®Ê•©Ê•¨Ê•∞Ê•±Ê•≤Ê•∫Ê•ªÊ•øÊ¶ÄÊ¶çÊ¶íÊ¶ñÊ¶òÊ¶°Ê¶•Ê¶¶Ê¶®Ê¶´Ê¶≠Ê¶ØÊ¶∑Ê¶∏Ê¶∫Ê¶ºÊßÖÊßàÊßëÊßñÊßóÊß¢Êß•ÊßÆÊßØÊß±Êß≥ÊßµÊßæÊ®ÄÊ®ÅÊ®ÉÊ®èÊ®ëÊ®ïÊ®öÊ®ùÊ®†Ê®§Ê®®Ê®∞Ê®≤"],["8fc5a1","Ê®¥Ê®∑Ê®ªÊ®æÊ®øÊ©ÖÊ©ÜÊ©âÊ©äÊ©éÊ©êÊ©ëÊ©íÊ©ïÊ©ñÊ©õÊ©§Ê©ßÊ©™Ê©±Ê©≥Ê©æÊ™ÅÊ™ÉÊ™ÜÊ™áÊ™âÊ™ãÊ™ëÊ™õÊ™ùÊ™ûÊ™üÊ™•Ê™´Ê™ØÊ™∞Ê™±Ê™¥Ê™ΩÊ™æÊ™øÊ´ÜÊ´âÊ´àÊ´åÊ´êÊ´îÊ´ïÊ´ñÊ´úÊ´ùÊ´§Ê´ßÊ´¨Ê´∞Ê´±Ê´≤Ê´ºÊ´ΩÊ¨ÇÊ¨ÉÊ¨ÜÊ¨áÊ¨âÊ¨èÊ¨êÊ¨ëÊ¨óÊ¨õÊ¨ûÊ¨§Ê¨®Ê¨´Ê¨¨Ê¨ØÊ¨µÊ¨∂Ê¨ªÊ¨øÊ≠ÜÊ≠äÊ≠çÊ≠íÊ≠ñÊ≠òÊ≠ùÊ≠†Ê≠ßÊ≠´Ê≠ÆÊ≠∞Ê≠µÊ≠Ω"],["8fc6a1","Ê≠æÊÆÇÊÆÖÊÆóÊÆõÊÆüÊÆ†ÊÆ¢ÊÆ£ÊÆ®ÊÆ©ÊÆ¨ÊÆ≠ÊÆÆÊÆ∞ÊÆ∏ÊÆπÊÆΩÊÆæÊØÉÊØÑÊØâÊØåÊØñÊØöÊØ°ÊØ£ÊØ¶ÊØßÊØÆÊØ±ÊØ∑ÊØπÊØøÊ∞ÇÊ∞ÑÊ∞ÖÊ∞âÊ∞çÊ∞éÊ∞êÊ∞íÊ∞ôÊ∞üÊ∞¶Ê∞ßÊ∞®Ê∞¨Ê∞ÆÊ∞≥Ê∞µÊ∞∂Ê∞∫Ê∞ªÊ∞øÊ±äÊ±ãÊ±çÊ±èÊ±íÊ±îÊ±ôÊ±õÊ±úÊ±´Ê±≠Ê±ØÊ±¥Ê±∂Ê±∏Ê±πÊ±ªÊ≤ÖÊ≤ÜÊ≤áÊ≤âÊ≤îÊ≤ïÊ≤óÊ≤òÊ≤úÊ≤üÊ≤∞Ê≤≤Ê≤¥Ê≥ÇÊ≥ÜÊ≥çÊ≥èÊ≥êÊ≥ëÊ≥íÊ≥îÊ≥ñ"],["8fc7a1","Ê≥öÊ≥úÊ≥†Ê≥ßÊ≥©Ê≥´Ê≥¨Ê≥ÆÊ≥≤Ê≥¥Ê¥ÑÊ¥áÊ¥äÊ¥éÊ¥èÊ¥ëÊ¥ìÊ¥öÊ¥¶Ê¥ßÊ¥®Ê±ßÊ¥ÆÊ¥ØÊ¥±Ê¥πÊ¥ºÊ¥øÊµóÊµûÊµüÊµ°Êµ•ÊµßÊµØÊµ∞ÊµºÊ∂ÇÊ∂áÊ∂ëÊ∂íÊ∂îÊ∂ñÊ∂óÊ∂òÊ∂™Ê∂¨Ê∂¥Ê∂∑Ê∂πÊ∂ΩÊ∂øÊ∑ÑÊ∑àÊ∑äÊ∑éÊ∑èÊ∑ñÊ∑õÊ∑ùÊ∑üÊ∑†Ê∑¢Ê∑•Ê∑©Ê∑ØÊ∑∞Ê∑¥Ê∑∂Ê∑ºÊ∏ÄÊ∏ÑÊ∏ûÊ∏¢Ê∏ßÊ∏≤Ê∏∂Ê∏πÊ∏ªÊ∏ºÊπÑÊπÖÊπàÊπâÊπãÊπèÊπëÊπíÊπìÊπîÊπóÊπúÊπùÊπû"],["8fc8a1","Êπ¢Êπ£Êπ®Êπ≥ÊπªÊπΩÊ∫çÊ∫ìÊ∫ôÊ∫†Ê∫ßÊ∫≠Ê∫ÆÊ∫±Ê∫≥Ê∫ªÊ∫øÊªÄÊªÅÊªÉÊªáÊªàÊªäÊªçÊªéÊªèÊª´Êª≠ÊªÆÊªπÊªªÊªΩÊºÑÊºàÊºäÊºåÊºçÊºñÊºòÊºöÊºõÊº¶Êº©Êº™ÊºØÊº∞Êº≥Êº∂ÊºªÊººÊº≠ÊΩèÊΩëÊΩíÊΩìÊΩóÊΩôÊΩöÊΩùÊΩûÊΩ°ÊΩ¢ÊΩ®ÊΩ¨ÊΩΩÊΩæÊæÉÊæáÊæàÊæãÊæåÊæçÊæêÊæíÊæìÊæîÊæñÊæöÊæüÊæ†Êæ•Êæ¶ÊæßÊæ®ÊæÆÊæØÊæ∞ÊæµÊæ∂ÊæºÊøÖÊøáÊøàÊøä"],["8fc9a1","ÊøöÊøûÊø®Êø©Êø∞ÊøµÊøπÊøºÊøΩÁÄÄÁÄÖÁÄÜÁÄáÁÄçÁÄóÁÄ†ÁÄ£ÁÄØÁÄ¥ÁÄ∑ÁÄπÁÄºÁÅÉÁÅÑÁÅàÁÅâÁÅäÁÅãÁÅîÁÅïÁÅùÁÅûÁÅéÁÅ§ÁÅ•ÁÅ¨ÁÅÆÁÅµÁÅ∂ÁÅæÁÇÅÁÇÖÁÇÜÁÇî",4,"ÁÇõÁÇ§ÁÇ´ÁÇ∞ÁÇ±ÁÇ¥ÁÇ∑ÁÉäÁÉëÁÉìÁÉîÁÉïÁÉñÁÉòÁÉúÁÉ§ÁÉ∫ÁÑÉ",4,"ÁÑãÁÑåÁÑèÁÑûÁÑ†ÁÑ´ÁÑ≠ÁÑØÁÑ∞ÁÑ±ÁÑ∏ÁÖÅÁÖÖÁÖÜÁÖáÁÖäÁÖãÁÖêÁÖíÁÖóÁÖöÁÖúÁÖûÁÖ†"],["8fcaa1","ÁÖ®ÁÖπÁÜÄÁÜÖÁÜáÁÜåÁÜíÁÜöÁÜõÁÜ†ÁÜ¢ÁÜØÁÜ∞ÁÜ≤ÁÜ≥ÁÜ∫ÁÜøÁáÄÁáÅÁáÑÁáãÁáåÁáìÁáñÁáôÁáöÁáúÁá∏ÁáæÁàÄÁàáÁààÁàâÁàìÁàóÁàöÁàùÁàüÁà§Áà´ÁàØÁà¥Áà∏ÁàπÁâÅÁâÇÁâÉÁâÖÁâéÁâèÁâêÁâìÁâïÁâñÁâöÁâúÁâûÁâ†Áâ£Áâ®Áâ´ÁâÆÁâØÁâ±Áâ∑Áâ∏ÁâªÁâºÁâøÁäÑÁäâÁäçÁäéÁäìÁäõÁä®Áä≠ÁäÆÁä±Áä¥ÁäæÁãÅÁãáÁãâÁãåÁãïÁãñÁãòÁãüÁã•Áã≥Áã¥Áã∫Áãª"],["8fcba1","ÁãæÁåÇÁåÑÁåÖÁåáÁåãÁåçÁåíÁåìÁåòÁåôÁåûÁå¢Áå§ÁåßÁå®Áå¨Áå±Áå≤ÁåµÁå∫ÁåªÁåΩÁçÉÁççÁçêÁçíÁçñÁçòÁçùÁçûÁçüÁç†Áç¶ÁçßÁç©Áç´Áç¨ÁçÆÁçØÁç±Áç∑ÁçπÁçºÁéÄÁéÅÁéÉÁéÖÁéÜÁééÁéêÁéìÁéïÁéóÁéòÁéúÁéûÁéüÁé†Áé¢Áé•Áé¶Áé™Áé´Áé≠ÁéµÁé∑ÁéπÁéºÁéΩÁéøÁèÖÁèÜÁèâÁèãÁèåÁèèÁèíÁèìÁèñÁèôÁèùÁè°Áè£Áè¶ÁèßÁè©Áè¥ÁèµÁè∑ÁèπÁè∫ÁèªÁèΩ"],["8fcca1","ÁèøÁêÄÁêÅÁêÑÁêáÁêäÁêëÁêöÁêõÁê§Áê¶Áê®",9,"ÁêπÁëÄÁëÉÁëÑÁëÜÁëáÁëãÁëçÁëëÁëíÁëóÁëùÁë¢Áë¶ÁëßÁë®Áë´Áë≠ÁëÆÁë±Áë≤ÁíÄÁíÅÁíÖÁíÜÁíáÁíâÁíèÁíêÁíëÁííÁíòÁíôÁíöÁíúÁíüÁí†Áí°Áí£Áí¶Áí®Áí©Áí™Áí´ÁíÆÁíØÁí±Áí≤ÁíµÁíπÁíªÁíøÁìàÁìâÁìåÁìêÁììÁìòÁìöÁìõÁìûÁìüÁì§Áì®Áì™Áì´ÁìØÁì¥Áì∫ÁìªÁìºÁìøÁîÜ"],["8fcda1","ÁîíÁîñÁîóÁî†Áî°Áî§ÁîßÁî©Áî™ÁîØÁî∂ÁîπÁîΩÁîæÁîøÁïÄÁïÉÁïáÁïàÁïéÁïêÁïíÁïóÁïûÁïüÁï°ÁïØÁï±Áïπ",5,"ÁñÅÁñÖÁñêÁñíÁñìÁñïÁñôÁñúÁñ¢Áñ§Áñ¥Áñ∫ÁñøÁóÄÁóÅÁóÑÁóÜÁóåÁóéÁóèÁóóÁóúÁóüÁó†Áó°Áó§ÁóßÁó¨ÁóÆÁóØÁó±ÁóπÁòÄÁòÇÁòÉÁòÑÁòáÁòàÁòäÁòåÁòèÁòíÁòìÁòïÁòñÁòôÁòõÁòúÁòùÁòûÁò£Áò•Áò¶Áò©Áò≠Áò≤Áò≥ÁòµÁò∏Áòπ"],["8fcea1","Áò∫ÁòºÁôäÁôÄÁôÅÁôÉÁôÑÁôÖÁôâÁôãÁôïÁôôÁôüÁô§Áô•Áô≠ÁôÆÁôØÁô±Áô¥ÁöÅÁöÖÁöåÁöçÁöïÁöõÁöúÁöùÁöüÁö†Áö¢",6,"Áö™Áö≠ÁöΩÁõÅÁõÖÁõâÁõãÁõåÁõéÁõîÁõôÁõ†Áõ¶Áõ®Áõ¨Áõ∞Áõ±Áõ∂ÁõπÁõºÁúÄÁúÜÁúäÁúéÁúíÁúîÁúïÁúóÁúôÁúöÁúúÁú¢Áú®Áú≠ÁúÆÁúØÁú¥ÁúµÁú∂ÁúπÁúΩÁúæÁùÇÁùÖÁùÜÁùäÁùçÁùéÁùèÁùíÁùñÁùóÁùúÁùûÁùüÁù†Áù¢"],["8fcfa1","Áù§ÁùßÁù™Áù¨Áù∞Áù≤Áù≥Áù¥Áù∫ÁùΩÁûÄÁûÑÁûåÁûçÁûîÁûïÁûñÁûöÁûüÁû¢ÁûßÁû™ÁûÆÁûØÁû±ÁûµÁûæÁüÉÁüâÁüëÁüíÁüïÁüôÁüûÁüüÁü†Áü§Áü¶Áü™Áü¨Áü∞Áü±Áü¥Áü∏ÁüªÁ†ÖÁ†ÜÁ†âÁ†çÁ†éÁ†ëÁ†ùÁ†°Á†¢Á†£Á†≠Á†ÆÁ†∞Á†µÁ†∑Á°ÉÁ°ÑÁ°áÁ°àÁ°åÁ°éÁ°íÁ°úÁ°ûÁ°†Á°°Á°£Á°§Á°®Á°™Á°ÆÁ°∫Á°æÁ¢äÁ¢èÁ¢îÁ¢òÁ¢°Á¢ùÁ¢ûÁ¢üÁ¢§Á¢®Á¢¨Á¢≠Á¢∞Á¢±Á¢≤Á¢≥"],["8fd0a1","Á¢ªÁ¢ΩÁ¢øÁ£áÁ£àÁ£âÁ£åÁ£éÁ£íÁ£ìÁ£ïÁ£ñÁ£§Á£õÁ£üÁ£†Á£°Á£¶Á£™Á£≤Á£≥Á§ÄÁ£∂Á£∑Á£∫Á£ªÁ£øÁ§ÜÁ§åÁ§êÁ§öÁ§úÁ§ûÁ§üÁ§†Á§•Á§ßÁ§©Á§≠Á§±Á§¥Á§µÁ§ªÁ§ΩÁ§øÁ•ÑÁ•ÖÁ•ÜÁ•äÁ•ãÁ•èÁ•ëÁ•îÁ•òÁ•õÁ•úÁ•ßÁ•©Á•´Á•≤Á•πÁ•ªÁ•ºÁ•æÁ¶ãÁ¶åÁ¶ëÁ¶ìÁ¶îÁ¶ïÁ¶ñÁ¶òÁ¶õÁ¶úÁ¶°Á¶®Á¶©Á¶´Á¶ØÁ¶±Á¶¥Á¶∏Á¶ªÁßÇÁßÑÁßáÁßàÁßäÁßèÁßîÁßñÁßöÁßùÁßû"],["8fd1a1","Áß†Áß¢Áß•Áß™Áß´Áß≠Áß±Áß∏ÁßºÁ®ÇÁ®ÉÁ®áÁ®âÁ®äÁ®åÁ®ëÁ®ïÁ®õÁ®ûÁ®°Á®ßÁ®´Á®≠Á®ØÁ®∞Á®¥Á®µÁ®∏Á®πÁ®∫Á©ÑÁ©ÖÁ©áÁ©àÁ©åÁ©ïÁ©ñÁ©ôÁ©úÁ©ùÁ©üÁ©†Á©•Á©ßÁ©™Á©≠Á©µÁ©∏Á©æÁ™ÄÁ™ÇÁ™ÖÁ™ÜÁ™äÁ™ãÁ™êÁ™ëÁ™îÁ™ûÁ™†Á™£Á™¨Á™≥Á™µÁ™πÁ™ªÁ™ºÁ´ÜÁ´âÁ´åÁ´éÁ´ëÁ´õÁ´®Á´©Á´´Á´¨Á´±Á´¥Á´ªÁ´ΩÁ´æÁ¨áÁ¨îÁ¨üÁ¨£Á¨ßÁ¨©Á¨™Á¨´Á¨≠Á¨ÆÁ¨ØÁ¨∞"],["8fd2a1","Á¨±Á¨¥Á¨ΩÁ¨øÁ≠ÄÁ≠ÅÁ≠áÁ≠éÁ≠ïÁ≠†Á≠§Á≠¶Á≠©Á≠™Á≠≠Á≠ØÁ≠≤Á≠≥Á≠∑ÁÆÑÁÆâÁÆéÁÆêÁÆëÁÆñÁÆõÁÆûÁÆ†ÁÆ•ÁÆ¨ÁÆØÁÆ∞ÁÆ≤ÁÆµÁÆ∂ÁÆ∫ÁÆªÁÆºÁÆΩÁØÇÁØÖÁØàÁØäÁØîÁØñÁØóÁØôÁØöÁØõÁØ®ÁØ™ÁØ≤ÁØ¥ÁØµÁØ∏ÁØπÁØ∫ÁØºÁØæÁ∞ÅÁ∞ÇÁ∞ÉÁ∞ÑÁ∞ÜÁ∞âÁ∞ãÁ∞åÁ∞éÁ∞èÁ∞ôÁ∞õÁ∞†Á∞•Á∞¶Á∞®Á∞¨Á∞±Á∞≥Á∞¥Á∞∂Á∞πÁ∞∫Á±ÜÁ±äÁ±ïÁ±ëÁ±íÁ±ìÁ±ô",5],["8fd3a1","Á±°Á±£Á±ßÁ±©Á±≠Á±ÆÁ±∞Á±≤Á±πÁ±ºÁ±ΩÁ≤ÜÁ≤áÁ≤èÁ≤îÁ≤ûÁ≤†Á≤¶Á≤∞Á≤∂Á≤∑Á≤∫Á≤ªÁ≤ºÁ≤øÁ≥ÑÁ≥áÁ≥àÁ≥âÁ≥çÁ≥èÁ≥ìÁ≥îÁ≥ïÁ≥óÁ≥ôÁ≥öÁ≥ùÁ≥¶Á≥©Á≥´Á≥µÁ¥ÉÁ¥áÁ¥àÁ¥âÁ¥èÁ¥ëÁ¥íÁ¥ìÁ¥ñÁ¥ùÁ¥ûÁ¥£Á¥¶Á¥™Á¥≠Á¥±Á¥ºÁ¥ΩÁ¥æÁµÄÁµÅÁµáÁµàÁµçÁµëÁµìÁµóÁµôÁµöÁµúÁµùÁµ•ÁµßÁµ™Áµ∞Áµ∏Áµ∫ÁµªÁµøÁ∂ÅÁ∂ÇÁ∂ÉÁ∂ÖÁ∂ÜÁ∂àÁ∂ãÁ∂åÁ∂çÁ∂ëÁ∂ñÁ∂óÁ∂ù"],["8fd4a1","Á∂ûÁ∂¶Á∂ßÁ∂™Á∂≥Á∂∂Á∂∑Á∂πÁ∑Ç",4,"Á∑åÁ∑çÁ∑éÁ∑óÁ∑ôÁ∏ÄÁ∑¢Á∑•Á∑¶Á∑™Á∑´Á∑≠Á∑±Á∑µÁ∑∂Á∑πÁ∑∫Á∏àÁ∏êÁ∏ëÁ∏ïÁ∏óÁ∏úÁ∏ùÁ∏†Á∏ßÁ∏®Á∏¨Á∏≠Á∏ØÁ∏≥Á∏∂Á∏øÁπÑÁπÖÁπáÁπéÁπêÁπíÁπòÁπüÁπ°Áπ¢Áπ•Áπ´ÁπÆÁπØÁπ≥Áπ∏ÁπæÁ∫ÅÁ∫ÜÁ∫áÁ∫äÁ∫çÁ∫ëÁ∫ïÁ∫òÁ∫öÁ∫ùÁ∫ûÁººÁºªÁºΩÁºæÁºøÁΩÉÁΩÑÁΩáÁΩèÁΩíÁΩìÁΩõÁΩúÁΩùÁΩ°ÁΩ£ÁΩ§ÁΩ•ÁΩ¶ÁΩ≠"],["8fd5a1","ÁΩ±ÁΩΩÁΩæÁΩøÁæÄÁæãÁæçÁæèÁæêÁæëÁæñÁæóÁæúÁæ°Áæ¢Áæ¶Áæ™Áæ≠Áæ¥ÁæºÁæøÁøÄÁøÉÁøàÁøéÁøèÁøõÁøüÁø£Áø•Áø®Áø¨ÁøÆÁøØÁø≤Áø∫ÁøΩÁøæÁøøËÄáËÄàËÄäËÄçËÄéËÄèËÄëËÄìËÄîËÄñËÄùËÄûËÄüËÄ†ËÄ§ËÄ¶ËÄ¨ËÄÆËÄ∞ËÄ¥ËÄµËÄ∑ËÄπËÄ∫ËÄºËÄæËÅÄËÅÑËÅ†ËÅ§ËÅ¶ËÅ≠ËÅ±ËÅµËÇÅËÇàËÇéËÇúËÇûËÇ¶ËÇßËÇ´ËÇ∏ËÇπËÉàËÉçËÉèËÉíËÉîËÉïËÉóËÉòËÉ†ËÉ≠ËÉÆ"],["8fd6a1","ËÉ∞ËÉ≤ËÉ≥ËÉ∂ËÉπËÉ∫ËÉæËÑÉËÑãËÑñËÑóËÑòËÑúËÑûËÑ†ËÑ§ËÑßËÑ¨ËÑ∞ËÑµËÑ∫ËÑºËÖÖËÖáËÖäËÖåËÖíËÖóËÖ†ËÖ°ËÖßËÖ®ËÖ©ËÖ≠ËÖØËÖ∑ËÜÅËÜêËÜÑËÜÖËÜÜËÜãËÜéËÜñËÜòËÜõËÜûËÜ¢ËÜÆËÜ≤ËÜ¥ËÜªËáãËáÉËáÖËáäËáéËáèËáïËáóËáõËáùËáûËá°Ëá§Ëá´Ëá¨Ëá∞Ëá±Ëá≤ËáµËá∂Ëá∏ËáπËáΩËáøËàÄËàÉËàèËàìËàîËàôËàöËàùËà°Ëà¢Ëà®Ëà≤Ëà¥Ëà∫ËâÉËâÑËâÖËâÜ"],["8fd7a1","ËâãËâéËâèËâëËâñËâúËâ†Ëâ£ËâßËâ≠Ëâ¥ËâªËâΩËâøËäÄËäÅËäÉËäÑËäáËäâËääËäéËäëËäîËäñËäòËäöËäõËä†Ëä°Ëä£Ëä§ËäßËä®Ëä©Ëä™ËäÆËä∞Ëä≤Ëä¥Ëä∑Ëä∫ËäºËäæËäøËãÜËãêËãïËãöËã†Ëã¢Ëã§Ëã®Ëã™Ëã≠ËãØËã∂Ëã∑ËãΩËãæËåÄËåÅËåáËåàËåäËåãËçîËåõËåùËåûËåüËå°Ëå¢Ëå¨Ëå≠ËåÆËå∞Ëå≥Ëå∑Ëå∫ËåºËåΩËçÇËçÉËçÑËçáËççËçéËçëËçïËçñËçóËç∞Ëç∏"],["8fd8a1","ËçΩËçøËéÄËéÇËéÑËéÜËéçËéíËéîËéïËéòËéôËéõËéúËéùËé¶ËéßËé©Ëé¨ËéæËéøËèÄËèáËèâËèèËèêËèëËèîËèùËçìËè®Ëè™Ëè∂Ëè∏ËèπËèºËêÅËêÜËêäËêèËêëËêïËêôËé≠ËêØËêπËëÖËëáËëàËëäËëçËëèËëëËëíËëñËëòËëôËëöËëúËë†Ëë§Ëë•ËëßËë™Ëë∞Ëë≥Ëë¥Ëë∂Ëë∏ËëºËëΩËíÅËíÖËííËíìËíïËíûËí¶Ëí®Ëí©Ëí™ËíØËí±Ëí¥Ëí∫ËíΩËíæËìÄËìÇËìáËìàËìåËìèËìì"],["8fd9a1","ËìúËìßËì™ËìØËì∞Ëì±Ëì≤Ëì∑Ëî≤Ëì∫ËìªËìΩËîÇËîÉËîáËîåËîéËîêËîúËîûËî¢Ëî£Ëî§Ëî•ËîßËî™Ëî´ËîØËî≥Ëî¥Ëî∂ËîøËïÜËïè",4,"ËïñËïôËïú",6,"Ëï§Ëï´ËïØËïπËï∫ËïªËïΩËïøËñÅËñÖËñÜËñâËñãËñåËñèËñìËñòËñùËñüËñ†Ëñ¢Ëñ•ËñßËñ¥Ëñ∂Ëñ∑Ëñ∏ËñºËñΩËñæËñøËóÇËóáËóäËóãËóéËñ≠ËóòËóöËóüËó†Ëó¶Ëó®Ëó≠Ëó≥Ëó∂Ëóº"],["8fdaa1","ËóøËòÄËòÑËòÖËòçËòéËòêËòëËòíËòòËòôËòõËòûËò°ËòßËò©Ëò∂Ëò∏Ëò∫ËòºËòΩËôÄËôÇËôÜËôíËôìËôñËôóËôòËôôËôùËô†",4,"Ëô©Ëô¨ËôØËôµËô∂Ëô∑Ëô∫ËöçËöëËöñËöòËööËöúËö°Ëö¶ËößËö®Ëö≠Ëö±Ëö≥Ëö¥ËöµËö∑Ëö∏ËöπËöøËõÄËõÅËõÉËõÖËõëËõíËõïËõóËõöËõúËõ†Ëõ£Ëõ•ËõßËöàËõ∫ËõºËõΩËúÑËúÖËúáËúãËúéËúèËúêËúìËúîËúôËúûËúüËú°Ëú£"],["8fdba1","Ëú®ËúÆËúØËú±Ëú≤ËúπËú∫ËúºËúΩËúæËùÄËùÉËùÖËùçËùòËùùËù°Ëù§Ëù•ËùØËù±Ëù≤ËùªËûÉ",6,"ËûãËûåËûêËûìËûïËûóËûòËûôËûûËû†Ëû£ËûßËû¨Ëû≠ËûÆËû±ËûµËûæËûøËüÅËüàËüâËüäËüéËüïËüñËüôËüöËüúËüüËü¢Ëü£Ëü§Ëü™Ëü´Ëü≠Ëü±Ëü≥Ëü∏Ëü∫ËüøË†ÅË†ÉË†ÜË†âË†äË†ãË†êË†ôË†íË†ìË†îË†òË†öË†õË†úË†ûË†üË†®Ë†≠Ë†ÆË†∞Ë†≤Ë†µ"],["8fdca1","Ë†∫Ë†ºË°ÅË°ÉË°ÖË°àË°âË°äË°ãË°éË°ëË°ïË°ñË°òË°öË°úË°üË°†Ë°§Ë°©Ë°±Ë°πË°ªË¢ÄË¢òË¢öË¢õË¢úË¢üË¢†Ë¢®Ë¢™Ë¢∫Ë¢ΩË¢æË£ÄË£ä",4,"Ë£ëË£íË£ìË£õË£ûË£ßË£ØË£∞Ë£±Ë£µË£∑Ë§ÅË§ÜË§çË§éË§èË§ïË§ñË§òË§ôË§öË§úË§†Ë§¶Ë§ßË§®Ë§∞Ë§±Ë§≤Ë§µË§πË§∫Ë§æË•ÄË•ÇË•ÖË•ÜË•âË•èË•íË•óË•öË•õË•úË•°Ë•¢Ë•£Ë•´Ë•ÆË•∞Ë•≥Ë•µË•∫"],["8fdda1","Ë•ªË•ºË•ΩË¶âË¶çË¶êË¶îË¶ïË¶õË¶úË¶üË¶†Ë¶•Ë¶∞Ë¶¥Ë¶µË¶∂Ë¶∑Ë¶ºËßî",4,"Ëß•Ëß©Ëß´Ëß≠Ëß±Ëß≥Ëß∂ËßπËßΩËßøË®ÑË®ÖË®áË®èË®ëË®íË®îË®ïË®ûË®†Ë®¢Ë®§Ë®¶Ë®´Ë®¨Ë®ØË®µË®∑Ë®ΩË®æË©ÄË©ÉË©ÖË©áË©âË©çË©éË©ìË©ñË©óË©òË©úË©ùË©°Ë©•Ë©ßË©µË©∂Ë©∑Ë©πË©∫Ë©ªË©æË©øË™ÄË™ÉË™ÜË™ãË™èË™êË™íË™ñË™óË™ôË™üË™ßË™©Ë™ÆË™ØË™≥"],["8fdea1","Ë™∂Ë™∑Ë™ªË™æË´ÉË´ÜË´àË´âË´äË´ëË´ìË´îË´ïË´óË´ùË´üË´¨Ë´∞Ë´¥Ë´µË´∂Ë´ºË´øË¨ÖË¨ÜË¨ãË¨ëË¨úË¨ûË¨üË¨äË¨≠Ë¨∞Ë¨∑Ë¨ºË≠Ç",4,"Ë≠àË≠íË≠ìË≠îË≠ôË≠çË≠ûË≠£Ë≠≠Ë≠∂Ë≠∏Ë≠πË≠ºË≠æËÆÅËÆÑËÆÖËÆãËÆçËÆèËÆîËÆïËÆúËÆûËÆüË∞∏Ë∞πË∞ΩË∞æË±ÖË±áË±âË±ãË±èË±ëË±ìË±îË±óË±òË±õË±ùË±ôË±£Ë±§Ë±¶Ë±®Ë±©Ë±≠Ë±≥Ë±µË±∂Ë±ªË±æË≤Ü"],["8fdfa1","Ë≤áË≤ãË≤êË≤íË≤ìË≤ôË≤õË≤úË≤§Ë≤πË≤∫Ë≥ÖË≥ÜË≥âË≥ãË≥èË≥ñË≥ïË≥ôË≥ùË≥°Ë≥®Ë≥¨Ë≥ØË≥∞Ë≥≤Ë≥µË≥∑Ë≥∏Ë≥æË≥øË¥ÅË¥ÉË¥âË¥íË¥óË¥õËµ•Ëµ©Ëµ¨ËµÆËµøË∂ÇË∂ÑË∂àË∂çË∂êË∂ëË∂ïË∂ûË∂üË∂†Ë∂¶Ë∂´Ë∂¨Ë∂ØË∂≤Ë∂µË∂∑Ë∂πË∂ªË∑ÄË∑ÖË∑ÜË∑áË∑àË∑äË∑éË∑ëË∑îË∑ïË∑óË∑ôË∑§Ë∑•Ë∑ßË∑¨Ë∑∞Ë∂ºË∑±Ë∑≤Ë∑¥Ë∑ΩË∏ÅË∏ÑË∏ÖË∏ÜË∏ãË∏ëË∏îË∏ñË∏†Ë∏°Ë∏¢"],["8fe0a1","Ë∏£Ë∏¶Ë∏ßË∏±Ë∏≥Ë∏∂Ë∏∑Ë∏∏Ë∏πË∏ΩËπÄËπÅËπãËπçËπéËπèËπîËπõËπúËπùËπûËπ°Ëπ¢Ëπ©Ëπ¨Ëπ≠ËπØËπ∞Ëπ±ËππËπ∫ËπªË∫ÇË∫ÉË∫âË∫êË∫íË∫ïË∫öË∫õË∫ùË∫ûË∫¢Ë∫ßË∫©Ë∫≠Ë∫ÆË∫≥Ë∫µË∫∫Ë∫ªËªÄËªÅËªÉËªÑËªáËªèËªëËªîËªúËª®ËªÆËª∞Ëª±Ëª∑ËªπËª∫Ëª≠ËºÄËºÇËºáËºàËºèËºêËºñËºóËºòËºûËº†Ëº°Ëº£Ëº•ËºßËº®Ëº¨Ëº≠ËºÆËº¥ËºµËº∂Ëº∑Ëº∫ËΩÄËΩÅ"],["8fe1a1","ËΩÉËΩáËΩèËΩë",4,"ËΩòËΩùËΩûËΩ•ËæùËæ†Ëæ°Ëæ§Ëæ•Ëæ¶ËæµËæ∂Ëæ∏ËææËøÄËøÅËøÜËøäËøãËøçËøêËøíËøìËøïËø†Ëø£Ëø§Ëø®ËøÆËø±ËøµËø∂ËøªËøæÈÄÇÈÄÑÈÄàÈÄåÈÄòÈÄõÈÄ®ÈÄ©ÈÄØÈÄ™ÈÄ¨ÈÄ≠ÈÄ≥ÈÄ¥ÈÄ∑ÈÄøÈÅÉÈÅÑÈÅåÈÅõÈÅùÈÅ¢ÈÅ¶ÈÅßÈÅ¨ÈÅ∞ÈÅ¥ÈÅπÈÇÖÈÇàÈÇãÈÇåÈÇéÈÇêÈÇïÈÇóÈÇòÈÇôÈÇõÈÇ†ÈÇ°ÈÇ¢ÈÇ•ÈÇ∞ÈÇ≤ÈÇ≥ÈÇ¥ÈÇ∂ÈÇΩÈÉåÈÇæÈÉÉ"],["8fe2a1","ÈÉÑÈÉÖÈÉáÈÉàÈÉïÈÉóÈÉòÈÉôÈÉúÈÉùÈÉüÈÉ•ÈÉíÈÉ∂ÈÉ´ÈÉØÈÉ∞ÈÉ¥ÈÉæÈÉøÈÑÄÈÑÑÈÑÖÈÑÜÈÑàÈÑçÈÑêÈÑîÈÑñÈÑóÈÑòÈÑöÈÑúÈÑûÈÑ†ÈÑ•ÈÑ¢ÈÑ£ÈÑßÈÑ©ÈÑÆÈÑØÈÑ±ÈÑ¥ÈÑ∂ÈÑ∑ÈÑπÈÑ∫ÈÑºÈÑΩÈÖÉÈÖáÈÖàÈÖèÈÖìÈÖóÈÖôÈÖöÈÖõÈÖ°ÈÖ§ÈÖßÈÖ≠ÈÖ¥ÈÖπÈÖ∫ÈÖªÈÜÅÈÜÉÈÜÖÈÜÜÈÜäÈÜéÈÜëÈÜìÈÜîÈÜïÈÜòÈÜûÈÜ°ÈÜ¶ÈÜ®ÈÜ¨ÈÜ≠ÈÜÆÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜªÈÜºÈÜΩÈÜø"],["8fe3a1","ÈáÇÈáÉÈáÖÈáìÈáîÈáóÈáôÈáöÈáûÈá§Èá•Èá©Èá™Èá¨",5,"Èá∑ÈáπÈáªÈáΩÈàÄÈàÅÈàÑÈàÖÈàÜÈàáÈàâÈàäÈàåÈàêÈàíÈàìÈàñÈàòÈàúÈàùÈà£Èà§Èà•Èà¶Èà®ÈàÆÈàØÈà∞Èà≥ÈàµÈà∂Èà∏ÈàπÈà∫ÈàºÈàæÈâÄÈâÇÈâÉÈâÜÈâáÈâäÈâçÈâéÈâèÈâëÈâòÈâôÈâúÈâùÈâ†Èâ°Èâ•ÈâßÈâ®Èâ©ÈâÆÈâØÈâ∞Èâµ",4,"ÈâªÈâºÈâΩÈâøÈäàÈäâÈääÈäçÈäéÈäíÈäó"],["8fe4a1","ÈäôÈäüÈä†Èä§Èä•ÈäßÈä®Èä´ÈäØÈä≤Èä∂Èä∏Èä∫ÈäªÈäºÈäΩÈäø",4,"ÈãÖÈãÜÈãáÈãàÈããÈãåÈãçÈãéÈãêÈãìÈãïÈãóÈãòÈãôÈãúÈãùÈãüÈã†Èã°Èã£Èã•ÈãßÈã®Èã¨ÈãÆÈã∞ÈãπÈãªÈãøÈåÄÈåÇÈåàÈåçÈåëÈåîÈåïÈåúÈåùÈåûÈåüÈå°Èå§Èå•ÈåßÈå©Èå™Èå≥Èå¥Èå∂Èå∑ÈçáÈçàÈçâÈçêÈçëÈçíÈçïÈçóÈçòÈçöÈçûÈç§Èç•ÈçßÈç©Èç™Èç≠ÈçØÈç∞Èç±Èç≥Èç¥Èç∂"],["8fe5a1","Èç∫ÈçΩÈçøÈéÄÈéÅÈéÇÈéàÈéäÈéãÈéçÈéèÈéíÈéïÈéòÈéõÈéûÈé°Èé£Èé§Èé¶Èé®Èé´Èé¥ÈéµÈé∂Èé∫Èé©ÈèÅÈèÑÈèÖÈèÜÈèáÈèâ",4,"ÈèìÈèôÈèúÈèûÈèüÈè¢Èè¶ÈèßÈèπÈè∑Èè∏Èè∫ÈèªÈèΩÈêÅÈêÇÈêÑÈêàÈêâÈêçÈêéÈêèÈêïÈêñÈêóÈêüÈêÆÈêØÈê±Èê≤Èê≥Èê¥ÈêªÈêøÈêΩÈëÉÈëÖÈëàÈëäÈëåÈëïÈëôÈëúÈëüÈë°Èë£Èë®Èë´Èë≠ÈëÆÈëØÈë±Èë≤ÈíÑÈíÉÈï∏Èïπ"],["8fe6a1","ÈïæÈñÑÈñàÈñåÈñçÈñéÈñùÈñûÈñüÈñ°Èñ¶Èñ©Èñ´Èñ¨Èñ¥Èñ∂Èñ∫ÈñΩÈñøÈóÜÈóàÈóâÈóãÈóêÈóëÈóíÈóìÈóôÈóöÈóùÈóûÈóüÈó†Èó§Èó¶ÈòùÈòûÈò¢Èò§Èò•Èò¶Èò¨Èò±Èò≥Èò∑Èò∏ÈòπÈò∫ÈòºÈòΩÈôÅÈôíÈôîÈôñÈôóÈôòÈô°ÈôÆÈô¥ÈôªÈôºÈôæÈôøÈöÅÈöÇÈöÉÈöÑÈöâÈöëÈöñÈööÈöùÈöüÈö§Èö•Èö¶Èö©ÈöÆÈöØÈö≥Èö∫ÈõäÈõíÂ∂≤ÈõòÈõöÈõùÈõûÈõüÈõ©ÈõØÈõ±Èõ∫ÈúÇ"],["8fe7a1","ÈúÉÈúÖÈúâÈúöÈúõÈúùÈú°Èú¢Èú£Èú®Èú±Èú≥ÈùÅÈùÉÈùäÈùéÈùèÈùïÈùóÈùòÈùöÈùõÈù£ÈùßÈù™ÈùÆÈù≥Èù∂Èù∑Èù∏ÈùªÈùΩÈùøÈûÄÈûâÈûïÈûñÈûóÈûôÈûöÈûûÈûüÈû¢Èû¨ÈûÆÈû±Èû≤ÈûµÈû∂Èû∏ÈûπÈû∫ÈûºÈûæÈûøÈüÅÈüÑÈüÖÈüáÈüâÈüäÈüåÈüçÈüéÈüêÈüëÈüîÈüóÈüòÈüôÈüùÈüûÈü†ÈüõÈü°Èü§ÈüØÈü±Èü¥Èü∑Èü∏Èü∫È†áÈ†äÈ†ôÈ†çÈ†éÈ†îÈ†ñÈ†úÈ†ûÈ††È†£È†¶"],["8fe8a1","È†´È†ÆÈ†ØÈ†∞È†≤È†≥È†µÈ†•È†æÈ°ÑÈ°áÈ°äÈ°ëÈ°íÈ°ìÈ°ñÈ°óÈ°ôÈ°öÈ°¢È°£È°•È°¶È°™È°¨È¢´È¢≠È¢ÆÈ¢∞È¢¥È¢∑È¢∏È¢∫È¢ªÈ¢øÈ£ÇÈ£ÖÈ£àÈ£åÈ£°È££È£•È£¶È£ßÈ£™È£≥È£∂È§ÇÈ§áÈ§àÈ§ëÈ§ïÈ§ñÈ§óÈ§öÈ§õÈ§úÈ§üÈ§¢È§¶È§ßÈ§´È§±",4,"È§πÈ§∫È§ªÈ§ºÈ•ÄÈ•ÅÈ•ÜÈ•áÈ•àÈ•çÈ•éÈ•îÈ•òÈ•ôÈ•õÈ•úÈ•ûÈ•üÈ•†È¶õÈ¶ùÈ¶üÈ¶¶È¶∞È¶±È¶≤È¶µ"],["8fe9a1","È¶πÈ¶∫È¶ΩÈ¶øÈßÉÈßâÈßìÈßîÈßôÈßöÈßúÈßûÈßßÈß™Èß´Èß¨Èß∞Èß¥ÈßµÈßπÈßΩÈßæÈ®ÇÈ®ÉÈ®ÑÈ®ãÈ®åÈ®êÈ®ëÈ®ñÈ®ûÈ®†È®¢È®£È®§È®ßÈ®≠È®ÆÈ®≥È®µÈ®∂È®∏È©áÈ©ÅÈ©ÑÈ©äÈ©ãÈ©åÈ©éÈ©ëÈ©îÈ©ñÈ©ùÈ™™È™¨È™ÆÈ™ØÈ™≤È™¥È™µÈ™∂È™πÈ™ªÈ™æÈ™øÈ´ÅÈ´ÉÈ´ÜÈ´àÈ´éÈ´êÈ´íÈ´ïÈ´ñÈ´óÈ´õÈ´úÈ´†È´§È´•È´ßÈ´©È´¨È´≤È´≥È´µÈ´πÈ´∫È´ΩÈ´ø",4],["8feaa1","È¨ÑÈ¨ÖÈ¨àÈ¨âÈ¨ãÈ¨åÈ¨çÈ¨éÈ¨êÈ¨íÈ¨ñÈ¨ôÈ¨õÈ¨úÈ¨†È¨¶È¨´È¨≠È¨≥È¨¥È¨µÈ¨∑È¨πÈ¨∫È¨ΩÈ≠àÈ≠ãÈ≠åÈ≠ïÈ≠ñÈ≠óÈ≠õÈ≠ûÈ≠°È≠£È≠•È≠¶È≠®È≠™",4,"È≠≥È≠µÈ≠∑È≠∏È≠πÈ≠øÈÆÄÈÆÑÈÆÖÈÆÜÈÆáÈÆâÈÆäÈÆãÈÆçÈÆèÈÆêÈÆîÈÆöÈÆùÈÆûÈÆ¶ÈÆßÈÆ©ÈÆ¨ÈÆ∞ÈÆ±ÈÆ≤ÈÆ∑ÈÆ∏ÈÆªÈÆºÈÆæÈÆøÈØÅÈØáÈØàÈØéÈØêÈØóÈØòÈØùÈØüÈØ•ÈØßÈØ™ÈØ´ÈØØÈØ≥ÈØ∑ÈØ∏"],["8feba1","ÈØπÈØ∫ÈØΩÈØøÈ∞ÄÈ∞ÇÈ∞ãÈ∞èÈ∞ëÈ∞ñÈ∞òÈ∞ôÈ∞öÈ∞úÈ∞ûÈ∞¢È∞£È∞¶",4,"È∞±È∞µÈ∞∂È∞∑È∞ΩÈ±ÅÈ±ÉÈ±ÑÈ±ÖÈ±âÈ±äÈ±éÈ±èÈ±êÈ±ìÈ±îÈ±ñÈ±òÈ±õÈ±ùÈ±ûÈ±üÈ±£È±©È±™È±úÈ±´È±®È±ÆÈ±∞È±≤È±µÈ±∑È±ªÈ≥¶È≥≤È≥∑È≥πÈ¥ãÈ¥ÇÈ¥ëÈ¥óÈ¥òÈ¥úÈ¥ùÈ¥ûÈ¥ØÈ¥∞È¥≤È¥≥È¥¥È¥∫È¥ºÈµÖÈ¥ΩÈµÇÈµÉÈµáÈµäÈµìÈµîÈµüÈµ£Èµ¢Èµ•Èµ©Èµ™Èµ´Èµ∞Èµ∂Èµ∑Èµª"],["8feca1","ÈµºÈµæÈ∂ÉÈ∂ÑÈ∂ÜÈ∂äÈ∂çÈ∂éÈ∂íÈ∂ìÈ∂ïÈ∂ñÈ∂óÈ∂òÈ∂°È∂™È∂¨È∂ÆÈ∂±È∂µÈ∂πÈ∂ºÈ∂øÈ∑ÉÈ∑áÈ∑âÈ∑äÈ∑îÈ∑ïÈ∑ñÈ∑óÈ∑öÈ∑ûÈ∑üÈ∑†È∑•È∑ßÈ∑©È∑´È∑ÆÈ∑∞È∑≥È∑¥È∑æÈ∏äÈ∏ÇÈ∏áÈ∏éÈ∏êÈ∏ëÈ∏íÈ∏ïÈ∏ñÈ∏ôÈ∏úÈ∏ùÈπ∫ÈπªÈπºÈ∫ÄÈ∫ÇÈ∫ÉÈ∫ÑÈ∫ÖÈ∫áÈ∫éÈ∫èÈ∫ñÈ∫òÈ∫õÈ∫ûÈ∫§È∫®È∫¨È∫ÆÈ∫ØÈ∫∞È∫≥È∫¥È∫µÈªÜÈªàÈªãÈªïÈªüÈª§ÈªßÈª¨Èª≠ÈªÆÈª∞Èª±Èª≤Èªµ"],["8feda1","Èª∏ÈªøÈºÇÈºÉÈºâÈºèÈºêÈºëÈºíÈºîÈºñÈºóÈºôÈºöÈºõÈºüÈº¢Èº¶Èº™Èº´ÈºØÈº±Èº≤Èº¥Èº∑ÈºπÈº∫ÈººÈºΩÈºøÈΩÅÈΩÉ",4,"ÈΩìÈΩïÈΩñÈΩóÈΩòÈΩöÈΩùÈΩûÈΩ®ÈΩ©ÈΩ≠",4,"ÈΩ≥ÈΩµÈΩ∫ÈΩΩÈæèÈæêÈæëÈæíÈæîÈæñÈæóÈæûÈæ°Èæ¢Èæ£Èæ•"]]');

/***/ }),
/* 97 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127,"‚Ç¨"],["8140","‰∏Ç‰∏Ñ‰∏Ö‰∏Ü‰∏è‰∏í‰∏ó‰∏ü‰∏†‰∏°‰∏£‰∏¶‰∏©‰∏Æ‰∏Ø‰∏±‰∏≥‰∏µ‰∏∑‰∏º‰πÄ‰πÅ‰πÇ‰πÑ‰πÜ‰πä‰πë‰πï‰πó‰πö‰πõ‰π¢‰π£‰π§‰π•‰πß‰π®‰π™",5,"‰π≤‰π¥",9,"‰πø",6,"‰∫á‰∫ä"],["8180","‰∫ê‰∫ñ‰∫ó‰∫ô‰∫ú‰∫ù‰∫û‰∫£‰∫™‰∫Ø‰∫∞‰∫±‰∫¥‰∫∂‰∫∑‰∫∏‰∫π‰∫º‰∫Ω‰∫æ‰ªà‰ªå‰ªè‰ªê‰ªí‰ªö‰ªõ‰ªú‰ª†‰ª¢‰ª¶‰ªß‰ª©‰ª≠‰ªÆ‰ªØ‰ª±‰ª¥‰ª∏‰ªπ‰ª∫‰ªº‰ªæ‰ºÄ‰ºÇ",6,"‰ºã‰ºå‰ºí",4,"‰ºú‰ºù‰º°‰º£‰º®‰º©‰º¨‰º≠‰ºÆ‰º±‰º≥‰ºµ‰º∑‰ºπ‰ºª‰ºæ",4,"‰ΩÑ‰ΩÖ‰Ωá",5,"‰Ωí‰Ωî‰Ωñ‰Ω°‰Ω¢‰Ω¶‰Ω®‰Ω™‰Ω´‰Ω≠‰ΩÆ‰Ω±‰Ω≤‰Ωµ‰Ω∑‰Ω∏‰Ωπ‰Ω∫‰ΩΩ‰æÄ‰æÅ‰æÇ‰æÖ‰æÜ‰æá‰æä‰æå‰æé‰æê‰æí‰æì‰æï‰æñ‰æò‰æô‰æö‰æú‰æû‰æü‰æ°‰æ¢"],["8240","‰æ§‰æ´‰æ≠‰æ∞",4,"‰æ∂",8,"‰øÄ‰øÅ‰øÇ‰øÜ‰øá‰øà‰øâ‰øã‰øå‰øç‰øí",4,"‰øô‰øõ‰ø†‰ø¢‰ø§‰ø•‰øß‰ø´‰ø¨‰ø∞‰ø≤‰ø¥‰øµ‰ø∂‰ø∑‰øπ‰øª‰øº‰øΩ‰øø",11],["8280","ÂÄãÂÄéÂÄêÂÄëÂÄìÂÄïÂÄñÂÄóÂÄõÂÄùÂÄûÂÄ†ÂÄ¢ÂÄ£ÂÄ§ÂÄßÂÄ´ÂÄØ",10,"ÂÄªÂÄΩÂÄøÂÅÄÂÅÅÂÅÇÂÅÑÂÅÖÂÅÜÂÅâÂÅäÂÅãÂÅçÂÅê",4,"ÂÅñÂÅóÂÅòÂÅôÂÅõÂÅù",7,"ÂÅ¶",5,"ÂÅ≠",8,"ÂÅ∏ÂÅπÂÅ∫ÂÅºÂÅΩÂÇÅÂÇÇÂÇÉÂÇÑÂÇÜÂÇáÂÇâÂÇäÂÇãÂÇåÂÇé",20,"ÂÇ§ÂÇ¶ÂÇ™ÂÇ´ÂÇ≠",4,"ÂÇ≥",6,"ÂÇº"],["8340","ÂÇΩ",17,"ÂÉê",5,"ÂÉóÂÉòÂÉôÂÉõ",10,"ÂÉ®ÂÉ©ÂÉ™ÂÉ´ÂÉØÂÉ∞ÂÉ±ÂÉ≤ÂÉ¥ÂÉ∂",4,"ÂÉº",9,"ÂÑà"],["8380","ÂÑâÂÑäÂÑå",5,"ÂÑì",13,"ÂÑ¢",28,"ÂÖÇÂÖáÂÖäÂÖåÂÖéÂÖèÂÖêÂÖíÂÖìÂÖóÂÖòÂÖôÂÖõÂÖù",4,"ÂÖ£ÂÖ§ÂÖ¶ÂÖßÂÖ©ÂÖ™ÂÖØÂÖ≤ÂÖ∫ÂÖæÂÖøÂÜÉÂÜÑÂÜÜÂÜáÂÜäÂÜãÂÜéÂÜèÂÜêÂÜëÂÜìÂÜîÂÜòÂÜöÂÜùÂÜûÂÜüÂÜ°ÂÜ£ÂÜ¶",4,"ÂÜ≠ÂÜÆÂÜ¥ÂÜ∏ÂÜπÂÜ∫ÂÜæÂÜøÂáÅÂáÇÂáÉÂáÖÂáàÂáäÂáçÂáéÂáêÂáí",5],["8440","ÂáòÂáôÂáöÂáúÂáûÂáüÂá¢Âá£Âá•",5,"Âá¨ÂáÆÂá±Âá≤Âá¥Âá∑ÂáæÂàÑÂàÖÂàâÂàãÂàåÂàèÂàêÂàìÂàîÂàïÂàúÂàûÂàüÂà°Âà¢Âà£Âà•Âà¶ÂàßÂà™Âà¨ÂàØÂà±Âà≤Âà¥ÂàµÂàºÂàæÂâÑ",5,"ÂâãÂâéÂâèÂâíÂâìÂâïÂâóÂâò"],["8480","ÂâôÂâöÂâõÂâùÂâüÂâ†Ââ¢Ââ£Ââ§Ââ¶Ââ®Ââ´Ââ¨Ââ≠ÂâÆÂâ∞Ââ±Ââ≥",9,"ÂâæÂäÄÂäÉ",4,"Âäâ",6,"ÂäëÂäíÂäî",6,"ÂäúÂä§Âä•Âä¶ÂäßÂäÆÂäØÂä∞Âä¥",9,"ÂãÄÂãÅÂãÇÂãÑÂãÖÂãÜÂãàÂãäÂãåÂãçÂãéÂãèÂãëÂãìÂãîÂãïÂãóÂãô",5,"Âã†Âã°Âã¢Âã£Âã•",10,"Âã±",7,"ÂãªÂãºÂãΩÂåÅÂåÇÂåÉÂåÑÂåáÂåâÂåäÂåãÂååÂåé"],["8540","ÂåëÂåíÂåìÂåîÂåòÂåõÂåúÂåûÂåüÂå¢Âå§Âå•ÂåßÂå®Âå©Âå´Âå¨Âå≠ÂåØ",9,"ÂåºÂåΩÂçÄÂçÇÂçÑÂçÜÂçãÂçåÂççÂçêÂçîÂçòÂçôÂçõÂçùÂç•Âç®Âç™Âç¨Âç≠Âç≤Âç∂ÂçπÂçªÂçºÂçΩÂçæÂéÄÂéÅÂéÉÂéáÂéàÂéäÂééÂéè"],["8580","Âéê",4,"ÂéñÂéóÂéôÂéõÂéúÂéûÂé†Âé°Âé§ÂéßÂé™Âé´Âé¨Âé≠ÂéØ",6,"Âé∑Âé∏ÂéπÂé∫ÂéºÂéΩÂéæÂèÄÂèÉ",4,"ÂèéÂèèÂèêÂèíÂèìÂèïÂèöÂèúÂèùÂèûÂè°Âè¢ÂèßÂè¥Âè∫ÂèæÂèøÂêÄÂêÇÂêÖÂêáÂêãÂêîÂêòÂêôÂêöÂêúÂê¢Âê§Âê•Âê™Âê∞Âê≥Âê∂Âê∑Âê∫ÂêΩÂêøÂëÅÂëÇÂëÑÂëÖÂëáÂëâÂëåÂëçÂëéÂëèÂëëÂëöÂëù",4,"Âë£Âë•ÂëßÂë©",7,"Âë¥ÂëπÂë∫ÂëæÂëøÂíÅÂíÉÂíÖÂíáÂíàÂíâÂíäÂíçÂíëÂíìÂíóÂíòÂíúÂíûÂíüÂí†Âí°"],["8640","Âí¢Âí•ÂíÆÂí∞Âí≤ÂíµÂí∂Âí∑ÂíπÂí∫ÂíºÂíæÂìÉÂìÖÂìäÂìãÂìñÂìòÂìõÂì†",4,"Âì´Âì¨ÂìØÂì∞Âì±Âì¥",5,"ÂìªÂìæÂîÄÂîÇÂîÉÂîÑÂîÖÂîàÂîä",4,"ÂîíÂîìÂîï",5,"ÂîúÂîùÂîûÂîüÂî°Âî•Âî¶"],["8680","Âî®Âî©Âî´Âî≠Âî≤Âî¥ÂîµÂî∂Âî∏ÂîπÂî∫ÂîªÂîΩÂïÄÂïÇÂïÖÂïáÂïàÂïã",4,"ÂïëÂïíÂïìÂïîÂïó",4,"ÂïùÂïûÂïüÂï†Âï¢Âï£Âï®Âï©Âï´ÂïØ",5,"ÂïπÂï∫ÂïΩÂïøÂñÖÂñÜÂñåÂñçÂñéÂñêÂñíÂñìÂñïÂññÂñóÂñöÂñõÂñûÂñ†",6,"Âñ®",8,"Âñ≤Âñ¥Âñ∂Âñ∏Âñ∫ÂñºÂñø",4,"ÂóÜÂóáÂóàÂóäÂóãÂóéÂóèÂóêÂóïÂóó",4,"ÂóûÂó†Âó¢ÂóßÂó©Âó≠ÂóÆÂó∞Âó±Âó¥Âó∂Âó∏",4,"ÂóøÂòÇÂòÉÂòÑÂòÖ"],["8740","ÂòÜÂòáÂòäÂòãÂòçÂòê",7,"ÂòôÂòöÂòúÂòùÂò†Âò°Âò¢Âò•Âò¶Âò®Âò©Âò™Âò´ÂòÆÂòØÂò∞Âò≥ÂòµÂò∑Âò∏Âò∫ÂòºÂòΩÂòæÂôÄ",11,"Âôè",4,"ÂôïÂôñÂôöÂôõÂôù",4],["8780","Âô£Âô•Âô¶ÂôßÂô≠ÂôÆÂôØÂô∞Âô≤Âô≥Âô¥ÂôµÂô∑Âô∏ÂôπÂô∫ÂôΩ",7,"Âöá",6,"ÂöêÂöëÂöíÂöî",14,"Âö§",10,"Âö∞",6,"Âö∏ÂöπÂö∫ÂöªÂöΩ",12,"Âõã",8,"ÂõïÂõñÂõòÂõôÂõúÂõ£Âõ•",5,"Âõ¨ÂõÆÂõØÂõ≤Âõ≥Âõ∂Âõ∑Âõ∏ÂõªÂõºÂúÄÂúÅÂúÇÂúÖÂúáÂúã",6],["8840","Âúí",9,"ÂúùÂúûÂú†Âú°Âú¢Âú§Âú•Âú¶ÂúßÂú´Âú±Âú≤Âú¥",4,"ÂúºÂúΩÂúøÂùÅÂùÉÂùÑÂùÖÂùÜÂùàÂùâÂùãÂùí",4,"ÂùòÂùôÂù¢Âù£Âù•ÂùßÂù¨ÂùÆÂù∞Âù±Âù≤Âù¥ÂùµÂù∏ÂùπÂù∫ÂùΩÂùæÂùøÂûÄ"],["8880","ÂûÅÂûáÂûàÂûâÂûäÂûç",4,"Âûî",6,"ÂûúÂûùÂûûÂûüÂû•Âû®Âû™Âû¨ÂûØÂû∞Âû±Âû≥ÂûµÂû∂Âû∑Âûπ",8,"ÂüÑ",6,"ÂüåÂüçÂüêÂüëÂüìÂüñÂüóÂüõÂüúÂüûÂü°Âü¢Âü£Âü•",7,"ÂüÆÂü∞Âü±Âü≤Âü≥ÂüµÂü∂Âü∑ÂüªÂüºÂüæÂüøÂ†ÅÂ†ÉÂ†ÑÂ†ÖÂ†àÂ†âÂ†äÂ†åÂ†éÂ†èÂ†êÂ†íÂ†ìÂ†îÂ†ñÂ†óÂ†òÂ†öÂ†õÂ†úÂ†ùÂ†üÂ†¢Â†£Â†•",4,"Â†´",4,"Â†±Â†≤Â†≥Â†¥Â†∂",7],["8940","Â†æ",5,"Â°Ö",6,"Â°éÂ°èÂ°êÂ°íÂ°ìÂ°ïÂ°ñÂ°óÂ°ô",4,"Â°ü",5,"Â°¶",4,"Â°≠",16,"Â°øÂ¢ÇÂ¢ÑÂ¢ÜÂ¢áÂ¢àÂ¢äÂ¢ãÂ¢å"],["8980","Â¢ç",4,"Â¢î",4,"Â¢õÂ¢úÂ¢ùÂ¢†",7,"Â¢™",17,"Â¢ΩÂ¢æÂ¢øÂ£ÄÂ£ÇÂ£ÉÂ£ÑÂ£Ü",10,"Â£íÂ£ìÂ£îÂ£ñ",13,"Â£•",5,"Â£≠Â£ØÂ£±Â£≤Â£¥Â£µÂ£∑Â£∏Â£∫",7,"Â§ÉÂ§ÖÂ§ÜÂ§à",4,"Â§éÂ§êÂ§ëÂ§íÂ§ìÂ§óÂ§òÂ§õÂ§ùÂ§ûÂ§†Â§°Â§¢Â§£Â§¶Â§®Â§¨Â§∞Â§≤Â§≥Â§µÂ§∂Â§ª"],["8a40","Â§ΩÂ§æÂ§øÂ•ÄÂ•ÉÂ•ÖÂ•ÜÂ•äÂ•åÂ•çÂ•êÂ•íÂ•ìÂ•ôÂ•õ",4,"Â•°Â•£Â•§Â•¶",12,"Â•µÂ•∑Â•∫Â•ªÂ•ºÂ•æÂ•øÂ¶ÄÂ¶ÖÂ¶âÂ¶ãÂ¶åÂ¶éÂ¶èÂ¶êÂ¶ëÂ¶îÂ¶ïÂ¶òÂ¶öÂ¶õÂ¶úÂ¶ùÂ¶üÂ¶†Â¶°Â¶¢Â¶¶"],["8a80","Â¶ßÂ¶¨Â¶≠Â¶∞Â¶±Â¶≥",5,"Â¶∫Â¶ºÂ¶ΩÂ¶ø",6,"ÂßáÂßàÂßâÂßåÂßçÂßéÂßèÂßïÂßñÂßôÂßõÂßû",4,"Âß§Âß¶ÂßßÂß©Âß™Âß´Âß≠",11,"Âß∫ÂßºÂßΩÂßæÂ®ÄÂ®ÇÂ®äÂ®ãÂ®çÂ®éÂ®èÂ®êÂ®íÂ®îÂ®ïÂ®ñÂ®óÂ®ôÂ®öÂ®õÂ®ùÂ®ûÂ®°Â®¢Â®§Â®¶Â®ßÂ®®Â®™",6,"Â®≥Â®µÂ®∑",4,"Â®ΩÂ®æÂ®øÂ©Å",4,"Â©áÂ©àÂ©ã",9,"Â©ñÂ©óÂ©òÂ©ôÂ©õ",5],["8b40","Â©°Â©£Â©§Â©•Â©¶Â©®Â©©Â©´",8,"Â©∏Â©πÂ©ªÂ©ºÂ©ΩÂ©æÂ™Ä",17,"Â™ì",6,"Â™ú",13,"Â™´Â™¨"],["8b80","Â™≠",4,"Â™¥Â™∂Â™∑Â™π",4,"Â™øÂ´ÄÂ´É",5,"Â´äÂ´ãÂ´ç",4,"Â´ìÂ´ïÂ´óÂ´ôÂ´öÂ´õÂ´ùÂ´ûÂ´üÂ´¢Â´§Â´•Â´ßÂ´®Â´™Â´¨",4,"Â´≤",22,"Â¨ä",11,"Â¨ò",25,"Â¨≥Â¨µÂ¨∂Â¨∏",7,"Â≠Å",6],["8c40","Â≠à",7,"Â≠íÂ≠ñÂ≠ûÂ≠†Â≠°Â≠ßÂ≠®Â≠´Â≠≠Â≠ÆÂ≠ØÂ≠≤Â≠¥Â≠∂Â≠∑Â≠∏Â≠πÂ≠ªÂ≠ºÂ≠æÂ≠øÂÆÇÂÆÜÂÆäÂÆçÂÆéÂÆêÂÆëÂÆíÂÆîÂÆñÂÆüÂÆßÂÆ®ÂÆ©ÂÆ¨ÂÆ≠ÂÆÆÂÆØÂÆ±ÂÆ≤ÂÆ∑ÂÆ∫ÂÆªÂÆºÂØÄÂØÅÂØÉÂØàÂØâÂØäÂØãÂØçÂØéÂØè"],["8c80","ÂØëÂØî",8,"ÂØ†ÂØ¢ÂØ£ÂØ¶ÂØßÂØ©",4,"ÂØØÂØ±",6,"ÂØΩÂØæÂ∞ÄÂ∞ÇÂ∞ÉÂ∞ÖÂ∞áÂ∞àÂ∞ãÂ∞åÂ∞çÂ∞éÂ∞êÂ∞íÂ∞ìÂ∞óÂ∞ôÂ∞õÂ∞ûÂ∞üÂ∞†Â∞°Â∞£Â∞¶Â∞®Â∞©Â∞™Â∞´Â∞≠Â∞ÆÂ∞ØÂ∞∞Â∞≤Â∞≥Â∞µÂ∞∂Â∞∑Â±ÉÂ±ÑÂ±ÜÂ±áÂ±åÂ±çÂ±íÂ±ìÂ±îÂ±ñÂ±óÂ±òÂ±öÂ±õÂ±úÂ±ùÂ±üÂ±¢Â±§Â±ß",6,"Â±∞Â±≤",6,"Â±ªÂ±ºÂ±ΩÂ±æÂ≤ÄÂ≤É",4,"Â≤âÂ≤äÂ≤ãÂ≤éÂ≤èÂ≤íÂ≤ìÂ≤ïÂ≤ù",4,"Â≤§",4],["8d40","Â≤™Â≤ÆÂ≤ØÂ≤∞Â≤≤Â≤¥Â≤∂Â≤πÂ≤∫Â≤ªÂ≤ºÂ≤æÂ≥ÄÂ≥ÇÂ≥ÉÂ≥Ö",5,"Â≥å",5,"Â≥ì",5,"Â≥ö",6,"Â≥¢Â≥£Â≥ßÂ≥©Â≥´Â≥¨Â≥ÆÂ≥ØÂ≥±",9,"Â≥º",4],["8d80","Â¥ÅÂ¥ÑÂ¥ÖÂ¥à",5,"Â¥è",4,"Â¥ïÂ¥óÂ¥òÂ¥ôÂ¥öÂ¥úÂ¥ùÂ¥ü",4,"Â¥•Â¥®Â¥™Â¥´Â¥¨Â¥Ø",4,"Â¥µ",7,"Â¥ø",7,"ÂµàÂµâÂµç",10,"ÂµôÂµöÂµúÂµû",10,"Âµ™Âµ≠ÂµÆÂµ∞Âµ±Âµ≤Âµ≥Âµµ",12,"Â∂É",21,"Â∂öÂ∂õÂ∂úÂ∂ûÂ∂üÂ∂†"],["8e40","Â∂°",21,"Â∂∏",12,"Â∑Ü",6,"Â∑é",12,"Â∑úÂ∑üÂ∑†Â∑£Â∑§Â∑™Â∑¨Â∑≠"],["8e80","Â∑∞Â∑µÂ∑∂Â∑∏",4,"Â∑øÂ∏ÄÂ∏ÑÂ∏áÂ∏âÂ∏äÂ∏ãÂ∏çÂ∏éÂ∏íÂ∏ìÂ∏óÂ∏û",7,"Â∏®",4,"Â∏ØÂ∏∞Â∏≤",4,"Â∏πÂ∏∫Â∏æÂ∏øÂπÄÂπÅÂπÉÂπÜ",5,"Âπç",6,"Âπñ",4,"ÂπúÂπùÂπüÂπ†Âπ£",14,"ÂπµÂπ∑ÂππÂπæÂ∫ÅÂ∫ÇÂ∫ÉÂ∫ÖÂ∫àÂ∫âÂ∫åÂ∫çÂ∫éÂ∫íÂ∫òÂ∫õÂ∫ùÂ∫°Â∫¢Â∫£Â∫§Â∫®",4,"Â∫Æ",4,"Â∫¥Â∫∫Â∫ªÂ∫ºÂ∫ΩÂ∫ø",6],["8f40","ÂªÜÂªáÂªàÂªã",5,"ÂªîÂªïÂªóÂªòÂªôÂªöÂªú",11,"Âª©Âª´",8,"ÂªµÂª∏ÂªπÂªªÂªºÂªΩÂºÖÂºÜÂºáÂºâÂºåÂºçÂºéÂºêÂºíÂºîÂºñÂºôÂºöÂºúÂºùÂºûÂº°Âº¢Âº£Âº§"],["8f80","Âº®Âº´Âº¨ÂºÆÂº∞Âº≤",6,"ÂºªÂºΩÂºæÂºøÂΩÅ",14,"ÂΩëÂΩîÂΩôÂΩöÂΩõÂΩúÂΩûÂΩüÂΩ†ÂΩ£ÂΩ•ÂΩßÂΩ®ÂΩ´ÂΩÆÂΩØÂΩ≤ÂΩ¥ÂΩµÂΩ∂ÂΩ∏ÂΩ∫ÂΩΩÂΩæÂΩøÂæÉÂæÜÂæçÂæéÂæèÂæëÂæìÂæîÂæñÂæöÂæõÂæùÂæûÂæüÂæ†Âæ¢",5,"Âæ©Âæ´Âæ¨ÂæØ",5,"Âæ∂Âæ∏ÂæπÂæ∫ÂæªÂææ",4,"ÂøáÂøàÂøäÂøãÂøéÂøìÂøîÂøïÂøöÂøõÂøúÂøûÂøüÂø¢Âø£Âø•Âø¶Âø®Âø©Âø¨ÂøØÂø∞Âø≤Âø≥Âø¥Âø∂Âø∑ÂøπÂø∫ÂøºÊÄá"],["9040","ÊÄàÊÄâÊÄãÊÄåÊÄêÊÄëÊÄìÊÄóÊÄòÊÄöÊÄûÊÄüÊÄ¢ÊÄ£ÊÄ§ÊÄ¨ÊÄ≠ÊÄÆÊÄ∞",4,"ÊÄ∂",4,"ÊÄΩÊÄæÊÅÄÊÅÑ",6,"ÊÅåÊÅéÊÅèÊÅëÊÅìÊÅîÊÅñÊÅóÊÅòÊÅõÊÅúÊÅûÊÅüÊÅ†ÊÅ°ÊÅ•ÊÅ¶ÊÅÆÊÅ±ÊÅ≤ÊÅ¥ÊÅµÊÅ∑ÊÅæÊÇÄ"],["9080","ÊÇÅÊÇÇÊÇÖÊÇÜÊÇáÊÇàÊÇäÊÇãÊÇéÊÇèÊÇêÊÇëÊÇìÊÇïÊÇóÊÇòÊÇôÊÇúÊÇûÊÇ°ÊÇ¢ÊÇ§ÊÇ•ÊÇßÊÇ©ÊÇ™ÊÇÆÊÇ∞ÊÇ≥ÊÇµÊÇ∂ÊÇ∑ÊÇπÊÇ∫ÊÇΩ",7,"ÊÉáÊÉàÊÉâÊÉå",4,"ÊÉíÊÉìÊÉîÊÉñÊÉóÊÉôÊÉõÊÉûÊÉ°",4,"ÊÉ™ÊÉ±ÊÉ≤ÊÉµÊÉ∑ÊÉ∏ÊÉª",4,"ÊÑÇÊÑÉÊÑÑÊÑÖÊÑáÊÑäÊÑãÊÑåÊÑê",4,"ÊÑñÊÑóÊÑòÊÑôÊÑõÊÑúÊÑùÊÑûÊÑ°ÊÑ¢ÊÑ•ÊÑ®ÊÑ©ÊÑ™ÊÑ¨",18,"ÊÖÄ",6],["9140","ÊÖáÊÖâÊÖãÊÖçÊÖèÊÖêÊÖíÊÖìÊÖîÊÖñ",6,"ÊÖûÊÖüÊÖ†ÊÖ°ÊÖ£ÊÖ§ÊÖ•ÊÖ¶ÊÖ©",6,"ÊÖ±ÊÖ≤ÊÖ≥ÊÖ¥ÊÖ∂ÊÖ∏",18,"ÊÜåÊÜçÊÜè",4,"ÊÜï"],["9180","ÊÜñ",6,"ÊÜû",8,"ÊÜ™ÊÜ´ÊÜ≠",9,"ÊÜ∏",5,"ÊÜøÊáÄÊáÅÊáÉ",4,"ÊáâÊáå",4,"ÊáìÊáï",16,"Êáß",13,"Êá∂",8,"ÊàÄ",5,"ÊàáÊàâÊàìÊàîÊàôÊàúÊàùÊàûÊà†Êà£Êà¶ÊàßÊà®Êà©Êà´Êà≠ÊàØÊà∞Êà±Êà≤ÊàµÊà∂Êà∏",4,"ÊâÇÊâÑÊâÖÊâÜÊâä"],["9240","ÊâèÊâêÊâïÊâñÊâóÊâôÊâöÊâú",6,"Êâ§Êâ•Êâ®Êâ±Êâ≤Êâ¥ÊâµÊâ∑Êâ∏Êâ∫ÊâªÊâΩÊäÅÊäÇÊäÉÊäÖÊäÜÊäáÊäàÊäã",5,"ÊäîÊäôÊäúÊäùÊäûÊä£Êä¶ÊäßÊä©Êä™Êä≠ÊäÆÊäØÊä∞Êä≤Êä≥Êä¥Êä∂Êä∑Êä∏Êä∫ÊäæÊãÄÊãÅ"],["9280","ÊãÉÊããÊãèÊãëÊãïÊãùÊãûÊã†Êã°Êã§Êã™Êã´Êã∞Êã≤ÊãµÊã∏ÊãπÊã∫ÊãªÊåÄÊåÉÊåÑÊåÖÊåÜÊåäÊåãÊååÊåçÊåèÊåêÊåíÊåìÊåîÊåïÊåóÊåòÊåôÊåúÊå¶ÊåßÊå©Êå¨Êå≠ÊåÆÊå∞Êå±Êå≥",5,"ÊåªÊåºÊåæÊåøÊçÄÊçÅÊçÑÊçáÊçàÊçäÊçëÊçíÊçìÊçîÊçñ",7,"Êç†Êç§Êç•Êç¶Êç®Êç™Êç´Êç¨ÊçØÊç∞Êç≤Êç≥Êç¥ÊçµÊç∏ÊçπÊçºÊçΩÊçæÊçøÊéÅÊéÉÊéÑÊéÖÊéÜÊéãÊéçÊéëÊéìÊéîÊéïÊéóÊéô",6,"Êé°Êé§Êé¶Êé´ÊéØÊé±Êé≤ÊéµÊé∂ÊéπÊéªÊéΩÊéøÊèÄ"],["9340","ÊèÅÊèÇÊèÉÊèÖÊèáÊèàÊèäÊèãÊèåÊèëÊèìÊèîÊèïÊèó",6,"ÊèüÊè¢Êè§",4,"Êè´Êè¨ÊèÆÊèØÊè∞Êè±Êè≥ÊèµÊè∑ÊèπÊè∫ÊèªÊèºÊèæÊêÉÊêÑÊêÜ",4,"ÊêçÊêéÊêëÊêíÊêï",5,"ÊêùÊêüÊê¢Êê£Êê§"],["9380","Êê•ÊêßÊê®Êê©Êê´ÊêÆ",5,"Êêµ",4,"ÊêªÊêºÊêæÊëÄÊëÇÊëÉÊëâÊëã",6,"ÊëìÊëïÊëñÊëóÊëô",4,"Êëü",7,"Êë®Êë™Êë´Êë¨ÊëÆ",9,"Êëª",6,"ÊíÉÊíÜÊíà",8,"ÊíìÊíîÊíóÊíòÊíöÊíõÊíúÊíùÊíü",4,"Êí•Êí¶ÊíßÊí®Êí™Êí´ÊíØÊí±Êí≤Êí≥Êí¥Êí∂ÊíπÊíªÊíΩÊíæÊíøÊìÅÊìÉÊìÑÊìÜ",6,"ÊìèÊìëÊììÊìîÊìïÊìñÊìôÊìö"],["9440","ÊìõÊìúÊìùÊìüÊì†Êì°Êì£Êì•Êìß",24,"ÊîÅ",7,"Êîä",7,"Êîì",4,"Êîô",8],["9480","Êî¢Êî£Êî§Êî¶",4,"Êî¨Êî≠Êî∞Êî±Êî≤Êî≥Êî∑Êî∫ÊîºÊîΩÊïÄ",4,"ÊïÜÊïáÊïäÊïãÊïçÊïéÊïêÊïíÊïìÊïîÊïóÊïòÊïöÊïúÊïüÊï†Êï°Êï§Êï•ÊïßÊï®Êï©Êï™Êï≠ÊïÆÊïØÊï±Êï≥ÊïµÊï∂Êï∏",14,"ÊñàÊñâÊñäÊñçÊñéÊñèÊñíÊñîÊñïÊññÊñòÊñöÊñùÊñûÊñ†Êñ¢Êñ£Êñ¶Êñ®Êñ™Êñ¨ÊñÆÊñ±",7,"Êñ∫ÊñªÊñæÊñøÊóÄÊóÇÊóáÊóàÊóâÊóäÊóçÊóêÊóëÊóìÊóîÊóïÊóò",7,"Êó°Êó£Êó§Êó™Êó´"],["9540","Êó≤Êó≥Êó¥ÊóµÊó∏ÊóπÊóª",4,"ÊòÅÊòÑÊòÖÊòáÊòàÊòâÊòãÊòçÊòêÊòëÊòíÊòñÊòóÊòòÊòöÊòõÊòúÊòûÊò°Êò¢Êò£Êò§Êò¶Êò©Êò™Êò´Êò¨ÊòÆÊò∞Êò≤Êò≥Êò∑",4,"ÊòΩÊòøÊôÄÊôÇÊôÑ",6,"ÊôçÊôéÊôêÊôëÊôò"],["9580","ÊôôÊôõÊôúÊôùÊôûÊô†Êô¢Êô£Êô•ÊôßÊô©",4,"Êô±Êô≤Êô≥ÊôµÊô∏ÊôπÊôªÊôºÊôΩÊôøÊöÄÊöÅÊöÉÊöÖÊöÜÊöàÊöâÊöäÊöãÊöçÊöéÊöèÊöêÊöíÊöìÊöîÊöïÊöò",4,"Êöû",8,"Êö©",4,"ÊöØ",4,"ÊöµÊö∂Êö∑Êö∏Êö∫ÊöªÊöºÊöΩÊöø",25,"ÊõöÊõû",7,"ÊõßÊõ®Êõ™",5,"Êõ±ÊõµÊõ∂Êõ∏Êõ∫ÊõªÊõΩÊúÅÊúÇÊúÉ"],["9640","ÊúÑÊúÖÊúÜÊúáÊúåÊúéÊúèÊúëÊúíÊúìÊúñÊúòÊúôÊúöÊúúÊúûÊú†",5,"ÊúßÊú©ÊúÆÊú∞Êú≤Êú≥Êú∂Êú∑Êú∏ÊúπÊúªÊúºÊúæÊúøÊùÅÊùÑÊùÖÊùáÊùäÊùãÊùçÊùíÊùîÊùïÊùó",4,"ÊùùÊù¢Êù£Êù§Êù¶ÊùßÊù´Êù¨ÊùÆÊù±Êù¥Êù∂"],["9680","Êù∏ÊùπÊù∫ÊùªÊùΩÊûÄÊûÇÊûÉÊûÖÊûÜÊûàÊûäÊûåÊûçÊûéÊûèÊûëÊûíÊûìÊûîÊûñÊûôÊûõÊûüÊû†Êû°Êû§Êû¶Êû©Êû¨ÊûÆÊû±Êû≤Êû¥Êûπ",7,"ÊüÇÊüÖ",9,"ÊüïÊüñÊüóÊüõÊüüÊü°Êü£Êü§Êü¶ÊüßÊü®Êü™Êü´Êü≠ÊüÆÊü≤Êüµ",7,"ÊüæÊ†ÅÊ†ÇÊ†ÉÊ†ÑÊ†ÜÊ†çÊ†êÊ†íÊ†îÊ†ïÊ†ò",4,"Ê†ûÊ†üÊ††Ê†¢",6,"Ê†´",6,"Ê†¥Ê†µÊ†∂Ê†∫Ê†ªÊ†øÊ°áÊ°ãÊ°çÊ°èÊ°íÊ°ñ",5],["9740","Ê°úÊ°ùÊ°ûÊ°üÊ°™Ê°¨",7,"Ê°µÊ°∏",8,"Ê¢ÇÊ¢ÑÊ¢á",7,"Ê¢êÊ¢ëÊ¢íÊ¢îÊ¢ïÊ¢ñÊ¢ò",9,"Ê¢£Ê¢§Ê¢•Ê¢©Ê¢™Ê¢´Ê¢¨Ê¢ÆÊ¢±Ê¢≤Ê¢¥Ê¢∂Ê¢∑Ê¢∏"],["9780","Ê¢π",6,"Ê£ÅÊ£É",5,"Ê£äÊ£åÊ£éÊ£èÊ£êÊ£ëÊ£ìÊ£îÊ£ñÊ£óÊ£ôÊ£õ",4,"Ê£°Ê£¢Ê£§",9,"Ê£ØÊ£≤Ê£≥Ê£¥Ê£∂Ê£∑Ê£∏Ê£ªÊ£ΩÊ£æÊ£øÊ§ÄÊ§ÇÊ§ÉÊ§ÑÊ§Ü",4,"Ê§åÊ§èÊ§ëÊ§ì",11,"Ê§°Ê§¢Ê§£Ê§•",7,"Ê§ÆÊ§ØÊ§±Ê§≤Ê§≥Ê§µÊ§∂Ê§∑Ê§∏Ê§∫Ê§ªÊ§ºÊ§æÊ•ÄÊ•ÅÊ•É",16,"Ê•ïÊ•ñÊ•òÊ•ôÊ•õÊ•úÊ•ü"],["9840","Ê•°Ê•¢Ê•§Ê••Ê•ßÊ•®Ê•©Ê•™Ê•¨Ê•≠Ê•ØÊ•∞Ê•≤",4,"Ê•∫Ê•ªÊ•ΩÊ•æÊ•øÊ¶ÅÊ¶ÉÊ¶ÖÊ¶äÊ¶ãÊ¶åÊ¶é",5,"Ê¶ñÊ¶óÊ¶ôÊ¶öÊ¶ù",9,"Ê¶©Ê¶™Ê¶¨Ê¶ÆÊ¶ØÊ¶∞Ê¶≤Ê¶≥Ê¶µÊ¶∂Ê¶∏Ê¶πÊ¶∫Ê¶ºÊ¶Ω"],["9880","Ê¶æÊ¶øÊßÄÊßÇ",7,"ÊßãÊßçÊßèÊßëÊßíÊßìÊßï",5,"ÊßúÊßùÊßûÊß°",11,"ÊßÆÊßØÊß∞Êß±Êß≥",9,"ÊßæÊ®Ä",9,"Ê®ã",11,"Ê®ô",5,"Ê®†Ê®¢",5,"Ê®©Ê®´Ê®¨Ê®≠Ê®ÆÊ®∞Ê®≤Ê®≥Ê®¥Ê®∂",6,"Ê®ø",4,"Ê©ÖÊ©ÜÊ©à",7,"Ê©ë",6,"Ê©ö"],["9940","Ê©ú",4,"Ê©¢Ê©£Ê©§Ê©¶",10,"Ê©≤",6,"Ê©∫Ê©ªÊ©ΩÊ©æÊ©øÊ™ÅÊ™ÇÊ™ÉÊ™Ö",8,"Ê™èÊ™í",4,"Ê™ò",7,"Ê™°",5],["9980","Ê™ßÊ™®Ê™™Ê™≠",114,"Ê¨•Ê¨¶Ê¨®",6],["9a40","Ê¨ØÊ¨∞Ê¨±Ê¨≥Ê¨¥Ê¨µÊ¨∂Ê¨∏Ê¨ªÊ¨ºÊ¨ΩÊ¨øÊ≠ÄÊ≠ÅÊ≠ÇÊ≠ÑÊ≠ÖÊ≠àÊ≠äÊ≠ãÊ≠ç",11,"Ê≠ö",7,"Ê≠®Ê≠©Ê≠´",13,"Ê≠∫Ê≠ΩÊ≠æÊ≠øÊÆÄÊÆÖÊÆà"],["9a80","ÊÆåÊÆéÊÆèÊÆêÊÆëÊÆîÊÆïÊÆóÊÆòÊÆôÊÆú",4,"ÊÆ¢",7,"ÊÆ´",7,"ÊÆ∂ÊÆ∏",6,"ÊØÄÊØÉÊØÑÊØÜ",4,"ÊØåÊØéÊØêÊØëÊØòÊØöÊØú",4,"ÊØ¢",7,"ÊØ¨ÊØ≠ÊØÆÊØ∞ÊØ±ÊØ≤ÊØ¥ÊØ∂ÊØ∑ÊØ∏ÊØ∫ÊØªÊØºÊØæ",6,"Ê∞à",4,"Ê∞éÊ∞íÊ∞óÊ∞úÊ∞ùÊ∞ûÊ∞†Ê∞£Ê∞•Ê∞´Ê∞¨Ê∞≠Ê∞±Ê∞≥Ê∞∂Ê∞∑Ê∞πÊ∞∫Ê∞ªÊ∞ºÊ∞æÊ∞øÊ±ÉÊ±ÑÊ±ÖÊ±àÊ±ã",4,"Ê±ëÊ±íÊ±ìÊ±ñÊ±ò"],["9b40","Ê±ôÊ±öÊ±¢Ê±£Ê±•Ê±¶Ê±ßÊ±´",4,"Ê±±Ê±≥Ê±µÊ±∑Ê±∏Ê±∫Ê±ªÊ±ºÊ±øÊ≤ÄÊ≤ÑÊ≤áÊ≤äÊ≤ãÊ≤çÊ≤éÊ≤ëÊ≤íÊ≤ïÊ≤ñÊ≤óÊ≤òÊ≤öÊ≤úÊ≤ùÊ≤ûÊ≤†Ê≤¢Ê≤®Ê≤¨Ê≤ØÊ≤∞Ê≤¥Ê≤µÊ≤∂Ê≤∑Ê≤∫Ê≥ÄÊ≥ÅÊ≥ÇÊ≥ÉÊ≥ÜÊ≥áÊ≥àÊ≥ãÊ≥çÊ≥éÊ≥èÊ≥ëÊ≥íÊ≥ò"],["9b80","Ê≥ôÊ≥öÊ≥úÊ≥ùÊ≥üÊ≥§Ê≥¶Ê≥ßÊ≥©Ê≥¨Ê≥≠Ê≥≤Ê≥¥Ê≥πÊ≥øÊ¥ÄÊ¥ÇÊ¥ÉÊ¥ÖÊ¥ÜÊ¥àÊ¥âÊ¥äÊ¥çÊ¥èÊ¥êÊ¥ëÊ¥ìÊ¥îÊ¥ïÊ¥ñÊ¥òÊ¥úÊ¥ùÊ¥ü",5,"Ê¥¶Ê¥®Ê¥©Ê¥¨Ê¥≠Ê¥ØÊ¥∞Ê¥¥Ê¥∂Ê¥∑Ê¥∏Ê¥∫Ê¥øÊµÄÊµÇÊµÑÊµâÊµåÊµêÊµïÊµñÊµóÊµòÊµõÊµùÊµüÊµ°Êµ¢Êµ§Êµ•ÊµßÊµ®Êµ´Êµ¨Êµ≠Êµ∞Êµ±Êµ≤Êµ≥ÊµµÊµ∂ÊµπÊµ∫ÊµªÊµΩ",4,"Ê∂ÉÊ∂ÑÊ∂ÜÊ∂áÊ∂äÊ∂ãÊ∂çÊ∂èÊ∂êÊ∂íÊ∂ñ",4,"Ê∂úÊ∂¢Ê∂•Ê∂¨Ê∂≠Ê∂∞Ê∂±Ê∂≥Ê∂¥Ê∂∂Ê∂∑Ê∂π",5,"Ê∑ÅÊ∑ÇÊ∑ÉÊ∑àÊ∑âÊ∑ä"],["9c40","Ê∑çÊ∑éÊ∑èÊ∑êÊ∑íÊ∑ìÊ∑îÊ∑ïÊ∑óÊ∑öÊ∑õÊ∑úÊ∑üÊ∑¢Ê∑£Ê∑•Ê∑ßÊ∑®Ê∑©Ê∑™Ê∑≠Ê∑ØÊ∑∞Ê∑≤Ê∑¥Ê∑µÊ∑∂Ê∑∏Ê∑∫Ê∑Ω",7,"Ê∏ÜÊ∏áÊ∏àÊ∏âÊ∏ãÊ∏èÊ∏íÊ∏ìÊ∏ïÊ∏òÊ∏ôÊ∏õÊ∏úÊ∏ûÊ∏üÊ∏¢Ê∏¶Ê∏ßÊ∏®Ê∏™Ê∏¨Ê∏ÆÊ∏∞Ê∏±Ê∏≥Ê∏µ"],["9c80","Ê∏∂Ê∏∑Ê∏πÊ∏ª",7,"ÊπÖ",7,"ÊπèÊπêÊπëÊπíÊπïÊπóÊπôÊπöÊπúÊπùÊπûÊπ†",10,"Êπ¨Êπ≠ÊπØ",14,"Ê∫ÄÊ∫ÅÊ∫ÇÊ∫ÑÊ∫áÊ∫àÊ∫ä",4,"Ê∫ë",6,"Ê∫ôÊ∫öÊ∫õÊ∫ùÊ∫ûÊ∫†Ê∫°Ê∫£Ê∫§Ê∫¶Ê∫®Ê∫©Ê∫´Ê∫¨Ê∫≠Ê∫ÆÊ∫∞Ê∫≥Ê∫µÊ∫∏Ê∫πÊ∫ºÊ∫æÊ∫øÊªÄÊªÉÊªÑÊªÖÊªÜÊªàÊªâÊªäÊªåÊªçÊªéÊªêÊªíÊªñÊªòÊªôÊªõÊªúÊªùÊª£ÊªßÊª™",5],["9d40","Êª∞Êª±Êª≤Êª≥ÊªµÊª∂Êª∑Êª∏Êª∫",7,"ÊºÉÊºÑÊºÖÊºáÊºàÊºä",4,"ÊºêÊºëÊºíÊºñ",9,"Êº°Êº¢Êº£Êº•Êº¶ÊºßÊº®Êº¨ÊºÆÊº∞Êº≤Êº¥ÊºµÊº∑",6,"ÊºøÊΩÄÊΩÅÊΩÇ"],["9d80","ÊΩÉÊΩÑÊΩÖÊΩàÊΩâÊΩäÊΩåÊΩé",9,"ÊΩôÊΩöÊΩõÊΩùÊΩüÊΩ†ÊΩ°ÊΩ£ÊΩ§ÊΩ•ÊΩß",5,"ÊΩØÊΩ∞ÊΩ±ÊΩ≥ÊΩµÊΩ∂ÊΩ∑ÊΩπÊΩªÊΩΩ",6,"ÊæÖÊæÜÊæáÊæäÊæãÊæè",12,"ÊæùÊæûÊæüÊæ†Êæ¢",4,"Êæ®",10,"Êæ¥ÊæµÊæ∑Êæ∏Êæ∫",5,"ÊøÅÊøÉ",5,"Êøä",6,"Êøì",10,"ÊøüÊø¢Êø£Êø§Êø•"],["9e40","Êø¶",7,"Êø∞",32,"ÁÄí",7,"ÁÄú",6,"ÁÄ§",6],["9e80","ÁÄ´",9,"ÁÄ∂ÁÄ∑ÁÄ∏ÁÄ∫",17,"ÁÅçÁÅéÁÅê",13,"ÁÅü",11,"ÁÅÆÁÅ±ÁÅ≤ÁÅ≥ÁÅ¥ÁÅ∑ÁÅπÁÅ∫ÁÅªÁÅΩÁÇÅÁÇÇÁÇÉÁÇÑÁÇÜÁÇáÁÇàÁÇãÁÇåÁÇçÁÇèÁÇêÁÇëÁÇìÁÇóÁÇòÁÇöÁÇõÁÇû",12,"ÁÇ∞ÁÇ≤ÁÇ¥ÁÇµÁÇ∂ÁÇ∫ÁÇæÁÇøÁÉÑÁÉÖÁÉÜÁÉáÁÉâÁÉã",12,"ÁÉö"],["9f40","ÁÉúÁÉùÁÉûÁÉ†ÁÉ°ÁÉ¢ÁÉ£ÁÉ•ÁÉ™ÁÉÆÁÉ∞",6,"ÁÉ∏ÁÉ∫ÁÉªÁÉºÁÉæ",10,"ÁÑã",4,"ÁÑëÁÑíÁÑîÁÑóÁÑõ",10,"ÁÑß",7,"ÁÑ≤ÁÑ≥ÁÑ¥"],["9f80","ÁÑµÁÑ∑",13,"ÁÖÜÁÖáÁÖàÁÖâÁÖãÁÖçÁÖè",12,"ÁÖùÁÖü",4,"ÁÖ•ÁÖ©",4,"ÁÖØÁÖ∞ÁÖ±ÁÖ¥ÁÖµÁÖ∂ÁÖ∑ÁÖπÁÖªÁÖºÁÖæ",5,"ÁÜÖ",4,"ÁÜãÁÜåÁÜçÁÜéÁÜêÁÜëÁÜíÁÜìÁÜïÁÜñÁÜóÁÜö",4,"ÁÜ°",6,"ÁÜ©ÁÜ™ÁÜ´ÁÜ≠",5,"ÁÜ¥ÁÜ∂ÁÜ∑ÁÜ∏ÁÜ∫",8,"ÁáÑ",9,"Ááè",4],["a040","Ááñ",9,"Áá°Áá¢Áá£Áá§Áá¶Áá®",5,"ÁáØ",9,"Áá∫",11,"Áàá",19],["a080","ÁàõÁàúÁàû",9,"Áà©Áà´Áà≠ÁàÆÁàØÁà≤Áà≥Áà¥Áà∫ÁàºÁàæÁâÄ",6,"ÁââÁâäÁâãÁâéÁâèÁâêÁâëÁâìÁâîÁâïÁâóÁâòÁâöÁâúÁâûÁâ†Áâ£Áâ§Áâ•Áâ®Áâ™Áâ´Áâ¨Áâ≠Áâ∞Áâ±Áâ≥Áâ¥Áâ∂Áâ∑Áâ∏ÁâªÁâºÁâΩÁäÇÁäÉÁäÖ",4,"ÁäåÁäéÁäêÁäëÁäì",11,"Áä†",11,"ÁäÆÁä±Áä≤Áä≥ÁäµÁä∫",6,"ÁãÖÁãÜÁãáÁãâÁãäÁããÁãåÁãèÁãëÁãìÁãîÁãïÁãñÁãòÁãöÁãõ"],["a1a1","„ÄÄ„ÄÅ„ÄÇ¬∑ÀâÀá¬®„ÄÉ„ÄÖ‚ÄîÔΩû‚Äñ‚Ä¶‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",7,"„Äñ„Äó„Äê„Äë¬±√ó√∑‚à∂‚àß‚à®‚àë‚àè‚à™‚à©‚àà‚à∑‚àö‚ä•‚à•‚à†‚åí‚äô‚à´‚àÆ‚â°‚âå‚âà‚àΩ‚àù‚â†‚âÆ‚âØ‚â§‚â•‚àû‚àµ‚à¥‚ôÇ‚ôÄ¬∞‚Ä≤‚Ä≥‚ÑÉÔºÑ¬§Ôø†Ôø°‚Ä∞¬ß‚Ññ‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚Äª‚Üí‚Üê‚Üë‚Üì„Äì"],["a2a1","‚Ö∞",9],["a2b1","‚íà",19,"‚ë¥",19,"‚ë†",9],["a2e5","„à†",9],["a2f1","‚Ö†",11],["a3a1","ÔºÅÔºÇÔºÉÔø•ÔºÖ",88,"Ôø£"],["a4a1","„ÅÅ",82],["a5a1","„Ç°",85],["a6a1","Œë",16,"Œ£",6],["a6c1","Œ±",16,"œÉ",6],["a6e0","Ô∏µÔ∏∂Ô∏πÔ∏∫Ô∏øÔπÄÔ∏ΩÔ∏æÔπÅÔπÇÔπÉÔπÑ"],["a6ee","Ô∏ªÔ∏ºÔ∏∑Ô∏∏Ô∏±"],["a6f4","Ô∏≥Ô∏¥"],["a7a1","–ê",5,"–Å–ñ",25],["a7d1","–∞",5,"—ë–∂",25],["a840","ÀäÀãÀô‚Äì‚Äï‚Ä•‚Äµ‚ÑÖ‚Ñâ‚Üñ‚Üó‚Üò‚Üô‚àï‚àü‚à£‚âí‚â¶‚âß‚äø‚ïê",35,"‚ñÅ",6],["a880","‚ñà",7,"‚ñì‚ñî‚ñï‚ñº‚ñΩ‚ó¢‚ó£‚ó§‚ó•‚òâ‚äï„Äí„Äù„Äû"],["a8a1","ƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö«ú√º√™…ë"],["a8bd","≈Ñ≈à"],["a8c0","…°"],["a8c5","„ÑÖ",36],["a940","„Ä°",8,"„ä£„éé„éè„éú„éù„éû„é°„èÑ„èé„èë„èí„èïÔ∏∞Ôø¢Ôø§"],["a959","‚Ñ°„à±"],["a95c","‚Äê"],["a960","„Éº„Çõ„Çú„ÉΩ„Éæ„ÄÜ„Çù„ÇûÔπâ",9,"ÔπîÔπïÔπñÔπóÔπô",8],["a980","Ôπ¢",4,"Ôπ®Ôπ©Ôπ™Ôπ´"],["a996","„Äá"],["a9a4","‚îÄ",75],["aa40","ÁãúÁãùÁãüÁã¢",5,"Áã™Áã´ÁãµÁã∂ÁãπÁãΩÁãæÁãøÁåÄÁåÇÁåÑ",5,"ÁåãÁååÁåçÁåèÁåêÁåëÁåíÁåîÁåòÁåôÁåöÁåüÁå†Áå£Áå§Áå¶ÁåßÁå®Áå≠ÁåØÁå∞Áå≤Áå≥ÁåµÁå∂Áå∫ÁåªÁåºÁåΩÁçÄ",8],["aa80","ÁçâÁçäÁçãÁçåÁçéÁçèÁçëÁçìÁçîÁçïÁçñÁçò",7,"Áç°",10,"ÁçÆÁç∞Áç±"],["ab40","Áç≤",11,"Áçø",4,"ÁéÖÁéÜÁéàÁéäÁéåÁéçÁéèÁéêÁéíÁéìÁéîÁéïÁéóÁéòÁéôÁéöÁéúÁéùÁéûÁé†Áé°Áé£",5,"Áé™Áé¨Áé≠Áé±Áé¥ÁéµÁé∂Áé∏ÁéπÁéºÁéΩÁéæÁéøÁèÅÁèÉ",4],["ab80","ÁèãÁèåÁèéÁèí",6,"ÁèöÁèõÁèúÁèùÁèüÁè°Áè¢Áè£Áè§Áè¶Áè®Áè™Áè´Áè¨ÁèÆÁèØÁè∞Áè±Áè≥",4],["ac40","Áè∏",10,"ÁêÑÁêáÁêàÁêãÁêåÁêçÁêéÁêë",8,"Áêú",5,"Áê£Áê§ÁêßÁê©Áê´Áê≠ÁêØÁê±Áê≤Áê∑",4,"ÁêΩÁêæÁêøÁëÄÁëÇ",11],["ac80","Áëé",6,"ÁëñÁëòÁëùÁë†",12,"ÁëÆÁëØÁë±",4,"Áë∏ÁëπÁë∫"],["ad40","ÁëªÁëºÁëΩÁëøÁíÇÁíÑÁíÖÁíÜÁíàÁíâÁíäÁíåÁíçÁíèÁíë",10,"ÁíùÁíü",7,"Áí™",15,"Áíª",12],["ad80","Áìà",9,"Áìì",8,"ÁìùÁìüÁì°Áì•Áìß",6,"Áì∞Áì±Áì≤"],["ae40","Áì≥ÁìµÁì∏",6,"ÁîÄÁîÅÁîÇÁîÉÁîÖ",7,"ÁîéÁîêÁîíÁîîÁîïÁîñÁîóÁîõÁîùÁîûÁî†",4,"Áî¶ÁîßÁî™ÁîÆÁî¥Áî∂ÁîπÁîºÁîΩÁîøÁïÅÁïÇÁïÉÁïÑÁïÜÁïáÁïâÁïäÁïçÁïêÁïëÁïíÁïìÁïïÁïñÁïóÁïò"],["ae80","Áïù",7,"ÁïßÁï®Áï©Áï´",6,"Áï≥ÁïµÁï∂Áï∑Áï∫",4,"ÁñÄÁñÅÁñÇÁñÑÁñÖÁñá"],["af40","ÁñàÁñâÁñäÁñåÁñçÁñéÁñêÁñìÁñïÁñòÁñõÁñúÁñûÁñ¢Áñ¶",4,"Áñ≠Áñ∂Áñ∑Áñ∫ÁñªÁñøÁóÄÁóÅÁóÜÁóãÁóåÁóéÁóèÁóêÁóëÁóìÁóóÁóôÁóöÁóúÁóùÁóüÁó†Áó°Áó•Áó©Áó¨Áó≠ÁóÆÁóØÁó≤Áó≥ÁóµÁó∂Áó∑Áó∏Áó∫ÁóªÁóΩÁóæÁòÇÁòÑÁòÜÁòá"],["af80","ÁòàÁòâÁòãÁòçÁòéÁòèÁòëÁòíÁòìÁòîÁòñÁòöÁòúÁòùÁòûÁò°Áò£ÁòßÁò®Áò¨ÁòÆÁòØÁò±Áò≤Áò∂Áò∑ÁòπÁò∫ÁòªÁòΩÁôÅÁôÇÁôÑ"],["b040","ÁôÖ",6,"Áôé",5,"ÁôïÁôó",4,"ÁôùÁôüÁô†Áô°Áô¢Áô§",6,"Áô¨Áô≠ÁôÆÁô∞",7,"ÁôπÁô∫ÁôºÁôøÁöÄÁöÅÁöÉÁöÖÁöâÁöäÁöåÁöçÁöèÁöêÁöíÁöîÁöïÁöóÁöòÁööÁöõ"],["b080","Áöú",7,"Áö•",8,"ÁöØÁö∞Áö≥Áöµ",9,"ÁõÄÁõÅÁõÉÂïäÈòøÂüÉÊå®ÂìéÂîâÂìÄÁöëÁôåËîºÁüÆËâæÁ¢çÁà±ÈöòÈûçÊ∞®ÂÆâ‰ø∫ÊåâÊöóÂ≤∏ËÉ∫Ê°àËÇÆÊòÇÁõéÂáπÊïñÁÜ¨Áø±Ë¢ÑÂÇ≤Â••ÊáäÊæ≥Ëä≠ÊçåÊâíÂè≠ÂêßÁ¨ÜÂÖ´Áñ§Â∑¥ÊãîË∑ãÈù∂ÊääËÄôÂùùÈú∏ÁΩ¢Áà∏ÁôΩÊüèÁôæÊëÜ‰Ω∞Ë¥•ÊãúÁ®óÊñëÁè≠Êê¨Êâ≥Ëà¨È¢ÅÊùøÁâàÊâÆÊãå‰º¥Áì£ÂçäÂäûÁªäÈÇ¶Â∏ÆÊ¢ÜÊ¶úËÜÄÁªëÊ£íÁ£ÖËöåÈïëÂÇçË∞§ËãûËÉûÂåÖË§íÂâ•"],["b140","ÁõÑÁõáÁõâÁõãÁõåÁõìÁõïÁõôÁõöÁõúÁõùÁõûÁõ†",4,"Áõ¶",7,"Áõ∞Áõ≥ÁõµÁõ∂Áõ∑Áõ∫ÁõªÁõΩÁõøÁúÄÁúÇÁúÉÁúÖÁúÜÁúäÁúåÁúé",10,"ÁúõÁúúÁúùÁúûÁú°Áú£Áú§Áú•ÁúßÁú™Áú´"],["b180","Áú¨ÁúÆÁú∞",4,"ÁúπÁúªÁúΩÁúæÁúøÁùÇÁùÑÁùÖÁùÜÁùà",7,"Áùí",7,"ÁùúËñÑÈõπ‰øùÂ†°È•±ÂÆùÊä±Êä•Êö¥Ë±πÈ≤çÁàÜÊùØÁ¢ëÊÇ≤ÂçëÂåóËæàËÉåË¥ùÈí°ÂÄçÁãàÂ§áÊÉ´ÁÑôË¢´Â•îËãØÊú¨Á¨®Â¥©Áª∑Áî≠Ê≥µËπ¶Ëø∏ÈÄºÈºªÊØîÈÑôÁ¨îÂΩºÁ¢ßËìñËîΩÊØïÊØôÊØñÂ∏ÅÂ∫áÁóπÈó≠ÊïùÂºäÂøÖËæüÂ£ÅËáÇÈÅøÈôõÈû≠ËæπÁºñË¥¨ÊâÅ‰æøÂèòÂçûËæ®Ëæ©Ëæ´ÈÅçÊ†áÂΩ™ËÜòË°®È≥ñÊÜãÂà´Áò™ÂΩ¨ÊñåÊøíÊª®ÂÆæÊëàÂÖµÂÜ∞ÊüÑ‰∏ôÁßâÈ•ºÁÇ≥"],["b240","ÁùùÁùûÁùüÁù†Áù§ÁùßÁù©Áù™Áù≠",11,"Áù∫ÁùªÁùºÁûÅÁûÇÁûÉÁûÜ",5,"ÁûèÁûêÁûì",11,"Áû°Áû£Áû§Áû¶Áû®Áû´Áû≠ÁûÆÁûØÁû±Áû≤Áû¥Áû∂",4],["b280","ÁûºÁûæÁüÄ",12,"Áüé",8,"ÁüòÁüôÁüöÁüù",4,"Áü§ÁóÖÂπ∂ÁéªËè†Êí≠Êã®ÈíµÊ≥¢ÂçöÂãÉÊêèÈìÇÁÆî‰ºØÂ∏õËà∂ËÑñËÜäÊ∏§Ê≥äÈ©≥ÊçïÂçúÂì∫Ë°•Âü†‰∏çÂ∏ÉÊ≠•Á∞øÈÉ®ÊÄñÊì¶ÁåúË£ÅÊùêÊâçË¥¢Áù¨Ë∏©ÈááÂΩ©ËèúËî°È§êÂèÇËöïÊÆãÊÉ≠ÊÉ®ÁÅøËãçËà±‰ªìÊ≤ßËóèÊìçÁ≥ôÊßΩÊõπËçâÂéïÁ≠ñ‰æßÂÜåÊµãÂ±ÇËπ≠ÊèíÂèâËå¨Ëå∂Êü•Á¢¥ÊêΩÂØüÂ≤îÂ∑ÆËØßÊãÜÊü¥Ë±∫ÊêÄÊé∫ËùâÈ¶ãË∞óÁº†Èì≤‰∫ßÈòêÈ¢§ÊòåÁåñ"],["b340","Áü¶Áü®Áü™ÁüØÁü∞Áü±Áü≤Áü¥ÁüµÁü∑ÁüπÁü∫ÁüªÁüºÁ†É",5,"Á†äÁ†ãÁ†éÁ†èÁ†êÁ†ìÁ†ïÁ†ôÁ†õÁ†ûÁ††Á†°Á†¢Á†§Á†®Á†™Á†´Á†ÆÁ†ØÁ†±Á†≤Á†≥Á†µÁ†∂Á†ΩÁ†øÁ°ÅÁ°ÇÁ°ÉÁ°ÑÁ°ÜÁ°àÁ°âÁ°äÁ°ãÁ°çÁ°èÁ°ëÁ°ìÁ°îÁ°òÁ°ôÁ°ö"],["b380","Á°õÁ°úÁ°û",11,"Á°Ø",7,"Á°∏Á°πÁ°∫Á°ªÁ°Ω",6,"Âú∫Â∞ùÂ∏∏ÈïøÂÅøËÇ†ÂéÇÊïûÁïÖÂî±ÂÄ°Ë∂ÖÊäÑÈíûÊúùÂò≤ÊΩÆÂ∑¢ÂêµÁÇíËΩ¶ÊâØÊí§Êé£ÂΩªÊæàÈÉ¥Ëá£Ëæ∞Â∞òÊô®Âø±Ê≤âÈôàË∂ÅË°¨ÊíëÁß∞ÂüéÊ©ôÊàêÂëà‰πòÁ®ãÊÉ©ÊæÑËØöÊâøÈÄûÈ™ãÁß§ÂêÉÁó¥ÊåÅÂåôÊ±†ËøüÂºõÈ©∞ËÄªÈΩø‰æàÂ∞∫Ëµ§ÁøÖÊñ•ÁÇΩÂÖÖÂÜ≤Ëô´Â¥áÂÆ†ÊäΩÈÖ¨Áï¥Ë∏åÁ®†ÊÑÅÁ≠π‰ªáÁª∏ÁûÖ‰∏ëËá≠ÂàùÂá∫Ê©±Âé®Ë∫áÈîÑÈõèÊªÅÈô§Ê•ö"],["b440","Á¢ÑÁ¢ÖÁ¢ÜÁ¢àÁ¢äÁ¢ãÁ¢èÁ¢êÁ¢íÁ¢îÁ¢ïÁ¢ñÁ¢ôÁ¢ùÁ¢ûÁ¢†Á¢¢Á¢§Á¢¶Á¢®",7,"Á¢µÁ¢∂Á¢∑Á¢∏Á¢∫Á¢ªÁ¢ºÁ¢ΩÁ¢øÁ£ÄÁ£ÇÁ£ÉÁ£ÑÁ£ÜÁ£áÁ£àÁ£åÁ£çÁ£éÁ£èÁ£ëÁ£íÁ£ìÁ£ñÁ£óÁ£òÁ£ö",9],["b480","Á£§Á£•Á£¶Á£ßÁ£©Á£™Á£´Á£≠",4,"Á£≥Á£µÁ£∂Á£∏Á£πÁ£ª",5,"Á§ÇÁ§ÉÁ§ÑÁ§Ü",6,"Á°ÄÂÇ®ÁüóÊêêËß¶Â§ÑÊè£Â∑ùÁ©øÊ§Ω‰º†ËàπÂñò‰∏≤ÁñÆÁ™óÂπ¢Â∫äÈóØÂàõÂêπÁÇäÊç∂Èî§ÂûÇÊò•Ê§øÈÜáÂîáÊ∑≥Á∫ØË†¢Êà≥Áª∞ÁñµËå®Á£ÅÈõåËæûÊÖàÁì∑ËØçÊ≠§Âà∫ËµêÊ¨°ËÅ™Ëë±Âõ±ÂåÜ‰ªé‰∏õÂáëÁ≤óÈÜãÁ∞á‰øÉËπøÁØ°Á™úÊëßÂ¥îÂÇ¨ËÑÜÁòÅÁ≤πÊ∑¨Áø†ÊùëÂ≠òÂØ∏Á£ãÊíÆÊêìÊé™Êå´ÈîôÊê≠ËææÁ≠îÁò©ÊâìÂ§ßÂëÜÊ≠πÂÇ£Êà¥Â∏¶ÊÆÜ‰ª£Ë¥∑Ë¢ãÂæÖÈÄÆ"],["b540","Á§ç",5,"Á§î",9,"Á§ü",4,"Á§•",14,"Á§µ",4,"Á§ΩÁ§øÁ•ÇÁ•ÉÁ•ÑÁ•ÖÁ•áÁ•ä",8,"Á•îÁ•ïÁ•òÁ•ôÁ•°Á•£"],["b580","Á•§Á•¶Á•©Á•™Á•´Á•¨Á•ÆÁ•∞",6,"Á•πÁ•ª",4,"Á¶ÇÁ¶ÉÁ¶ÜÁ¶áÁ¶àÁ¶âÁ¶ãÁ¶åÁ¶çÁ¶éÁ¶êÁ¶ëÁ¶íÊÄ†ËÄΩÊãÖ‰∏πÂçïÈÉ∏Êé∏ËÉÜÊó¶Ê∞Æ‰ΩÜÊÉÆÊ∑°ËØûÂºπËõãÂΩìÊå°ÂÖöËç°Ê°£ÂàÄÊç£ËπàÂÄíÂ≤õÁ•∑ÂØºÂà∞Á®ªÊÇºÈÅìÁõóÂæ∑ÂæóÁöÑËπ¨ÁÅØÁôªÁ≠âÁû™Âá≥ÈÇìÂ†§‰ΩéÊª¥Ëø™ÊïåÁ¨õÁãÑÊ∂§ÁøüÂ´°ÊäµÂ∫ïÂú∞ËíÇÁ¨¨Â∏ùÂºüÈÄíÁºîÈ¢†ÊéÇÊªáÁ¢òÁÇπÂÖ∏ÈùõÂû´Áîµ‰ΩÉÁî∏Â∫óÊÉ¶Â•†Ê∑ÄÊÆøÁ¢âÂèºÈõïÂáãÂàÅÊéâÂêäÈíìË∞ÉË∑åÁàπÁ¢üËù∂Ëø≠Ë∞çÂè†"],["b640","Á¶ì",6,"Á¶õ",11,"Á¶®",10,"Á¶¥",4,"Á¶ºÁ¶øÁßÇÁßÑÁßÖÁßáÁßàÁßäÁßåÁßéÁßèÁßêÁßìÁßîÁßñÁßóÁßô",5,"Áß†Áß°Áß¢Áß•Áß®Áß™"],["b680","Áß¨ÁßÆÁß±",6,"ÁßπÁß∫ÁßºÁßæÁßøÁ®ÅÁ®ÑÁ®ÖÁ®áÁ®àÁ®âÁ®äÁ®åÁ®è",4,"Á®ïÁ®ñÁ®òÁ®ôÁ®õÁ®ú‰∏ÅÁõØÂèÆÈíâÈ°∂ÈºéÈî≠ÂÆöËÆ¢‰∏¢‰∏úÂÜ¨Ëë£ÊáÇÂä®Ê†ã‰æóÊÅ´ÂÜªÊ¥ûÂÖúÊäñÊñóÈô°Ë±ÜÈÄóÁóòÈÉΩÁù£ÊØíÁääÁã¨ËØªÂ†µÁùπËµåÊùúÈïÄËÇöÂ∫¶Ê∏°Â¶íÁ´ØÁü≠ÈîªÊÆµÊñ≠ÁºéÂ†ÜÂÖëÈòüÂØπÂ¢©Âê®Ëπ≤Êï¶È°øÂõ§ÈíùÁõæÈÅÅÊéáÂìÜÂ§öÂ§∫ÂûõË∫≤ÊúµË∑∫ËàµÂâÅÊÉ∞Â†ïËõæÂ≥®ÈπÖ‰øÑÈ¢ùËÆπÂ®•ÊÅ∂ÂéÑÊâºÈÅèÈÑÇÈ•øÊÅ©ËÄåÂÑøËÄ≥Â∞îÈ•µÊ¥±‰∫å"],["b740","Á®ùÁ®üÁ®°Á®¢Á®§",14,"Á®¥Á®µÁ®∂Á®∏Á®∫Á®æÁ©Ä",5,"Á©á",9,"Á©í",4,"Á©ò",16],["b780","Á©©",6,"Á©±Á©≤Á©≥Á©µÁ©ªÁ©ºÁ©ΩÁ©æÁ™ÇÁ™ÖÁ™áÁ™âÁ™äÁ™ãÁ™åÁ™éÁ™èÁ™êÁ™ìÁ™îÁ™ôÁ™öÁ™õÁ™ûÁ™°Á™¢Ë¥∞ÂèëÁΩöÁ≠è‰ºê‰πèÈòÄÊ≥ïÁèêËó©Â∏ÜÁï™ÁøªÊ®äÁüæÈííÁπÅÂá°ÁÉ¶ÂèçËøîËåÉË¥©ÁäØÈ•≠Ê≥õÂùäËä≥ÊñπËÇ™ÊàøÈò≤Â¶®‰ªøËÆøÁ∫∫ÊîæËè≤ÈùûÂï°È£ûËÇ•Âå™ËØΩÂê†ËÇ∫Â∫üÊ≤∏Ë¥πËä¨ÈÖöÂê©Ê∞õÂàÜÁ∫∑ÂùüÁÑöÊ±æÁ≤âÂ•ã‰ªΩÂøøÊÑ§Á≤™‰∏∞Â∞ÅÊû´ËúÇÂ≥∞ÈîãÈ£éÁñØÁÉΩÈÄ¢ÂÜØÁºùËÆΩÂ•âÂá§‰ΩõÂê¶Â§´Êï∑ËÇ§Â≠µÊâ∂ÊãÇËæêÂπÖÊ∞üÁ¨¶‰ºè‰øòÊúç"],["b840","Á™£Á™§Á™ßÁ™©Á™™Á™´Á™Æ",4,"Á™¥",10,"Á´Ä",10,"Á´å",9,"Á´óÁ´òÁ´öÁ´õÁ´úÁ´ùÁ´°Á´¢Á´§Á´ß",5,"Á´ÆÁ´∞Á´±Á´≤Á´≥"],["b880","Á´¥",4,"Á´ªÁ´ºÁ´æÁ¨ÄÁ¨ÅÁ¨ÇÁ¨ÖÁ¨áÁ¨âÁ¨åÁ¨çÁ¨éÁ¨êÁ¨íÁ¨ìÁ¨ñÁ¨óÁ¨òÁ¨öÁ¨úÁ¨ùÁ¨üÁ¨°Á¨¢Á¨£Á¨ßÁ¨©Á¨≠ÊµÆÊ∂™Á¶èË¢±ÂºóÁî´ÊäöËæÖ‰øØÈáúÊñßËÑØËÖëÂ∫úËÖêËµ¥ÂâØË¶ÜËµãÂ§çÂÇÖ‰ªòÈòúÁà∂ËÖπË¥üÂØåËÆ£ÈôÑÂ¶áÁºöÂíêÂô∂ÂòéËØ•ÊîπÊ¶ÇÈíôÁõñÊ∫âÂπ≤ÁîòÊùÜÊüëÁ´øËÇùËµ∂ÊÑüÁßÜÊï¢Ëµ£ÂÜàÂàöÈí¢Áº∏ËÇõÁ∫≤Â≤óÊ∏ØÊù†ÁØôÁöãÈ´òËÜèÁæîÁ≥ïÊêûÈïêÁ®øÂëäÂì•Ê≠åÊêÅÊààÈ∏ΩËÉ≥ÁñôÂâ≤Èù©ËëõÊ†ºËõ§ÈòÅÈöîÈì¨‰∏™ÂêÑÁªôÊ†πË∑üËÄïÊõ¥Â∫öÁæπ"],["b940","Á¨ØÁ¨∞Á¨≤Á¨¥Á¨µÁ¨∂Á¨∑Á¨πÁ¨ªÁ¨ΩÁ¨ø",5,"Á≠ÜÁ≠àÁ≠äÁ≠çÁ≠éÁ≠ìÁ≠ïÁ≠óÁ≠ôÁ≠úÁ≠ûÁ≠üÁ≠°Á≠£",10,"Á≠ØÁ≠∞Á≠≥Á≠¥Á≠∂Á≠∏Á≠∫Á≠ºÁ≠ΩÁ≠øÁÆÅÁÆÇÁÆÉÁÆÑÁÆÜ",6,"ÁÆéÁÆè"],["b980","ÁÆëÁÆíÁÆìÁÆñÁÆòÁÆôÁÆöÁÆõÁÆûÁÆüÁÆ†ÁÆ£ÁÆ§ÁÆ•ÁÆÆÁÆØÁÆ∞ÁÆ≤ÁÆ≥ÁÆµÁÆ∂ÁÆ∑ÁÆπ",7,"ÁØÇÁØÉÁØÑÂüÇËÄøÊ¢óÂ∑•ÊîªÂäüÊÅ≠Èæö‰æõË∫¨ÂÖ¨ÂÆ´ÂºìÂ∑©Ê±ûÊã±Ë¥°ÂÖ±Èí©ÂãæÊ≤üËãüÁãóÂû¢ÊûÑË¥≠Â§üËæúËèáÂíïÁÆç‰º∞Ê≤ΩÂ≠§ÂßëÈºìÂè§ËõäÈ™®Ë∞∑ËÇ°ÊïÖÈ°æÂõ∫ÈõáÂàÆÁìúÂâêÂØ°ÊåÇË§Ç‰πñÊãêÊÄ™Ê£∫ÂÖ≥ÂÆòÂÜ†ËßÇÁÆ°È¶ÜÁΩêÊÉØÁÅåË¥ØÂÖâÂπøÈÄõÁë∞ËßÑÂú≠Á°ÖÂΩíÈæüÈó∫ËΩ®È¨ºËØ°Áô∏Ê°ÇÊüúË∑™Ë¥µÂàΩËæäÊªöÊ£çÈîÖÈÉ≠ÂõΩÊûúË£πËøáÂìà"],["ba40","ÁØÖÁØàÁØâÁØäÁØãÁØçÁØéÁØèÁØêÁØíÁØî",4,"ÁØõÁØúÁØûÁØüÁØ†ÁØ¢ÁØ£ÁØ§ÁØßÁØ®ÁØ©ÁØ´ÁØ¨ÁØ≠ÁØØÁØ∞ÁØ≤",4,"ÁØ∏ÁØπÁØ∫ÁØªÁØΩÁØø",7,"Á∞àÁ∞âÁ∞äÁ∞çÁ∞éÁ∞ê",5,"Á∞óÁ∞òÁ∞ô"],["ba80","Á∞ö",4,"Á∞†",5,"Á∞®Á∞©Á∞´",12,"Á∞π",5,"Á±ÇÈ™∏Â≠©Êµ∑Ê∞¶‰∫•ÂÆ≥È™áÈÖ£ÊÜ®ÈÇØÈü©Âê´Ê∂µÂØíÂáΩÂñäÁΩïÁø∞ÊíºÊççÊó±ÊÜæÊÇçÁÑäÊ±óÊ±âÂ§ØÊù≠Ëà™Â£ïÂöéË±™ÊØ´ÈÉùÂ•ΩËÄóÂè∑Êµ©ÂëµÂñùËç∑ËèèÊ†∏Á¶æÂíå‰ΩïÂêàÁõíË≤âÈòÇÊ≤≥Ê∂∏Ëµ´Ë§êÈπ§Ë¥∫ÂòøÈªëÁóïÂæàÁã†ÊÅ®Âìº‰∫®Ê®™Ë°°ÊÅíËΩ∞ÂìÑÁÉòËôπÈ∏øÊ¥™ÂÆèÂºòÁ∫¢Âñâ‰æØÁå¥ÂêºÂéöÂÄôÂêéÂëº‰πéÂøΩÁëöÂ£∂Ëë´ËÉ°Ëù¥ÁãêÁ≥äÊπñ"],["bb40","Á±É",9,"Á±é",36,"Á±µ",5,"Á±æ",9],["bb80","Á≤àÁ≤ä",6,"Á≤ìÁ≤îÁ≤ñÁ≤ôÁ≤öÁ≤õÁ≤†Á≤°Á≤£Á≤¶Á≤ßÁ≤®Á≤©Á≤´Á≤¨Á≤≠Á≤ØÁ≤∞Á≤¥",4,"Á≤∫Á≤ªÂºßËôéÂî¨Êä§‰∫íÊ≤™Êà∑Ëä±ÂìóÂçéÁåæÊªëÁîªÂàíÂåñËØùÊßêÂæäÊÄÄÊ∑ÆÂùèÊ¨¢ÁéØÊ°ìËøòÁºìÊç¢ÊÇ£Âî§Áó™Ë±¢ÁÑïÊ∂£ÂÆ¶ÂπªËçíÊÖåÈªÑÁ£∫ËùóÁ∞ßÁöáÂá∞ÊÉ∂ÁÖåÊôÉÂπåÊÅçË∞éÁÅ∞Êå•ËæâÂæΩÊÅ¢ËõîÂõûÊØÅÊÇîÊÖßÂçâÊÉ†Êô¶Ë¥øÁßΩ‰ºöÁÉ©Ê±áËÆ≥ËØ≤ÁªòËç§ÊòèÂ©öÈ≠ÇÊµëÊ∑∑Ë±ÅÊ¥ª‰ºôÁÅ´Ëé∑ÊàñÊÉëÈúçË¥ßÁ•∏ÂáªÂúæÂü∫Êú∫Áï∏Á®ΩÁßØÁÆï"],["bc40","Á≤øÁ≥ÄÁ≥ÇÁ≥ÉÁ≥ÑÁ≥ÜÁ≥âÁ≥ãÁ≥é",6,"Á≥òÁ≥öÁ≥õÁ≥ùÁ≥ûÁ≥°",6,"Á≥©",5,"Á≥∞",7,"Á≥πÁ≥∫Á≥º",13,"Á¥ã",5],["bc80","Á¥ë",14,"Á¥°Á¥£Á¥§Á¥•Á¥¶Á¥®Á¥©Á¥™Á¥¨Á¥≠Á¥ÆÁ¥∞",6,"ËÇåÈ••ËøπÊøÄËÆ•È∏°Âß¨Áª©ÁºâÂêâÊûÅÊ£òËæëÁ±çÈõÜÂèäÊÄ•ÁñæÊ±≤Âç≥Â´âÁ∫ßÊå§Âá†ËÑäÂ∑±ËìüÊäÄÂÜÄÂ≠£‰ºéÁ•≠ÂâÇÊÇ∏ÊµéÂØÑÂØÇËÆ°ËÆ∞Êó¢ÂøåÈôÖÂ¶ìÁªßÁ∫™ÂòâÊû∑Â§π‰Ω≥ÂÆ∂Âä†ËçöÈ¢äË¥æÁî≤ÈíæÂÅáÁ®º‰ª∑Êû∂È©æÂ´ÅÊ≠ºÁõëÂùöÂ∞ñÁ¨∫Èó¥ÁÖéÂÖºËÇ©Ëâ∞Â•∏ÁºÑËåßÊ£ÄÊü¨Á¢±Á°∑Êã£Êç°ÁÆÄ‰ø≠Ââ™ÂáèËçêÊßõÈâ¥Ë∑µË¥±ËßÅÈîÆÁÆ≠‰ª∂"],["bd40","Á¥∑",54,"ÁµØ",7],["bd80","Áµ∏",32,"ÂÅ•Ëà∞ÂâëÈ•ØÊ∏êÊ∫ÖÊ∂ßÂª∫ÂÉµÂßúÂ∞ÜÊµÜÊ±üÁñÜËíãÊ°®Â•ñËÆ≤Âå†ÈÖ±ÈôçËïâÊ§íÁ§ÅÁÑ¶ËÉ∂‰∫§ÈÉäÊµáÈ™ÑÂ®áÂöºÊêÖÈì∞Áü´‰æ•ËÑöÁã°ËßíÈ•∫Áº¥ÁªûÂâøÊïôÈÖµËΩøËæÉÂè´Á™ñÊè≠Êé•ÁöÜÁß∏Ë°óÈò∂Êà™Âä´ËäÇÊ°îÊù∞Êç∑Áù´Á´≠Ê¥ÅÁªìËß£ÂßêÊàíËóâËä•ÁïåÂÄü‰ªãÁñ•ËØ´Â±äÂ∑æÁ≠ãÊñ§Èáë‰ªäÊ¥•Ë•üÁ¥ßÈî¶‰ªÖË∞®ËøõÈù≥ÊôãÁ¶ÅËøëÁÉ¨Êµ∏"],["be40","Á∂ô",12,"Á∂ß",6,"Á∂Ø",42],["be80","Á∑ö",32,"Â∞ΩÂä≤ËçÜÂÖ¢ËåéÁùõÊô∂È≤∏‰∫¨ÊÉäÁ≤æÁ≤≥Áªè‰∫ïË≠¶ÊôØÈ¢àÈùôÂ¢ÉÊï¨ÈïúÂæÑÁóâÈùñÁ´üÁ´ûÂáÄÁÇØÁ™òÊè™Á©∂Á∫†ÁéñÈü≠‰πÖÁÅ∏‰πùÈÖíÂé©ÊïëÊóßËáºËàÖÂíéÂ∞±ÁñöÈû†ÊãòÁãôÁñΩÂ±ÖÈ©πËèäÂ±ÄÂíÄÁü©‰∏æÊ≤ÆËÅöÊãíÊçÆÂ∑®ÂÖ∑Ë∑ùË∏ûÈîØ‰ø±Âè•ÊÉßÁÇ¨ÂâßÊçêÈπÉÂ®üÂÄ¶Áú∑Âç∑Áª¢ÊíÖÊî´ÊäâÊéòÂÄîÁàµËßâÂÜ≥ËØÄÁªùÂùáËèåÈíßÂÜõÂêõÂ≥ª"],["bf40","Á∑ª",62],["bf80","Á∏∫Á∏º",4,"ÁπÇ",4,"Áπà",21,"‰øäÁ´£ÊµöÈÉ°È™èÂñÄÂíñÂç°ÂíØÂºÄÊè©Ê•∑ÂáØÊÖ®ÂàäÂ†™ÂãòÂùéÁ†çÁúãÂ∫∑ÊÖ∑Á≥†ÊâõÊäó‰∫¢ÁÇïËÄÉÊã∑ÁÉ§Èù†Âù∑ËãõÊüØÊ£µÁ£ïÈ¢óÁßëÂ£≥Âí≥ÂèØÊ∏¥ÂÖãÂàªÂÆ¢ËØæËÇØÂïÉÂû¶ÊÅ≥ÂùëÂê≠Á©∫ÊÅêÂ≠îÊéßÊä†Âè£Êâ£ÂØáÊûØÂì≠Á™üËã¶ÈÖ∑Â∫ìË£§Â§∏ÂûÆÊåéË∑®ËÉØÂùóÁ≠∑‰æ©Âø´ÂÆΩÊ¨æÂå°Á≠êÁãÇÊ°ÜÁüøÁú∂Êó∑ÂÜµ‰∫èÁõîÂ≤øÁ™•ËëµÂ•éÈ≠ÅÂÇÄ"],["c040","Áπû",35,"Á∫É",23,"Á∫úÁ∫ùÁ∫û"],["c080","Á∫ÆÁ∫¥Á∫ªÁ∫ºÁªñÁª§Áª¨ÁªπÁºäÁºêÁºûÁº∑ÁºπÁºª",6,"ÁΩÉÁΩÜ",9,"ÁΩíÁΩìÈ¶àÊÑßÊ∫ÉÂù§ÊòÜÊçÜÂõ∞Êã¨Êâ©ÂªìÈòîÂûÉÊãâÂñáËú°ËÖäËæ£Âï¶Ëé±Êù•ËµñËìùÂ©™Ê†èÊã¶ÁØÆÈòëÂÖ∞ÊæúË∞∞ÊèΩËßàÊáíÁºÜÁÉÇÊª•ÁêÖÊ¶îÁãºÂªäÈÉéÊúóÊµ™ÊçûÂä≥Áâ¢ËÄÅ‰Ω¨Âß•ÈÖ™ÁÉôÊ∂ùÂãí‰πêÈõ∑Èï≠ËïæÁ£äÁ¥ØÂÑ°ÂûíÊìÇËÇãÁ±ªÊ≥™Ê£±Ê•ûÂÜ∑ÂéòÊ¢®ÁäÅÈªéÁØ±Áã∏Á¶ªÊºìÁêÜÊùéÈáåÈ≤§Á§ºËéâËçîÂêèÊ†ó‰∏ΩÂéâÂä±Á†æÂéÜÂà©ÂÇà‰æã‰øê"],["c140","ÁΩñÁΩôÁΩõÁΩúÁΩùÁΩûÁΩ†ÁΩ£",4,"ÁΩ´ÁΩ¨ÁΩ≠ÁΩØÁΩ∞ÁΩ≥ÁΩµÁΩ∂ÁΩ∑ÁΩ∏ÁΩ∫ÁΩªÁΩºÁΩΩÁΩøÁæÄÁæÇ",7,"ÁæãÁæçÁæè",4,"Áæï",4,"ÁæõÁæúÁæ†Áæ¢Áæ£Áæ•Áæ¶Áæ®",6,"Áæ±"],["c180","Áæ≥",4,"Áæ∫ÁæªÁææÁøÄÁøÇÁøÉÁøÑÁøÜÁøáÁøàÁøâÁøãÁøçÁøè",4,"ÁøñÁøóÁøô",5,"Áø¢Áø£Áó¢Á´ãÁ≤íÊ≤•Èö∂ÂäõÁíÉÂì©‰ø©ËÅîËé≤ËøûÈï∞ÂªâÊÄúÊ∂üÂ∏òÊïõËÑ∏ÈìæÊÅãÁÇºÁªÉÁ≤ÆÂáâÊ¢ÅÁ≤±ËâØ‰∏§ËæÜÈáèÊôæ‰∫ÆË∞ÖÊí©ËÅäÂÉöÁñóÁáéÂØ•ËæΩÊΩ¶‰∫ÜÊíÇÈï£ÂªñÊñôÂàóË£ÇÁÉàÂä£ÁåéÁê≥ÊûóÁ£∑Èúñ‰∏¥ÈÇªÈ≥ûÊ∑ãÂáõËµÅÂêùÊãéÁé≤Ëè±Èõ∂ÈæÑÈìÉ‰º∂ÁæöÂáåÁÅµÈôµÂ≤≠È¢ÜÂè¶‰ª§Ê∫úÁêâÊ¶¥Á°´È¶èÁïôÂàòÁò§ÊµÅÊü≥ÂÖ≠ÈæôËÅãÂíôÁ¨ºÁ™ø"],["c240","Áø§ÁøßÁø®Áø™Áø´Áø¨Áø≠ÁøØÁø≤Áø¥",6,"ÁøΩÁøæÁøøËÄÇËÄáËÄàËÄâËÄäËÄéËÄèËÄëËÄìËÄöËÄõËÄùËÄûËÄüËÄ°ËÄ£ËÄ§ËÄ´",5,"ËÄ≤ËÄ¥ËÄπËÄ∫ËÄºËÄæËÅÄËÅÅËÅÑËÅÖËÅáËÅàËÅâËÅéËÅèËÅêËÅëËÅìËÅïËÅñËÅó"],["c280","ËÅôËÅõ",13,"ËÅ´",5,"ËÅ≤",11,"ÈöÜÂûÑÊã¢ÈôáÊ•ºÂ®ÑÊêÇÁØìÊºèÈôãËä¶Âç¢È¢ÖÂ∫êÁÇâÊé≥Âç§ËôèÈ≤ÅÈ∫ìÁ¢åÈú≤Ë∑ØËµÇÈπøÊΩûÁ¶ÑÂΩïÈôÜÊàÆÈ©¥ÂêïÈìù‰æ£ÊóÖÂ±•Â±°ÁºïËôëÊ∞ØÂæãÁéáÊª§ÁªøÂ≥¶ÊåõÂ≠™Êª¶Âçµ‰π±Êé†Áï•Êä°ËΩÆ‰º¶‰ªëÊ≤¶Á∫∂ËÆ∫ËêùËû∫ÁΩóÈÄªÈî£ÁÆ©È™°Ë£∏ËêΩÊ¥õÈ™ÜÁªúÂ¶àÈ∫ªÁéõÁ†ÅËöÇÈ©¨È™ÇÂòõÂêóÂüã‰π∞È∫¶ÂçñËøàËÑâÁûíÈ¶íËõÆÊª°ËîìÊõºÊÖ¢Êº´"],["c340","ËÅæËÇÅËÇÇËÇÖËÇàËÇäËÇç",5,"ËÇîËÇïËÇóËÇôËÇûËÇ£ËÇ¶ËÇßËÇ®ËÇ¨ËÇ∞ËÇ≥ËÇµËÇ∂ËÇ∏ËÇπËÇªËÉÖËÉá",4,"ËÉè",6,"ËÉòËÉüËÉ†ËÉ¢ËÉ£ËÉ¶ËÉÆËÉµËÉ∑ËÉπËÉªËÉæËÉøËÑÄËÑÅËÑÉËÑÑËÑÖËÑáËÑàËÑã"],["c380","ËÑåËÑïËÑóËÑôËÑõËÑúËÑùËÑü",12,"ËÑ≠ËÑÆËÑ∞ËÑ≥ËÑ¥ËÑµËÑ∑ËÑπ",4,"ËÑøË∞©ËäíËå´Áõ≤Ê∞ìÂøôËéΩÁå´ËåÖÈîöÊØõÁüõÈìÜÂçØËåÇÂÜíÂ∏ΩË≤åË¥∏‰πàÁé´ÊûöÊ¢ÖÈÖ∂ÈúâÁÖ§Ê≤°ÁúâÂ™íÈïÅÊØèÁæéÊòßÂØêÂ¶πÂ™öÈó®Èó∑‰ª¨ËêåËíôÊ™¨ÁõüÈî∞ÁåõÊ¢¶Â≠üÁúØÈÜöÈù°Á≥úËø∑Ë∞úÂº•Á±≥ÁßòËßÖÊ≥åËúúÂØÜÂπÇÊ£âÁú†ÁªµÂÜïÂÖçÂãâÂ®©ÁºÖÈù¢ËãóÊèèÁûÑËóêÁßíÊ∏∫Â∫ôÂ¶ôËîëÁÅ≠Ê∞ëÊäøÁöøÊïèÊÇØÈóΩÊòéËûüÈ∏£Èì≠ÂêçÂëΩË∞¨Êë∏"],["c440","ËÖÄ",5,"ËÖáËÖâËÖçËÖéËÖèËÖíËÖñËÖóËÖòËÖõ",4,"ËÖ°ËÖ¢ËÖ£ËÖ§ËÖ¶ËÖ®ËÖ™ËÖ´ËÖ¨ËÖØËÖ≤ËÖ≥ËÖµËÖ∂ËÖ∑ËÖ∏ËÜÅËÜÉ",4,"ËÜâËÜãËÜåËÜçËÜéËÜêËÜí",5,"ËÜôËÜöËÜû",4,"ËÜ§ËÜ•"],["c480","ËÜßËÜ©ËÜ´",7,"ËÜ¥",5,"ËÜºËÜΩËÜæËÜøËáÑËáÖËááËáàËáâËáãËáç",6,"ÊëπËòëÊ®°ËÜúÁ£®Êë©È≠îÊäπÊú´Ëé´Â¢®ÈªòÊ≤´Êº†ÂØûÈôåË∞ãÁâüÊüêÊãáÁâ°‰∫©ÂßÜÊØçÂ¢ìÊöÆÂπïÂãüÊÖïÊú®ÁõÆÁù¶ÁâßÁ©ÜÊãøÂì™ÂëêÈí†ÈÇ£Â®úÁ∫≥Ê∞ñ‰πÉÂ•∂ËÄêÂ•àÂçóÁî∑ÈöæÂõäÊå†ËÑëÊÅºÈóπÊ∑ñÂë¢È¶ÅÂÜÖÂ´©ËÉΩÂ¶ÆÈúìÂÄ™Ê≥•Â∞ºÊãü‰Ω†ÂåøËÖªÈÄÜÊ∫∫Ëî´ÊãàÂπ¥Á¢æÊíµÊçªÂøµÂ®òÈÖøÈ∏üÂ∞øÊçèËÅÇÂ≠ΩÂïÆÈïäÈïçÊ∂ÖÊÇ®Êü†ÁãûÂáùÂÆÅ"],["c540","Ëáî",14,"Ëá§Ëá•Ëá¶Ëá®Ëá©Ëá´ËáÆ",4,"Ëáµ",5,"ËáΩËáøËàÉËàá",4,"ËàéËàèËàëËàìËàï",5,"ËàùËà†Ëà§Ëà•Ëà¶ËàßËà©ËàÆËà≤Ëà∫ËàºËàΩËàø"],["c580","ËâÄËâÅËâÇËâÉËâÖËâÜËâàËâäËâåËâçËâéËâê",7,"ËâôËâõËâúËâùËâûËâ†",7,"Ëâ©ÊãßÊ≥ûÁâõÊâ≠ÈíÆÁ∫ΩËÑìÊµìÂÜúÂºÑÂ•¥Âä™ÊÄíÂ•≥ÊöñËôêÁñüÊå™Êá¶Á≥ØËØ∫Âì¶Ê¨ßÈ∏•ÊÆ¥ËóïÂëïÂÅ∂Ê≤§Âï™Ë∂¥Áà¨Â∏ïÊÄïÁê∂ÊãçÊéíÁâåÂæòÊπÉÊ¥æÊîÄÊΩòÁõòÁ£êÁõºÁïîÂà§Âèõ‰πìÂ∫ûÊóÅËÄ™ËÉñÊäõÂíÜÂà®ÁÇÆË¢çË∑ëÊ≥°Âë∏ËÉöÂüπË£¥ËµîÈô™ÈÖç‰Ω©Ê≤õÂñ∑ÁõÜÁ†∞Êä®ÁÉπÊæéÂΩ≠Ëì¨Ê£öÁ°ºÁØ∑ËÜ®ÊúãÈπèÊçßÁ¢∞ÂùØÁ†íÈúπÊâπÊä´ÂäàÁêµÊØó"],["c640","Ëâ™Ëâ´Ëâ¨Ëâ≠Ëâ±ËâµËâ∂Ëâ∑Ëâ∏ËâªËâºËäÄËäÅËäÉËäÖËäÜËäáËäâËäåËäêËäìËäîËäïËäñËäöËäõËäûËä†Ëä¢Ëä£ËäßËä≤ËäµËä∂Ëä∫ËäªËäºËäøËãÄËãÇËãÉËãÖËãÜËãâËãêËãñËãôËãöËãùËã¢ËãßËã®Ëã©Ëã™Ëã¨Ëã≠ËãÆËã∞Ëã≤Ëã≥ËãµËã∂Ëã∏"],["c680","Ëã∫Ëãº",4,"ËåäËåãËåçËåêËåíËåìËåñËåòËåôËåù",9,"Ëå©Ëå™ËåÆËå∞Ëå≤Ëå∑ËåªËåΩÂï§ËÑæÁñ≤ÁöÆÂåπÁóûÂÉªÂ±ÅË≠¨ÁØáÂÅèÁâáÈ™óÈ£òÊºÇÁì¢Á•®ÊíáÁû•ÊãºÈ¢ëË¥´ÂìÅËÅò‰πíÂù™ËãπËêçÂπ≥Âá≠Áì∂ËØÑÂ±èÂù°Ê≥ºÈ¢áÂ©ÜÁ†¥È≠ÑËø´Á≤ïÂâñÊâëÈì∫‰ªÜËéÜËë°Ëè©Ëí≤ÂüîÊú¥ÂúÉÊôÆÊµ¶Ë∞±ÊõùÁÄëÊúüÊ¨∫Ê†ñÊàöÂ¶ª‰∏ÉÂáÑÊºÜÊüíÊ≤èÂÖ∂Ê£ãÂ•áÊ≠ßÁï¶Â¥éËÑêÈΩêÊóóÁ•àÁ•ÅÈ™ëËµ∑Â≤Ç‰πû‰ºÅÂêØÂ•ëÁ†åÂô®Ê∞îËøÑÂºÉÊ±ΩÊ≥£ËÆ´Êéê"],["c740","ËåæËåøËçÅËçÇËçÑËçÖËçàËçä",4,"ËçìËçï",4,"ËçùËç¢Ëç∞",6,"ËçπËç∫Ëçæ",6,"ËéáËéàËéäËéãËéåËéçËéèËéêËéëËéîËéïËéñËéóËéôËéöËéùËéüËé°",6,"Ëé¨Ëé≠ËéÆ"],["c780","ËéØËéµËéªËéæËéøËèÇËèÉËèÑËèÜËèàËèâËèãËèçËèéËèêËèëËèíËèìËèïËèóËèôËèöËèõËèûËè¢Ëè£Ëè§Ëè¶ËèßËè®Ëè´Ëè¨Ëè≠ÊÅ∞Ê¥ΩÁâµÊâ¶ÈíéÈìÖÂçÉËøÅÁ≠æ‰ªüË∞¶‰πæÈªîÈí±Èí≥ÂâçÊΩúÈÅ£ÊµÖË∞¥Â†ëÂµåÊ¨†Ê≠âÊû™ÂëõËÖîÁæåÂ¢ôËî∑Âº∫Êä¢Ê©áÈîπÊï≤ÊÇÑÊ°•Áûß‰πî‰æ®Â∑ßÈûòÊí¨ÁøòÂ≥≠‰øèÁ™çÂàáËåÑ‰∏îÊÄØÁ™ÉÈí¶‰æµ‰∫≤Áß¶Áê¥Âã§ËäπÊìíÁ¶ΩÂØùÊ≤ÅÈùíËΩªÊ∞¢ÂÄæÂçøÊ∏ÖÊìéÊô¥Ê∞∞ÊÉÖÈ°∑ËØ∑Â∫ÜÁêºÁ©∑Áßã‰∏òÈÇ±ÁêÉÊ±ÇÂõöÈÖãÊ≥ÖË∂ãÂå∫ËõÜÊõ≤Ë∫ØÂ±àÈ©±Ê∏†"],["c840","ËèÆËèØËè≥",4,"Ëè∫ËèªËèºËèæËèøËêÄËêÇËêÖËêáËêàËêâËêäËêêËêí",5,"ËêôËêöËêõËêû",5,"Ëê©",7,"Ëê≤",5,"ËêπËê∫ËêªËêæ",7,"ËëáËëàËëâ"],["c880","Ëëä",6,"Ëëí",4,"ËëòËëùËëûËëüËë†Ëë¢Ëë§",4,"Ëë™ËëÆËëØËë∞Ëë≤Ëë¥Ëë∑ËëπËëªËëºÂèñÂ®∂ÈæãË∂£ÂéªÂúàÈ¢ßÊùÉÈÜõÊ≥âÂÖ®ÁóäÊã≥Áä¨Âà∏ÂäùÁº∫ÁÇîÁò∏Âç¥ÈπäÊ¶∑Á°ÆÈõÄË£ôÁæ§ÁÑ∂ÁáÉÂÜâÊüìÁì§Â£§ÊîòÂö∑ËÆ©È•∂Êâ∞ÁªïÊÉπÁÉ≠Â£¨‰ªÅ‰∫∫ÂøçÈüß‰ªªËÆ§ÂàÉÂ¶äÁ∫´Êâî‰ªçÊó•ÊàéËå∏ËìâËç£ËûçÁÜîÊ∫∂ÂÆπÁªíÂÜóÊèâÊüîËÇâËåπË†ïÂÑíÂ≠∫Â¶ÇËæ±‰π≥Ê±ùÂÖ•Ë§•ËΩØÈòÆËïäÁëûÈîêÈó∞Ê∂¶Ëã•Âº±ÊííÊ¥íËê®ËÖÆÈ≥ÉÂ°ûËµõ‰∏âÂèÅ"],["c940","ËëΩ",4,"ËíÉËíÑËíÖËíÜËíäËíçËíè",7,"ËíòËíöËíõËíùËíûËíüËí†Ëí¢",12,"Ëí∞Ëí±Ëí≥ËíµËí∂Ëí∑ËíªËíºËíæËìÄËìÇËìÉËìÖËìÜËìáËìàËìãËìåËìéËìèËìíËìîËìïËìó"],["c980","Ëìò",4,"ËìûËì°Ëì¢Ëì§Ëìß",4,"Ëì≠ËìÆËìØËì±",10,"ËìΩËìæËîÄËîÅËîÇ‰ºûÊï£Ê°ëÂóì‰∏ßÊêîÈ™öÊâ´Â´ÇÁëüËâ≤Ê∂©Ê£ÆÂÉßËééÁ†ÇÊùÄÂàπÊ≤ôÁ∫±ÂÇªÂï•ÁÖûÁ≠õÊôíÁèäËã´ÊùâÂ±±Âà†ÁÖΩË°´Èó™ÈôïÊìÖËµ°ËÜ≥ÂñÑÊ±ïÊâáÁºÆÂ¢í‰º§ÂïÜËµèÊôå‰∏äÂ∞öË£≥Ê¢¢ÊçéÁ®çÁÉßËäçÂã∫Èü∂Â∞ëÂì®ÈÇµÁªçÂ•¢ËµäËõáËàåËàçËµ¶ÊëÑÂ∞ÑÊÖëÊ∂âÁ§æËÆæÁ†∑Áî≥Âëª‰º∏Ë∫´Ê∑±Â®†ÁªÖÁ•ûÊ≤àÂÆ°Â©∂ÁîöËÇæÊÖéÊ∏óÂ£∞ÁîüÁî•Áâ≤ÂçáÁª≥"],["ca40","ËîÉ",8,"ËîçËîéËîèËîêËîíËîîËîïËîñËîòËîôËîõËîúËîùËîûËî†Ëî¢",8,"Ëî≠",9,"Ëîæ",4,"ËïÑËïÖËïÜËïáËïã",10],["ca80","ËïóËïòËïöËïõËïúËïùËïü",4,"Ëï•Ëï¶ËïßËï©",8,"Ëï≥ËïµËï∂Ëï∑Ëï∏ËïºËïΩËïøËñÄËñÅÁúÅÁõõÂâ©ËÉúÂú£Â∏àÂ§±ÁãÆÊñΩÊπøËØóÂ∞∏Ëô±ÂçÅÁü≥ÊãæÊó∂‰ªÄÈ£üËöÄÂÆûËØÜÂè≤Áü¢‰ΩøÂ±éÈ©∂ÂßãÂºèÁ§∫Â£´‰∏ñÊüø‰∫ãÊã≠Ë™ìÈÄùÂäøÊòØÂóúÂô¨ÈÄÇ‰ªï‰æçÈáäÈ•∞Ê∞èÂ∏ÇÊÅÉÂÆ§ËßÜËØïÊî∂ÊâãÈ¶ñÂÆàÂØøÊéàÂîÆÂèóÁò¶ÂÖΩËî¨Êû¢Ê¢≥ÊÆäÊäíËæìÂèîËàíÊ∑ëÁñè‰π¶ËµéÂ≠∞ÁÜüËñØÊöëÊõôÁΩ≤ËúÄÈªçÈº†Â±ûÊúØËø∞Ê†ëÊùüÊàçÁ´ñÂ¢ÖÂ∫∂Êï∞Êº±"],["cb40","ËñÇËñÉËñÜËñà",6,"Ëñê",10,"Ëñù",6,"Ëñ•Ëñ¶ËñßËñ©Ëñ´Ëñ¨Ëñ≠Ëñ±",5,"Ëñ∏Ëñ∫",6,"ËóÇ",6,"Ëóä",4,"ËóëËóí"],["cb80","ËóîËóñ",5,"Ëóù",6,"Ëó•Ëó¶ËóßËó®Ëó™",14,"ÊÅïÂà∑ËÄçÊëîË°∞Áî©Â∏ÖÊ†ìÊã¥ÈúúÂèåÁàΩË∞ÅÊ∞¥Áù°Á®éÂêÆÁû¨È°∫ËàúËØ¥Á°ïÊúîÁÉÅÊñØÊíïÂò∂ÊÄùÁßÅÂè∏‰∏ùÊ≠ªËÇÜÂØ∫Âó£Âõõ‰º∫‰ººÈ•≤Â∑≥ÊùæËÄ∏ÊÄÇÈ¢ÇÈÄÅÂÆãËÆºËØµÊêúËâòÊìûÂóΩËãèÈÖ•‰øóÁ¥†ÈÄüÁ≤üÂÉ≥Â°ëÊ∫ØÂÆøËØâËÇÉÈÖ∏ËíúÁÆóËôΩÈöãÈöèÁª•È´ìÁ¢éÂ≤ÅÁ©óÈÅÇÈößÁ•üÂ≠ôÊçüÁ¨ãËìëÊ¢≠ÂîÜÁº©ÁêêÁ¥¢ÈîÅÊâÄÂ°å‰ªñÂÆÉÂ•πÂ°î"],["cc40","ËóπËó∫ËóºËóΩËóæËòÄ",4,"ËòÜ",10,"ËòíËòìËòîËòïËòó",15,"Ëò®Ëò™",13,"ËòπËò∫ËòªËòΩËòæËòøËôÄ"],["cc80","ËôÅ",11,"ËôíËôìËôï",4,"ËôõËôúËôùËôüËô†Ëô°Ëô£",7,"Áç≠ÊåûËπãË∏èËÉéËãîÊä¨Âè∞Ê≥∞ÈÖûÂ§™ÊÄÅÊ±∞ÂùçÊëäË¥™Áò´Êª©ÂùõÊ™ÄÁó∞ÊΩ≠Ë∞≠Ë∞àÂù¶ÊØØË¢íÁ¢≥Êé¢ÂèπÁÇ≠Ê±§Â°òÊê™Â†ÇÊ£†ËÜõÂîêÁ≥ñÂÄòË∫∫Ê∑åË∂üÁÉ´ÊéèÊ∂õÊªîÁª¶ËêÑÊ°ÉÈÄÉÊ∑òÈô∂ËÆ®Â•óÁâπËó§ËÖæÁñºË™äÊ¢ØÂâîË∏¢ÈîëÊèêÈ¢òËπÑÂïº‰ΩìÊõøÂöèÊÉïÊ∂ïÂâÉÂ±âÂ§©Ê∑ªÂ°´Áî∞ÁîúÊÅ¨ËàîËÖÜÊåëÊù°Ëø¢Áú∫Ë∑≥Ë¥¥ÈìÅÂ∏ñÂéÖÂê¨ÁÉÉ"],["cd40","Ëô≠ËôØËô∞Ëô≤",6,"ËöÉ",6,"Ëöé",4,"ËöîËöñ",5,"Ëöû",4,"Ëö•Ëö¶Ëö´Ëö≠ËöÆËö≤Ëö≥Ëö∑Ëö∏ËöπËöª",4,"ËõÅËõÇËõÉËõÖËõàËõåËõçËõíËõìËõïËõñËõóËõöËõú"],["cd80","ËõùËõ†Ëõ°Ëõ¢Ëõ£Ëõ•Ëõ¶ËõßËõ®Ëõ™Ëõ´Ëõ¨ËõØËõµËõ∂Ëõ∑Ëõ∫ËõªËõºËõΩËõøËúÅËúÑËúÖËúÜËúãËúåËúéËúèËúêËúëËúîËúñÊ±ÄÂª∑ÂÅú‰∫≠Â∫≠Êå∫ËâáÈÄöÊ°êÈÖÆÁû≥ÂêåÈìúÂΩ§Á´•Ê°∂ÊçÖÁ≠íÁªüÁóõÂÅ∑ÊäïÂ§¥ÈÄèÂá∏ÁßÉÁ™ÅÂõæÂæíÈÄîÊ∂ÇÂ±†ÂúüÂêêÂÖîÊπçÂõ¢Êé®È¢ìËÖøËúïË§™ÈÄÄÂêûÂ±ØËáÄÊãñÊâòËÑ±È∏µÈôÄÈ©ÆÈ©ºÊ§≠Â¶•ÊãìÂîæÊåñÂìáËõôÊ¥ºÂ®ÉÁì¶Ë¢úÊ≠™Â§ñË±åÂºØÊπæÁé©È°Ω‰∏∏ÁÉ∑ÂÆåÁ¢óÊåΩÊôöÁöñÊÉãÂÆõÂ©â‰∏áËÖïÊ±™Áéã‰∫°ÊûâÁΩëÂæÄÊó∫ÊúõÂøòÂ¶ÑÂ®Å"],["ce40","ËúôËúõËúùËúüËú†Ëú§Ëú¶ËúßËú®Ëú™Ëú´Ëú¨Ëú≠ËúØËú∞Ëú≤Ëú≥ËúµËú∂Ëú∏ËúπËú∫ËúºËúΩËùÄ",6,"ËùäËùãËùçËùèËùêËùëËùíËùîËùïËùñËùòËùö",5,"Ëù°Ëù¢Ëù¶",7,"ËùØËù±Ëù≤Ëù≥Ëùµ"],["ce80","Ëù∑Ëù∏ËùπËù∫ËùøËûÄËûÅËûÑËûÜËûáËûâËûäËûåËûé",4,"ËûîËûïËûñËûò",6,"Ëû†",4,"Â∑çÂæÆÂç±Èü¶ËøùÊ°ÖÂõ¥ÂîØÊÉü‰∏∫ÊΩçÁª¥ËãáËêéÂßî‰ºü‰º™Â∞æÁ∫¨Êú™ËîöÂë≥ÁïèËÉÉÂñÇÈ≠è‰ΩçÊ∏≠Ë∞ìÂ∞âÊÖ∞Âç´ÁòüÊ∏©ËöäÊñáÈóªÁ∫πÂêªÁ®≥Á¥äÈóÆÂó°ÁøÅÁìÆÊåùËúóÊ∂°Á™ùÊàëÊñ°ÂçßÊè°Ê≤ÉÂ∑´ÂëúÈí®‰πåÊ±°ËØ¨Â±ãÊó†ËäúÊ¢ßÂêæÂê¥ÊØãÊ≠¶‰∫îÊçÇÂçàËàû‰ºç‰æÆÂùûÊàäÈõæÊô§Áâ©ÂãøÂä°ÊÇüËØØÊòîÁÜôÊûêË•øÁ°íÁüΩÊô∞ÂòªÂê∏Èî°Áâ∫"],["cf40","Ëû•Ëû¶ËûßËû©Ëû™ËûÆËû∞Ëû±Ëû≤Ëû¥Ëû∂Ëû∑Ëû∏ËûπËûªËûºËûæËûøËüÅ",4,"ËüáËüàËüâËüå",4,"Ëüî",6,"ËüúËüùËüûËüüËü°Ëü¢Ëü£Ëü§Ëü¶ËüßËü®Ëü©Ëü´Ëü¨Ëü≠ËüØ",9],["cf80","Ëü∫ËüªËüºËüΩËüøË†ÄË†ÅË†ÇË†Ñ",5,"Ë†ã",7,"Ë†îË†óË†òË†ôË†öË†ú",4,"Ë†£Á®ÄÊÅØÂ∏åÊÇâËÜùÂ§ïÊÉúÁÜÑÁÉØÊ∫™Ê±êÁäÄÊ™ÑË¢≠Â∏≠‰π†Â™≥ÂñúÈì£Ê¥óÁ≥ªÈöôÊàèÁªÜÁûéËôæÂå£ÈúûËæñÊöáÂ≥°‰æ†Áã≠‰∏ãÂé¶Â§èÂêìÊéÄÈî®ÂÖà‰ªôÈ≤úÁ∫§Âí∏Ë¥§Ë°îËà∑Èó≤Ê∂éÂº¶Â´åÊòæÈô©Áé∞ÁåÆÂéøËÖ∫È¶ÖÁæ°ÂÆ™Èô∑ÈôêÁ∫øÁõ∏Âé¢Èï∂È¶ôÁÆ±Ë•ÑÊπò‰π°ÁøîÁ••ËØ¶ÊÉ≥Âìç‰∫´È°πÂ∑∑Ê©°ÂÉèÂêëË±°ËêßÁ°ùÈúÑÂâäÂìÆÂö£ÈîÄÊ∂àÂÆµÊ∑ÜÊôì"],["d040","Ë†§",13,"Ë†≥",5,"Ë†∫Ë†ªË†ΩË†æË†øË°ÅË°ÇË°ÉË°Ü",5,"Ë°é",5,"Ë°ïË°ñË°òË°ö",6,"Ë°¶Ë°ßË°™Ë°≠Ë°ØË°±Ë°≥Ë°¥Ë°µË°∂Ë°∏Ë°πË°∫"],["d080","Ë°ªË°ºË¢ÄË¢ÉË¢ÜË¢áË¢âË¢äË¢åË¢éË¢èË¢êË¢ëË¢ìË¢îË¢ïË¢ó",4,"Ë¢ù",4,"Ë¢£Ë¢•",5,"Â∞èÂ≠ùÊ†°ËÇñÂï∏Á¨ëÊïàÊ•î‰∫õÊ≠áËùéÈûãÂçèÊåüÊê∫ÈÇ™ÊñúËÉÅË∞êÂÜôÊ¢∞Âç∏ËüπÊáàÊ≥ÑÊ≥ªË∞¢Â±ëËñ™ËäØÈîåÊ¨£ËæõÊñ∞ÂøªÂøÉ‰ø°Ë°ÖÊòüËÖ•Áå©ÊÉ∫ÂÖ¥ÂàëÂûãÂΩ¢ÈÇ¢Ë°åÈÜíÂπ∏ÊùèÊÄßÂßìÂÖÑÂá∂ËÉ∏ÂåàÊ±πÈõÑÁÜä‰ºë‰øÆÁæûÊúΩÂóÖÈîàÁßÄË¢ñÁª£Â¢üÊàåÈúÄËôöÂòòÈ°ªÂæêËÆ∏ËìÑÈÖóÂèôÊó≠Â∫èÁïúÊÅ§ÁµÆÂ©øÁª™Áª≠ËΩ©ÂñßÂÆ£ÊÇ¨ÊóãÁéÑ"],["d140","Ë¢¨Ë¢ÆË¢ØË¢∞Ë¢≤",4,"Ë¢∏Ë¢πË¢∫Ë¢ªË¢ΩË¢æË¢øË£ÄË£ÉË£ÑË£áË£àË£äË£ãË£åË£çË£èË£êË£ëË£ìË£ñË£óË£ö",4,"Ë£†Ë£°Ë£¶Ë£ßË£©",6,"Ë£≤Ë£µË£∂Ë£∑Ë£∫Ë£ªË£ΩË£øË§ÄË§ÅË§É",5],["d180","Ë§âË§ã",4,"Ë§ëË§î",4,"Ë§ú",4,"Ë§¢Ë§£Ë§§Ë§¶Ë§ßË§®Ë§©Ë§¨Ë§≠Ë§ÆË§ØË§±Ë§≤Ë§≥Ë§µË§∑ÈÄâÁô£Áú©ÁªöÈù¥ËñõÂ≠¶Á©¥Èõ™Ë°ÄÂããÁÜèÂæ™Êó¨ËØ¢ÂØªÈ©ØÂ∑°ÊÆâÊ±õËÆ≠ËÆØÈÄäËøÖÂéãÊäºÈ∏¶È∏≠ÂëÄ‰∏´ËäΩÁâôËöúÂ¥ñË°ôÊ∂ØÈõÖÂìë‰∫öËÆ∂ÁÑâÂíΩÈòâÁÉüÊ∑πÁõê‰∏•Á†îËúíÂ≤©Âª∂Ë®ÄÈ¢úÈòéÁÇéÊ≤øÂ•ÑÊé©ÁúºË°çÊºîËâ≥Â†∞ÁáïÂéåÁ†öÈõÅÂîÅÂΩ¶ÁÑ∞ÂÆ¥Ë∞öÈ™åÊÆÉÂ§ÆÈ∏ØÁßßÊù®Êâ¨‰ΩØÁñ°ÁæäÊ¥ãÈò≥Ê∞ß‰ª∞ÁóíÂÖªÊ†∑ÊºæÈÇÄËÖ∞Â¶ñÁë∂"],["d240","Ë§∏",8,"Ë•ÇË•ÉË•Ö",24,"Ë•†",5,"Ë•ß",19,"Ë•º"],["d280","Ë•ΩË•æË¶ÄË¶ÇË¶ÑË¶ÖË¶á",26,"ÊëáÂ∞ßÈÅ•Á™ëË∞£ÂßöÂí¨ËàÄËçØË¶ÅËÄÄÊ§∞ÂôéËÄ∂Áà∑ÈáéÂÜ∂‰πüÈ°µÊéñ‰∏öÂè∂Êõ≥ËÖãÂ§úÊ∂≤‰∏ÄÂ£πÂåªÊèñÈì±‰æù‰ºäË°£È¢êÂ§∑ÈÅóÁßª‰ª™ËÉ∞ÁñëÊ≤ÇÂÆúÂß®ÂΩùÊ§ÖËöÅÂÄöÂ∑≤‰πôÁü£‰ª•Ëâ∫ÊäëÊòìÈÇëÂ±π‰∫øÂΩπËáÜÈÄ∏ËÇÑÁñ´‰∫¶Ë£îÊÑèÊØÖÂøÜ‰πâÁõäÊ∫¢ËØ£ËÆÆË∞äËØëÂºÇÁøºÁøåÁªéËåµËç´Âõ†ÊÆ∑Èü≥Èò¥ÂßªÂêüÈì∂Ê∑´ÂØÖÈ•ÆÂ∞πÂºïÈöê"],["d340","Ë¶¢",30,"ËßÉËßçËßìËßîËßïËßóËßòËßôËßõËßùËßüËß†Ëß°Ëß¢Ëß§ËßßËß®Ëß©Ëß™Ëß¨Ëß≠ËßÆËß∞Ëß±Ëß≤Ëß¥",6],["d380","Ëßª",4,"Ë®Å",5,"Ë®à",21,"Âç∞Ëã±Ê®±Â©¥Èπ∞Â∫îÁº®ËéπËê§Ëê•ËçßËùáËøéËµ¢ÁõàÂΩ±È¢ñÁ°¨Êò†ÂìüÊã•‰Ω£ËáÉÁóàÂ∫∏ÈõçË∏äËõπÂíèÊ≥≥Ê∂åÊ∞∏ÊÅøÂãáÁî®ÂπΩ‰ºòÊÇ†ÂøßÂ∞§Áî±ÈÇÆÈìÄÁäπÊ≤πÊ∏∏ÈÖâÊúâÂèãÂè≥‰ΩëÈáâËØ±ÂèàÂπºËøÇÊ∑§‰∫éÁõÇÊ¶ÜËôûÊÑöËàÜ‰Ωô‰øûÈÄæÈ±ºÊÑâÊ∏ùÊ∏îÈöÖ‰∫àÂ®±Èõ®‰∏éÂ±øÁ¶πÂÆáËØ≠ÁæΩÁéâÂüüËäãÈÉÅÂêÅÈÅáÂñªÂ≥™Âæ°ÊÑàÊ¨≤Áã±ËÇ≤Ë™â"],["d440","Ë®û",31,"Ë®ø",8,"Ë©â",21],["d480","Ë©ü",25,"Ë©∫",6,"Êµ¥ÂØìË£ïÈ¢ÑË±´È©≠È∏≥Ê∏äÂÜ§ÂÖÉÂû£Ë¢ÅÂéüÊè¥ËæïÂõ≠ÂëòÂúÜÁåøÊ∫êÁºòËøúËãëÊÑøÊÄ®Èô¢Êõ∞Á∫¶Ë∂äË∑ÉÈí•Â≤≥Á≤§ÊúàÊÇ¶ÈòÖËÄò‰∫ëÈÉßÂåÄÈô®ÂÖÅËøêËï¥ÈÖùÊôïÈüµÂ≠ïÂåùÁ†∏ÊùÇÊ†ΩÂìâÁÅæÂÆ∞ËΩΩÂÜçÂú®Âí±ÊîíÊöÇËµûËµÉËÑèËë¨ÈÅ≠Á≥üÂáøËóªÊû£Êó©Êæ°Ëö§Ë∫ÅÂô™ÈÄ†ÁöÇÁÅ∂Áá•Ë¥£Êã©ÂàôÊ≥ΩË¥ºÊÄéÂ¢ûÊÜéÊõæËµ†ÊâéÂñ≥Ê∏£Êú≠ËΩß"],["d540","Ë™Å",7,"Ë™ã",7,"Ë™î",46],["d580","Ë´É",32,"Èì°Èó∏Áú®Ê†ÖÊ¶®Âíã‰πçÁÇ∏ËØàÊëòÊñãÂÆÖÁ™ÑÂÄ∫ÂØ®ÁûªÊØ°Ë©πÁ≤òÊ≤æÁõèÊñ©ËæóÂ¥≠Â±ïËò∏Ê†àÂç†ÊàòÁ´ôÊπõÁªΩÊ®üÁ´†ÂΩ∞Êº≥Âº†ÊéåÊ∂®Êùñ‰∏àÂ∏êË¥¶‰ªóËÉÄÁò¥ÈöúÊãõÊò≠ÊâæÊ≤ºËµµÁÖßÁΩ©ÂÖÜËÇáÂè¨ÈÅÆÊäòÂì≤Ëõ∞ËæôËÄÖÈîóËîóËøôÊµôÁèçÊñüÁúüÁîÑÁ†ßËáªË¥ûÈíà‰æ¶ÊûïÁñπËØäÈúáÊåØÈïáÈòµËí∏Êå£ÁùÅÂæÅÁã∞‰∫âÊÄîÊï¥ÊãØÊ≠£Êîø"],["d640","Ë´§",34,"Ë¨à",27],["d680","Ë¨§Ë¨•Ë¨ß",30,"Â∏ßÁóáÈÉëËØÅËäùÊûùÊîØÂê±ËúòÁü•ËÇ¢ËÑÇÊ±Å‰πãÁªáËÅåÁõ¥Ê§çÊÆñÊâßÂÄº‰æÑÂùÄÊåáÊ≠¢Ë∂æÂè™Êó®Á∫∏ÂøóÊåöÊé∑Ëá≥Ëá¥ÁΩÆÂ∏úÂ≥ôÂà∂Êô∫Áß©Á®öË¥®ÁÇôÁóîÊªûÊ≤ªÁ™í‰∏≠ÁõÖÂø†ÈíüË°∑ÁªàÁßçËÇøÈáç‰ª≤‰ºóËàüÂë®Â∑ûÊ¥≤ËØåÁ≤•ËΩ¥ËÇòÂ∏öÂííÁö±ÂÆôÊòºÈ™§Áè†Ê†™ËõõÊú±Áå™ËØ∏ËØõÈÄêÁ´πÁÉõÁÖÆÊãÑÁû©Âò±‰∏ªËëóÊü±Âä©ËõÄË¥ÆÈì∏Á≠ë"],["d740","Ë≠Ü",31,"Ë≠ß",4,"Ë≠≠",25],["d780","ËÆá",24,"ËÆ¨ËÆ±ËÆªËØáËØêËØ™Ë∞âË∞û‰ΩèÊ≥®Á•ùÈ©ªÊäìÁà™ÊãΩ‰∏ìÁ†ñËΩ¨Êí∞ËµöÁØÜÊ°©Â∫ÑË£ÖÂ¶ÜÊíûÂ£ÆÁä∂Ê§éÈî•ËøΩËµòÂù†ÁºÄË∞ÜÂáÜÊçâÊãôÂçìÊ°åÁê¢ËåÅÈÖåÂïÑÁùÄÁÅºÊµäÂÖπÂí®ËµÑÂßøÊªãÊ∑ÑÂ≠úÁ¥´‰ªîÁ±ΩÊªìÂ≠êËá™Ê∏çÂ≠óÈ¨ÉÊ£ïË∏™ÂÆóÁªºÊÄªÁ∫µÈÇπËµ∞Â•èÊèçÁßüË∂≥ÂçíÊóèÁ•ñËØÖÈòªÁªÑÈíªÁ∫ÇÂò¥ÈÜâÊúÄÁΩ™Â∞äÈÅµÊò®Â∑¶‰ΩêÊüûÂÅö‰ΩúÂùêÂ∫ß"],["d840","Ë∞∏",8,"Ë±ÇË±ÉË±ÑË±ÖË±àË±äË±ãË±ç",7,"Ë±ñË±óË±òË±ôË±õ",5,"Ë±£",6,"Ë±¨",6,"Ë±¥Ë±µË±∂Ë±∑Ë±ª",6,"Ë≤ÉË≤ÑË≤ÜË≤á"],["d880","Ë≤àË≤ãË≤ç",6,"Ë≤ïË≤ñË≤óË≤ô",20,"‰∫ç‰∏åÂÖÄ‰∏êÂªøÂçÖ‰∏ï‰∫ò‰∏ûÈ¨≤Â≠¨Âô©‰∏®Á¶∫‰∏øÂåï‰πáÂ§≠ÁàªÂçÆÊ∞êÂõüËÉ§È¶óÊØìÁùæÈºó‰∏∂‰∫üÈºê‰πú‰π©‰∫ìËäàÂ≠õÂï¨Âòè‰ªÑÂéçÂéùÂé£Âé•ÂéÆÈù•ËµùÂåöÂèµÂå¶ÂåÆÂåæËµúÂç¶Âç£ÂàÇÂààÂàéÂà≠Âà≥ÂàøÂâÄÂâåÂâûÂâ°ÂâúËíØÂâΩÂäÇÂäÅÂäêÂäìÂÜÇÁΩî‰∫ª‰ªÉ‰ªâ‰ªÇ‰ª®‰ª°‰ª´‰ªû‰ºõ‰ª≥‰º¢‰Ω§‰ªµ‰º•‰ºß‰ºâ‰º´‰Ωû‰ΩßÊî∏‰Ωö‰Ωù"],["d940","Ë≤Æ",62],["d980","Ë≥≠",32,"‰Ωü‰Ωó‰º≤‰ºΩ‰Ω∂‰Ω¥‰æë‰æâ‰æÉ‰æè‰Ωæ‰Ωª‰æ™‰Ωº‰æ¨‰æî‰ø¶‰ø®‰ø™‰øÖ‰øö‰ø£‰øú‰øë‰øü‰ø∏ÂÄ©ÂÅå‰ø≥ÂÄ¨ÂÄèÂÄÆÂÄ≠‰øæÂÄúÂÄåÂÄ•ÂÄ®ÂÅæÂÅÉÂÅïÂÅàÂÅéÂÅ¨ÂÅªÂÇ•ÂÇßÂÇ©ÂÇ∫ÂÉñÂÑÜÂÉ≠ÂÉ¨ÂÉ¶ÂÉÆÂÑáÂÑã‰ªùÊ∞Ω‰Ωò‰Ω•‰øéÈæ†Ê±ÜÁ±¥ÂÖÆÂ∑ΩÈªâÈ¶òÂÜÅÂ§îÂãπÂåçË®áÂåêÂá´Â§ôÂÖï‰∫†ÂÖñ‰∫≥Ë°ÆË¢§‰∫µËÑîË£íÁ¶ÄÂ¨¥Ë†ÉÁæ∏ÂÜ´ÂÜ±ÂÜΩÂÜº"],["da40","Ë¥é",14,"Ë¥†ËµëËµíËµóËµüËµ•Ëµ®Ëµ©Ëµ™Ëµ¨ËµÆËµØËµ±Ëµ≤Ëµ∏",8,"Ë∂ÇË∂ÉË∂ÜË∂áË∂àË∂âË∂å",4,"Ë∂íË∂ìË∂ï",9,"Ë∂†Ë∂°"],["da80","Ë∂¢Ë∂§",12,"Ë∂≤Ë∂∂Ë∂∑Ë∂πË∂ªË∂ΩË∑ÄË∑ÅË∑ÇË∑ÖË∑áË∑àË∑âË∑äË∑çË∑êË∑íË∑ìË∑îÂááÂÜñÂÜ¢ÂÜ•ËÆ†ËÆ¶ËÆßËÆ™ËÆ¥ËÆµËÆ∑ËØÇËØÉËØãËØèËØéËØíËØìËØîËØñËØòËØôËØúËØüËØ†ËØ§ËØ®ËØ©ËØÆËØ∞ËØ≥ËØ∂ËØπËØºËØøË∞ÄË∞ÇË∞ÑË∞áË∞åË∞èË∞ëË∞íË∞îË∞ïË∞ñË∞ôË∞õË∞òË∞ùË∞üË∞†Ë∞°Ë∞•Ë∞ßË∞™Ë∞´Ë∞ÆË∞ØË∞≤Ë∞≥Ë∞µË∞∂Âç©Âç∫ÈòùÈò¢Èò°Èò±Èò™ÈòΩÈòºÈôÇÈôâÈôîÈôüÈôßÈô¨Èô≤Èô¥ÈöàÈöçÈöóÈö∞ÈÇóÈÇõÈÇùÈÇôÈÇ¨ÈÇ°ÈÇ¥ÈÇ≥ÈÇ∂ÈÇ∫"],["db40","Ë∑ïË∑òË∑ôË∑úË∑†Ë∑°Ë∑¢Ë∑•Ë∑¶Ë∑ßË∑©Ë∑≠Ë∑ÆË∑∞Ë∑±Ë∑≤Ë∑¥Ë∑∂Ë∑ºË∑æ",6,"Ë∏ÜË∏áË∏àË∏ãË∏çË∏éË∏êË∏ëË∏íË∏ìË∏ï",7,"Ë∏†Ë∏°Ë∏§",4,"Ë∏´Ë∏≠Ë∏∞Ë∏≤Ë∏≥Ë∏¥Ë∏∂Ë∏∑Ë∏∏Ë∏ªË∏ºË∏æ"],["db80","Ë∏øËπÉËπÖËπÜËπå",4,"Ëπì",5,"Ëπö",11,"ËπßËπ®Ëπ™Ëπ´ËπÆËπ±ÈÇ∏ÈÇ∞ÈÉèÈÉÖÈÇæÈÉêÈÉÑÈÉáÈÉìÈÉ¶ÈÉ¢ÈÉúÈÉóÈÉõÈÉ´ÈÉØÈÉæÈÑÑÈÑ¢ÈÑûÈÑ£ÈÑ±ÈÑØÈÑπÈÖÉÈÖÜÂàçÂ•ÇÂä¢Âä¨Âä≠ÂäæÂìøÂãêÂãñÂã∞ÂèüÁáÆÁüçÂª¥ÂáµÂáºÈ¨ØÂé∂ÂºÅÁïöÂ∑ØÂùåÂû©Âû°Â°æÂ¢ºÂ£ÖÂ£ëÂú©Âú¨Âú™Âú≥ÂúπÂúÆÂúØÂùúÂúªÂùÇÂù©ÂûÖÂù´ÂûÜÂùºÂùªÂù®Âù≠Âù∂Âù≥Âû≠Âû§ÂûåÂû≤ÂüèÂûßÂû¥ÂûìÂû†ÂüïÂüòÂüöÂüôÂüíÂû∏Âü¥ÂüØÂü∏Âü§Âüù"],["dc40","Ëπ≥ËπµËπ∑",4,"ËπΩËπæË∫ÄË∫ÇË∫ÉË∫ÑË∫ÜË∫à",6,"Ë∫ëË∫íË∫ìË∫ï",6,"Ë∫ùË∫ü",11,"Ë∫≠Ë∫ÆË∫∞Ë∫±Ë∫≥",6,"Ë∫ª",7],["dc80","ËªÉ",10,"Ëªè",21,"Â†ãÂ†çÂüΩÂü≠Â†ÄÂ†ûÂ†ôÂ°ÑÂ††Â°•Â°¨Â¢ÅÂ¢âÂ¢öÂ¢ÄÈ¶®ÈºôÊáøËâπËâΩËâøËäèËääËä®ËäÑËäéËäëËäóËäôËä´Ëä∏ËäæËä∞ËãàËãäËã£ËäòËä∑ËäÆËããËãåËãÅËä©Ëä¥Ëä°Ëä™ËäüËãÑËãéËä§Ëã°ËåâËã∑Ëã§ËåèËåáËãúËã¥ËãíËãòËååËãªËãìËåëËåöËåÜËåîËåïËã†ËãïËåúËçëËçõËçúËåàËéíËåºËå¥Ëå±ËéõËçûËåØËçèËçáËçÉËçüËçÄËåóËç†Ëå≠Ëå∫Ëå≥Ëç¶Ëç•"],["dd40","Ëª•",62],["dd80","Ëº§",32,"Ëç®ËåõËç©Ëç¨Ëç™Ëç≠ËçÆËé∞Ëç∏Ëé≥Ëé¥Ëé†Ëé™ËéìËéúËéÖËçºËé∂Ëé©ËçΩËé∏ËçªËéòËéûËé®Ëé∫ËéºËèÅËêÅËè•ËèòÂ†áËêòËêãËèùËèΩËèñËêúËê∏ËêëËêÜËèîËèüËêèËêÉËè∏ËèπËè™ËèÖËèÄËê¶Ëè∞Ëè°ËëúËëëËëöËëôËë≥ËíáËíàËë∫ËíâËë∏ËêºËëÜËë©Ëë∂ËíåËíéËê±Ëë≠ËìÅËìçËìêËì¶ËíΩËììËìäËíøËí∫Ëì†Ëí°ËíπËí¥ËíóËì•Ëì£ËîåÁîçËî∏Ëì∞ËîπËîüËî∫"],["de40","ËΩÖ",32,"ËΩ™ËæÄËæåËæíËæùËæ†Ëæ°Ëæ¢Ëæ§Ëæ•Ëæ¶ËæßËæ™Ëæ¨Ëæ≠ËæÆËæØËæ≤Ëæ≥Ëæ¥ËæµËæ∑Ëæ∏Ëæ∫ËæªËæºËæøËøÄËøÉËøÜ"],["de80","Ëøâ",4,"ËøèËøíËøñËøóËøöËø†Ëø°Ëø£ËøßËø¨ËøØËø±Ëø≤Ëø¥ËøµËø∂Ëø∫ËøªËøºËøæËøøÈÄáÈÄàÈÄåÈÄéÈÄìÈÄïÈÄòËïñËîªËìøËìºËïôËïàËï®Ëï§ËïûËï∫Áû¢ËïÉËï≤ËïªËñ§Ëñ®ËñáËñèËïπËñÆËñúËñÖËñπËñ∑Ëñ∞ËóìËóÅËóúËóøËòßËòÖËò©ËòñËòºÂªæÂºàÂ§ºÂ•ÅËÄ∑Â•ïÂ•öÂ•òÂåèÂ∞¢Â∞•Â∞¨Â∞¥ÊâåÊâ™ÊäüÊäªÊãäÊãöÊãóÊãÆÊå¢Êã∂ÊåπÊçãÊçÉÊé≠Êè∂Êç±Êç∫ÊééÊé¥Êç≠Êé¨ÊéäÊç©ÊéÆÊéºÊè≤Êè∏Êè†ÊèøÊèÑÊèûÊèéÊëíÊèÜÊéæÊëÖÊëÅÊêãÊêõÊê†ÊêåÊê¶Êê°ÊëûÊíÑÊë≠Êíñ"],["df40","ÈÄôÈÄúÈÄ£ÈÄ§ÈÄ•ÈÄß",5,"ÈÄ∞",4,"ÈÄ∑ÈÄπÈÄ∫ÈÄΩÈÄøÈÅÄÈÅÉÈÅÖÈÅÜÈÅà",4,"ÈÅéÈÅîÈÅïÈÅñÈÅôÈÅöÈÅú",5,"ÈÅ§ÈÅ¶ÈÅßÈÅ©ÈÅ™ÈÅ´ÈÅ¨ÈÅØ",4,"ÈÅ∂",6,"ÈÅæÈÇÅ"],["df80","ÈÇÑÈÇÖÈÇÜÈÇáÈÇâÈÇäÈÇå",4,"ÈÇíÈÇîÈÇñÈÇòÈÇöÈÇúÈÇûÈÇüÈÇ†ÈÇ§ÈÇ•ÈÇßÈÇ®ÈÇ©ÈÇ´ÈÇ≠ÈÇ≤ÈÇ∑ÈÇºÈÇΩÈÇøÈÉÄÊë∫Êí∑Êí∏ÊíôÊí∫ÊìÄÊìêÊìóÊì§Êì¢ÊîâÊî•ÊîÆÂºãÂøíÁîôÂºëÂçüÂè±ÂèΩÂè©Âè®ÂèªÂêíÂêñÂêÜÂëãÂëíÂëìÂëîÂëñÂëÉÂê°ÂëóÂëôÂê£Âê≤ÂíÇÂíîÂë∑Âë±Âë§ÂíöÂíõÂíÑÂë∂Âë¶ÂíùÂìêÂí≠ÂìÇÂí¥ÂìíÂíßÂí¶ÂììÂìîÂë≤Âí£ÂìïÂíªÂíøÂìåÂìôÂìöÂìúÂí©Âí™Âí§ÂìùÂìèÂìûÂîõÂìßÂî†ÂìΩÂîîÂì≥Âî¢Âî£ÂîèÂîëÂîßÂî™ÂïßÂñèÂñµÂïâÂï≠ÂïÅÂïïÂîøÂïêÂîº"],["e040","ÈÉÇÈÉÉÈÉÜÈÉàÈÉâÈÉãÈÉåÈÉçÈÉíÈÉîÈÉïÈÉñÈÉòÈÉôÈÉöÈÉûÈÉüÈÉ†ÈÉ£ÈÉ§ÈÉ•ÈÉ©ÈÉ™ÈÉ¨ÈÉÆÈÉ∞ÈÉ±ÈÉ≤ÈÉ≥ÈÉµÈÉ∂ÈÉ∑ÈÉπÈÉ∫ÈÉªÈÉºÈÉøÈÑÄÈÑÅÈÑÉÈÑÖ",19,"ÈÑöÈÑõÈÑú"],["e080","ÈÑùÈÑüÈÑ†ÈÑ°ÈÑ§",10,"ÈÑ∞ÈÑ≤",6,"ÈÑ∫",8,"ÈÖÑÂî∑ÂïñÂïµÂï∂Âï∑Âî≥Âî∞ÂïúÂñãÂóíÂñÉÂñ±ÂñπÂñàÂñÅÂñüÂïæÂóñÂñëÂïªÂóüÂñΩÂñæÂñîÂñôÂó™Âó∑ÂóâÂòüÂóëÂó´Âó¨ÂóîÂó¶ÂóùÂóÑÂóØÂó•Âó≤Âó≥ÂóåÂóçÂó®ÂóµÂó§ËæîÂòûÂòàÂòåÂòÅÂò§Âò£ÂóæÂòÄÂòßÂò≠ÂôòÂòπÂôóÂò¨ÂôçÂô¢ÂôôÂôúÂôåÂôîÂöÜÂô§Âô±Âô´ÂôªÂôºÂöÖÂöìÂöØÂõîÂõóÂõùÂõ°ÂõµÂõ´ÂõπÂõøÂúÑÂúäÂúâÂúúÂ∏èÂ∏ôÂ∏îÂ∏ëÂ∏±Â∏ªÂ∏º"],["e140","ÈÖÖÈÖáÈÖàÈÖëÈÖìÈÖîÈÖïÈÖñÈÖòÈÖôÈÖõÈÖúÈÖüÈÖ†ÈÖ¶ÈÖßÈÖ®ÈÖ´ÈÖ≠ÈÖ≥ÈÖ∫ÈÖªÈÖºÈÜÄ",4,"ÈÜÜÈÜàÈÜäÈÜéÈÜèÈÜì",6,"ÈÜú",5,"ÈÜ§",5,"ÈÜ´ÈÜ¨ÈÜ∞ÈÜ±ÈÜ≤ÈÜ≥ÈÜ∂ÈÜ∑ÈÜ∏ÈÜπÈÜª"],["e180","ÈÜº",10,"ÈáàÈáãÈáêÈáí",9,"Èáù",8,"Â∏∑ÂπÑÂπîÂπõÂπûÂπ°Â≤åÂ±∫Â≤çÂ≤êÂ≤ñÂ≤àÂ≤òÂ≤ôÂ≤ëÂ≤öÂ≤úÂ≤µÂ≤¢Â≤ΩÂ≤¨Â≤´Â≤±Â≤£Â≥ÅÂ≤∑Â≥ÑÂ≥íÂ≥§Â≥ãÂ≥•Â¥ÇÂ¥ÉÂ¥ßÂ¥¶Â¥ÆÂ¥§Â¥ûÂ¥ÜÂ¥õÂµòÂ¥æÂ¥¥Â¥ΩÂµ¨ÂµõÂµØÂµùÂµ´ÂµãÂµäÂµ©Âµ¥Â∂ÇÂ∂ôÂ∂ùË±≥Â∂∑Â∑ÖÂΩ≥ÂΩ∑ÂæÇÂæáÂæâÂæåÂæïÂæôÂæúÂæ®Âæ≠ÂæµÂæºË°¢ÂΩ°Áä≠Áä∞Áä¥Áä∑Áä∏ÁãÉÁãÅÁãéÁãçÁãíÁã®ÁãØÁã©Áã≤Áã¥Áã∑ÁåÅÁã≥ÁåÉÁã∫"],["e240","Èá¶",62],["e280","Èà•",32,"ÁãªÁåóÁåìÁå°ÁåäÁåûÁåùÁåïÁå¢ÁåπÁå•Áå¨Áå∏Áå±ÁçêÁççÁçóÁç†Áç¨ÁçØÁçæËàõÂ§•È£ßÂ§§Â§ÇÈ•£È•ß",5,"È•¥È•∑È•ΩÈ¶ÄÈ¶ÑÈ¶áÈ¶äÈ¶çÈ¶êÈ¶ëÈ¶ìÈ¶îÈ¶ïÂ∫ÄÂ∫ëÂ∫ãÂ∫ñÂ∫•Â∫†Â∫πÂ∫µÂ∫æÂ∫≥ËµìÂªíÂªëÂªõÂª®Âª™ËÜ∫ÂøÑÂøâÂøñÂøèÊÄÉÂøÆÊÄÑÂø°Âø§ÂøæÊÄÖÊÄÜÂø™Âø≠Âø∏ÊÄôÊÄµÊÄ¶ÊÄõÊÄèÊÄçÊÄ©ÊÄ´ÊÄäÊÄøÊÄ°ÊÅ∏ÊÅπÊÅªÊÅ∫ÊÅÇ"],["e340","ÈâÜ",45,"Èâµ",16],["e380","ÈäÜ",7,"Èäè",24,"ÊÅ™ÊÅΩÊÇñÊÇöÊÇ≠ÊÇùÊÇÉÊÇíÊÇåÊÇõÊÉ¨ÊÇªÊÇ±ÊÉùÊÉòÊÉÜÊÉöÊÇ¥ÊÑ†ÊÑ¶ÊÑïÊÑ£ÊÉ¥ÊÑÄÊÑéÊÑ´ÊÖäÊÖµÊÜ¨ÊÜîÊÜßÊÜ∑ÊáîÊáµÂøùÈö≥Èó©Èó´Èó±Èó≥ÈóµÈó∂ÈóºÈóæÈòÉÈòÑÈòÜÈòàÈòäÈòãÈòåÈòçÈòèÈòíÈòïÈòñÈòóÈòôÈòö‰∏¨ÁàøÊàïÊ∞µÊ±îÊ±úÊ±äÊ≤£Ê≤ÖÊ≤êÊ≤îÊ≤åÊ±®Ê±©Ê±¥Ê±∂Ê≤ÜÊ≤©Ê≥êÊ≥îÊ≤≠Ê≥∑Ê≥∏Ê≥±Ê≥óÊ≤≤Ê≥†Ê≥ñÊ≥∫Ê≥´Ê≥ÆÊ≤±Ê≥ìÊ≥ØÊ≥æ"],["e440","Èä®",5,"ÈäØ",24,"Èãâ",31],["e480","Èã©",32,"Ê¥πÊ¥ßÊ¥åÊµÉÊµàÊ¥áÊ¥ÑÊ¥ôÊ¥éÊ¥´ÊµçÊ¥ÆÊ¥µÊ¥öÊµèÊµíÊµîÊ¥≥Ê∂ëÊµØÊ∂ûÊ∂†ÊµûÊ∂ìÊ∂îÊµúÊµ†ÊµºÊµ£Ê∏öÊ∑áÊ∑ÖÊ∑ûÊ∏éÊ∂øÊ∑†Ê∏ëÊ∑¶Ê∑ùÊ∑ôÊ∏ñÊ∂´Ê∏åÊ∂ÆÊ∏´ÊπÆÊπéÊπ´Ê∫≤ÊπüÊ∫ÜÊπìÊπîÊ∏≤Ê∏•ÊπÑÊªüÊ∫±Ê∫òÊª†Êº≠Êª¢Ê∫•Ê∫ßÊ∫ΩÊ∫ªÊ∫∑ÊªóÊ∫¥ÊªèÊ∫èÊªÇÊ∫üÊΩ¢ÊΩÜÊΩáÊº§ÊºïÊªπÊºØÊº∂ÊΩãÊΩ¥Êº™ÊºâÊº©ÊæâÊæçÊæåÊΩ∏ÊΩ≤ÊΩºÊΩ∫Êøë"],["e540","Èåä",51,"Èåø",10],["e580","Èçä",31,"Èç´ÊøâÊæßÊæπÊæ∂ÊøÇÊø°ÊøÆÊøûÊø†ÊøØÁÄöÁÄ£ÁÄõÁÄπÁÄµÁÅèÁÅûÂÆÄÂÆÑÂÆïÂÆìÂÆ•ÂÆ∏ÁîØÈ™ûÊê¥ÂØ§ÂØÆË§∞ÂØ∞ËπáË¨áËæ∂ËøìËøïËø•ËøÆËø§Ëø©Ëø¶Ëø≥Ëø®ÈÄÖÈÄÑÈÄãÈÄ¶ÈÄëÈÄçÈÄñÈÄ°ÈÄµÈÄ∂ÈÄ≠ÈÄØÈÅÑÈÅëÈÅíÈÅêÈÅ®ÈÅòÈÅ¢ÈÅõÊöπÈÅ¥ÈÅΩÈÇÇÈÇàÈÇÉÈÇãÂΩêÂΩóÂΩñÂΩòÂ∞ªÂí´Â±êÂ±ôÂ≠±Â±£Â±¶ÁæºÂº™Âº©Âº≠Ëâ¥ÂººÈ¨ªÂ±ÆÂ¶ÅÂ¶ÉÂ¶çÂ¶©Â¶™Â¶£"],["e640","Èç¨",34,"Èéê",27],["e680","Èé¨",29,"ÈèãÈèåÈèçÂ¶óÂßäÂ¶´Â¶ûÂ¶§ÂßíÂ¶≤Â¶ØÂßóÂ¶æÂ®ÖÂ®ÜÂßùÂ®àÂß£ÂßòÂßπÂ®åÂ®âÂ®≤Â®¥Â®ëÂ®£Â®ìÂ©ÄÂ©ßÂ©äÂ©ïÂ®ºÂ©¢Â©µËÉ¨Â™™Â™õÂ©∑Â©∫Â™æÂ´´Â™≤Â´íÂ´îÂ™∏Â´†Â´£Â´±Â´ñÂ´¶Â´òÂ´úÂ¨âÂ¨óÂ¨ñÂ¨≤Â¨∑Â≠ÄÂ∞ïÂ∞úÂ≠öÂ≠•Â≠≥Â≠ëÂ≠ìÂ≠¢È©µÈ©∑È©∏È©∫È©øÈ©ΩÈ™ÄÈ™ÅÈ™ÖÈ™àÈ™äÈ™êÈ™íÈ™ìÈ™ñÈ™òÈ™õÈ™úÈ™ùÈ™üÈ™†È™¢È™£È™•È™ßÁ∫üÁ∫°Á∫£Á∫•Á∫®Á∫©"],["e740","Èèé",7,"Èèó",54],["e780","Èêé",32,"Á∫≠Á∫∞Á∫æÁªÄÁªÅÁªÇÁªâÁªãÁªåÁªêÁªîÁªóÁªõÁª†Áª°Áª®Áª´ÁªÆÁªØÁª±Áª≤ÁºçÁª∂Áª∫ÁªªÁªæÁºÅÁºÇÁºÉÁºáÁºàÁºãÁºåÁºèÁºëÁºíÁºóÁºôÁºúÁºõÁºüÁº°",6,"Áº™Áº´Áº¨Áº≠ÁºØ",4,"ÁºµÂπ∫ÁïøÂ∑õÁîæÈÇïÁééÁéëÁéÆÁé¢ÁéüÁèèÁèÇÁèëÁé∑Áé≥ÁèÄÁèâÁèàÁè•ÁèôÈ°ºÁêäÁè©ÁèßÁèûÁé∫Áè≤ÁêèÁê™ÁëõÁê¶Áê•Áê®Áê∞ÁêÆÁê¨"],["e840","ÈêØ",14,"Èêø",43,"Èë¨Èë≠ÈëÆÈëØ"],["e880","Èë∞",20,"ÈíëÈíñÈíòÈìáÈìèÈììÈìîÈìöÈì¶ÈìªÈîúÈî†ÁêõÁêöÁëÅÁëúÁëóÁëïÁëôÁë∑Áë≠ÁëæÁíúÁíéÁíÄÁíÅÁíáÁíãÁíûÁí®Áí©ÁíêÁíßÁìíÁí∫Èü™Èü´Èü¨ÊùåÊùìÊùûÊùàÊù©Êû•ÊûáÊù™Êù≥ÊûòÊûßÊùµÊû®ÊûûÊû≠ÊûãÊù∑ÊùºÊü∞Ê†âÊüòÊ†äÊü©Êû∞Ê†åÊüôÊûµÊüöÊû≥ÊüùÊ†ÄÊüÉÊû∏Êü¢Ê†éÊüÅÊüΩÊ†≤Ê†≥Ê°†Ê°°Ê°éÊ°¢Ê°ÑÊ°§Ê¢ÉÊ†ùÊ°ïÊ°¶Ê°ÅÊ°ßÊ°ÄÊ†æÊ°äÊ°âÊ†©Ê¢µÊ¢èÊ°¥Ê°∑Ê¢ìÊ°´Ê£ÇÊ•ÆÊ£ºÊ§üÊ§†Ê£π"],["e940","ÈîßÈî≥ÈîΩÈïÉÈïàÈïãÈïïÈïöÈï†ÈïÆÈï¥ÈïµÈï∑",7,"ÈñÄ",42],["e980","Èñ´",32,"Ê§§Ê£∞Ê§ãÊ§ÅÊ•óÊ££Ê§êÊ•±Ê§πÊ•†Ê•ÇÊ•ùÊ¶ÑÊ•´Ê¶ÄÊ¶òÊ•∏Ê§¥ÊßåÊ¶áÊ¶àÊßéÊ¶âÊ•¶Ê•£Ê•πÊ¶õÊ¶ßÊ¶ªÊ¶´Ê¶≠ÊßîÊ¶±ÊßÅÊßäÊßüÊ¶ïÊß†Ê¶çÊßøÊ®ØÊß≠Ê®óÊ®òÊ©•Êß≤Ê©ÑÊ®æÊ™†Ê©êÊ©õÊ®µÊ™éÊ©πÊ®ΩÊ®®Ê©òÊ©ºÊ™ëÊ™êÊ™©Ê™óÊ™´Áå∑ÁçíÊÆÅÊÆÇÊÆáÊÆÑÊÆíÊÆìÊÆçÊÆöÊÆõÊÆ°ÊÆ™ËΩ´ËΩ≠ËΩ±ËΩ≤ËΩ≥ËΩµËΩ∂ËΩ∏ËΩ∑ËΩπËΩ∫ËΩºËΩæËæÅËæÇËæÑËæáËæã"],["ea40","Èóå",27,"Èó¨ÈóøÈòáÈòìÈòòÈòõÈòûÈò†Èò£",6,"Èò´Èò¨Èò≠ÈòØÈò∞Èò∑Èò∏ÈòπÈò∫ÈòæÈôÅÈôÉÈôäÈôéÈôèÈôëÈôíÈôìÈôñÈôó"],["ea80","ÈôòÈôôÈôöÈôúÈôùÈôûÈô†Èô£Èô•Èô¶Èô´Èô≠",4,"Èô≥Èô∏",12,"ÈöáÈöâÈöäËæçËæéËæèËæòËæöËªéÊàãÊàóÊàõÊàüÊà¢Êà°Êà•Êà§Êà¨ËáßÁìØÁì¥ÁìøÁîèÁîëÁîìÊî¥ÊóÆÊóØÊó∞ÊòäÊòôÊù≤ÊòÉÊòïÊòÄÁÇÖÊõ∑ÊòùÊò¥Êò±Êò∂ÊòµËÄÜÊôüÊôîÊôÅÊôèÊôñÊô°ÊôóÊô∑ÊöÑÊöåÊößÊöùÊöæÊõõÊõúÊõ¶Êõ©Ë¥≤Ë¥≥Ë¥∂Ë¥ªË¥ΩËµÄËµÖËµÜËµàËµâËµáËµçËµïËµôËßáËßäËßãËßåËßéËßèËßêËßëÁâÆÁäüÁâùÁâ¶ÁâØÁâæÁâøÁäÑÁäãÁäçÁäèÁäíÊåàÊå≤Êé∞"],["eb40","ÈöåÈöéÈöëÈöíÈöìÈöïÈöñÈööÈöõÈöù",9,"Èö®",7,"Èö±Èö≤Èö¥ÈöµÈö∑Èö∏Èö∫ÈöªÈöøÈõÇÈõÉÈõàÈõäÈõãÈõêÈõëÈõìÈõîÈõñ",9,"Èõ°",6,"Èõ´"],["eb80","Èõ¨Èõ≠ÈõÆÈõ∞Èõ±Èõ≤Èõ¥ÈõµÈõ∏Èõ∫ÈõªÈõºÈõΩÈõøÈúÇÈúÉÈúÖÈúäÈúãÈúåÈúêÈúëÈúíÈúîÈúïÈúó",4,"ÈúùÈúüÈú†ÊêøÊìòËÄÑÊØ™ÊØ≥ÊØΩÊØµÊØπÊ∞ÖÊ∞áÊ∞ÜÊ∞çÊ∞ïÊ∞òÊ∞ôÊ∞öÊ∞°Ê∞©Ê∞§Ê∞™Ê∞≤ÊîµÊïïÊï´ÁâçÁâíÁâñÁà∞Ëô¢ÂàñËÇüËÇúËÇìËÇºÊúäËÇΩËÇ±ËÇ´ËÇ≠ËÇ¥ËÇ∑ËÉßËÉ®ËÉ©ËÉ™ËÉõËÉÇËÉÑËÉôËÉçËÉóÊúêËÉùËÉ´ËÉ±ËÉ¥ËÉ≠ËÑçËÑéËÉ≤ËÉºÊúïËÑíË±öËÑ∂ËÑûËÑ¨ËÑòËÑ≤ËÖàËÖåËÖìËÖ¥ËÖôËÖöËÖ±ËÖ†ËÖ©ËÖºËÖΩËÖ≠ËÖßÂ°çÂ™µËÜàËÜÇËÜëÊªïËÜ£ËÜ™ËáåÊú¶ËáäËÜª"],["ec40","Èú°",8,"Èú´Èú¨ÈúÆÈúØÈú±Èú≥",4,"Èú∫ÈúªÈúºÈúΩÈúø",18,"ÈùîÈùïÈùóÈùòÈùöÈùúÈùùÈùüÈù£Èù§Èù¶ÈùßÈù®Èù™",7],["ec80","Èù≤ÈùµÈù∑",4,"ÈùΩ",7,"ÈûÜ",4,"ÈûåÈûéÈûèÈûêÈûìÈûïÈûñÈûóÈûô",4,"ËáÅËÜ¶Ê¨§Ê¨∑Ê¨πÊ≠ÉÊ≠ÜÊ≠ôÈ£ëÈ£íÈ£ìÈ£ïÈ£ôÈ£öÊÆ≥ÂΩÄÊØÇËß≥ÊñêÈΩëÊñìÊñºÊóÜÊóÑÊóÉÊóåÊóéÊóíÊóñÁÇÄÁÇúÁÇñÁÇùÁÇªÁÉÄÁÇ∑ÁÇ´ÁÇ±ÁÉ®ÁÉäÁÑêÁÑìÁÑñÁÑØÁÑ±ÁÖ≥ÁÖúÁÖ®ÁÖÖÁÖ≤ÁÖäÁÖ∏ÁÖ∫ÁÜòÁÜ≥ÁÜµÁÜ®ÁÜ†Áá†ÁáîÁáßÁáπÁàùÁà®ÁÅ¨ÁÑòÁÖ¶ÁÜπÊàæÊàΩÊâÉÊâàÊââÁ§ªÁ•ÄÁ•ÜÁ•âÁ•õÁ•úÁ•ìÁ•öÁ•¢Á•óÁ•†Á•ØÁ•ßÁ•∫Á¶ÖÁ¶äÁ¶öÁ¶ßÁ¶≥ÂøëÂøê"],["ed40","ÈûûÈûüÈû°Èû¢Èû§",6,"Èû¨ÈûÆÈû∞Èû±Èû≥Èûµ",46],["ed80","Èü§Èü•Èü®ÈüÆ",4,"Èü¥Èü∑",23,"ÊÄºÊÅùÊÅöÊÅßÊÅÅÊÅôÊÅ£ÊÇ´ÊÑÜÊÑçÊÖùÊÜ©ÊÜùÊáãÊáëÊàÜËÇÄËÅøÊ≤ìÊ≥∂Ê∑ºÁü∂Áü∏Á†ÄÁ†âÁ†óÁ†òÁ†ëÊñ´Á†≠Á†úÁ†ùÁ†πÁ†∫Á†ªÁ†üÁ†ºÁ†•Á†¨Á†£Á†©Á°éÁ°≠Á°ñÁ°óÁ†¶Á°êÁ°áÁ°åÁ°™Á¢õÁ¢ìÁ¢öÁ¢áÁ¢úÁ¢°Á¢£Á¢≤Á¢πÁ¢•Á£îÁ£ôÁ£âÁ£¨Á£≤Á§ÖÁ£¥Á§ìÁ§§Á§ûÁ§¥ÈæõÈªπÈªªÈªºÁõ±ÁúÑÁúçÁõπÁúáÁúàÁúöÁú¢ÁúôÁú≠Áú¶ÁúµÁú∏ÁùêÁùëÁùáÁùÉÁùöÁù®"],["ee40","È†è",62],["ee80","È°é",32,"Áù¢Áù•ÁùøÁûçÁùΩÁûÄÁûåÁûëÁûüÁû†Áû∞ÁûµÁûΩÁî∫ÁïÄÁïéÁïãÁïàÁïõÁï≤ÁïπÁñÉÁΩòÁΩ°ÁΩüË©àÁΩ®ÁΩ¥ÁΩ±ÁΩπÁæÅÁΩæÁõçÁõ•Ë†≤ÈíÖÈíÜÈíáÈíãÈíäÈíåÈíçÈíèÈíêÈíîÈíóÈíïÈíöÈíõÈíúÈí£Èí§Èí´Èí™Èí≠Èí¨ÈíØÈí∞Èí≤Èí¥Èí∂",4,"ÈíºÈíΩÈíøÈìÑÈìà",6,"ÈìêÈìëÈìíÈìïÈìñÈìóÈìôÈìòÈìõÈìûÈìüÈì†Èì¢Èì§Èì•ÈìßÈì®Èì™"],["ef40","È°Ø",5,"È¢ãÈ¢éÈ¢íÈ¢ïÈ¢ôÈ¢£È¢®",37,"È£èÈ£êÈ£îÈ£ñÈ£óÈ£õÈ£úÈ£ùÈ£†",4],["ef80","È£•È£¶È£©",30,"Èì©Èì´ÈìÆÈìØÈì≥Èì¥ÈìµÈì∑ÈìπÈìºÈìΩÈìøÈîÉÈîÇÈîÜÈîáÈîâÈîäÈîçÈîéÈîèÈîí",4,"ÈîòÈîõÈîùÈîûÈîüÈî¢Èî™Èî´Èî©Èî¨Èî±Èî≤Èî¥Èî∂Èî∑Èî∏ÈîºÈîæÈîøÈïÇÈîµÈïÑÈïÖÈïÜÈïâÈïåÈïéÈïèÈïíÈïìÈïîÈïñÈïóÈïòÈïôÈïõÈïûÈïüÈïùÈï°Èï¢Èï§",8,"ÈïØÈï±Èï≤Èï≥Èî∫ÁüßÁü¨ÈõâÁßïÁß≠Áß£Áß´Á®ÜÂµáÁ®ÉÁ®ÇÁ®ûÁ®î"],["f040","È§à",4,"È§éÈ§èÈ§ë",28,"È§Ø",26],["f080","È•ä",9,"È•ñ",12,"È•§È•¶È•≥È•∏È•πÈ•ªÈ•æÈ¶ÇÈ¶ÉÈ¶âÁ®πÁ®∑Á©ëÈªèÈ¶•Á©∞ÁöàÁöéÁöìÁöôÁö§ÁìûÁì†Áî¨È∏†È∏¢È∏®",4,"È∏≤È∏±È∏∂È∏∏È∏∑È∏πÈ∏∫È∏æÈπÅÈπÇÈπÑÈπÜÈπáÈπàÈπâÈπãÈπåÈπéÈπëÈπïÈπóÈπöÈπõÈπúÈπûÈπ£Èπ¶",6,"Èπ±Èπ≠Èπ≥ÁñíÁñîÁññÁñ†ÁñùÁñ¨Áñ£Áñ≥Áñ¥Áñ∏ÁóÑÁñ±Áñ∞ÁóÉÁóÇÁóñÁóçÁó£Áó®Áó¶Áó§Áó´ÁóßÁòÉÁó±ÁóºÁóøÁòêÁòÄÁòÖÁòåÁòóÁòäÁò•ÁòòÁòïÁòô"],["f140","È¶åÈ¶éÈ¶ö",10,"È¶¶È¶ßÈ¶©",47],["f180","Èßô",32,"ÁòõÁòºÁò¢Áò†ÁôÄÁò≠Áò∞ÁòøÁòµÁôÉÁòæÁò≥ÁôçÁôûÁôîÁôúÁôñÁô´ÁôØÁøäÁ´¶Á©∏Á©πÁ™ÄÁ™ÜÁ™àÁ™ïÁ™¶Á™†Á™¨Á™®Á™≠Á™≥Ë°§Ë°©Ë°≤Ë°ΩË°øË¢ÇË¢¢Ë£ÜË¢∑Ë¢ºË£âË£¢Ë£éË££Ë£•Ë£±Ë§öË£ºË£®Ë£æË£∞Ë§°Ë§ôË§ìË§õË§äË§¥Ë§´Ë§∂Ë•ÅË•¶Ë•ªÁñãËÉ•Áö≤Áö¥ÁüúËÄíËÄîËÄñËÄúËÄ†ËÄ¢ËÄ•ËÄ¶ËÄßËÄ©ËÄ®ËÄ±ËÄãËÄµËÅÉËÅÜËÅçËÅíËÅ©ËÅ±Ë¶ÉÈ°∏È¢ÄÈ¢É"],["f240","Èß∫",62],["f280","È®π",32,"È¢âÈ¢åÈ¢çÈ¢èÈ¢îÈ¢öÈ¢õÈ¢ûÈ¢üÈ¢°È¢¢È¢•È¢¶ËôçËôîËô¨ËôÆËôøËô∫ËôºËôªËö®ËöçËöãËö¨ËöùËößËö£Ëö™ËöìËö©Ëö∂ËõÑËöµËõéËö∞Ëö∫Ëö±ËöØËõâËõèËö¥Ëõ©Ëõ±Ëõ≤Ëõ≠Ëõ≥ËõêËúìËõûËõ¥ËõüËõòËõëËúÉËúáËõ∏ËúàËúäËúçËúâËú£ËúªËúûËú•ËúÆËúöËúæËùàËú¥Ëú±Ëú©Ëú∑ËúøËûÇËú¢ËùΩËùæËùªËù†Ëù∞ËùåËùÆËûãËùìËù£ËùºËù§ËùôËù•ËûìËûØËû®Ëüí"],["f340","È©ö",17,"È©≤È™ÉÈ™âÈ™çÈ™éÈ™îÈ™ïÈ™ôÈ™¶È™©",6,"È™≤È™≥È™¥È™µÈ™πÈ™ªÈ™ΩÈ™æÈ™øÈ´ÉÈ´ÑÈ´Ü",4,"È´çÈ´éÈ´èÈ´êÈ´íÈ´îÈ´ïÈ´ñÈ´óÈ´ôÈ´öÈ´õÈ´ú"],["f380","È´ùÈ´ûÈ´†È´¢È´£È´§È´•È´ßÈ´®È´©È´™È´¨È´ÆÈ´∞",8,"È´∫È´º",6,"È¨ÑÈ¨ÖÈ¨ÜËüÜËûàËûÖËû≠ËûóËûÉËû´Ëü•Ëû¨ËûµËû≥ËüãËüìËûΩËüëËüÄËüäËüõËü™Ëü†ËüÆË†ñË†ìËüæË†äË†õË†°Ë†πË†ºÁº∂ÁΩÇÁΩÑÁΩÖËàêÁ´∫Á´ΩÁ¨àÁ¨ÉÁ¨ÑÁ¨ïÁ¨äÁ¨´Á¨èÁ≠áÁ¨∏Á¨™Á¨ôÁ¨ÆÁ¨±Á¨†Á¨•Á¨§Á¨≥Á¨æÁ¨ûÁ≠òÁ≠öÁ≠ÖÁ≠µÁ≠åÁ≠ùÁ≠†Á≠ÆÁ≠ªÁ≠¢Á≠≤Á≠±ÁÆêÁÆ¶ÁÆßÁÆ∏ÁÆ¨ÁÆùÁÆ®ÁÆÖÁÆ™ÁÆúÁÆ¢ÁÆ´ÁÆ¥ÁØëÁØÅÁØåÁØùÁØöÁØ•ÁØ¶ÁØ™Á∞åÁØæÁØºÁ∞èÁ∞ñÁ∞ã"],["f440","È¨áÈ¨â",5,"È¨êÈ¨ëÈ¨íÈ¨î",10,"È¨†È¨°È¨¢È¨§",10,"È¨∞È¨±È¨≥",7,"È¨ΩÈ¨æÈ¨øÈ≠ÄÈ≠ÜÈ≠äÈ≠ãÈ≠åÈ≠éÈ≠êÈ≠íÈ≠ìÈ≠ï",5],["f480","È≠õ",32,"Á∞üÁ∞™Á∞¶Á∞∏Á±ÅÁ±ÄËáæËàÅËàÇËàÑËá¨Ë°ÑËà°Ëà¢Ëà£Ëà≠ËàØËà®Ëà´Ëà∏ËàªËà≥Ëà¥ËàæËâÑËââËâãËâèËâöËâüËâ®Ë°æË¢ÖË¢àË£òË£üË•ûÁæùÁæüÁæßÁæØÁæ∞Áæ≤Á±ºÊïâÁ≤ëÁ≤ùÁ≤úÁ≤ûÁ≤¢Á≤≤Á≤ºÁ≤ΩÁ≥ÅÁ≥áÁ≥åÁ≥çÁ≥àÁ≥ÖÁ≥óÁ≥®ËâÆÊö®ÁæøÁøéÁøïÁø•Áø°Áø¶Áø©ÁøÆÁø≥Á≥∏Áµ∑Á∂¶Á∂ÆÁπáÁ∫õÈ∫∏È∫¥Ëµ≥Ë∂ÑË∂îË∂ëË∂±ËµßËµ≠Ë±áË±âÈÖäÈÖêÈÖéÈÖèÈÖ§"],["f540","È≠º",62],["f580","ÈÆª",32,"ÈÖ¢ÈÖ°ÈÖ∞ÈÖ©ÈÖØÈÖΩÈÖæÈÖ≤ÈÖ¥ÈÖπÈÜåÈÜÖÈÜêÈÜçÈÜëÈÜ¢ÈÜ£ÈÜ™ÈÜ≠ÈÜÆÈÜØÈÜµÈÜ¥ÈÜ∫Ë±ïÈπæË∂∏Ë∑´Ë∏ÖËπôËπ©Ë∂µË∂øË∂ºË∂∫Ë∑ÑË∑ñË∑óË∑öË∑ûË∑éË∑èË∑õË∑ÜË∑¨Ë∑∑Ë∑∏Ë∑£Ë∑πË∑ªË∑§Ë∏âË∑ΩË∏îË∏ùË∏üË∏¨Ë∏ÆË∏£Ë∏ØË∏∫ËπÄË∏πË∏µË∏ΩË∏±ËπâËπÅËπÇËπëËπíËπäËπ∞Ëπ∂ËπºËπØËπ¥Ë∫ÖË∫èË∫îË∫êË∫úË∫ûË±∏Ë≤ÇË≤äË≤ÖË≤òË≤îÊñõËßñËßûËßöËßú"],["f640","ÈØú",62],["f680","È∞õ",32,"Ëß•Ëß´ËßØË®æË¨¶ÈùìÈõ©Èõ≥ÈõØÈúÜÈúÅÈúàÈúèÈúéÈú™Èú≠Èú∞ÈúæÈæÄÈæÉÈæÖ",5,"ÈæåÈªæÈºãÈºçÈöπÈöºÈöΩÈõéÈõíÁûøÈõ†ÈäéÈäÆÈãàÈåæÈç™ÈèäÈéèÈêæÈë´È±øÈ≤ÇÈ≤ÖÈ≤ÜÈ≤áÈ≤àÁ®£È≤ãÈ≤éÈ≤êÈ≤ëÈ≤íÈ≤îÈ≤ïÈ≤öÈ≤õÈ≤û",5,"È≤•",4,"È≤´È≤≠È≤ÆÈ≤∞",7,"È≤∫È≤ªÈ≤ºÈ≤ΩÈ≥ÑÈ≥ÖÈ≥ÜÈ≥áÈ≥äÈ≥ã"],["f740","È∞º",62],["f780","È±ªÈ±ΩÈ±æÈ≤ÄÈ≤ÉÈ≤ÑÈ≤âÈ≤äÈ≤åÈ≤èÈ≤ìÈ≤ñÈ≤óÈ≤òÈ≤ôÈ≤ùÈ≤™È≤¨È≤ØÈ≤πÈ≤æ",4,"È≥àÈ≥âÈ≥ëÈ≥íÈ≥öÈ≥õÈ≥†È≥°È≥å",4,"È≥ìÈ≥îÈ≥ïÈ≥óÈ≥òÈ≥ôÈ≥úÈ≥ùÈ≥üÈ≥¢ÈùºÈûÖÈûëÈûíÈûîÈûØÈû´Èû£Èû≤Èû¥È™±È™∞È™∑ÈπòÈ™∂È™∫È™ºÈ´ÅÈ´ÄÈ´ÖÈ´ÇÈ´ãÈ´åÈ´ëÈ≠ÖÈ≠ÉÈ≠áÈ≠âÈ≠àÈ≠çÈ≠ëÈ£®È§çÈ§ÆÈ•ïÈ•îÈ´üÈ´°È´¶È´ØÈ´´È´ªÈ´≠È´πÈ¨àÈ¨èÈ¨ìÈ¨üÈ¨£È∫ΩÈ∫æÁ∏ªÈ∫ÇÈ∫áÈ∫àÈ∫ãÈ∫íÈèñÈ∫ùÈ∫üÈªõÈªúÈªùÈª†ÈªüÈª¢Èª©ÈªßÈª•Èª™ÈªØÈº¢Èº¨ÈºØÈºπÈº∑ÈºΩÈºæÈΩÑ"],["f840","È≥£",62],["f880","È¥¢",32],["f940","ÈµÉ",62],["f980","È∂Ç",32],["fa40","È∂£",62],["fa80","È∑¢",32],["fb40","È∏É",27,"È∏§È∏ßÈ∏ÆÈ∏∞È∏¥È∏ªÈ∏ºÈπÄÈπçÈπêÈπíÈπìÈπîÈπñÈπôÈπùÈπüÈπ†Èπ°Èπ¢Èπ•ÈπÆÈπØÈπ≤Èπ¥",9,"È∫Ä"],["fb80","È∫ÅÈ∫ÉÈ∫ÑÈ∫ÖÈ∫ÜÈ∫âÈ∫äÈ∫å",5,"È∫î",8,"È∫ûÈ∫†",5,"È∫ßÈ∫®È∫©È∫™"],["fc40","È∫´",8,"È∫µÈ∫∂È∫∑È∫πÈ∫∫È∫ºÈ∫ø",4,"ÈªÖÈªÜÈªáÈªàÈªäÈªãÈªåÈªêÈªíÈªìÈªïÈªñÈªóÈªôÈªöÈªûÈª°Èª£Èª§Èª¶Èª®Èª´Èª¨Èª≠ÈªÆÈª∞",8,"Èª∫ÈªΩÈªø",6],["fc80","ÈºÜ",4,"ÈºåÈºèÈºëÈºíÈºîÈºïÈºñÈºòÈºö",5,"Èº°Èº£",8,"Èº≠ÈºÆÈº∞Èº±"],["fd40","Èº≤",4,"Èº∏Èº∫ÈººÈºø",4,"ÈΩÖ",10,"ÈΩí",38],["fd80","ÈΩπ",5,"ÈæÅÈæÇÈæç",11,"ÈæúÈæùÈæûÈæ°",4,"Ô§¨Ô•πÔ¶ïÔßßÔß±"],["fe40","Ô®åÔ®çÔ®éÔ®èÔ®ëÔ®ìÔ®îÔ®òÔ®üÔ®†Ô®°Ô®£Ô®§Ô®ßÔ®®Ô®©"]]');

/***/ }),
/* 98 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["a140","ÓìÜ",62],["a180","ÓîÖ",32],["a240","Óî¶",62],["a280","Óï•",32],["a2ab","Óù¶",5],["a2e3","‚Ç¨Óù≠"],["a2ef","ÓùÆÓùØ"],["a2fd","Óù∞Óù±"],["a340","ÓñÜ",62],["a380","ÓóÖ",31,"„ÄÄ"],["a440","Óó¶",62],["a480","Óò•",32],["a4f4","Óù≤",10],["a540","ÓôÜ",62],["a580","ÓöÖ",32],["a5f7","ÓùΩ",7],["a640","Óö¶",62],["a680","Óõ•",32],["a6b9","ÓûÖ",7],["a6d9","Óûç",6],["a6ec","ÓûîÓûï"],["a6f3","Óûñ"],["a6f6","Óûó",8],["a740","ÓúÜ",62],["a780","ÓùÖ",32],["a7c2","Óû†",14],["a7f2","ÓûØ",12],["a896","Óûº",10],["a8bc","·∏ø"],["a8bf","«π"],["a8c1","ÓüâÓüäÓüãÓüå"],["a8ea","Óüç",20],["a958","Óü¢"],["a95b","Óü£"],["a95d","Óü§Óü•Óü¶"],["a989","„Äæ‚ø∞",11],["a997","Óü¥",12],["a9f0","Ó†Å",14],["aaa1","ÓÄÄ",93],["aba1","ÓÅû",93],["aca1","ÓÇº",93],["ada1","ÓÑö",93],["aea1","ÓÖ∏",93],["afa1","Óáñ",93],["d7fa","Ó†ê",4],["f8a1","Óà¥",93],["f9a1","Óäí",93],["faa1","Óã∞",93],["fba1","Óçé",93],["fca1","Óé¨",93],["fda1","Óêä",93],["fe50","‚∫ÅÓ†ñÓ†óÓ†ò‚∫Ñ„ë≥„ëá‚∫à‚∫ãÓ†û„ñû„òö„òé‚∫å‚∫ó„•Æ„§òÓ†¶„ßè„ßü„©≥„ßêÓ†´Ó†¨„≠é„±Æ„≥†‚∫ßÓ†±Ó†≤‚∫™‰Åñ‰Öü‚∫Æ‰å∑‚∫≥‚∫∂‚∫∑Ó†ª‰é±‰é¨‚∫ª‰èù‰ìñ‰ô°‰ôåÓ°É"],["fe80","‰ú£‰ú©‰ùº‰ûç‚ªä‰•á‰•∫‰•Ω‰¶Ç‰¶É‰¶Ö‰¶Ü‰¶ü‰¶õ‰¶∑‰¶∂Ó°îÓ°ï‰≤£‰≤ü‰≤†‰≤°‰±∑‰≤¢‰¥ì",6,"‰∂ÆÓ°§Óë®",93],["8135f437","Óüá"]]');

/***/ }),
/* 99 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');

/***/ }),
/* 100 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8141","Í∞ÇÍ∞ÉÍ∞ÖÍ∞ÜÍ∞ã",4,"Í∞òÍ∞ûÍ∞üÍ∞°Í∞¢Í∞£Í∞•",6,"Í∞ÆÍ∞≤Í∞≥Í∞¥"],["8161","Í∞µÍ∞∂Í∞∑Í∞∫Í∞ªÍ∞ΩÍ∞æÍ∞øÍ±Å",9,"Í±åÍ±é",5,"Í±ï"],["8181","Í±ñÍ±óÍ±ôÍ±öÍ±õÍ±ù",18,"Í±≤Í±≥Í±µÍ±∂Í±πÍ±ª",4,"Í≤ÇÍ≤áÍ≤àÍ≤çÍ≤éÍ≤èÍ≤ëÍ≤íÍ≤ìÍ≤ï",6,"Í≤ûÍ≤¢",5,"Í≤´Í≤≠Í≤ÆÍ≤±",6,"Í≤∫Í≤æÍ≤øÍ≥ÄÍ≥ÇÍ≥ÉÍ≥ÖÍ≥ÜÍ≥áÍ≥âÍ≥äÍ≥ãÍ≥ç",7,"Í≥ñÍ≥ò",7,"Í≥¢Í≥£Í≥•Í≥¶Í≥©Í≥´Í≥≠Í≥ÆÍ≥≤Í≥¥Í≥∑",4,"Í≥æÍ≥øÍ¥ÅÍ¥ÇÍ¥ÉÍ¥ÖÍ¥á",4,"Í¥éÍ¥êÍ¥íÍ¥ì"],["8241","Í¥îÍ¥ïÍ¥ñÍ¥óÍ¥ôÍ¥öÍ¥õÍ¥ùÍ¥ûÍ¥üÍ¥°",7,"Í¥™Í¥´Í¥Æ",5],["8261","Í¥∂Í¥∑Í¥πÍ¥∫Í¥ªÍ¥Ω",6,"ÍµÜÍµàÍµä",5,"ÍµëÍµíÍµìÍµïÍµñÍµó"],["8281","Íµô",7,"Íµ¢Íµ§",7,"ÍµÆÍµØÍµ±Íµ≤Íµ∑Íµ∏ÍµπÍµ∫ÍµæÍ∂ÄÍ∂É",4,"Í∂äÍ∂ãÍ∂çÍ∂éÍ∂èÍ∂ë",10,"Í∂û",5,"Í∂•",17,"Í∂∏",7,"Í∑ÇÍ∑ÉÍ∑ÖÍ∑ÜÍ∑áÍ∑â",6,"Í∑íÍ∑î",7,"Í∑ùÍ∑ûÍ∑üÍ∑°Í∑¢Í∑£Í∑•",18],["8341","Í∑∫Í∑ªÍ∑ΩÍ∑æÍ∏Ç",5,"Í∏äÍ∏åÍ∏é",5,"Í∏ï",7],["8361","Í∏ù",18,"Í∏≤Í∏≥Í∏µÍ∏∂Í∏πÍ∏ªÍ∏º"],["8381","Í∏ΩÍ∏æÍ∏øÍπÇÍπÑÍπáÍπàÍπâÍπãÍπèÍπëÍπíÍπìÍπïÍπó",4,"ÍπûÍπ¢Íπ£Íπ§Íπ¶ÍπßÍπ™Íπ´Íπ≠ÍπÆÍπØÍπ±",6,"Íπ∫Íπæ",5,"Í∫Ü",5,"Í∫ç",46,"Í∫øÍªÅÍªÇÍªÉÍªÖ",6,"ÍªéÍªí",5,"ÍªöÍªõÍªù",8],["8441","Íª¶ÍªßÍª©Íª™Íª¨ÍªÆ",5,"ÍªµÍª∂Íª∑ÍªπÍª∫ÍªªÍªΩ",8],["8461","ÍºÜÍºâÍºäÍºãÍºåÍºéÍºèÍºë",18],["8481","Íº§",7,"ÍºÆÍºØÍº±Íº≥Íºµ",6,"ÍºæÍΩÄÍΩÑÍΩÖÍΩÜÍΩáÍΩä",5,"ÍΩë",10,"ÍΩû",5,"ÍΩ¶",18,"ÍΩ∫",5,"ÍæÅÍæÇÍæÉÍæÖÍæÜÍæáÍæâ",6,"ÍæíÍæìÍæîÍæñ",5,"Íæù",26,"Íæ∫ÍæªÍæΩÍææ"],["8541","ÍæøÍøÅ",5,"ÍøäÍøåÍøè",4,"Íøï",6,"Íøù",4],["8561","Íø¢",5,"Íø™",5,"Íø≤Íø≥ÍøµÍø∂Íø∑Íøπ",6,"ÎÄÇÎÄÉ"],["8581","ÎÄÖ",6,"ÎÄçÎÄéÎÄèÎÄëÎÄíÎÄìÎÄï",6,"ÎÄû",9,"ÎÄ©",26,"ÎÅÜÎÅáÎÅâÎÅãÎÅçÎÅèÎÅêÎÅëÎÅíÎÅñÎÅòÎÅöÎÅõÎÅúÎÅû",29,"ÎÅæÎÅøÎÇÅÎÇÇÎÇÉÎÇÖ",6,"ÎÇéÎÇêÎÇí",5,"ÎÇõÎÇùÎÇûÎÇ£ÎÇ§"],["8641","ÎÇ•ÎÇ¶ÎÇßÎÇ™ÎÇ∞ÎÇ≤ÎÇ∂ÎÇ∑ÎÇπÎÇ∫ÎÇªÎÇΩ",6,"ÎÉÜÎÉä",5,"ÎÉí"],["8661","ÎÉìÎÉïÎÉñÎÉóÎÉô",6,"ÎÉ°ÎÉ¢ÎÉ£ÎÉ§ÎÉ¶",10],["8681","ÎÉ±",22,"ÎÑäÎÑçÎÑéÎÑèÎÑëÎÑîÎÑïÎÑñÎÑóÎÑöÎÑû",4,"ÎÑ¶ÎÑßÎÑ©ÎÑ™ÎÑ´ÎÑ≠",6,"ÎÑ∂ÎÑ∫",5,"ÎÖÇÎÖÉÎÖÖÎÖÜÎÖáÎÖâ",6,"ÎÖíÎÖìÎÖñÎÖóÎÖôÎÖöÎÖõÎÖùÎÖûÎÖüÎÖ°",22,"ÎÖ∫ÎÖªÎÖΩÎÖæÎÖøÎÜÅÎÜÉ",4,"ÎÜäÎÜåÎÜéÎÜèÎÜêÎÜëÎÜïÎÜñÎÜóÎÜôÎÜöÎÜõÎÜù"],["8741","ÎÜû",9,"ÎÜ©",15],["8761","ÎÜπ",18,"ÎáçÎáéÎáèÎáëÎáíÎáìÎáï"],["8781","Îáñ",5,"ÎáûÎá†",7,"Îá™Îá´Îá≠ÎáÆÎáØÎá±",7,"Îá∫ÎáºÎáæ",5,"ÎàÜÎàáÎàâÎàäÎàç",6,"ÎàñÎàòÎàö",5,"Îà°",18,"Îàµ",6,"ÎàΩ",26,"ÎâôÎâöÎâõÎâùÎâûÎâüÎâ°",6,"Îâ™",4],["8841","ÎâØ",4,"Îâ∂",5,"ÎâΩ",6,"ÎäÜÎäáÎäàÎää",4],["8861","ÎäèÎäíÎäìÎäïÎäñÎäóÎäõ",4,"Îä¢Îä§ÎäßÎä®Îä©Îä´Îä≠ÎäÆÎäØÎä±Îä≤Îä≥ÎäµÎä∂Îä∑"],["8881","Îä∏",15,"ÎãäÎããÎãçÎãéÎãèÎãëÎãì",4,"ÎãöÎãúÎãûÎãüÎã†Îã°Îã£ÎãßÎã©Îã™Îã∞Îã±Îã≤Îã∂ÎãºÎãΩÎãæÎåÇÎåÉÎåÖÎåÜÎåáÎåâ",6,"ÎåíÎåñ",5,"Îåù",54,"ÎçóÎçôÎçöÎçùÎç†Îç°Îç¢Îç£"],["8941","Îç¶Îç®Îç™Îç¨Îç≠ÎçØÎç≤Îç≥ÎçµÎç∂Îç∑Îçπ",6,"ÎéÇÎéÜ",5,"Îéç"],["8961","ÎééÎéèÎéëÎéíÎéìÎéï",10,"Îé¢",5,"Îé©Îé™Îé´Îé≠"],["8981","ÎéÆ",21,"ÎèÜÎèáÎèâÎèäÎèçÎèèÎèëÎèíÎèìÎèñÎèòÎèöÎèúÎèûÎèüÎè°Îè¢Îè£Îè•Îè¶ÎèßÎè©",18,"ÎèΩ",18,"Îêë",6,"ÎêôÎêöÎêõÎêùÎêûÎêüÎê°",6,"Îê™Îê¨",7,"Îêµ",15],["8a41","ÎëÖ",10,"ÎëíÎëìÎëïÎëñÎëóÎëô",6,"Îë¢Îë§Îë¶"],["8a61","Îëß",4,"Îë≠",18,"ÎíÅÎíÇ"],["8a81","ÎíÉ",4,"Îíâ",19,"Îíû",5,"Îí•Îí¶ÎíßÎí©Îí™Îí´Îí≠",7,"Îí∂Îí∏Îí∫",5,"ÎìÅÎìÇÎìÉÎìÖÎìÜÎìáÎìâ",6,"ÎìëÎìíÎììÎìîÎìñ",5,"ÎìûÎìüÎì°Îì¢Îì•Îìß",4,"ÎìÆÎì∞Îì≤",5,"Îìπ",26,"ÎîñÎîóÎîôÎîöÎîù"],["8b41","Îîû",5,"Îî¶Îî´",4,"Îî≤Îî≥ÎîµÎî∂Îî∑Îîπ",6,"ÎïÇÎïÜ"],["8b61","ÎïáÎïàÎïâÎïäÎïéÎïèÎïëÎïíÎïìÎïï",6,"ÎïûÎï¢",8],["8b81","Îï´",52,"Îñ¢Îñ£Îñ•Îñ¶ÎñßÎñ©Îñ¨Îñ≠ÎñÆÎñØÎñ≤Îñ∂",4,"ÎñæÎñøÎóÅÎóÇÎóÉÎóÖ",6,"ÎóéÎóí",5,"Îóô",18,"Îó≠",18],["8c41","ÎòÄ",15,"ÎòíÎòìÎòïÎòñÎòóÎòô",4],["8c61","Îòû",6,"Îò¶",5,"Îò≠",6,"Îòµ",5],["8c81","Îòª",12,"Îôâ",26,"Îô•Îô¶ÎôßÎô©",50,"ÎöûÎöüÎö°Îö¢Îö£Îö•",5,"Îö≠ÎöÆÎöØÎö∞Îö≤",16],["8d41","ÎõÉ",16,"Îõï",8],["8d61","Îõû",17,"Îõ±Îõ≤Îõ≥ÎõµÎõ∂Îõ∑ÎõπÎõ∫"],["8d81","Îõª",4,"ÎúÇÎúÉÎúÑÎúÜ",33,"Îú™Îú´Îú≠ÎúÆÎú±",6,"Îú∫Îúº",7,"ÎùÖÎùÜÎùáÎùâÎùäÎùãÎùç",6,"Îùñ",9,"Îù°Îù¢Îù£Îù•Îù¶ÎùßÎù©",6,"Îù≤Îù¥Îù∂",5,"ÎùæÎùøÎûÅÎûÇÎûÉÎûÖ",6,"ÎûéÎûìÎûîÎûïÎûöÎûõÎûùÎûû"],["8e41","ÎûüÎû°",6,"Îû™ÎûÆ",5,"Îû∂Îû∑Îûπ",8],["8e61","ÎüÇ",4,"ÎüàÎüä",19],["8e81","Îüû",13,"ÎüÆÎüØÎü±Îü≤Îü≥Îüµ",6,"ÎüæÎ†Ç",4,"Î†äÎ†ãÎ†çÎ†éÎ†èÎ†ë",6,"Î†öÎ†úÎ†û",5,"Î†¶Î†ßÎ†©Î†™Î†´Î†≠",6,"Î†∂Î†∫",5,"Î°ÅÎ°ÇÎ°ÉÎ°Ö",11,"Î°íÎ°î",7,"Î°ûÎ°üÎ°°Î°¢Î°£Î°•",6,"Î°ÆÎ°∞Î°≤",5,"Î°πÎ°∫Î°ªÎ°Ω",7],["8f41","Î¢Ö",7,"Î¢é",17],["8f61","Î¢†",7,"Î¢©",6,"Î¢±Î¢≤Î¢≥Î¢µÎ¢∂Î¢∑Î¢π",4],["8f81","Î¢æÎ¢øÎ£ÇÎ£ÑÎ£Ü",5,"Î£çÎ£éÎ£èÎ£ëÎ£íÎ£ìÎ£ï",7,"Î£ûÎ£†Î£¢",5,"Î£™Î£´Î£≠Î£ÆÎ£ØÎ£±",6,"Î£∫Î£ºÎ£æ",5,"Î§Ö",18,"Î§ô",6,"Î§°",26,"Î§æÎ§øÎ•ÅÎ•ÇÎ•ÉÎ•Ö",6,"Î•çÎ•éÎ•êÎ•í",5],["9041","Î•öÎ•õÎ•ùÎ•ûÎ•üÎ•°",6,"Î•™Î•¨Î•Æ",5,"Î•∂Î•∑Î•πÎ•∫Î•ªÎ•Ω"],["9061","Î•æ",5,"Î¶ÜÎ¶àÎ¶ãÎ¶åÎ¶è",15],["9081","Î¶ü",12,"Î¶ÆÎ¶ØÎ¶±Î¶≤Î¶≥Î¶µ",6,"Î¶æÎßÄÎßÇ",5,"ÎßäÎßãÎßçÎßì",4,"ÎßöÎßúÎßüÎß†Îß¢Îß¶ÎßßÎß©Îß™Îß´Îß≠",6,"Îß∂Îßª",4,"Î®Ç",5,"Î®â",11,"Î®ñ",33,"Î®∫Î®ªÎ®ΩÎ®æÎ®øÎ©ÅÎ©ÉÎ©ÑÎ©ÖÎ©Ü"],["9141","Î©áÎ©äÎ©åÎ©èÎ©êÎ©ëÎ©íÎ©ñÎ©óÎ©ôÎ©öÎ©õÎ©ù",6,"Î©¶Î©™",5],["9161","Î©≤Î©≥Î©µÎ©∂Î©∑Î©π",9,"Î™ÜÎ™àÎ™âÎ™äÎ™ãÎ™ç",5],["9181","Î™ì",20,"Î™™Î™≠Î™ÆÎ™ØÎ™±Î™≥",4,"Î™∫Î™ºÎ™æ",5,"Î´ÖÎ´ÜÎ´áÎ´â",14,"Î´ö",33,"Î´ΩÎ´æÎ´øÎ¨ÅÎ¨ÇÎ¨ÉÎ¨Ö",7,"Î¨éÎ¨êÎ¨í",5,"Î¨ôÎ¨öÎ¨õÎ¨ùÎ¨ûÎ¨üÎ¨°",6],["9241","Î¨®Î¨™Î¨¨",7,"Î¨∑Î¨πÎ¨∫Î¨ø",4,"Î≠ÜÎ≠àÎ≠äÎ≠ãÎ≠åÎ≠éÎ≠ëÎ≠í"],["9261","Î≠ìÎ≠ïÎ≠ñÎ≠óÎ≠ô",7,"Î≠¢Î≠§",7,"Î≠≠",4],["9281","Î≠≤",21,"ÎÆâÎÆäÎÆãÎÆçÎÆéÎÆèÎÆë",18,"ÎÆ•ÎÆ¶ÎÆßÎÆ©ÎÆ™ÎÆ´ÎÆ≠",6,"ÎÆµÎÆ∂ÎÆ∏",7,"ÎØÅÎØÇÎØÉÎØÖÎØÜÎØáÎØâ",6,"ÎØëÎØíÎØî",35,"ÎØ∫ÎØªÎØΩÎØæÎ∞Å"],["9341","Î∞É",4,"Î∞äÎ∞éÎ∞êÎ∞íÎ∞ìÎ∞ôÎ∞öÎ∞†Î∞°Î∞¢Î∞£Î∞¶Î∞®Î∞™Î∞´Î∞¨Î∞ÆÎ∞ØÎ∞≤Î∞≥Î∞µ"],["9361","Î∞∂Î∞∑Î∞π",6,"Î±ÇÎ±ÜÎ±áÎ±àÎ±äÎ±ãÎ±éÎ±èÎ±ë",8],["9381","Î±öÎ±õÎ±úÎ±û",37,"Î≤ÜÎ≤áÎ≤âÎ≤äÎ≤çÎ≤è",4,"Î≤ñÎ≤òÎ≤õ",4,"Î≤¢Î≤£Î≤•Î≤¶Î≤©",6,"Î≤≤Î≤∂",5,"Î≤æÎ≤øÎ≥ÅÎ≥ÇÎ≥ÉÎ≥Ö",7,"Î≥éÎ≥íÎ≥ìÎ≥îÎ≥ñÎ≥óÎ≥ôÎ≥öÎ≥õÎ≥ù",22,"Î≥∑Î≥πÎ≥∫Î≥ªÎ≥Ω"],["9441","Î≥æ",5,"Î¥ÜÎ¥àÎ¥ä",5,"Î¥ëÎ¥íÎ¥ìÎ¥ï",8],["9461","Î¥û",5,"Î¥•",6,"Î¥≠",12],["9481","Î¥∫",5,"ÎµÅ",6,"ÎµäÎµãÎµçÎµéÎµèÎµë",6,"Îµö",9,"Îµ•Îµ¶ÎµßÎµ©",22,"Î∂ÇÎ∂ÉÎ∂ÖÎ∂ÜÎ∂ã",4,"Î∂íÎ∂îÎ∂ñÎ∂óÎ∂òÎ∂õÎ∂ù",6,"Î∂•",10,"Î∂±",6,"Î∂π",24],["9541","Î∑íÎ∑ìÎ∑ñÎ∑óÎ∑ôÎ∑öÎ∑õÎ∑ù",11,"Î∑™",5,"Î∑±"],["9561","Î∑≤Î∑≥Î∑µÎ∑∂Î∑∑Î∑π",6,"Î∏ÅÎ∏ÇÎ∏ÑÎ∏Ü",5,"Î∏éÎ∏èÎ∏ëÎ∏íÎ∏ì"],["9581","Î∏ï",6,"Î∏ûÎ∏†",35,"ÎπÜÎπáÎπâÎπäÎπãÎπçÎπè",4,"ÎπñÎπòÎπúÎπùÎπûÎπüÎπ¢Îπ£Îπ•Îπ¶ÎπßÎπ©Îπ´",4,"Îπ≤Îπ∂",4,"ÎπæÎπøÎ∫ÅÎ∫ÇÎ∫ÉÎ∫Ö",6,"Î∫éÎ∫í",5,"Î∫ö",13,"Î∫©",14],["9641","Î∫∏",23,"ÎªíÎªì"],["9661","ÎªïÎªñÎªô",6,"Îª°Îª¢Îª¶",5,"Îª≠",8],["9681","Îª∂",10,"ÎºÇ",5,"Îºä",13,"ÎºöÎºû",33,"ÎΩÇÎΩÉÎΩÖÎΩÜÎΩáÎΩâ",6,"ÎΩíÎΩìÎΩîÎΩñ",44],["9741","ÎæÉ",16,"Îæï",8],["9761","Îæû",17,"Îæ±",7],["9781","Îæπ",11,"ÎøÜ",5,"ÎøéÎøèÎøëÎøíÎøìÎøï",6,"ÎøùÎøûÎø†Îø¢",89,"ÏÄΩÏÄæÏÄø"],["9841","ÏÅÄ",16,"ÏÅí",5,"ÏÅôÏÅöÏÅõ"],["9861","ÏÅùÏÅûÏÅüÏÅ°",6,"ÏÅ™",15],["9881","ÏÅ∫",21,"ÏÇíÏÇìÏÇïÏÇñÏÇóÏÇô",6,"ÏÇ¢ÏÇ§ÏÇ¶",5,"ÏÇÆÏÇ±ÏÇ≤ÏÇ∑",4,"ÏÇæÏÉÇÏÉÉÏÉÑÏÉÜÏÉáÏÉäÏÉãÏÉçÏÉéÏÉèÏÉë",6,"ÏÉöÏÉû",5,"ÏÉ¶ÏÉßÏÉ©ÏÉ™ÏÉ´ÏÉ≠",6,"ÏÉ∂ÏÉ∏ÏÉ∫",5,"ÏÑÅÏÑÇÏÑÉÏÑÖÏÑÜÏÑáÏÑâ",6,"ÏÑëÏÑíÏÑìÏÑîÏÑñ",5,"ÏÑ°ÏÑ¢ÏÑ•ÏÑ®ÏÑ©ÏÑ™ÏÑ´ÏÑÆ"],["9941","ÏÑ≤ÏÑ≥ÏÑ¥ÏÑµÏÑ∑ÏÑ∫ÏÑªÏÑΩÏÑæÏÑøÏÖÅ",6,"ÏÖäÏÖé",5,"ÏÖñÏÖó"],["9961","ÏÖôÏÖöÏÖõÏÖù",6,"ÏÖ¶ÏÖ™",5,"ÏÖ±ÏÖ≤ÏÖ≥ÏÖµÏÖ∂ÏÖ∑ÏÖπÏÖ∫ÏÖª"],["9981","ÏÖº",8,"ÏÜÜ",5,"ÏÜèÏÜëÏÜíÏÜìÏÜïÏÜó",4,"ÏÜûÏÜ†ÏÜ¢ÏÜ£ÏÜ§ÏÜ¶ÏÜßÏÜ™ÏÜ´ÏÜ≠ÏÜÆÏÜØÏÜ±",11,"ÏÜæ",5,"ÏáÖÏáÜÏááÏáâÏáäÏáãÏáç",6,"ÏáïÏáñÏáô",6,"Ïá°Ïá¢Ïá£Ïá•Ïá¶ÏáßÏá©",6,"Ïá≤Ïá¥",7,"ÏáæÏáøÏàÅÏàÇÏàÉÏàÖ",6,"ÏàéÏàêÏàí",5,"ÏàöÏàõÏàùÏàûÏà°Ïà¢Ïà£"],["9a41","Ïà§Ïà•Ïà¶ÏàßÏà™Ïà¨ÏàÆÏà∞Ïà≥Ïàµ",16],["9a61","ÏâÜÏâáÏââ",6,"ÏâíÏâìÏâïÏâñÏâóÏâô",6,"Ïâ°Ïâ¢Ïâ£Ïâ§Ïâ¶"],["9a81","Ïâß",4,"ÏâÆÏâØÏâ±Ïâ≤Ïâ≥Ïâµ",6,"ÏâæÏäÄÏäÇ",5,"Ïää",5,"Ïäë",6,"ÏäôÏäöÏäúÏäû",5,"Ïä¶ÏäßÏä©Ïä™Ïä´ÏäÆ",5,"Ïä∂Ïä∏Ïä∫",33,"ÏãûÏãüÏã°Ïã¢Ïã•",5,"ÏãÆÏã∞Ïã≤Ïã≥Ïã¥ÏãµÏã∑Ïã∫ÏãΩÏãæÏãøÏåÅ",6,"ÏåäÏåãÏåéÏåè"],["9b41","ÏåêÏåëÏåíÏåñÏåóÏåôÏåöÏåõÏåù",6,"Ïå¶ÏåßÏå™",8],["9b61","Ïå≥",17,"ÏçÜ",7],["9b81","Ïçé",25,"Ïç™Ïç´Ïç≠ÏçÆÏçØÏç±Ïç≥",4,"Ïç∫ÏçªÏçæ",5,"ÏéÖÏéÜÏéáÏéâÏéäÏéãÏéç",50,"ÏèÅ",22,"Ïèö"],["9c41","ÏèõÏèùÏèûÏè°Ïè£",4,"Ïè™Ïè´Ïè¨ÏèÆ",5,"Ïè∂Ïè∑Ïèπ",5],["9c61","Ïèø",8,"Ïêâ",6,"Ïêë",9],["9c81","Ïêõ",8,"Ïê•",6,"Ïê≠ÏêÆÏêØÏê±Ïê≤Ïê≥Ïêµ",6,"Ïêæ",9,"Ïëâ",26,"Ïë¶ÏëßÏë©Ïë™Ïë´Ïë≠",6,"Ïë∂Ïë∑Ïë∏Ïë∫",5,"ÏíÅ",18,"Ïíï",6,"Ïíù",12],["9d41","Ïí™",13,"ÏíπÏí∫ÏíªÏíΩ",8],["9d61","ÏìÜ",25],["9d81","Ïì†",8,"Ïì™",5,"Ïì≤Ïì≥ÏìµÏì∂Ïì∑ÏìπÏìªÏìºÏìΩÏìæÏîÇ",9,"ÏîçÏîéÏîèÏîëÏîíÏîìÏîï",6,"Ïîù",10,"Ïî™Ïî´Ïî≠ÏîÆÏîØÏî±",6,"Ïî∫ÏîºÏîæ",5,"ÏïÜÏïáÏïãÏïèÏïêÏïëÏïíÏïñÏïöÏïõÏïúÏïüÏï¢Ïï£Ïï•Ïï¶ÏïßÏï©",6,"Ïï≤Ïï∂",5,"ÏïæÏïøÏñÅÏñÇÏñÉÏñÖÏñÜÏñàÏñâÏñäÏñãÏñéÏñêÏñíÏñìÏñî"],["9e41","ÏññÏñôÏñöÏñõÏñùÏñûÏñüÏñ°",7,"Ïñ™",9,"Ïñ∂"],["9e61","Ïñ∑Ïñ∫Ïñø",4,"ÏóãÏóçÏóèÏóíÏóìÏóïÏóñÏóóÏóô",6,"Ïó¢Ïó§Ïó¶Ïóß"],["9e81","Ïó®Ïó©Ïó™Ïó´ÏóØÏó±Ïó≤Ïó≥ÏóµÏó∏ÏóπÏó∫ÏóªÏòÇÏòÉÏòÑÏòâÏòäÏòãÏòçÏòéÏòèÏòë",6,"ÏòöÏòù",6,"Ïò¶ÏòßÏò©Ïò™Ïò´ÏòØÏò±Ïò≤Ïò∂Ïò∏Ïò∫ÏòºÏòΩÏòæÏòøÏôÇÏôÉÏôÖÏôÜÏôáÏôâ",6,"ÏôíÏôñ",5,"ÏôûÏôüÏô°",10,"Ïô≠ÏôÆÏô∞Ïô≤",5,"Ïô∫ÏôªÏôΩÏôæÏôøÏöÅ",6,"ÏöäÏöåÏöé",5,"ÏöñÏöóÏöôÏööÏöõÏöù",6,"Ïö¶"],["9f41","Ïö®Ïö™",5,"Ïö≤Ïö≥ÏöµÏö∂Ïö∑Ïöª",4,"ÏõÇÏõÑÏõÜ",5,"Ïõé"],["9f61","ÏõèÏõëÏõíÏõìÏõï",6,"ÏõûÏõüÏõ¢",5,"Ïõ™Ïõ´Ïõ≠ÏõÆÏõØÏõ±Ïõ≤"],["9f81","Ïõ≥",4,"Ïõ∫ÏõªÏõºÏõæ",5,"ÏúÜÏúáÏúâÏúäÏúãÏúç",6,"ÏúñÏúòÏúö",5,"Ïú¢Ïú£Ïú•Ïú¶ÏúßÏú©",6,"Ïú≤Ïú¥Ïú∂Ïú∏ÏúπÏú∫ÏúªÏúæÏúøÏùÅÏùÇÏùÉÏùÖ",4,"ÏùãÏùéÏùêÏùôÏùöÏùõÏùùÏùûÏùüÏù°",6,"Ïù©Ïù™Ïù¨",7,"Ïù∂Ïù∑ÏùπÏù∫ÏùªÏùøÏûÄÏûÅÏûÇÏûÜÏûãÏûåÏûçÏûèÏûíÏûìÏûïÏûôÏûõ",4,"Ïû¢Ïûß",4,"ÏûÆÏûØÏû±Ïû≤Ïû≥ÏûµÏû∂Ïû∑"],["a041","Ïû∏ÏûπÏû∫ÏûªÏûæÏüÇ",5,"ÏüäÏüãÏüçÏüèÏüë",6,"ÏüôÏüöÏüõÏüú"],["a061","Ïüû",5,"Ïü•Ïü¶ÏüßÏü©Ïü™Ïü´Ïü≠",13],["a081","Ïüª",4,"Ï†ÇÏ†ÉÏ†ÖÏ†ÜÏ†áÏ†âÏ†ã",4,"Ï†íÏ†îÏ†ó",4,"Ï†ûÏ†üÏ†°Ï†¢Ï†£Ï†•",6,"Ï†ÆÏ†∞Ï†≤",5,"Ï†πÏ†∫Ï†ªÏ†ΩÏ†æÏ†øÏ°Å",6,"Ï°äÏ°ãÏ°é",5,"Ï°ï",26,"Ï°≤Ï°≥Ï°µÏ°∂Ï°∑Ï°πÏ°ª",4,"Ï¢ÇÏ¢ÑÏ¢àÏ¢âÏ¢äÏ¢é",5,"Ï¢ï",7,"Ï¢ûÏ¢†Ï¢¢Ï¢£Ï¢§"],["a141","Ï¢•Ï¢¶Ï¢ßÏ¢©",18,"Ï¢æÏ¢øÏ£ÄÏ£Å"],["a161","Ï£ÇÏ£ÉÏ£ÖÏ£ÜÏ£áÏ£âÏ£äÏ£ãÏ£ç",6,"Ï£ñÏ£òÏ£ö",5,"Ï£¢Ï££Ï£•"],["a181","Ï£¶",14,"Ï£∂",5,"Ï£æÏ£øÏ§ÅÏ§ÇÏ§ÉÏ§á",4,"Ï§é„ÄÄ„ÄÅ„ÄÇ¬∑‚Ä•‚Ä¶¬®„ÄÉ¬≠‚Äï‚à•Ôºº‚àº‚Äò‚Äô‚Äú‚Äù„Äî„Äï„Äà",9,"¬±√ó√∑‚â†‚â§‚â•‚àû‚à¥¬∞‚Ä≤‚Ä≥‚ÑÉ‚Ñ´Ôø†Ôø°Ôø•‚ôÇ‚ôÄ‚à†‚ä•‚åí‚àÇ‚àá‚â°‚âí¬ß‚Äª‚òÜ‚òÖ‚óã‚óè‚óé‚óá‚óÜ‚ñ°‚ñ†‚ñ≥‚ñ≤‚ñΩ‚ñº‚Üí‚Üê‚Üë‚Üì‚Üî„Äì‚â™‚â´‚àö‚àΩ‚àù‚àµ‚à´‚à¨‚àà‚àã‚äÜ‚äá‚äÇ‚äÉ‚à™‚à©‚àß‚à®Ôø¢"],["a241","Ï§êÏ§í",5,"Ï§ô",18],["a261","Ï§≠",6,"Ï§µ",18],["a281","Ï•à",7,"Ï•íÏ•ìÏ•ïÏ•ñÏ•óÏ•ô",6,"Ï•¢Ï•§",7,"Ï•≠Ï•ÆÏ•Ø‚áí‚áî‚àÄ‚àÉ¬¥ÔΩûÀáÀòÀùÀöÀô¬∏Àõ¬°¬øÀê‚àÆ‚àë‚àè¬§‚Ñâ‚Ä∞‚óÅ‚óÄ‚ñ∑‚ñ∂‚ô§‚ô†‚ô°‚ô•‚ôß‚ô£‚äô‚óà‚ñ£‚óê‚óë‚ñí‚ñ§‚ñ•‚ñ®‚ñß‚ñ¶‚ñ©‚ô®‚òè‚òé‚òú‚òû¬∂‚Ä†‚Ä°‚Üï‚Üó‚Üô‚Üñ‚Üò‚ô≠‚ô©‚ô™‚ô¨„âø„àú‚Ññ„èá‚Ñ¢„èÇ„èò‚Ñ°‚Ç¨¬Æ"],["a341","Ï•±Ï•≤Ï•≥Ï•µ",6,"Ï•Ω",10,"Ï¶äÏ¶ãÏ¶çÏ¶éÏ¶è"],["a361","Ï¶ë",6,"Ï¶öÏ¶úÏ¶û",16],["a381","Ï¶Ø",16,"ÏßÇÏßÉÏßÖÏßÜÏßâÏßã",4,"ÏßíÏßîÏßóÏßòÏßõÔºÅ",58,"Ôø¶ÔºΩ",32,"Ôø£"],["a441","ÏßûÏßüÏß°Ïß£Ïß•Ïß¶Ïß®Ïß©Ïß™Ïß´ÏßÆÏß≤",5,"Ïß∫ÏßªÏßΩÏßæÏßøÏ®ÅÏ®ÇÏ®ÉÏ®Ñ"],["a461","Ï®ÖÏ®ÜÏ®áÏ®äÏ®é",5,"Ï®ïÏ®ñÏ®óÏ®ô",12],["a481","Ï®¶Ï®ßÏ®®Ï®™",28,"„Ñ±",93],["a541","Ï©á",4,"Ï©éÏ©èÏ©ëÏ©íÏ©ìÏ©ï",6,"Ï©ûÏ©¢",5,"Ï©©Ï©™"],["a561","Ï©´",17,"Ï©æ",5,"Ï™ÖÏ™Ü"],["a581","Ï™á",16,"Ï™ô",14,"‚Ö∞",9],["a5b0","‚Ö†",9],["a5c1","Œë",16,"Œ£",6],["a5e1","Œ±",16,"œÉ",6],["a641","Ï™®",19,"Ï™æÏ™øÏ´ÅÏ´ÇÏ´ÉÏ´Ö"],["a661","Ï´Ü",5,"Ï´éÏ´êÏ´íÏ´îÏ´ïÏ´ñÏ´óÏ´ö",5,"Ï´°",6],["a681","Ï´®Ï´©Ï´™Ï´´Ï´≠",6,"Ï´µ",18,"Ï¨âÏ¨ä‚îÄ‚îÇ‚îå‚îê‚îò‚îî‚îú‚î¨‚î§‚î¥‚îº‚îÅ‚îÉ‚îè‚îì‚îõ‚îó‚î£‚î≥‚î´‚îª‚ïã‚î†‚îØ‚î®‚î∑‚îø‚îù‚î∞‚î•‚î∏‚ïÇ‚îí‚îë‚îö‚îô‚îñ‚îï‚îé‚îç‚îû‚îü‚î°‚î¢‚î¶‚îß‚î©‚î™‚î≠‚îÆ‚î±‚î≤‚îµ‚î∂‚îπ‚î∫‚îΩ‚îæ‚ïÄ‚ïÅ‚ïÉ",7],["a741","Ï¨ã",4,"Ï¨ëÏ¨íÏ¨ìÏ¨ïÏ¨ñÏ¨óÏ¨ô",6,"Ï¨¢",7],["a761","Ï¨™",22,"Ï≠ÇÏ≠ÉÏ≠Ñ"],["a781","Ï≠ÖÏ≠ÜÏ≠áÏ≠äÏ≠ãÏ≠çÏ≠éÏ≠èÏ≠ë",6,"Ï≠öÏ≠õÏ≠úÏ≠û",5,"Ï≠•",7,"„éï„éñ„éó‚Ñì„éò„èÑ„é£„é§„é•„é¶„éô",9,"„èä„éç„éé„éè„èè„éà„éâ„èà„éß„é®„é∞",9,"„éÄ",4,"„é∫",5,"„éê",4,"‚Ñ¶„èÄ„èÅ„éä„éã„éå„èñ„èÖ„é≠„éÆ„éØ„èõ„é©„é™„é´„é¨„èù„èê„èì„èÉ„èâ„èú„èÜ"],["a841","Ï≠≠",10,"Ï≠∫",14],["a861","ÏÆâ",18,"ÏÆù",6],["a881","ÏÆ§",19,"ÏÆπ",11,"√Ü√ê¬™ƒ¶"],["a8a6","ƒ≤"],["a8a8","ƒø≈Å√ò≈í¬∫√û≈¶≈ä"],["a8b1","„â†",27,"‚ìê",25,"‚ë†",14,"¬Ω‚Öì‚Öî¬º¬æ‚Öõ‚Öú‚Öù‚Öû"],["a941","ÏØÖ",14,"ÏØï",10],["a961","ÏØ†ÏØ°ÏØ¢ÏØ£ÏØ•ÏØ¶ÏØ®ÏØ™",18],["a981","ÏØΩ",14,"Ï∞éÏ∞èÏ∞ëÏ∞íÏ∞ìÏ∞ï",6,"Ï∞ûÏ∞üÏ∞†Ï∞£Ï∞§√¶ƒë√∞ƒßƒ±ƒ≥ƒ∏≈Ä≈Ç√∏≈ì√ü√æ≈ß≈ã≈â„àÄ",27,"‚íú",25,"‚ë¥",14,"¬π¬≤¬≥‚Å¥‚Åø‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ"],["aa41","Ï∞•Ï∞¶Ï∞™Ï∞´Ï∞≠Ï∞ØÏ∞±",6,"Ï∞∫Ï∞ø",4,"Ï±ÜÏ±áÏ±âÏ±äÏ±ãÏ±çÏ±é"],["aa61","Ï±è",4,"Ï±ñÏ±ö",5,"Ï±°Ï±¢Ï±£Ï±•Ï±ßÏ±©",6,"Ï±±Ï±≤"],["aa81","Ï±≥Ï±¥Ï±∂",29,"„ÅÅ",82],["ab41","Ï≤îÏ≤ïÏ≤ñÏ≤óÏ≤öÏ≤õÏ≤ùÏ≤ûÏ≤üÏ≤°",6,"Ï≤™Ï≤Æ",5,"Ï≤∂Ï≤∑Ï≤π"],["ab61","Ï≤∫Ï≤ªÏ≤Ω",6,"Ï≥ÜÏ≥àÏ≥ä",5,"Ï≥ëÏ≥íÏ≥ìÏ≥ï",5],["ab81","Ï≥õ",8,"Ï≥•",6,"Ï≥≠Ï≥ÆÏ≥ØÏ≥±",12,"„Ç°",85],["ac41","Ï≥æÏ≥øÏ¥ÄÏ¥Ç",5,"Ï¥äÏ¥ãÏ¥çÏ¥éÏ¥èÏ¥ë",6,"Ï¥öÏ¥úÏ¥ûÏ¥üÏ¥†"],["ac61","Ï¥°Ï¥¢Ï¥£Ï¥•Ï¥¶Ï¥ßÏ¥©Ï¥™Ï¥´Ï¥≠",11,"Ï¥∫",4],["ac81","Ï¥ø",28,"ÏµùÏµûÏµü–ê",5,"–Å–ñ",25],["acd1","–∞",5,"—ë–∂",25],["ad41","Ïµ°Ïµ¢Ïµ£Ïµ•",6,"ÏµÆÏµ∞Ïµ≤",5,"Ïµπ",7],["ad61","Ï∂Å",6,"Ï∂â",10,"Ï∂ñÏ∂óÏ∂ôÏ∂öÏ∂õÏ∂ùÏ∂ûÏ∂ü"],["ad81","Ï∂†Ï∂°Ï∂¢Ï∂£Ï∂¶Ï∂®Ï∂™",5,"Ï∂±",18,"Ï∑Ö"],["ae41","Ï∑Ü",5,"Ï∑çÏ∑éÏ∑èÏ∑ë",16],["ae61","Ï∑¢",5,"Ï∑©Ï∑™Ï∑´Ï∑≠Ï∑ÆÏ∑ØÏ∑±",6,"Ï∑∫Ï∑ºÏ∑æ",4],["ae81","Ï∏ÉÏ∏ÖÏ∏ÜÏ∏áÏ∏âÏ∏äÏ∏ãÏ∏ç",6,"Ï∏ïÏ∏ñÏ∏óÏ∏òÏ∏ö",5,"Ï∏¢Ï∏£Ï∏•Ï∏¶Ï∏ßÏ∏©Ï∏™Ï∏´"],["af41","Ï∏¨Ï∏≠Ï∏ÆÏ∏ØÏ∏≤Ï∏¥Ï∏∂",19],["af61","Ïπä",13,"ÏπöÏπõÏπùÏπûÏπ¢",5,"Ïπ™Ïπ¨"],["af81","ÏπÆ",5,"Ïπ∂Ïπ∑ÏππÏπ∫ÏπªÏπΩ",6,"Ï∫ÜÏ∫àÏ∫ä",5,"Ï∫íÏ∫ìÏ∫ïÏ∫ñÏ∫óÏ∫ô"],["b041","Ï∫ö",5,"Ï∫¢Ï∫¶",5,"Ï∫Æ",12],["b061","Ï∫ª",5,"ÏªÇ",19],["b081","Ïªñ",13,"Ïª¶ÏªßÏª©Ïª™Ïª≠",6,"Ïª∂Ïª∫",5,"Í∞ÄÍ∞ÅÍ∞ÑÍ∞áÍ∞àÍ∞âÍ∞äÍ∞ê",7,"Í∞ô",4,"Í∞†Í∞§Í∞¨Í∞≠Í∞ØÍ∞∞Í∞±Í∞∏Í∞πÍ∞ºÍ±ÄÍ±ãÍ±çÍ±îÍ±òÍ±úÍ±∞Í±±Í±¥Í±∑Í±∏Í±∫Í≤ÄÍ≤ÅÍ≤ÉÍ≤ÑÍ≤ÖÍ≤ÜÍ≤âÍ≤äÍ≤ãÍ≤åÍ≤êÍ≤îÍ≤úÍ≤ùÍ≤üÍ≤†Í≤°Í≤®Í≤©Í≤™Í≤¨Í≤ØÍ≤∞Í≤∏Í≤πÍ≤ªÍ≤ºÍ≤ΩÍ≥ÅÍ≥ÑÍ≥àÍ≥åÍ≥ïÍ≥óÍ≥†Í≥°Í≥§Í≥ßÍ≥®Í≥™Í≥¨Í≥ØÍ≥∞Í≥±Í≥≥Í≥µÍ≥∂Í≥ºÍ≥ΩÍ¥ÄÍ¥ÑÍ¥Ü"],["b141","ÏºÇÏºÉÏºÖÏºÜÏºáÏºâ",6,"ÏºíÏºîÏºñ",5,"ÏºùÏºûÏºüÏº°Ïº¢Ïº£"],["b161","Ïº•",6,"ÏºÆÏº≤",5,"Ïºπ",11],["b181","ÏΩÖ",14,"ÏΩñÏΩóÏΩôÏΩöÏΩõÏΩù",6,"ÏΩ¶ÏΩ®ÏΩ™ÏΩ´ÏΩ¨Í¥åÍ¥çÍ¥èÍ¥ëÍ¥òÍ¥úÍ¥†Í¥©Í¥¨Í¥≠Í¥¥Í¥µÍ¥∏Í¥ºÍµÑÍµÖÍµáÍµâÍµêÍµîÍµòÍµ°Íµ£Íµ¨Íµ≠Íµ∞Íµ≥Íµ¥ÍµµÍµ∂ÍµªÍµºÍµΩÍµøÍ∂ÅÍ∂ÇÍ∂àÍ∂âÍ∂åÍ∂êÍ∂úÍ∂ùÍ∂§Í∂∑Í∑ÄÍ∑ÅÍ∑ÑÍ∑àÍ∑êÍ∑ëÍ∑ìÍ∑úÍ∑†Í∑§Í∑∏Í∑πÍ∑ºÍ∑øÍ∏ÄÍ∏ÅÍ∏àÍ∏âÍ∏ãÍ∏çÍ∏îÍ∏∞Í∏±Í∏¥Í∏∑Í∏∏Í∏∫ÍπÄÍπÅÍπÉÍπÖÍπÜÍπäÍπåÍπçÍπéÍπêÍπîÍπñÍπúÍπùÍπüÍπ†Íπ°Íπ•Íπ®Íπ©Íπ¨Íπ∞Íπ∏"],["b241","ÏΩ≠ÏΩÆÏΩØÏΩ≤ÏΩ≥ÏΩµÏΩ∂ÏΩ∑ÏΩπ",6,"ÏæÅÏæÇÏæÉÏæÑÏæÜ",5,"Ïæç"],["b261","Ïæé",18,"Ïæ¢",5,"Ïæ©"],["b281","Ïæ™",5,"Ïæ±",18,"ÏøÖ",6,"ÍππÍπªÍπºÍπΩÍ∫ÑÍ∫ÖÍ∫åÍ∫ºÍ∫ΩÍ∫æÍªÄÍªÑÍªåÍªçÍªèÍªêÍªëÍªòÍªôÍªúÍª®Íª´Íª≠Íª¥Íª∏ÍªºÍºáÍºàÍºçÍºêÍº¨Íº≠Íº∞Íº≤Íº¥ÍººÍºΩÍºøÍΩÅÍΩÇÍΩÉÍΩàÍΩâÍΩêÍΩúÍΩùÍΩ§ÍΩ•ÍΩπÍæÄÍæÑÍæàÍæêÍæëÍæïÍæúÍæ∏ÍæπÍæºÍøÄÍøáÍøàÍøâÍøãÍøçÍøéÍøîÍøúÍø®Íø©Íø∞Íø±Íø¥Íø∏ÎÄÄÎÄÅÎÄÑÎÄåÎÄêÎÄîÎÄúÎÄùÎÄ®ÎÅÑÎÅÖÎÅàÎÅäÎÅåÎÅéÎÅìÎÅîÎÅïÎÅóÎÅô"],["b341","Ïøå",19,"Ïø¢Ïø£Ïø•Ïø¶ÏøßÏø©"],["b361","Ïø™",5,"Ïø≤Ïø¥Ïø∂",5,"ÏøΩÏøæÏøøÌÄÅÌÄÇÌÄÉÌÄÖ",5],["b381","ÌÄã",5,"ÌÄí",5,"ÌÄô",19,"ÎÅùÎÅºÎÅΩÎÇÄÎÇÑÎÇåÎÇçÎÇèÎÇëÎÇòÎÇôÎÇöÎÇúÎÇüÎÇ†ÎÇ°ÎÇ¢ÎÇ®ÎÇ©ÎÇ´",4,"ÎÇ±ÎÇ≥ÎÇ¥ÎÇµÎÇ∏ÎÇºÎÉÑÎÉÖÎÉáÎÉàÎÉâÎÉêÎÉëÎÉîÎÉòÎÉ†ÎÉ•ÎÑàÎÑâÎÑãÎÑåÎÑêÎÑíÎÑìÎÑòÎÑôÎÑõÎÑúÎÑùÎÑ£ÎÑ§ÎÑ•ÎÑ®ÎÑ¨ÎÑ¥ÎÑµÎÑ∑ÎÑ∏ÎÑπÎÖÄÎÖÅÎÖÑÎÖàÎÖêÎÖëÎÖîÎÖïÎÖòÎÖúÎÖ†ÎÖ∏ÎÖπÎÖºÎÜÄÎÜÇÎÜàÎÜâÎÜãÎÜçÎÜíÎÜìÎÜîÎÜòÎÜúÎÜ®ÎáåÎáêÎáîÎáúÎáù"],["b441","ÌÄÆ",5,"ÌÄ∂ÌÄ∑ÌÄπÌÄ∫ÌÄªÌÄΩ",6,"ÌÅÜÌÅàÌÅä",5],["b461","ÌÅëÌÅíÌÅìÌÅïÌÅñÌÅóÌÅô",6,"ÌÅ°",10,"ÌÅÆÌÅØ"],["b481","ÌÅ±ÌÅ≤ÌÅ≥ÌÅµ",6,"ÌÅæÌÅøÌÇÄÌÇÇ",18,"ÎáüÎá®Îá©Îá¨Îá∞ÎáπÎáªÎáΩÎàÑÎàÖÎààÎàãÎàåÎàîÎàïÎàóÎàôÎà†Îà¥ÎàºÎâòÎâúÎâ†Îâ®Îâ©Îâ¥ÎâµÎâºÎäÑÎäÖÎäâÎäêÎäëÎäîÎäòÎäôÎäöÎä†Îä°Îä£Îä•Îä¶Îä™Îä¨Îä∞Îä¥ÎãàÎãâÎãåÎãêÎãíÎãòÎãôÎãõÎãùÎã¢Îã§Îã•Îã¶Îã®Îã´",4,"Îã≥Îã¥ÎãµÎã∑",4,"ÎãøÎåÄÎåÅÎåÑÎåàÎåêÎåëÎåìÎåîÎåïÎåúÎçîÎçïÎçñÎçòÎçõÎçúÎçûÎçüÎç§Îç•"],["b541","ÌÇï",14,"ÌÇ¶ÌÇßÌÇ©ÌÇ™ÌÇ´ÌÇ≠",5],["b561","ÌÇ≥ÌÇ∂ÌÇ∏ÌÇ∫",5,"ÌÉÇÌÉÉÌÉÖÌÉÜÌÉáÌÉä",5,"ÌÉíÌÉñ",4],["b581","ÌÉõÌÉûÌÉüÌÉ°ÌÉ¢ÌÉ£ÌÉ•",6,"ÌÉÆÌÉ≤",5,"ÌÉπ",11,"ÎçßÎç©Îç´ÎçÆÎç∞Îç±Îç¥Îç∏ÎéÄÎéÅÎéÉÎéÑÎéÖÎéåÎéêÎéîÎé†Îé°Îé®Îé¨ÎèÑÎèÖÎèàÎèãÎèåÎèéÎèêÎèîÎèïÎèóÎèôÎèõÎèùÎè†Îè§Îè®ÎèºÎêêÎêòÎêúÎê†Îê®Îê©Îê´Îê¥ÎëêÎëëÎëîÎëòÎë†Îë°Îë£Îë•Îë¨ÎíÄÎíàÎíùÎí§Îí®Îí¨ÎíµÎí∑ÎíπÎìÄÎìÑÎìàÎìêÎìïÎìúÎìùÎì†Îì£Îì§Îì¶Îì¨Îì≠ÎìØÎì±Îì∏ÎîîÎîïÎîòÎîõÎîúÎî§Îî•ÎîßÎî®Îî©Îî™Îî∞Îî±Îî¥Îî∏"],["b641","ÌÑÖ",7,"ÌÑé",17],["b661","ÌÑ†",15,"ÌÑ≤ÌÑ≥ÌÑµÌÑ∂ÌÑ∑ÌÑπÌÑªÌÑºÌÑΩÌÑæ"],["b681","ÌÑøÌÖÇÌÖÜ",5,"ÌÖéÌÖèÌÖëÌÖíÌÖìÌÖï",6,"ÌÖûÌÖ†ÌÖ¢",5,"ÌÖ©ÌÖ™ÌÖ´ÌÖ≠ÎïÄÎïÅÎïÉÎïÑÎïÖÎïãÎïåÎïçÎïêÎïîÎïúÎïùÎïüÎï†Îï°Îñ†Îñ°Îñ§Îñ®Îñ™Îñ´Îñ∞Îñ±Îñ≥Îñ¥ÎñµÎñªÎñºÎñΩÎóÄÎóÑÎóåÎóçÎóèÎóêÎóëÎóòÎó¨ÎòêÎòëÎòîÎòòÎò•Îò¨Îò¥ÎôàÎô§Îô®ÎöúÎöùÎö†Îö§Îö´Îö¨Îö±ÎõîÎõ∞Îõ¥Îõ∏ÎúÄÎúÅÎúÖÎú®Îú©Îú¨ÎúØÎú∞Îú∏ÎúπÎúªÎùÑÎùàÎùåÎùîÎùïÎù†Îù§Îù®Îù∞Îù±Îù≥ÎùµÎùºÎùΩÎûÄÎûÑÎûåÎûçÎûèÎûêÎûëÎûíÎûñÎûó"],["b741","ÌÖÆ",13,"ÌÖΩ",6,"ÌÜÖÌÜÜÌÜáÌÜâÌÜä"],["b761","ÌÜã",20,"ÌÜ¢ÌÜ£ÌÜ•ÌÜ¶ÌÜß"],["b781","ÌÜ©",6,"ÌÜ≤ÌÜ¥ÌÜ∂ÌÜ∑ÌÜ∏ÌÜπÌÜªÌÜΩÌÜæÌÜøÌáÅ",14,"ÎûòÎûôÎûúÎû†Îû®Îû©Îû´Îû¨Îû≠Îû¥ÎûµÎû∏ÎüáÎüâÎü¨Îü≠Îü∞Îü¥ÎüºÎüΩÎüøÎ†ÄÎ†ÅÎ†áÎ†àÎ†âÎ†åÎ†êÎ†òÎ†ôÎ†õÎ†ùÎ†§Î†•Î†®Î†¨Î†¥Î†µÎ†∑Î†∏Î†πÎ°ÄÎ°ÑÎ°ëÎ°ìÎ°úÎ°ùÎ°†Î°§Î°¨Î°≠Î°ØÎ°±Î°∏Î°ºÎ¢çÎ¢®Î¢∞Î¢¥Î¢∏Î£ÄÎ£ÅÎ£ÉÎ£ÖÎ£åÎ£êÎ£îÎ£ùÎ£üÎ£°Î£®Î£©Î£¨Î£∞Î£∏Î£πÎ£ªÎ£ΩÎ§ÑÎ§òÎ§†Î§ºÎ§ΩÎ•ÄÎ•ÑÎ•åÎ•èÎ•ëÎ•òÎ•ôÎ•úÎ•†Î•®Î•©"],["b841","Ìáê",7,"Ìáô",17],["b861","Ìá´",8,"ÌáµÌá∂Ìá∑Ìáπ",13],["b881","ÌààÌàä",5,"Ìàë",24,"Î•´Î•≠Î•¥Î•µÎ•∏Î•ºÎ¶ÑÎ¶ÖÎ¶áÎ¶âÎ¶äÎ¶çÎ¶éÎ¶¨Î¶≠Î¶∞Î¶¥Î¶ºÎ¶ΩÎ¶øÎßÅÎßàÎßâÎßåÎßé",4,"ÎßòÎßôÎßõÎßùÎßûÎß°Îß£Îß§Îß•Îß®Îß¨Îß¥ÎßµÎß∑Îß∏ÎßπÎß∫Î®ÄÎ®ÅÎ®àÎ®ïÎ®∏Î®πÎ®ºÎ©ÄÎ©ÇÎ©àÎ©âÎ©ãÎ©çÎ©éÎ©ìÎ©îÎ©ïÎ©òÎ©úÎ©§Î©•Î©ßÎ©®Î©©Î©∞Î©±Î©¥Î©∏Î™ÉÎ™ÑÎ™ÖÎ™áÎ™åÎ™®Î™©Î™´Î™¨Î™∞Î™≤Î™∏Î™πÎ™ªÎ™ΩÎ´ÑÎ´àÎ´òÎ´ôÎ´º"],["b941","Ìà™Ìà´ÌàÆÌàØÌà±Ìà≤Ìà≥Ìàµ",6,"ÌàæÌâÄÌâÇ",5,"ÌââÌâäÌâãÌâå"],["b961","Ìâç",14,"Ìâù",6,"Ìâ•Ìâ¶ÌâßÌâ®"],["b981","Ìâ©",22,"ÌäÇÌäÉÌäÖÌäÜÌäáÌäâÌääÌäãÌäåÎ¨ÄÎ¨ÑÎ¨çÎ¨èÎ¨ëÎ¨òÎ¨úÎ¨†Î¨©Î¨´Î¨¥Î¨µÎ¨∂Î¨∏Î¨ªÎ¨ºÎ¨ΩÎ¨æÎ≠ÑÎ≠ÖÎ≠áÎ≠âÎ≠çÎ≠èÎ≠êÎ≠îÎ≠òÎ≠°Î≠£Î≠¨ÎÆàÎÆåÎÆêÎÆ§ÎÆ®ÎÆ¨ÎÆ¥ÎÆ∑ÎØÄÎØÑÎØàÎØêÎØìÎØ∏ÎØπÎØºÎØøÎ∞ÄÎ∞ÇÎ∞àÎ∞âÎ∞ãÎ∞åÎ∞çÎ∞èÎ∞ëÎ∞î",4,"Î∞õ",4,"Î∞§Î∞•Î∞ßÎ∞©Î∞≠Î∞∞Î∞±Î∞¥Î∞∏Î±ÄÎ±ÅÎ±ÉÎ±ÑÎ±ÖÎ±âÎ±åÎ±çÎ±êÎ±ùÎ≤ÑÎ≤ÖÎ≤àÎ≤ãÎ≤åÎ≤éÎ≤îÎ≤ïÎ≤ó"],["ba41","ÌäçÌäéÌäèÌäíÌäìÌäîÌäñ",5,"ÌäùÌäûÌäüÌä°Ìä¢Ìä£Ìä•",6,"Ìä≠"],["ba61","ÌäÆÌäØÌä∞Ìä≤",5,"Ìä∫ÌäªÌäΩÌäæÌãÅÌãÉ",4,"ÌãäÌãå",5],["ba81","ÌãíÌãìÌãïÌãñÌãóÌãôÌãöÌãõÌãù",6,"Ìã¶",9,"Ìã≤Ìã≥ÌãµÌã∂Ìã∑ÌãπÌã∫Î≤ôÎ≤öÎ≤†Î≤°Î≤§Î≤ßÎ≤®Î≤∞Î≤±Î≤≥Î≤¥Î≤µÎ≤ºÎ≤ΩÎ≥ÄÎ≥ÑÎ≥çÎ≥èÎ≥êÎ≥ëÎ≥ïÎ≥òÎ≥úÎ≥¥Î≥µÎ≥∂Î≥∏Î≥ºÎ¥ÑÎ¥ÖÎ¥áÎ¥âÎ¥êÎ¥îÎ¥§Î¥¨ÎµÄÎµàÎµâÎµåÎµêÎµòÎµôÎµ§Îµ®Î∂ÄÎ∂ÅÎ∂ÑÎ∂áÎ∂àÎ∂âÎ∂äÎ∂êÎ∂ëÎ∂ìÎ∂ïÎ∂ôÎ∂öÎ∂úÎ∂§Î∂∞Î∂∏Î∑îÎ∑ïÎ∑òÎ∑úÎ∑©Î∑∞Î∑¥Î∑∏Î∏ÄÎ∏ÉÎ∏ÖÎ∏åÎ∏çÎ∏êÎ∏îÎ∏úÎ∏ùÎ∏üÎπÑÎπÖÎπàÎπåÎπéÎπîÎπïÎπóÎπôÎπöÎπõÎπ†Îπ°Îπ§"],["bb41","Ìãª",4,"ÌåÇÌåÑÌåÜ",5,"ÌåèÌåëÌåíÌåìÌåïÌåó",4,"ÌåûÌå¢Ìå£"],["bb61","Ìå§Ìå¶ÌåßÌå™Ìå´Ìå≠ÌåÆÌåØÌå±",6,"Ìå∫Ìåæ",5,"ÌçÜÌçáÌçàÌçâ"],["bb81","Ìçä",31,"Îπ®Îπ™Îπ∞Îπ±Îπ≥Îπ¥ÎπµÎπªÎπºÎπΩÎ∫ÄÎ∫ÑÎ∫åÎ∫çÎ∫èÎ∫êÎ∫ëÎ∫òÎ∫ôÎ∫®ÎªêÎªëÎªîÎªóÎªòÎª†Îª£Îª§Îª•Îª¨ÎºÅÎºàÎºâÎºòÎºôÎºõÎºúÎºùÎΩÄÎΩÅÎΩÑÎΩàÎΩêÎΩëÎΩïÎæîÎæ∞ÎøÖÎøåÎøçÎøêÎøîÎøúÎøüÎø°ÏÄºÏÅëÏÅòÏÅúÏÅ†ÏÅ®ÏÅ©ÏÇêÏÇëÏÇîÏÇòÏÇ†ÏÇ°ÏÇ£ÏÇ•ÏÇ¨ÏÇ≠ÏÇØÏÇ∞ÏÇ≥ÏÇ¥ÏÇµÏÇ∂ÏÇºÏÇΩÏÇøÏÉÄÏÉÅÏÉÖÏÉàÏÉâÏÉåÏÉêÏÉòÏÉôÏÉõÏÉúÏÉùÏÉ§"],["bc41","Ìç™",17,"ÌçæÌçøÌéÅÌéÇÌéÉÌéÖÌéÜÌéá"],["bc61","ÌéàÌéâÌéäÌéãÌééÌéí",5,"ÌéöÌéõÌéùÌéûÌéüÌé°",6,"Ìé™Ìé¨ÌéÆ"],["bc81","ÌéØ",4,"ÌéµÌé∂Ìé∑ÌéπÌé∫ÌéªÌéΩ",6,"ÌèÜÌèáÌèä",5,"Ìèë",5,"ÏÉ•ÏÉ®ÏÉ¨ÏÉ¥ÏÉµÏÉ∑ÏÉπÏÑÄÏÑÑÏÑàÏÑêÏÑïÏÑú",4,"ÏÑ£ÏÑ§ÏÑ¶ÏÑßÏÑ¨ÏÑ≠ÏÑØÏÑ∞ÏÑ±ÏÑ∂ÏÑ∏ÏÑπÏÑºÏÖÄÏÖàÏÖâÏÖãÏÖåÏÖçÏÖîÏÖïÏÖòÏÖúÏÖ§ÏÖ•ÏÖßÏÖ®ÏÖ©ÏÖ∞ÏÖ¥ÏÖ∏ÏÜÖÏÜåÏÜçÏÜéÏÜêÏÜîÏÜñÏÜúÏÜùÏÜüÏÜ°ÏÜ•ÏÜ®ÏÜ©ÏÜ¨ÏÜ∞ÏÜΩÏáÑÏáàÏáåÏáîÏáóÏáòÏá†Ïá§Ïá®Ïá∞Ïá±Ïá≥ÏáºÏáΩÏàÄÏàÑÏàåÏàçÏàèÏàëÏàòÏàôÏàúÏàüÏà†Ïà®Ïà©Ïà´Ïà≠"],["bd41","ÌèóÌèô",7,"Ìè¢Ìè§",7,"ÌèÆÌèØÌè±Ìè≤Ìè≥ÌèµÌè∂Ìè∑"],["bd61","Ìè∏ÌèπÌè∫ÌèªÌèæÌêÄÌêÇ",5,"Ìêâ",13],["bd81","Ìêó",5,"Ìêû",25,"ÏàØÏà±Ïà≤Ïà¥ÏâàÏâêÏâëÏâîÏâòÏâ†Ïâ•Ïâ¨Ïâ≠Ïâ∞Ïâ¥ÏâºÏâΩÏâøÏäÅÏäàÏäâÏäêÏäòÏäõÏäùÏä§Ïä•Ïä®Ïä¨Ïä≠Ïä¥ÏäµÏä∑ÏäπÏãúÏãùÏã†Ïã£Ïã§Ïã´Ïã¨Ïã≠ÏãØÏã±Ïã∂Ïã∏ÏãπÏãªÏãºÏåÄÏåàÏåâÏååÏåçÏåìÏåîÏåïÏåòÏåúÏå§Ïå•Ïå®Ïå©ÏçÖÏç®Ïç©Ïç¨Ïç∞Ïç≤Ïç∏ÏçπÏçºÏçΩÏéÑÏéàÏéåÏèÄÏèòÏèôÏèúÏèüÏè†Ïè¢Ïè®Ïè©Ïè≠Ïè¥ÏèµÏè∏ÏêàÏêêÏê§Ïê¨Ïê∞"],["be41","Ìê∏",7,"ÌëÅÌëÇÌëÉÌëÖ",14],["be61","Ìëî",7,"ÌëùÌëûÌëüÌë°Ìë¢Ìë£Ìë•",7,"ÌëÆÌë∞Ìë±Ìë≤"],["be81","Ìë≥",4,"Ìë∫ÌëªÌëΩÌëæÌíÅÌíÉ",4,"ÌíäÌíåÌíé",5,"Ìíï",8,"Ïê¥ÏêºÏêΩÏëàÏë§Ïë•Ïë®Ïë¨Ïë¥ÏëµÏëπÏíÄÏíîÏíúÏí∏ÏíºÏì©Ïì∞Ïì±Ïì¥Ïì∏Ïì∫ÏìøÏîÄÏîÅÏîåÏîêÏîîÏîúÏî®Ïî©Ïî¨Ïî∞Ïî∏ÏîπÏîªÏîΩÏïÑÏïÖÏïàÏïâÏïäÏïåÏïçÏïéÏïìÏïîÏïïÏïóÏïòÏïôÏïùÏïûÏï†Ïï°Ïï§Ïï®Ïï∞Ïï±Ïï≥Ïï¥ÏïµÏïºÏïΩÏñÄÏñÑÏñáÏñåÏñçÏñèÏñëÏñïÏñóÏñòÏñúÏñ†Ïñ©Ïñ¥ÏñµÏñ∏ÏñπÏñªÏñºÏñΩÏñæÏóÑ",6,"ÏóåÏóé"],["bf41","Ìíû",10,"Ìí™",14],["bf61","Ìíπ",18,"ÌìçÌìéÌìèÌìëÌìíÌììÌìï"],["bf81","Ììñ",5,"ÌìùÌìûÌì†",7,"Ìì©Ìì™Ìì´Ìì≠ÌìÆÌìØÌì±",6,"ÌìπÌì∫ÌìºÏóêÏóëÏóîÏóòÏó†Ïó°Ïó£Ïó•Ïó¨Ïó≠ÏóÆÏó∞Ïó¥Ïó∂Ïó∑Ïóº",5,"ÏòÖÏòÜÏòáÏòàÏòåÏòêÏòòÏòôÏòõÏòúÏò§Ïò•Ïò®Ïò¨Ïò≠ÏòÆÏò∞Ïò≥Ïò¥ÏòµÏò∑ÏòπÏòªÏôÄÏôÅÏôÑÏôàÏôêÏôëÏôìÏôîÏôïÏôúÏôùÏô†Ïô¨ÏôØÏô±Ïô∏ÏôπÏôºÏöÄÏöàÏöâÏöãÏöçÏöîÏöïÏöòÏöúÏö§Ïö•ÏößÏö©Ïö∞Ïö±Ïö¥Ïö∏ÏöπÏö∫ÏõÄÏõÅÏõÉÏõÖÏõåÏõçÏõêÏõîÏõúÏõùÏõ†Ïõ°Ïõ®"],["c041","Ììæ",5,"ÌîÖÌîÜÌîáÌîâÌîäÌîãÌîç",6,"ÌîñÌîò",5],["c061","Ìîû",25],["c081","Ìî∏ÌîπÌî∫ÌîªÌîæÌîøÌïÅÌïÇÌïÉÌïÖ",6,"ÌïéÌïêÌïí",5,"ÌïöÌïõÌïùÌïûÌïüÌï°Ìï¢Ìï£Ïõ©Ïõ¨Ïõ∞Ïõ∏ÏõπÏõΩÏúÑÏúÖÏúàÏúåÏúîÏúïÏúóÏúôÏú†Ïú°Ïú§Ïú®Ïú∞Ïú±Ïú≥ÏúµÏú∑ÏúºÏúΩÏùÄÏùÑÏùäÏùåÏùçÏùèÏùë",7,"ÏùúÏù†Ïù®Ïù´Ïù¥ÏùµÏù∏ÏùºÏùΩÏùæÏûÉÏûÑÏûÖÏûáÏûàÏûâÏûäÏûéÏûêÏûëÏûîÏûñÏûóÏûòÏûöÏû†Ïû°Ïû£Ïû§Ïû•Ïû¶Ïû¨Ïû≠Ïû∞Ïû¥ÏûºÏûΩÏûøÏüÄÏüÅÏüàÏüâÏüåÏüéÏüêÏüòÏüùÏü§Ïü®Ïü¨Ï†ÄÏ†ÅÏ†ÑÏ†àÏ†ä"],["c141","Ìï§Ìï¶ÌïßÌï™Ìï¨ÌïÆ",5,"Ìï∂Ìï∑ÌïπÌï∫ÌïªÌïΩ",6,"ÌñÜÌñäÌñã"],["c161","ÌñåÌñçÌñéÌñèÌñë",19,"Ìñ¶Ìñß"],["c181","Ìñ®",31,"Ï†êÏ†ëÏ†ìÏ†ïÏ†ñÏ†úÏ†ùÏ††Ï†§Ï†¨Ï†≠Ï†ØÏ†±Ï†∏Ï†ºÏ°ÄÏ°àÏ°âÏ°åÏ°çÏ°îÏ°∞Ï°±Ï°¥Ï°∏Ï°∫Ï¢ÄÏ¢ÅÏ¢ÉÏ¢ÖÏ¢ÜÏ¢áÏ¢ãÏ¢åÏ¢çÏ¢îÏ¢ùÏ¢üÏ¢°Ï¢®Ï¢ºÏ¢ΩÏ£ÑÏ£àÏ£åÏ£îÏ£ïÏ£óÏ£ôÏ£†Ï£°Ï£§Ï£µÏ£ºÏ£ΩÏ§ÄÏ§ÑÏ§ÖÏ§ÜÏ§åÏ§çÏ§èÏ§ëÏ§òÏ§¨Ï§¥Ï•êÏ•ëÏ•îÏ•òÏ•†Ï•°Ï•£Ï•¨Ï•∞Ï•¥Ï•ºÏ¶àÏ¶âÏ¶åÏ¶êÏ¶òÏ¶ôÏ¶õÏ¶ùÏßÄÏßÅÏßÑÏßáÏßàÏßäÏßêÏßëÏßì"],["c241","ÌóäÌóãÌóçÌóéÌóèÌóëÌóì",4,"ÌóöÌóúÌóû",5,"Ìó¶ÌóßÌó©Ìó™Ìó´Ìó≠ÌóÆ"],["c261","ÌóØ",4,"Ìó∂Ìó∏Ìó∫",5,"ÌòÇÌòÉÌòÖÌòÜÌòáÌòâ",6,"Ìòí"],["c281","Ìòñ",5,"ÌòùÌòûÌòüÌò°Ìò¢Ìò£Ìò•",7,"ÌòÆ",9,"Ìò∫ÌòªÏßïÏßñÏßôÏßöÏßúÏßùÏß†Ïß¢Ïß§ÏßßÏß¨Ïß≠ÏßØÏß∞Ïß±Ïß∏ÏßπÏßºÏ®ÄÏ®àÏ®âÏ®ãÏ®åÏ®çÏ®îÏ®òÏ®©Ï©åÏ©çÏ©êÏ©îÏ©úÏ©ùÏ©üÏ©†Ï©°Ï©®Ï©ΩÏ™ÑÏ™òÏ™ºÏ™ΩÏ´ÄÏ´ÑÏ´åÏ´çÏ´èÏ´ëÏ´ìÏ´òÏ´ôÏ´†Ï´¨Ï´¥Ï¨àÏ¨êÏ¨îÏ¨òÏ¨†Ï¨°Ï≠ÅÏ≠àÏ≠âÏ≠åÏ≠êÏ≠òÏ≠ôÏ≠ùÏ≠§Ï≠∏Ï≠πÏÆúÏÆ∏ÏØîÏØ§ÏØßÏØ©Ï∞åÏ∞çÏ∞êÏ∞îÏ∞úÏ∞ùÏ∞°Ï∞¢Ï∞ßÏ∞®Ï∞©Ï∞¨Ï∞ÆÏ∞∞Ï∞∏Ï∞πÏ∞ª"],["c341","ÌòΩÌòæÌòøÌôÅÌôÇÌôÉÌôÑÌôÜÌôáÌôäÌôåÌôéÌôèÌôêÌôíÌôìÌôñÌôóÌôôÌôöÌôõÌôù",4],["c361","Ìô¢",4,"Ìô®Ìô™",5,"Ìô≤Ìô≥Ìôµ",11],["c381","ÌöÅÌöÇÌöÑÌöÜ",5,"ÌöéÌöèÌöëÌöíÌöìÌöï",7,"ÌöûÌö†Ìö¢",5,"Ìö©Ìö™Ï∞ºÏ∞ΩÏ∞æÏ±ÑÏ±ÖÏ±àÏ±åÏ±îÏ±ïÏ±óÏ±òÏ±ôÏ±†Ï±§Ï±¶Ï±®Ï±∞Ï±µÏ≤òÏ≤ôÏ≤úÏ≤†Ï≤®Ï≤©Ï≤´Ï≤¨Ï≤≠Ï≤¥Ï≤µÏ≤∏Ï≤ºÏ≥ÑÏ≥ÖÏ≥áÏ≥âÏ≥êÏ≥îÏ≥§Ï≥¨Ï≥∞Ï¥ÅÏ¥àÏ¥âÏ¥åÏ¥êÏ¥òÏ¥ôÏ¥õÏ¥ùÏ¥§Ï¥®Ï¥¨Ï¥πÏµúÏµ†Ïµ§Ïµ¨Ïµ≠ÏµØÏµ±Ïµ∏Ï∂àÏ∂îÏ∂ïÏ∂òÏ∂úÏ∂§Ï∂•Ï∂ßÏ∂©Ï∂∞Ï∑ÑÏ∑åÏ∑êÏ∑®Ï∑¨Ï∑∞Ï∑∏Ï∑πÏ∑ªÏ∑ΩÏ∏ÑÏ∏àÏ∏åÏ∏îÏ∏ôÏ∏†Ï∏°Ï∏§Ï∏®Ï∏∞Ï∏±Ï∏≥Ï∏µ"],["c441","Ìö´Ìö≠ÌöÆÌöØÌö±",7,"Ìö∫Ìöº",7,"ÌõÜÌõáÌõâÌõäÌõã"],["c461","ÌõçÌõéÌõèÌõêÌõíÌõìÌõïÌõñÌõòÌõö",5,"Ìõ°Ìõ¢Ìõ£Ìõ•Ìõ¶ÌõßÌõ©",4],["c481","ÌõÆÌõØÌõ±Ìõ≤Ìõ≥Ìõ¥Ìõ∂",5,"ÌõæÌõøÌúÅÌúÇÌúÉÌúÖ",11,"ÌúíÌúìÌúîÏπòÏπôÏπúÏπüÏπ†Ïπ°Ïπ®Ïπ©Ïπ´Ïπ≠Ïπ¥ÏπµÏπ∏ÏπºÏ∫ÑÏ∫ÖÏ∫áÏ∫âÏ∫êÏ∫ëÏ∫îÏ∫òÏ∫†Ï∫°Ï∫£Ï∫§Ï∫•Ï∫¨Ï∫≠ÏªÅÏª§Ïª•Ïª®Ïª´Ïª¨Ïª¥ÏªµÏª∑Ïª∏ÏªπÏºÄÏºÅÏºÑÏºàÏºêÏºëÏºìÏºïÏºúÏº†Ïº§Ïº¨Ïº≠ÏºØÏº∞Ïº±Ïº∏ÏΩîÏΩïÏΩòÏΩúÏΩ§ÏΩ•ÏΩßÏΩ©ÏΩ∞ÏΩ±ÏΩ¥ÏΩ∏ÏæÄÏæÖÏæåÏæ°Ïæ®Ïæ∞ÏøÑÏø†Ïø°Ïø§Ïø®Ïø∞Ïø±Ïø≥ÏøµÏøºÌÄÄÌÄÑÌÄëÌÄòÌÄ≠ÌÄ¥ÌÄµÌÄ∏ÌÄº"],["c541","ÌúïÌúñÌúóÌúöÌúõÌúùÌúûÌúüÌú°",6,"Ìú™Ìú¨ÌúÆ",5,"Ìú∂Ìú∑Ìúπ"],["c561","Ìú∫ÌúªÌúΩ",6,"ÌùÖÌùÜÌùàÌùä",5,"ÌùíÌùìÌùïÌùö",4],["c581","ÌùüÌù¢Ìù§Ìù¶ÌùßÌù®Ìù™Ìù´Ìù≠ÌùÆÌùØÌù±Ìù≤Ìù≥Ìùµ",6,"ÌùæÌùøÌûÄÌûÇ",5,"ÌûäÌûãÌÅÑÌÅÖÌÅáÌÅâÌÅêÌÅîÌÅòÌÅ†ÌÅ¨ÌÅ≠ÌÅ∞ÌÅ¥ÌÅºÌÅΩÌÇÅÌÇ§ÌÇ•ÌÇ®ÌÇ¨ÌÇ¥ÌÇµÌÇ∑ÌÇπÌÉÄÌÉÅÌÉÑÌÉàÌÉâÌÉêÌÉëÌÉìÌÉîÌÉïÌÉúÌÉùÌÉ†ÌÉ§ÌÉ¨ÌÉ≠ÌÉØÌÉ∞ÌÉ±ÌÉ∏ÌÑçÌÑ∞ÌÑ±ÌÑ¥ÌÑ∏ÌÑ∫ÌÖÄÌÖÅÌÖÉÌÖÑÌÖÖÌÖåÌÖçÌÖêÌÖîÌÖúÌÖùÌÖüÌÖ°ÌÖ®ÌÖ¨ÌÖºÌÜÑÌÜàÌÜ†ÌÜ°ÌÜ§ÌÜ®ÌÜ∞ÌÜ±ÌÜ≥ÌÜµÌÜ∫ÌÜºÌáÄÌáòÌá¥Ìá∏ÌàáÌàâÌàêÌà¨Ìà≠Ìà∞Ìà¥ÌàºÌàΩÌàøÌâÅÌâàÌâú"],["c641","ÌûçÌûéÌûèÌûë",6,"ÌûöÌûúÌûû",5],["c6a1","Ìâ§ÌäÄÌäÅÌäÑÌäàÌäêÌäëÌäïÌäúÌä†Ìä§Ìä¨Ìä±Ìä∏ÌäπÌäºÌäøÌãÄÌãÇÌãàÌãâÌããÌãîÌãòÌãúÌã§Ìã•Ìã∞Ìã±Ìã¥Ìã∏ÌåÄÌåÅÌåÉÌåÖÌååÌåçÌåéÌåêÌåîÌåñÌåúÌåùÌåüÌå†Ìå°Ìå•Ìå®Ìå©Ìå¨Ìå∞Ìå∏ÌåπÌåªÌåºÌåΩÌçÑÌçÖÌçºÌçΩÌéÄÌéÑÌéåÌéçÌéèÌéêÌéëÌéòÌéôÌéúÌé†Ìé®Ìé©Ìé´Ìé≠Ìé¥Ìé∏ÌéºÌèÑÌèÖÌèàÌèâÌèêÌèòÌè°Ìè£Ìè¨Ìè≠Ìè∞Ìè¥ÌèºÌèΩÌèøÌêÅ"],["c7a1","ÌêàÌêùÌëÄÌëÑÌëúÌë†Ìë§Ìë≠ÌëØÌë∏ÌëπÌëºÌëøÌíÄÌíÇÌíàÌíâÌíãÌíçÌíîÌí©ÌìåÌìêÌìîÌìúÌìüÌì®Ìì¨Ìì∞Ìì∏ÌìªÌìΩÌîÑÌîàÌîåÌîîÌîïÌîóÌîºÌîΩÌïÄÌïÑÌïåÌïçÌïèÌïëÌïòÌïôÌïúÌï†Ìï•Ìï®Ìï©Ìï´Ìï≠Ìï¥ÌïµÌï∏ÌïºÌñÑÌñÖÌñáÌñàÌñâÌñêÌñ•ÌóàÌóâÌóåÌóêÌóíÌóòÌóôÌóõÌóùÌó§Ìó•Ìó®Ìó¨Ìó¥ÌóµÌó∑ÌóπÌòÄÌòÅÌòÑÌòàÌòêÌòëÌòìÌòîÌòïÌòúÌò†"],["c8a1","Ìò§Ìò≠Ìò∏ÌòπÌòºÌôÄÌôÖÌôàÌôâÌôãÌôçÌôëÌôîÌôïÌôòÌôúÌôßÌô©Ìô∞Ìô±Ìô¥ÌöÉÌöÖÌöåÌöçÌöêÌöîÌöùÌöüÌö°Ìö®Ìö¨Ìö∞ÌöπÌöªÌõÑÌõÖÌõàÌõåÌõëÌõîÌõóÌõôÌõ†Ìõ§Ìõ®Ìõ∞ÌõµÌõºÌõΩÌúÄÌúÑÌúëÌúòÌúôÌúúÌú†Ìú®Ìú©Ìú´Ìú≠Ìú¥ÌúµÌú∏ÌúºÌùÑÌùáÌùâÌùêÌùëÌùîÌùñÌùóÌùòÌùôÌù†Ìù°Ìù£Ìù•Ìù©Ìù¨Ìù∞Ìù¥ÌùºÌùΩÌûÅÌûàÌûâÌûåÌûêÌûòÌûôÌûõÌûù"],["caa1","‰ºΩ‰Ω≥ÂÅáÂÉπÂä†ÂèØÂëµÂì•ÂòâÂ´ÅÂÆ∂ÊöáÊû∂Êû∑ÊüØÊ≠åÁèÇÁóÇÁ®ºËãõËåÑË°óË¢àË®∂Ë≥àË∑èËªªËø¶ÈßïÂàªÂç¥ÂêÑÊÅ™ÊÖ§ÊÆºÁèèËÑöË¶∫ËßíÈñ£‰æÉÂàäÂ¢æÂ•∏Âß¶Âπ≤ÂππÊááÊèÄÊùÜÊü¨Ê°øÊæóÁôéÁúãÁ£µÁ®àÁ´øÁ∞°ËÇùËâÆËâ±Ë´´Èñì‰π´ÂñùÊõ∑Ê∏¥Á¢£Á´≠ËëõË§êËùéÈû®ÂãòÂùéÂ†™ÂµåÊÑüÊÜæÊà°Êï¢ÊüëÊ©ÑÊ∏õÁîòÁñ≥Áõ£Áû∞Á¥∫ÈÇØÈëëÈëíÈæï"],["cba1","Âå£Â≤¨Áî≤ËÉõÈâÄÈñòÂâõÂ†àÂßúÂ≤°Â¥óÂ∫∑Âº∫ÂΩäÊÖ∑Ê±üÁï∫ÁñÜÁ≥†Áµ≥Á∂±ÁæåËÖîËà°ËñëË•ÅË¨õÈãºÈôçÈ±á‰ªã‰ª∑ÂÄãÂá±Â°èÊÑ∑ÊÑæÊÖ®ÊîπÊß™ÊºëÁñ•ÁöÜÁõñÁÆáËä•ËìãÔ§ÄÈéßÈñãÂñÄÂÆ¢ÂùëÔ§ÅÁ≤≥ÁæπÈÜµÂÄ®ÂéªÂ±ÖÂ∑®ÊãíÊçÆÊìöÊìßÊ∏†ÁÇ¨Á•õË∑ùË∏ûÔ§ÇÈÅΩÈâÖÈã∏‰πæ‰ª∂ÂÅ•Â∑æÂª∫ÊÑÜÊ•óËÖ±ËôîËπáÈçµÈ®´‰πûÂÇëÊù∞Ê°ÄÂÑâÂäçÂäíÊ™¢"],["cca1","ÁûºÈàêÈªîÂä´ÊÄØËø≤ÂÅàÊÜ©Êè≠ÊìäÊ†ºÊ™ÑÊøÄËÜàË¶°ÈöîÂ†ÖÁâΩÁä¨ÁîÑÁµπÁπ≠ËÇ©Ë¶ãË≠¥ÈÅ£ÈµëÊäâÊ±∫ÊΩîÁµêÁº∫Ë®£ÂÖºÊÖäÁÆùË¨ôÈâóÈéå‰∫¨‰øìÂÄûÂÇæÂÑÜÂãÅÂãçÂçøÂù∞Â¢ÉÂ∫öÂæëÊÖ∂ÊÜ¨ÊìéÊï¨ÊôØÊöªÊõ¥Ê¢óÊ∂áÁÇÖÁÉ±ÁíüÁí•ÁìäÁóôÁ°¨Á£¨Á´üÁ´∂ÁµÖÁ∂ìËÄïËÄøËÑõËéñË≠¶ËºïÈÄïÈè°È†ÉÈ†∏È©öÈØ®‰øÇÂïìÂ†∫Â•ëÂ≠£Â±ÜÊÇ∏ÊàíÊ°ÇÊ¢∞"],["cda1","Ê£®Ê∫™ÁïåÁô∏Á£éÁ®ΩÁ≥ªÁπ´ÁπºË®àË™°Ë∞øÈöéÈ∑ÑÂè§Âè©ÂëäÂë±Âõ∫ÂßëÂ≠§Â∞ªÂ∫´Êã∑Êî∑ÊïÖÊï≤Êö†ÊûØÊßÅÊ≤ΩÁóºÁöêÁùæÁ®øÁæîËÄÉËÇ°ËÜèËã¶ËãΩËè∞ËóÅË†±Ë¢¥Ë™•Ô§ÉËæúÈåÆÈõáÈ°ßÈ´òÈºìÂì≠ÊñõÊõ≤Ê¢èÁ©ÄË∞∑Èµ†Âõ∞Âù§Â¥ëÊòÜÊ¢±Ê£çÊªæÁê®Ë¢ûÈØ§Ê±®Ô§ÑÈ™®‰æõÂÖ¨ÂÖ±ÂäüÂ≠îÂ∑•ÊÅêÊÅ≠Êã±ÊéßÊîªÁèôÁ©∫Ëö£Ë≤¢Èûè‰∏≤ÂØ°ÊààÊûúÁìú"],["cea1","ÁßëËèìË™áË™≤Ë∑®ÈÅéÈçãÈ°ÜÂªìÊß®ËóøÈÉ≠Ô§ÖÂÜ†ÂÆòÂØ¨ÊÖ£Ê£∫Ê¨æÁÅåÁêØÁìòÁÆ°ÁΩêËèÖËßÄË≤´ÈóúÈ§®ÂàÆÊÅùÊã¨ÈÄÇ‰æäÂÖâÂå°Â£ôÂª£Êõ†Ê¥∏ÁÇöÁãÇÁèñÁ≠êËÉ±ÈëõÂç¶ÊéõÁΩ´‰πñÂÇÄÂ°äÂ£ûÊÄ™ÊÑßÊãêÊßêÈ≠ÅÂÆèÁ¥òËÇ±ËΩü‰∫§ÂÉëÂí¨Âñ¨Â¨åÂ∂†Â∑ßÊî™ÊïéÊ†°Ê©ãÁã°ÁöéÁüØÁµûÁøπËÜ†ËïéËõüËºÉËΩéÈÉäÈ§ÉÈ©ïÈÆ´‰∏ò‰πÖ‰πù‰ªá‰ø±ÂÖ∑Âãæ"],["cfa1","ÂçÄÂè£Âè•ÂíéÂòîÂùµÂû¢ÂØáÂ∂áÂªêÊáºÊãòÊïëÊû∏Êü©ÊßãÊ≠êÊØÜÊØ¨Ê±ÇÊ∫ùÁÅ∏ÁãóÁéñÁêÉÁûøÁü©Á©∂ÁµøËÄâËáºËàÖËàäËãüË°¢Ë¨≥Ë≥ºËªÄÈÄëÈÇ±Èâ§Èä∂ÈßíÈ©ÖÈ≥©È∑óÈæúÂúãÂ±ÄËèäÈû†Èû´È∫¥ÂêõÁ™òÁæ§Ë£ôËªçÈÉ°Â†ÄÂ±àÊéòÁ™üÂÆÆÂºìÁ©πÁ™ÆËäéË∫¨ÂÄ¶Âà∏Âã∏Âç∑ÂúàÊã≥Êç≤Ê¨äÊ∑ÉÁú∑Âé•ÁçóËï®Ëπ∂ÈóïÊú∫Ê´ÉÊΩ∞Ë©≠ËªåÈ•ãÔ§ÜÊô∑Ê≠∏Ë≤¥"],["d0a1","È¨ºÔ§áÂè´Âú≠Â•éÊèÜÊßªÁè™Á°ÖÁ™∫Á´ÖÁ≥æËëµË¶èËµ≥ÈÄµÈñ®ÂãªÂùáÁïáÁ≠†ËèåÈàûÔ§àÊ©òÂÖãÂâãÂäáÊàüÊ£òÊ•µÈöôÂÉÖÂä§Âã§ÊáÉÊñ§Ê†πÊßøÁëæÁ≠ãËäπËè´Ë¶≤Ë¨πËøëÈ•âÔ§â‰ªäÂ¶óÊìíÊòëÊ™éÁê¥Á¶ÅÁ¶ΩËä©Ë°æË°øË•üÔ§äÈå¶‰ºãÂèäÊÄ•Êâ±Ê±≤Á¥öÁµ¶‰∫òÂÖ¢ÁüúËÇØ‰ºÅ‰ºéÂÖ∂ÂÜÄÂóúÂô®ÂúªÂü∫ÂüºÂ§îÂ•áÂ¶ìÂØÑÂ≤êÂ¥éÂ∑±ÂπæÂøåÊäÄÊóóÊó£"],["d1a1","ÊúûÊúüÊùûÊ£ãÊ£ÑÊ©üÊ¨∫Ê∞£Ê±ΩÊ≤ÇÊ∑áÁéòÁê¶Áê™ÁíÇÁí£Áï∏ÁïøÁ¢ÅÁ£ØÁ•ÅÁ•áÁ•àÁ•∫ÁÆïÁ¥ÄÁ∂∫ÁæàËÄÜËÄ≠ËÇåË®òË≠èË±àËµ∑Èå°Èå§È£¢È•ëÈ®éÈ®èÈ©•È∫íÁ∑ä‰Ω∂ÂêâÊãÆÊ°îÈáëÂñ´ÂÑ∫Ô§ãÔ§åÂ®úÊá¶Ô§çÊãèÊãøÔ§é",5,"ÈÇ£Ô§î",4,"Ë´æÔ§ôÔ§öÔ§õÔ§úÊöñÔ§ùÁÖñÔ§ûÔ§üÈõ£Ô§†ÊçèÊç∫ÂçóÔ§°ÊûèÊ•†Êπ≥Ô§¢Áî∑Ô§£Ô§§Ô§•"],["d2a1","Á¥çÔ§¶Ô§ßË°≤ÂõäÂ®òÔ§®",4,"‰πÉÔ§≠ÂÖßÂ•àÊü∞ËÄêÔ§ÆÂ•≥Âπ¥ÊíöÁßäÂøµÊÅ¨ÊãàÊçªÂØßÂØóÂä™Ô§ØÂ•¥Âº©ÊÄíÔ§∞Ô§±Ô§≤ÁëôÔ§≥",5,"ÈßëÔ§π",10,"ÊøÉÔ•ÑÔ•ÖËÜøËæ≤ÊÉ±Ô•ÜÔ•áËÖ¶Ô•àÔ•âÂ∞øÔ•ä",7,"Â´©Ë®•ÊùªÁ¥êÔ•í",5,"ËÉΩÔ•òÔ•ôÂ∞ºÊ≥•ÂåøÊ∫∫Â§öËå∂"],["d3a1","‰∏π‰∫∂‰ΩÜÂñÆÂúòÂ£áÂΩñÊñ∑Êó¶Ê™ÄÊÆµÊπçÁü≠Á´ØÁ∞ûÁ∑ûËõãË¢íÈÑ≤ÈçõÊíªÊææÁç∫Áñ∏ÈÅîÂïñÂùçÊÜ∫ÊìîÊõáÊ∑°ÊπõÊΩ≠ÊæπÁó∞ËÅÉËÜΩËïÅË¶ÉË´áË≠öÈåüÊ≤ìÁïìÁ≠îË∏èÈÅùÂîêÂ†ÇÂ°òÂπ¢ÊàáÊíûÊ£†Áï∂Á≥ñËû≥Èª®‰ª£ÂûàÂùÆÂ§ßÂ∞çÂ≤±Â∏∂ÂæÖÊà¥Êì°Áé≥Ëá∫Ë¢ãË≤∏ÈöäÈªõÂÆÖÂæ∑ÊÇ≥ÂÄíÂàÄÂà∞ÂúñÂ†µÂ°óÂ∞éÂ±†Â≥∂Â∂ãÂ∫¶ÂæíÊÇºÊåëÊéâÊêóÊ°É"],["d4a1","Ê£πÊ´ÇÊ∑òÊ∏°ÊªîÊø§ÁáæÁõúÁùπÁ¶±Á®ªËêÑË¶©Ë≥≠Ë∑≥ËπàÈÄÉÈÄîÈÅìÈÉΩÈççÈô∂ÈüúÊØíÁÄÜÁâòÁä¢Áç®Áù£Á¶øÁØ§Á∫õËÆÄÂ¢©ÊÉáÊï¶ÊóΩÊöæÊ≤åÁÑûÁáâË±öÈ†ì‰π≠Á™Å‰ªùÂÜ¨ÂáçÂãïÂêåÊÜßÊù±Ê°êÊ£üÊ¥ûÊΩºÁñºÁû≥Á´•ËÉ¥Ëë£ÈäÖÂÖúÊñóÊùúÊûìÁóòÁ´áËç≥Ô•öË±ÜÈÄóÈ†≠Â±ØËáÄËäöÈÅÅÈÅØÈàçÂæóÂ∂ùÊ©ôÁáàÁôªÁ≠âËó§Ë¨ÑÈÑßÈ®∞ÂñáÊá∂Ô•õÁô©ÁæÖ"],["d5a1","ËòøËû∫Ë£∏ÈÇèÔ•úÊ¥õÁÉôÁèûÁµ°ËêΩÔ•ùÈÖ™Èß±Ô•û‰∫ÇÂçµÊ¨ÑÊ¨íÁÄæÁàõËò≠È∏ûÂâåËæ£ÂµêÊì•Êî¨Ê¨ñÊø´Á±ÉÁ∫úËóçË•§Ë¶ΩÊãâËáòË†üÂªäÊúóÊµ™ÁãºÁêÖÁëØËûÇÈÉû‰æÜÂ¥çÂæ†ËêäÂÜ∑Êé†Áï•‰∫ÆÂÄÜÂÖ©ÂáâÊ¢ÅÊ®ëÁ≤ÆÁ≤±Á≥ßËâØË´íËºõÈáè‰æ∂ÂÑ∑ÂãµÂëÇÂª¨ÊÖÆÊàæÊóÖÊ´öÊøæÁ§™ËóúË†£Èñ≠È©¢È©™È∫óÈªéÂäõÊõÜÊ≠∑ÁÄùÁ§´ËΩ¢ÈùÇÊÜêÊàÄÊî£Êº£"],["d6a1","ÁÖâÁíâÁ∑¥ËÅØËìÆËº¶ÈÄ£ÈçäÂÜΩÂàóÂä£Ê¥åÁÉàË£ÇÂªâÊñÇÊÆÆÊøÇÁ∞æÁçµ‰ª§‰º∂ÂõπÔ•üÂ≤∫Â∂∫ÊÄúÁé≤Á¨≠ÁæöÁøéËÅÜÈÄûÈà¥Èõ∂ÈùàÈ†òÈΩ°‰æãÊæßÁ¶ÆÈÜ¥Èö∑ÂãûÔ•†ÊíàÊìÑÊ´ìÊΩûÁÄòÁàêÁõßËÄÅËòÜËôúË∑ØËºÖÈú≤È≠ØÈ∑∫ÈπµÁ¢åÁ•øÁ∂†ËèâÈåÑÈπøÈ∫ìË´ñÂ£üÂºÑÊúßÁÄßÁìèÁ±†ËÅæÂÑ°ÁÄ®Áâ¢Á£äË≥ÇË≥öË≥¥Èõ∑‰∫ÜÂÉöÂØÆÂªñÊñôÁáéÁôÇÁû≠ËÅäËìº"],["d7a1","ÈÅºÈ¨ßÈæçÂ£òÂ©ÅÂ±¢Ê®ìÊ∑öÊºèÁòªÁ¥ØÁ∏∑ËîûË§∏Èè§ÈôãÂäâÊóíÊü≥Ê¶¥ÊµÅÊ∫úÁÄèÁêâÁë†ÁïôÁò§Á°´Ë¨¨È°ûÂÖ≠ÊàÆÈô∏‰æñÂÄ´Â¥ôÊ∑™Á∂∏Ëº™ÂæãÊÖÑÊ†óÔ•°ÈöÜÂãíËÇãÂáúÂáåÊ•ûÁ®úÁ∂æËè±Èôµ‰øöÂà©ÂéòÂêèÂîéÂ±•ÊÇßÊùéÊ¢®Êµ¨ÁäÅÁã∏ÁêÜÁíÉÔ•¢Áó¢Á±¨ÁΩπÁæ∏ËéâË£èË£°ÈáåÈáêÈõ¢ÈØâÂêùÊΩæÁáêÁíòËó∫Ë∫™Èö£È±óÈ∫üÊûóÊ∑ãÁê≥Ëá®ÈúñÁ†¨"],["d8a1","Á´ãÁ¨†Á≤íÊë©Áë™Áó≤Á¢ºÁ£®È¶¨È≠îÈ∫ªÂØûÂπïÊº†ËÜúËé´ÈÇà‰∏áÂççÂ®©Â∑íÂΩéÊÖ¢ÊåΩÊô©ÊõºÊªøÊº´ÁÅ£ÁûûËê¨ËîìË†ªËºìÈ•ÖÈ∞ªÂîúÊäπÊú´Ê≤´ËåâË•™Èù∫‰∫°Â¶ÑÂøòÂøôÊúõÁ∂≤ÁΩîËäíËå´ËéΩËºûÈÇôÂüãÂ¶πÂ™íÂØêÊòßÊûöÊ¢ÖÊØèÁÖ§ÁΩµË≤∑Ë≥£ÈÇÅÈ≠ÖËÑàË≤äÈôåÈ©ÄÈ∫•Â≠üÊ∞ìÁåõÁõ≤ÁõüËêåÂÜ™Ë¶ìÂÖçÂÜïÂãâÊ£âÊ≤îÁúÑÁú†Á∂øÁ∑¨Èù¢È∫µÊªÖ"],["d9a1","ËîëÂÜ•ÂêçÂëΩÊòéÊöùÊ§ßÊ∫üÁöøÁûëËåóËìÇËûüÈÖ©ÈäòÈ≥¥Ë¢Ç‰æÆÂÜíÂãüÂßÜÂ∏ΩÊÖïÊë∏ÊëπÊöÆÊüêÊ®°ÊØçÊØõÁâüÁâ°ÁëÅÁú∏ÁüõËÄóËäºËåÖË¨ÄË¨®Ë≤åÊú®Ê≤êÁâßÁõÆÁù¶Á©ÜÈ∂©Ê≠øÊ≤íÂ§¢Êú¶ËíôÂçØÂ¢ìÂ¶ôÂªüÊèèÊò¥Êù≥Ê∏∫Áå´Á´óËãóÈå®ÂãôÂ∑´ÊÜÆÊáãÊàäÊãáÊí´Êó†Ê•ôÊ≠¶ÊØãÁÑ°Áè∑ÁïùÁπÜËàûËåÇËï™Ë™£Ë≤øÈúßÈµ°Â¢®ÈªòÂÄëÂàéÂêªÂïèÊñá"],["daa1","Ê±∂Á¥äÁ¥ãËÅûËöäÈñÄÈõØÂãøÊ≤ïÁâ©Âë≥Â™öÂ∞æÂµãÂΩåÂæÆÊú™Ê¢∂Ê•£Ê∏ºÊπÑÁúâÁ±≥ÁæéËñáË¨éËø∑Èù°Èª¥Â≤∑ÊÇ∂ÊÑçÊÜ´ÊïèÊóªÊóºÊ∞ëÊ≥ØÁéüÁèâÁ∑°ÈñîÂØÜËúúË¨êÂâùÂçöÊãçÊêèÊí≤Êú¥Ê®∏Ê≥äÁèÄÁíûÁÆîÁ≤ïÁ∏õËÜäËà∂ËñÑËø´ÈõπÈßÅ‰º¥ÂçäÂèçÂèõÊãåÊê¨ÊîÄÊñëÊßÉÊ≥ÆÊΩòÁè≠ÁïîÁò¢Áõ§ÁõºÁ£êÁ£ªÁ§¨ÁµÜËà¨Ëü†ËøîÈ†íÈ£ØÂãÉÊãîÊí•Ê∏§ÊΩë"],["dba1","ÁôºË∑ãÈÜ±Èâ¢È´ÆÈ≠ÉÂÄ£ÂÇçÂùäÂ¶®Â∞®ÂπáÂΩ∑ÊàøÊîæÊñπÊóÅÊòâÊûãÊ¶úÊªÇÁ£ÖÁ¥°ËÇ™ËÜÄËà´Ëä≥Ëí°ËöåË®™Ë¨óÈÇ¶Èò≤ÈæêÂÄç‰ø≥Ô•£ÂüπÂæòÊãúÊéíÊùØÊπÉÁÑôÁõÉËÉåËÉöË£¥Ë£µË§ôË≥†Ëº©ÈÖçÈô™‰ºØ‰Ω∞Â∏õÊüèÊ†¢ÁôΩÁôæÈ≠ÑÂπ°Ê®äÁÖ©ÁáîÁï™Ô•§ÁπÅËïÉËó©È£ú‰ºêÁ≠èÁΩ∞Èñ•Âá°Â∏ÜÊ¢µÊ∞æÊ±éÊ≥õÁäØÁØÑËåÉÊ≥ïÁê∫ÂÉªÂäàÂ£ÅÊìòÊ™óÁíßÁôñ"],["dca1","Á¢ßËòóÈó¢ÈúπÔ••ÂçûÂºÅËÆäËæ®ËæØÈÇäÂà•Áû•È±âÈºà‰∏ôÂÄÇÂÖµÂ±õÂπ∑ÊòûÊò∫ÊüÑÊ£ÖÁÇ≥ÁîÅÁóÖÁßâÁ´ùËºßÈ§†È®à‰øùÂ†°Â†±ÂØ∂ÊôÆÊ≠•Ê¥ëÊπ∫ÊΩΩÁè§Áî´Ëè©Ë£úË§ìË≠úËºî‰ºèÂÉïÂåêÂçúÂÆìÂæ©ÊúçÁ¶èËÖπËåØËîîË§áË¶ÜËºπËºªÈ¶•È∞íÊú¨‰π∂‰ø∏Â•âÂ∞ÅÂ≥ØÂ≥∞ÊçßÊ£íÁÉΩÁÜ¢Áê´Á∏´Ëì¨ËúÇÈÄ¢ÈãíÈ≥≥‰∏ç‰ªò‰øØÂÇÖÂâñÂâØÂê¶ÂíêÂü†Â§´Â©¶"],["dda1","Â≠öÂ≠µÂØåÂ∫úÔ•¶Êâ∂Êï∑ÊñßÊµÆÊ∫•Áà∂Á¨¶Á∞øÁº∂ËÖêËÖëËÜöËâÄËäôËé©Ë®ÉË≤†Ë≥¶Ë≥ªËµ¥Ë∂∫ÈÉ®ÈáúÈòúÈôÑÈßôÈ≥ßÂåóÂàÜÂê©Âô¥Â¢≥Â•îÂ•ÆÂøøÊÜ§ÊâÆÊòêÊ±æÁÑöÁõÜÁ≤âÁ≥ûÁ¥õËä¨Ë≥ÅÈõ∞Ô•ß‰ΩõÂºóÂΩøÊãÇÂ¥©ÊúãÊ£öÁ°ºÁπÉÈµ¨‰∏ïÂÇôÂåïÂå™ÂçëÂ¶ÉÂ©¢Â∫áÊÇ≤ÊÜäÊââÊâπÊñêÊûáÊ¶ßÊØîÊØñÊØóÊØòÊ≤∏Ô•®ÁêµÁó∫Á†íÁ¢ëÁßïÁßòÁ≤ÉÁ∑ãÁø°ËÇ•"],["dea1","ËÑæËáÇËè≤ËúöË£®Ë™πË≠¨Ë≤ªÈÑôÈùûÈ£õÈºªÂö¨Â¨™ÂΩ¨ÊñåÊ™≥ÊÆØÊµúÊø±ÁÄïÁâùÁé≠Ë≤ßË≥ìÈ†ªÊÜëÊ∞∑ËÅòÈ®Å‰πç‰∫ã‰∫õ‰ªï‰º∫‰ºº‰Ωø‰øüÂÉøÂè≤Âè∏ÂîÜÂó£ÂõõÂ£´Â•¢Â®ëÂØ´ÂØ∫Â∞ÑÂ∑≥Â∏´ÂæôÊÄùÊç®ÊñúÊñØÊü∂ÊüªÊ¢≠Ê≠ªÊ≤ôÊ≥óÊ∏£ÁÄâÁçÖÁ†ÇÁ§æÁ•ÄÁ•†ÁßÅÁØ©Á¥óÁµ≤ËÇÜËàçËééËìëËõáË£üË©êË©ûË¨ùË≥úËµ¶Ëæ≠ÈÇ™È£ºÈßüÈ∫ùÂâäÔ•©ÊúîÔ•™"],["dfa1","ÂÇòÂà™Â±±Êï£Ê±ïÁèäÁî£ÁñùÁÆóËíúÈÖ∏Èú∞‰π∑ÊííÊÆ∫ÁÖûËñ©‰∏âÔ•´ÊùâÊ£ÆÊ∏óËäüËîòË°´Êè∑ÊæÅÈàíÈ¢Ø‰∏äÂÇ∑ÂÉèÂÑüÂïÜÂñ™ÂòóÂ≠ÄÂ∞ôÂ≥†Â∏∏Â∫äÂ∫†ÂªÇÊÉ≥Ê°ëÊ©°ÊπòÁàΩÁâÄÁãÄÁõ∏Á••ÁÆ±ÁøîË£≥Ëß¥Ë©≥Ë±°Ë≥ûÈúúÂ°ûÁíΩË≥ΩÂóáÔ•¨Á©°Á¥¢Ëâ≤Áâ≤ÁîüÁî•Ô•≠Á¨ôÂ¢ÖÂ£ªÂ∂ºÂ∫èÂ∫∂ÂæêÊÅïÊäíÊçøÊïçÊöëÊõôÊõ∏Ê†ñÊ£≤ÁäÄÁëûÁ≠ÆÁµÆÁ∑ñÁΩ≤"],["e0a1","ËÉ•ËàíËñØË•øË™ìÈÄùÈã§ÈªçÈº†Â§ïÂ•≠Â∏≠ÊÉúÊòîÊô≥ÊûêÊ±êÊ∑ÖÊΩüÁü≥Á¢©ËìÜÈáãÈå´‰ªôÂÉäÂÖàÂñÑÂ¨ãÂÆ£ÊâáÊïæÊóãÊ∏≤ÁÖΩÁêÅÁëÑÁíáÁíøÁô¨Á¶™Á∑öÁπïÁæ®ËÖ∫ËÜ≥ËàπËòöËü¨Ë©µË∑£ÈÅ∏ÈäëÈê•È•çÈÆÆÂç®Â±ëÊ•îÊ≥ÑÊ¥©Ê∏´ËàåËñõË§ªË®≠Ë™™Èõ™ÈΩßÂâ°ÊöπÊÆ≤Á∫ñËüæË¥çÈñÉÈôùÊîùÊ∂âÁáÆÔ•ÆÂüéÂßìÂÆ¨ÊÄßÊÉ∫ÊàêÊòüÊôüÁå©ÁèπÁõõÁúÅÁ≠¨"],["e1a1","ËÅñËÅ≤ËÖ•Ë™†ÈÜí‰∏ñÂã¢Ê≠≤Ê¥óÁ®ÖÁ¨πÁ¥∞Ô•ØË≤∞Âè¨ÂòØÂ°ëÂÆµÂ∞èÂ∞ëÂ∑¢ÊâÄÊéÉÊêîÊò≠Ê¢≥Ê≤ºÊ∂àÊ∫ØÁÄüÁÇ§ÁáíÁî¶ÁñèÁñéÁòôÁ¨ëÁØ†Á∞´Á¥†Á¥πËî¨Ëï≠ËòáË®¥ÈÄçÈÅ°ÈÇµÈä∑Èü∂È®∑‰øóÂ±¨ÊùüÊ∂ëÁ≤üÁ∫åË¨ñË¥ñÈÄüÂ≠´Â∑ΩÊêçËìÄÈÅúÈ£°ÁéáÂÆãÊÇöÊùæÊ∑ûË®üË™¶ÈÄÅÈ†åÂà∑Ô•∞ÁÅëÁ¢éÈéñË°∞Èáó‰øÆÂèóÂóΩÂõöÂûÇÂ£ΩÂ´ÇÂÆàÂ≤´Â≥ÄÂ∏•ÊÑÅ"],["e2a1","ÊàçÊâãÊéàÊêúÊî∂Êï∏Ê®πÊÆäÊ∞¥Ê¥ôÊº±ÁáßÁã©Áç∏ÁêáÁí≤Áò¶Áù°ÁßÄÁ©óÁ´™Á≤πÁ∂èÁ∂¨Áπ°ÁæûËÑ©Ëå±ËíêËìöËó™Ë¢ñË™∞ËÆêËº∏ÈÅÇÈÇÉÈÖ¨ÈäñÈäπÈöãÈößÈö®ÈõñÈúÄÈ†àÈ¶ñÈ´ìÈ¨öÂèîÂ°æÂ§ôÂ≠∞ÂÆøÊ∑ëÊΩöÁÜüÁê°ÁíπËÇÖËèΩÂ∑°ÂæáÂæ™ÊÅÇÊó¨Ê†íÊ•ØÊ©ìÊÆâÊ¥µÊ∑≥Áè£ÁõæÁû¨Á≠çÁ¥îËÑ£ËàúËçÄËì¥Ëï£Ë©¢Ë´ÑÈÜáÈåûÈ†ÜÈ¶¥ÊàåË°ìËø∞Èâ•Â¥áÂ¥ß"],["e3a1","Âµ©ÁëüËÜùËù®ÊøïÊãæÁøíË§∂Ë•≤‰∏û‰πòÂÉßÂãùÂçáÊâøÊòáÁπ©Ë†ÖÈôû‰æçÂåôÂò∂ÂßãÂ™§Â∞∏Â±éÂ±çÂ∏ÇÂºëÊÅÉÊñΩÊòØÊôÇÊûæÊü¥ÁåúÁü¢Á§∫ÁøÖËíîËìçË¶ñË©¶Ë©©Ë´°Ë±ïË±∫Âü¥ÂØîÂºèÊÅØÊã≠Ê§çÊÆñÊπúÁÜÑÁØíËùïË≠òËªæÈ£üÈ£æ‰º∏‰æÅ‰ø°ÂëªÂ®†ÂÆ∏ÊÑºÊñ∞Êô®ÁáºÁî≥Á•ûÁ¥≥ËÖéËá£ËéòËñ™ËóéËúÉË®äË∫´ËæõÔ•±ËøÖÂ§±ÂÆ§ÂØ¶ÊÇâÂØ©Â∞ãÂøÉÊ≤Å"],["e4a1","Ô•≤Ê∑±ÁÄãÁîöËäØË´∂‰ªÄÂçÅÔ•≥ÈõôÊ∞è‰∫û‰øÑÂÖíÂïûÂ®•Â≥®ÊàëÁâôËäΩËé™ËõæË°ôË®ùÈòøÈõÖÈ§ìÈ¥âÈµùÂ†äÂ≤≥Â∂ΩÂπÑÊÉ°ÊÑïÊè°Ê®ÇÊ∏•ÈÑÇÈçîÈ°éÈ∞êÈΩ∑ÂÆâÂ≤∏ÊåâÊôèÊ°àÁúºÈõÅÈûçÈ°îÈÆüÊñ°Ë¨ÅËªãÈñºÂîµÂ≤©Â∑ñÂ∫µÊöóÁôåËè¥ÈóáÂ£ìÊäºÁãéÈ¥®‰ª∞Â§ÆÊÄèÊòªÊÆÉÁßßÈ¥¶ÂéìÂìÄÂüÉÂ¥ñÊÑõÊõñÊ∂ØÁ¢çËâæÈöòÈùÑÂéÑÊâºÊéñÊ∂≤Á∏äËÖãÈ°ç"],["e5a1","Ê´ªÁΩåÈ∂ØÈ∏ö‰πüÂÄªÂÜ∂Â§úÊÉπÊè∂Ê§∞Áà∫ËÄ∂Ô•¥ÈáéÂº±Ô•µÔ•∂Á¥ÑËã•ËëØËíªËó•Ë∫çÔ•∑‰ΩØÔ•∏Ô•πÂ£§Â≠ÉÊÅôÊèöÊîòÊï≠ÊöòÔ•∫Ê•äÊ®£Ê¥ãÁÄÅÁÖ¨ÁóíÁòçÁ¶≥Á©∞Ô•ªÁæäÔ•ºË•ÑÔ•ΩËÆìÈáÄÈôΩÔ•æÈ§äÂúÑÂæ°ÊñºÊºÅÁòÄÁ¶¶Ë™ûÈ¶≠È≠öÈΩ¨ÂÑÑÊÜ∂ÊäëÊ™çËáÜÂÅÉÂ†∞ÂΩ¶ÁÑâË®ÄË´∫Â≠ºËòñ‰ø∫ÂÑºÂö¥Â•ÑÊé©Ê∑πÂ∂™Ê•≠ÂÜÜ‰∫à‰ΩôÔ•øÔ¶ÄÔ¶ÅÂ¶ÇÔ¶Ç"],["e6a1","Ô¶ÉÊ≠üÊ±ùÔ¶ÑÁíµÁ§ñÔ¶ÖËàáËâÖËåπËºøËΩùÔ¶ÜÈ§òÔ¶áÔ¶àÔ¶â‰∫¶Ô¶äÂüüÂΩπÊòìÔ¶ãÔ¶åÁñ´ÁππË≠ØÔ¶çÈÄÜÈ©õÂö•Â†ßÂß∏Â®üÂÆ¥Ô¶éÂª∂Ô¶èÔ¶êÊçêÊåªÔ¶ëÊ§ΩÊ≤áÊ≤øÊ∂éÊ∂ìÊ∑µÊºîÔ¶íÁÉüÁÑ∂ÁÖôÔ¶ìÁáÉÁáïÔ¶îÁ°èÁ°ØÔ¶ïÁ≠µÁ∑£Ô¶ñÁ∏ØÔ¶óË°çËªüÔ¶òÔ¶ôÔ¶öÈâõÔ¶õÈ≥∂Ô¶úÔ¶ùÔ¶ûÊÇÖÊ∂ÖÔ¶üÁÜ±Ô¶†Ô¶°Èñ±Âé≠Ô¶¢Ô¶£Ô¶§ÊüìÔ¶•ÁÇéÁÑ∞Áê∞Ëâ∂Ëãí"],["e7a1","Ô¶¶ÈñªÈ´•ÈπΩÊõÑÔ¶ßÁáÅËëâÔ¶®Ô¶©Â°ãÔ¶™Ô¶´Â∂∏ÂΩ±Ô¶¨Êò†ÊöéÊ•πÊ¶ÆÊ∞∏Ê≥≥Ê∏∂ÊΩÅÊøöÁÄõÁÄØÁÖêÁáüÁç∞Ô¶≠ÁëõÔ¶ÆÁìîÁõàÁ©éÁ∫ìÔ¶ØÔ¶∞Ëã±Ë©†ËøéÔ¶±ÈçàÔ¶≤ÈúôÔ¶≥Ô¶¥‰πÇÂÄ™Ô¶µÂààÂè°Êõ≥Ê±≠ÊøäÁåäÁùøÁ©¢ËäÆËóùËòÇÔ¶∂Ë£îË©£Ë≠ΩË±´Ô¶∑Èä≥Ô¶∏ÈúìÈ†ê‰∫î‰ºç‰øâÂÇ≤ÂçàÂêæÂê≥ÂóöÂ°¢Â¢∫Â•ßÂ®õÂØ§ÊÇüÔ¶πÊáäÊïñÊóøÊô§Ê¢ßÊ±öÊæ≥"],["e8a1","ÁÉèÁÜ¨ÁçíÁ≠ΩËúàË™§È∞≤ÈºáÂ±ãÊ≤ÉÁçÑÁéâÈà∫Ê∫´Áë•ÁòüÁ©©Á∏ïËòäÂÖÄÂ£ÖÊìÅÁìÆÁîïÁô∞ÁøÅÈÇïÈõçÈ•îÊ∏¶Áì¶Á™©Á™™Ëá•ËõôËù∏Ë®õÂ©âÂÆåÂÆõÊ¢°Ê§ÄÊµ£Áé©ÁêìÁê¨Á¢óÁ∑©Áø´ËÑòËÖïËéûË±åÈòÆÈ†ëÊõ∞ÂæÄÊó∫ÊûâÊ±™ÁéãÂÄ≠Â®ÉÊ≠™ÁüÆÂ§ñÂµ¨Â∑çÁå•ÁïèÔ¶∫Ô¶ªÂÉ•ÂáπÂ†ØÂ§≠Â¶ñÂßöÂØ•Ô¶ºÔ¶ΩÂ∂¢ÊãóÊêñÊíìÊìæÔ¶æÊõúÔ¶øÊ©àÔßÄÁáøÁë§ÔßÅ"],["e9a1","Á™àÁ™ØÁπáÁπûËÄÄËÖ∞ÔßÇËüØË¶ÅË¨†ÈÅôÔßÉÈÇÄÈ•íÊÖæÊ¨≤Êµ¥Á∏üË§•Ëæ±‰øëÂÇ≠ÂÜóÂãáÂüáÂ¢âÂÆπÂ∫∏ÊÖÇÊ¶ïÊ∂åÊπßÊ∫∂ÁÜîÁë¢Áî®Áî¨ËÅ≥Ëå∏ËìâË∏äÈéîÈèûÔßÑ‰∫é‰ΩëÂÅ∂ÂÑ™ÂèàÂèãÂè≥ÂÆáÂØìÂ∞§ÊÑöÊÜÇÊó¥ÁâõÁéóÁëÄÁõÇÁ•êÁ¶ëÁ¶πÁ¥ÜÁæΩËäãËóïËôûËøÇÈÅáÈÉµÈá™ÈöÖÈõ®Èõ©ÂãñÂΩßÊó≠Êò±Ê†ØÁÖúÁ®∂ÈÉÅÈ†ä‰∫ëÔßÖÊ©íÊÆûÊæêÁÜâËÄòËä∏Ëïì"],["eaa1","ÈÅãÈöïÈõ≤ÈüªËîöÈ¨±‰∫êÁÜäÈõÑÂÖÉÂéüÂì°ÂúìÂúíÂû£Â™õÂ´ÑÂØÉÊÄ®ÊÑøÊè¥Ê≤ÖÊ¥πÊπ≤Ê∫êÁà∞ÁåøÁëóËãëË¢ÅËΩÖÈÅ†ÔßÜÈô¢È°òÈ¥õÊúàË∂äÈâû‰ΩçÂÅâÂÉûÂç±ÂúçÂßîÂ®ÅÂ∞âÊÖ∞ÊöêÊ∏≠Áà≤ÁëãÁ∑ØËÉÉËêéËë¶ËîøËùüË°õË§òË¨ÇÈÅïÈüãÈ≠è‰π≥‰æëÂÑíÂÖ™ÔßáÂîØÂñ©Â≠∫ÂÆ•ÂπºÂπΩÂ∫æÊÇ†ÊÉüÊÑàÊÑâÊèÑÊî∏ÊúâÔßàÊüîÊüöÔßâÊ•°Ê•¢Ê≤πÊ¥ßÔßäÊ∏∏Ôßã"],["eba1","Êø°Áå∂Áå∑ÔßåÁëúÁî±ÔßçÁôíÔßéÔßèÁ∂≠ËáæËê∏Ë£ïË™òË´õË´≠Ë∏∞ËπÇÈÅäÈÄæÈÅ∫ÈÖâÈáâÈçÆÔßêÔßëÂ†âÔßíÊØìËÇâËÇ≤ÔßìÔßîÂÖÅÂ•´Â∞πÔßïÔßñÊΩ§ÁéßËÉ§Ë¥áÔßóÈàóÈñèÔßòÔßôÔßöÔßõËÅøÊàéÁÄúÁµ®ËûçÔßúÂû†ÊÅ©ÊÖáÊÆ∑Ë™æÈäÄÈö±‰πôÂêüÊ∑´Ëî≠Èô∞Èü≥È£ÆÊèñÊ≥£ÈÇëÂáùÊáâËÜ∫È∑π‰æùÂÄöÂÑÄÂÆúÊÑèÊáøÊì¨Ê§ÖÊØÖÁñëÁü£Áæ©Ëâ§ËñèËüªË°£Ë™º"],["eca1","Ë≠∞ÈÜ´‰∫å‰ª•‰ºäÔßùÔßûÂ§∑Âß®ÔßüÂ∑≤ÂºõÂΩõÊÄ°Ôß†Ôß°Ôß¢Ôß£ÁàæÁè•Ôß§Áï∞ÁóçÔß•ÁßªÔß¶ËÄåËÄ≥ËÇÑËã°ËçëÔßßÔß®Ë≤ΩË≤≥ÈÇáÔß©Ôß™È£¥È§åÔß´Ôß¨ÁÄ∑ÁõäÁøäÁøåÁøºË¨ö‰∫∫‰ªÅÂàÉÂç∞Ôß≠ÂíΩÂõ†ÂßªÂØÖÂºïÂøçÊπÆÔßÆÔßØÁµ™ËåµÔß∞ËöìË™çÔß±Èù≠Èù∑Ôß≤Ôß≥‰∏Ä‰Ωö‰ΩæÂ£πÊó•Ê∫¢ÈÄ∏Èé∞È¶π‰ªªÂ£¨Â¶äÂßôÊÅÅÔß¥ÔßµÁ®îÔß∂ËçèË≥ÉÂÖ•ÂçÑ"],["eda1","Ôß∑Ôß∏Ôßπ‰ªçÂâ©Â≠ïËäø‰ªîÂà∫Âí®ÂßâÂßøÂ≠êÂ≠óÂ≠úÊÅ£ÊÖàÊªãÁÇôÁÖÆÁéÜÁì∑ÁñµÁ£ÅÁ¥´ËÄÖËá™Ëå®ËîóËóâË´ÆË≥áÈõå‰ΩúÂã∫ÂöºÊñ´Êò®ÁÅºÁÇ∏ÁàµÁ∂ΩËäçÈÖåÈõÄÈµ≤Â≠±Ê£ßÊÆòÊΩ∫ÁõûÂ≤ëÊö´ÊΩõÁÆ¥Á∞™Ë†∂Èõú‰∏à‰ªóÂå†Â†¥Â¢ªÂ£ØÂ•¨Â∞áÂ∏≥Â∫ÑÂºµÊéåÊö≤ÊùñÊ®üÊ™£Ê¨åÊºøÁâÜÔß∫ÁçêÁíãÁ´†Á≤ßËÖ∏ËáüËáßËéäËë¨Ëî£ËñîËóèË£ùË¥ìÈÜ¨Èï∑"],["eea1","ÈöúÂÜçÂìâÂú®ÂÆ∞ÊâçÊùêÊ†ΩÊ¢ìÊ∏ΩÊªìÁÅΩÁ∏°Ë£ÅË≤°ËºâÈΩãÈΩéÁà≠ÁÆèË´çÈåö‰Ωá‰ΩéÂÑ≤ÂíÄÂßêÂ∫ïÊäµÊùµÊ•ÆÊ®óÊ≤ÆÊ∏öÁãôÁå™ÁñΩÁÆ∏Á¥µËãßËèπËëóËó∑Ë©õË≤ØË∫áÈÄôÈÇ∏ÈõéÈΩüÂã£ÂêäÂ´°ÂØÇÊëòÊïµÊª¥ÁãÑÔßªÁöÑÁ©çÁ¨õÁ±çÁ∏æÁøüËçªË¨´Ë≥äËµ§Ë∑°ËπüËø™ËøπÈÅ©Èèë‰ΩÉ‰Ω∫ÂÇ≥ÂÖ®ÂÖ∏ÂâçÂâ™Â°°Â°ºÂ•†Â∞àÂ±ïÂªõÊÇõÊà∞Ê†ìÊÆøÊ∞àÊæ±"],["efa1","ÁÖéÁê†Áî∞Áî∏ÁïëÁô≤Á≠åÁÆãÁÆ≠ÁØÜÁ∫èË©ÆËºæËΩâÈàøÈäìÈå¢Èê´ÈõªÈ°öÈ°´È§ûÂàáÊà™ÊäòÊµôÁô§Á´äÁØÄÁµ∂Âç†Â≤æÂ∫óÊº∏ÁÇπÁ≤òÈúëÈÆéÈªûÊé•Êë∫Ëù∂‰∏Å‰∫ï‰∫≠ÂÅúÂÅµÂëàÂßÉÂÆöÂπÄÂ∫≠Âª∑ÂæÅÊÉÖÊå∫ÊîøÊï¥ÊóåÊô∂Êô∏ÊüæÊ•®Ê™âÊ≠£Ê±ÄÊ∑ÄÊ∑®Ê∏üÊπûÁÄûÁÇ°ÁééÁèΩÁî∫ÁùõÁ¢áÁ¶éÁ®ãÁ©ΩÁ≤æÁ∂éËâáË®ÇË´™Ë≤ûÈÑ≠ÈÖäÈáòÈâ¶ÈãåÈå†ÈúÜÈùñ"],["f0a1","ÈùúÈ†ÇÈºéÂà∂ÂäëÂïºÂ†§Â∏ùÂºüÊÇåÊèêÊ¢ØÊøüÁ•≠Á¨¨ËáçËñ∫Ë£ΩË´∏ËπÑÈÜçÈô§ÈöõÈúΩÈ°åÈΩä‰øéÂÖÜÂáãÂä©Âò≤ÂºîÂΩ´Êé™ÊìçÊó©ÊôÅÊõ∫ÊõπÊúùÊ¢ùÊ£óÊßΩÊºïÊΩÆÁÖßÁá•Áà™Áí™Áú∫Á•ñÁ•öÁßüÁ®†Á™ïÁ≤óÁ≥üÁµÑÁπ∞ËÇáËóªËö§Ë©îË™øË∂ôË∫ÅÈÄ†ÈÅ≠Èá£ÈòªÈõïÈ≥•ÊóèÁ∞áË∂≥ÈèÉÂ≠òÂ∞äÂçíÊãôÁåùÂÄßÂÆóÂæûÊÇ∞ÊÖ´Ê£ïÊ∑ôÁêÆÁ®ÆÁµÇÁ∂úÁ∏±ËÖ´"],["f1a1","Ë∏™Ë∏µÈçæÈêò‰ΩêÂùêÂ∑¶Â∫ßÊå´ÁΩ™‰∏ª‰Ωè‰æèÂÅöÂßùËÉÑÂë™Âë®ÂóæÂ•èÂÆôÂ∑ûÂªöÊôùÊú±Êü±Ê†™Ê≥®Ê¥≤ÊπäÊæçÁÇ∑Áè†ÁñáÁ±åÁ¥ÇÁ¥¨Á∂¢ËàüËõõË®ªË™ÖËµ∞Ë∫äËº≥ÈÄ±ÈÖéÈÖíÈëÑÈßêÁ´πÁ≤•‰øäÂÑÅÂáÜÂüàÂØØÂ≥ªÊôôÊ®ΩÊµöÊ∫ñÊø¨ÁÑåÁïØÁ´£Ë†¢ÈÄ°ÈÅµÈõãÈßøËåÅ‰∏≠‰ª≤Ë°ÜÈáçÂçΩÊ´õÊ•´Ê±ÅËë∫Â¢ûÊÜéÊõæÊãØÁÉùÁîëÁóáÁπíËí∏Ë≠âË¥à‰πãÂè™"],["f2a1","Âí´Âú∞ÂùÄÂøóÊåÅÊåáÊëØÊîØÊó®Êô∫ÊûùÊû≥Ê≠¢Ê±†Ê≤öÊº¨Áü•Á†•Á•âÁ•óÁ¥ôËÇ¢ËÑÇËá≥ËäùËä∑ËúòË™åÔßºË¥ÑË∂æÈÅ≤Áõ¥Á®ôÁ®∑ÁπîËÅ∑ÂîáÂóîÂ°µÊåØÊê¢ÊôâÊôãÊ°≠Ê¶õÊÆÑÊ¥•Ê∫±ÁèçÁë®Áí°ÁïõÁñπÁõ°ÁúûÁûãÁß¶Á∏âÁ∏ùËáªËîØË¢óË®∫Ë≥ëËª´Ëæ∞ÈÄ≤Èé≠Èô£Èô≥Èúá‰æÑÂè±Âß™Â´âÂ∏ôÊ°éÁìÜÁñæÁß©Á™íËÜ£Ëõ≠Ë≥™Ë∑åËø≠ÊñüÊúïÔßΩÂü∑ÊΩóÁ∑ùËºØ"],["f3a1","Èè∂ÈõÜÂæµÊá≤ÊæÑ‰∏î‰æòÂÄüÂèâÂóüÂµØÂ∑ÆÊ¨°Ê≠§Á£ãÁÆöÔßæËπâËªäÈÅÆÊçâÊêæÁùÄÁ™ÑÈåØÈëøÈΩ™Êí∞ÊæØÁá¶Áí®ÁìöÁ´ÑÁ∞íÁ∫ÇÁ≤≤Á∫òËÆöË¥äÈëΩÈ§êÈ•åÂàπÂØüÊì¶Êú≠Á¥ÆÂÉ≠ÂèÉÂ°πÊÖòÊÖôÊá∫Êñ¨Á´ôËÆíËÆñÂÄâÂÄ°ÂâµÂî±Â®ºÂª†ÂΩ∞ÊÑ¥ÊïûÊòåÊò∂Êö¢ÊßçÊªÑÊº≤ÁåñÁò°Á™ìËÑπËâôËèñËíºÂÇµÂü∞ÂØÄÂØ®ÂΩ©Êé°Á†¶Á∂µËèúËî°ÈááÈáµÂÜäÊüµÁ≠ñ"],["f4a1","Ë≤¨ÂáÑÂ¶ªÊÇΩËôïÂÄúÔßøÂâîÂ∞∫ÊÖΩÊàöÊãìÊì≤Êñ•ÊªåÁò†ËÑäËπ†ÈôüÈöª‰ªüÂçÉÂñòÂ§©Â∑ùÊìÖÊ≥âÊ∑∫ÁéîÁ©øËàõËñ¶Ë≥§Ë∏êÈÅ∑ÈáßÈó°Èò°ÈüÜÂá∏Âì≤ÂñÜÂæπÊí§ÊæàÁ∂¥ËºüËΩçÈêµÂÉâÂ∞ñÊ≤æÊ∑ªÁîõÁûªÁ∞ΩÁ±§Ë©πË´ÇÂ†ûÂ¶æÂ∏ñÊç∑ÁâíÁñäÁù´Ë´úË≤ºËºíÂª≥Êô¥Ê∑∏ËÅΩËèÅË´ãÈùëÈØñÔ®ÄÂâÉÊõøÊ∂ïÊªØÁ∑†Ë´¶ÈÄÆÈÅûÈ´îÂàùÂâøÂì®ÊÜîÊäÑÊãõÊ¢¢"],["f5a1","Ê§íÊ•öÊ®µÁÇíÁÑ¶Á°ùÁ§ÅÁ§éÁßíÁ®çËÇñËâ∏ËãïËçâËïâË≤ÇË∂ÖÈÖ¢ÈÜãÈÜÆ‰øÉÂõëÁá≠ÁüóËúÄËß∏ÂØ∏ÂøñÊùëÈÇ®Âè¢Â°öÂØµÊÇ§ÊÜÅÊë†Á∏ΩËÅ∞Ëî•ÈäÉÊíÆÂÇ¨Â¥îÊúÄÂ¢úÊäΩÊé®Ê§éÊ•∏Ê®ûÊπ´Áö∫ÁßãËäªËê©Ë´èË∂®ËøΩÈÑíÈÖãÈÜúÈåêÈåòÈéöÈõõÈ®∂È∞ç‰∏ëÁïúÁ•ùÁ´∫Á≠ëÁØâÁ∏ÆËìÑËπôËπ¥Ëª∏ÈÄêÊò•Ê§øÁëÉÂá∫ÊúÆÈªúÂÖÖÂø†Ê≤ñËü≤Ë°ùË°∑ÊÇ¥ËÜµËêÉ"],["f6a1","Ë¥ÖÂèñÂêπÂò¥Â®∂Â∞±ÁÇäÁø†ËÅöËÑÜËá≠Ë∂£ÈÜâÈ©üÈ∑≤ÂÅ¥‰ªÑÂé†ÊÉªÊ∏¨Â±§‰æàÂÄ§Âó§Â≥ôÂπüÊÅ•Ê¢îÊ≤ªÊ∑ÑÁÜæÁóîÁó¥Áô°Á®öÁ©âÁ∑áÁ∑ªÁΩÆËá¥Ëö©ËºúÈõâÈ¶≥ÈΩíÂâáÂãÖÈ£≠Ë¶™‰∏ÉÊüíÊºÜ‰æµÂØ¢ÊûïÊ≤àÊµ∏ÁêõÁ†ßÈáùÈçºËüÑÁß§Á®±Âø´‰ªñÂí§ÂîæÂ¢ÆÂ¶•ÊÉ∞ÊâìÊãñÊú∂Ê•ïËàµÈôÄÈ¶±ÈßùÂÄ¨ÂçìÂïÑÂùºÔ®ÅÊâòÔ®ÇÊì¢Êô´ÊüùÊøÅÊøØÁê¢Áê∏Ë®ó"],["f7a1","Èê∏ÂëëÂòÜÂù¶ÂΩàÊÜöÊ≠éÁÅòÁÇ≠Á∂ªË™ïÂ•™ËÑ´Êé¢ÁúàËÄΩË≤™Â°îÊê≠Ê¶ªÂÆïÂ∏ëÊπØÔ®ÉËï©ÂÖåÂè∞Â§™ÊÄ†ÊÖãÊÆÜÊ±∞Ê≥∞Á¨ûËÉéËãîË∑ÜÈÇ∞È¢±Ô®ÑÊìáÊæ§ÊíëÊîÑÂÖéÂêêÂúüË®éÊÖüÊ°∂Ô®ÖÁóõÁ≠íÁµ±ÈÄöÂ†ÜÊßåËÖøË§™ÈÄÄÈ†πÂÅ∏Â•óÂ¶¨ÊäïÈÄèÈ¨™ÊÖùÁâπÈóñÂù°Â©ÜÂ∑¥ÊääÊí≠Êì∫Êù∑Ê≥¢Ê¥æÁà¨Áê∂Á†¥ÁΩ∑Ëä≠Ë∑õÈ†óÂà§ÂùÇÊùøÁâàÁì£Ë≤©Ëæ¶Èàë"],["f8a1","Èò™ÂÖ´Âè≠Êçå‰Ω©ÂîÑÊÇñÊïóÊ≤õÊµøÁâåÁãΩÁ®óË¶áË≤ùÂΩ≠ÊæéÁÉπËÜ®ÊÑé‰æøÂÅèÊâÅÁâáÁØáÁ∑®Áø©ÈÅçÈû≠È®ôË≤∂Âù™Âπ≥Êû∞ËêçË©ïÂê†Â¨ñÂπ£Âª¢ÂºäÊñÉËÇ∫ËîΩÈñâÈôõ‰ΩàÂåÖÂåçÂåèÂíÜÂì∫ÂúÉÂ∏ÉÊÄñÊäõÊä±ÊçïÔ®ÜÊ≥°Êµ¶Áñ±Á†≤ËÉûËÑØËãûËë°Ëí≤Ë¢çË§íÈÄãÈã™È£ΩÈÆëÂπÖÊö¥ÊõùÁÄëÁàÜÔ®á‰øµÂâΩÂΩ™ÊÖìÊùìÊ®ôÊºÇÁì¢Á•®Ë°®Ë±πÈ£áÈ£ÑÈ©É"],["f9a1","ÂìÅÁ®üÊ•ìË´∑Ë±äÈ¢®È¶ÆÂΩºÊä´Áñ≤ÁöÆË¢´ÈÅøÈôÇÂåπÂººÂøÖÊ≥åÁèåÁï¢ÁñãÁ≠ÜËãæÈ¶ù‰πèÈÄº‰∏ã‰ΩïÂé¶Â§èÂªàÊò∞Ê≤≥ÁëïËç∑Ëù¶Ë≥ÄÈÅêÈúûÈ∞ïÂ£ëÂ≠∏ËôêË¨îÈ∂¥ÂØíÊÅ®ÊÇçÊó±Ê±óÊº¢Êæ£ÁÄöÁΩïÁø∞ÈñëÈñíÈôêÈüìÂâ≤ËΩÑÂáΩÂê´Âí∏Âï£ÂñäÊ™ªÊ∂µÁ∑òËâ¶ÈäúÈô∑ÈππÂêàÂìàÁõíËõ§Èñ§ÈóîÈôú‰∫¢‰ºâÂßÆÂ´¶Â∑∑ÊÅíÊäóÊù≠Ê°ÅÊ≤ÜÊ∏ØÁº∏ËÇõËà™"],["faa1","Ô®àÔ®âÈ†Ö‰∫•ÂÅïÂí≥ÂûìÂ•öÂ≠©ÂÆ≥ÊáàÊ•∑Êµ∑ÁÄ£ËüπËß£Ë©≤Ë´ßÈÇÇÈß≠È™∏ÂäæÊ†∏ÂÄñÂπ∏ÊùèËçáË°å‰∫´ÂêëÂöÆÁè¶ÈÑïÈüøÈ§âÈ•óÈ¶ôÂôìÂ¢üËôõË®±ÊÜ≤Ê´∂ÁçªËªíÊ≠áÈö™È©óÂ•ïÁàÄËµ´Èù©‰øîÂ≥¥Âº¶Êá∏ÊôõÊ≥´ÁÇ´ÁéÑÁéπÁèæÁú©ÁùçÁµÉÁµ¢Á∏£Ëà∑Ë°íÔ®äË≥¢ÈââÈ°ØÂ≠ëÁ©¥Ë°ÄÈ†ÅÂ´å‰ø†ÂçîÂ§æÂ≥ΩÊåæÊµπÁãπËÑÖËÑáËé¢ÈãèÈ†∞‰∫®ÂÖÑÂàëÂûã"],["fba1","ÂΩ¢Ê≥ÇÊªéÁÄÖÁÅêÁÇØÁÜíÁè©Áë©ËçäËû¢Ë°°ÈÄàÈÇ¢Èé£È¶®ÂÖÆÂΩóÊÉ†ÊÖßÊö≥ËïôËπäÈÜØÈûã‰πé‰∫íÂëºÂ£ïÂ£∫Â•ΩÂ≤µÂºßÊà∂ÊâàÊòäÊôßÊØ´Êµ©Ê∑èÊπñÊª∏ÊæîÊø†Êø©ÁÅùÁãêÁê•ÁëöÁì†ÁöìÁ•úÁ≥äÁ∏ûËÉ°Ëä¶Ëë´ËíøËôéËôüËù¥Ë≠∑Ë±™Èé¨È†ÄÈ°•ÊÉëÊàñÈÖ∑Â©öÊòèÊ∑∑Ê∏æÁêøÈ≠ÇÂøΩÊÉöÁ¨èÂìÑÂºòÊ±ûÊ≥ìÊ¥™ÁÉòÁ¥ÖËôπË®åÈ¥ªÂåñÂíåÂ¨ÖÊ®∫ÁÅ´Áïµ"],["fca1","Á¶çÁ¶æËä±ËèØË©±Ë≠ÅË≤®Èù¥Ô®ãÊì¥Êî´Á¢∫Á¢ªÁ©´‰∏∏ÂñöÂ•êÂÆ¶ÂπªÊÇ£ÊèõÊ≠°Êô•Ê°ìÊ∏ôÁÖ•Áí∞Á¥àÈÇÑÈ©©È∞•Ê¥ªÊªëÁåæË±ÅÈóäÂá∞ÂπåÂæ®ÊÅçÊÉ∂ÊÑ∞ÊÖåÊôÉÊôÑÊ¶•Ê≥ÅÊπüÊªâÊΩ¢ÁÖåÁíúÁöáÁØÅÁ∞ßËçíËùóÈÅëÈöçÈªÉÂåØÂõûÂªªÂæäÊÅ¢ÊÇîÊá∑Êô¶ÊúÉÊ™úÊ∑ÆÊæÆÁÅ∞Áç™Áπ™ËÜæËå¥ËõîË™®Ë≥ÑÂäÉÁç≤ÂÆñÊ©´ÈêÑÂìÆÂöÜÂ≠ùÊïàÊñÖÊõâÊ¢üÊ∂çÊ∑Ü"],["fda1","ÁàªËÇ¥ÈÖµÈ©ç‰æØÂÄôÂéöÂêéÂêºÂñâÂóÖÂ∏øÂæåÊúΩÁÖ¶ÁèùÈÄÖÂãõÂã≥Â°§Â£éÁÑÑÁÜèÁáªËñ∞Ë®ìÊöàËñ®ÂñßÊöÑÁÖäËê±ÂçâÂñôÊØÅÂΩôÂæΩÊèÆÊöâÁÖáË´±ËºùÈ∫æ‰ºëÊê∫ÁÉãÁï¶ËôßÊÅ§Ë≠éÈ∑∏ÂÖáÂá∂ÂåàÊ¥∂ËÉ∏ÈªëÊòïÊ¨£ÁÇòÁóïÂêÉÂ±πÁ¥áË®ñÊ¨†Ê¨ΩÊ≠ÜÂê∏ÊÅ∞Ê¥ΩÁøïËààÂÉñÂáûÂñúÂô´ÂõçÂß¨Â¨âÂ∏åÊÜôÊÜòÊà±ÊôûÊõ¶ÁÜôÁÜπÁÜ∫ÁäßÁ¶ßÁ®ÄÁæ≤Ë©∞"]]');

/***/ }),
/* 101 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["a140","„ÄÄÔºå„ÄÅ„ÄÇÔºé‚ÄßÔºõÔºöÔºüÔºÅÔ∏∞‚Ä¶‚Ä•ÔπêÔπëÔπí¬∑ÔπîÔπïÔπñÔπóÔΩú‚ÄìÔ∏±‚ÄîÔ∏≥‚ï¥Ô∏¥ÔπèÔºàÔºâÔ∏µÔ∏∂ÔΩõÔΩùÔ∏∑Ô∏∏„Äî„ÄïÔ∏πÔ∏∫„Äê„ÄëÔ∏ªÔ∏º„Ää„ÄãÔ∏ΩÔ∏æ„Äà„ÄâÔ∏øÔπÄ„Äå„ÄçÔπÅÔπÇ„Äé„ÄèÔπÉÔπÑÔπôÔπö"],["a1a1","ÔπõÔπúÔπùÔπû‚Äò‚Äô‚Äú‚Äù„Äù„Äû‚Äµ‚Ä≤ÔºÉÔºÜÔºä‚Äª¬ß„ÄÉ‚óã‚óè‚ñ≥‚ñ≤‚óé‚òÜ‚òÖ‚óá‚óÜ‚ñ°‚ñ†‚ñΩ‚ñº„ä£‚ÑÖ¬ØÔø£ÔºøÀçÔπâÔπäÔπçÔπéÔπãÔπåÔπüÔπ†Ôπ°ÔºãÔºç√ó√∑¬±‚àöÔºúÔºûÔºù‚â¶‚âß‚â†‚àû‚âí‚â°Ôπ¢",4,"ÔΩû‚à©‚à™‚ä•‚à†‚àü‚äø„èí„èë‚à´‚àÆ‚àµ‚à¥‚ôÄ‚ôÇ‚äï‚äô‚Üë‚Üì‚Üê‚Üí‚Üñ‚Üó‚Üô‚Üò‚à•‚à£Ôºè"],["a240","Ôºº‚àïÔπ®ÔºÑÔø•„ÄíÔø†Ôø°ÔºÖÔº†‚ÑÉ‚ÑâÔπ©Ôπ™Ôπ´„èï„éú„éù„éû„èé„é°„éé„éè„èÑ¬∞ÂÖôÂÖõÂÖûÂÖùÂÖ°ÂÖ£ÂóßÁì©Á≥é‚ñÅ",7,"‚ñè‚ñé‚ñç‚ñå‚ñã‚ñä‚ñâ‚îº‚î¥‚î¨‚î§‚îú‚ñî‚îÄ‚îÇ‚ñï‚îå‚îê‚îî‚îò‚ï≠"],["a2a1","‚ïÆ‚ï∞‚ïØ‚ïê‚ïû‚ï™‚ï°‚ó¢‚ó£‚ó•‚ó§‚ï±‚ï≤‚ï≥Ôºê",9,"‚Ö†",9,"„Ä°",8,"ÂçÅÂçÑÂçÖÔº°",25,"ÔΩÅ",21],["a340","ÔΩóÔΩòÔΩôÔΩöŒë",16,"Œ£",6,"Œ±",16,"œÉ",6,"„ÑÖ",10],["a3a1","„Ñê",25,"ÀôÀâÀäÀáÀã"],["a3e1","‚Ç¨"],["a440","‰∏Ä‰πô‰∏Å‰∏É‰πÉ‰πù‰∫Ü‰∫å‰∫∫ÂÑøÂÖ•ÂÖ´Âá†ÂàÄÂàÅÂäõÂåïÂçÅÂçúÂèà‰∏â‰∏ã‰∏à‰∏ä‰∏´‰∏∏Âá°‰πÖ‰πà‰πü‰πû‰∫é‰∫°ÂÖÄÂàÉÂã∫ÂçÉÂèâÂè£ÂúüÂ£´Â§ïÂ§ßÂ•≥Â≠êÂ≠ëÂ≠ìÂØ∏Â∞èÂ∞¢Â∞∏Â±±Â∑ùÂ∑•Â∑±Â∑≤Â∑≥Â∑æÂπ≤ÂªæÂºãÂºìÊâç"],["a4a1","‰∏ë‰∏ê‰∏ç‰∏≠‰∏∞‰∏π‰πãÂ∞π‰∫à‰∫ë‰∫ï‰∫í‰∫î‰∫¢‰ªÅ‰ªÄ‰ªÉ‰ªÜ‰ªá‰ªç‰ªä‰ªã‰ªÑÂÖÉÂÖÅÂÖßÂÖ≠ÂÖÆÂÖ¨ÂÜóÂá∂ÂàÜÂàáÂààÂãªÂãæÂãøÂåñÂåπÂçàÂçáÂçÖÂçûÂéÑÂèãÂèäÂèçÂ£¨Â§©Â§´Â§™Â§≠Â≠îÂ∞ëÂ∞§Â∞∫Â±ØÂ∑¥ÂπªÂªøÂºîÂºïÂøÉÊààÊà∂ÊâãÊâéÊîØÊñáÊñóÊñ§ÊñπÊó•Êõ∞ÊúàÊú®Ê¨†Ê≠¢Ê≠πÊØãÊØîÊØõÊ∞èÊ∞¥ÁÅ´Áà™Áà∂ÁàªÁâáÁâôÁâõÁä¨Áéã‰∏ô"],["a540","‰∏ñ‰∏ï‰∏î‰∏ò‰∏ª‰πç‰πè‰πé‰ª•‰ªò‰ªî‰ªï‰ªñ‰ªó‰ª£‰ª§‰ªô‰ªûÂÖÖÂÖÑÂÜâÂÜäÂÜ¨ÂáπÂá∫Âá∏ÂàäÂä†ÂäüÂåÖÂåÜÂåóÂåù‰ªüÂçäÂçâÂç°Âç†ÂçØÂçÆÂéªÂèØÂè§Âè≥Âè¨ÂèÆÂè©Âè®ÂèºÂè∏ÂèµÂè´Âè¶Âè™Âè≤Âè±Âè∞Âè•Âè≠ÂèªÂõõÂõöÂ§ñ"],["a5a1","Â§ÆÂ§±Â•¥Â•∂Â≠ïÂÆÉÂ∞ºÂ∑®Â∑ßÂ∑¶Â∏ÇÂ∏ÉÂπ≥ÂπºÂºÅÂºòÂºóÂøÖÊàäÊâìÊâîÊâíÊâëÊñ•Êó¶ÊúÆÊú¨Êú™Êú´Êú≠Ê≠£ÊØçÊ∞ëÊ∞êÊ∞∏Ê±ÅÊ±ÄÊ∞æÁäØÁéÑÁéâÁìúÁì¶ÁîòÁîüÁî®Áî©Áî∞Áî±Áî≤Áî≥ÁñãÁôΩÁöÆÁöøÁõÆÁüõÁü¢Áü≥Á§∫Á¶æÁ©¥Á´ã‰∏û‰∏ü‰πí‰πì‰π©‰∫ô‰∫§‰∫¶‰∫•‰ªø‰ºâ‰ºô‰ºä‰ºï‰ºç‰ºê‰ºë‰ºè‰ª≤‰ª∂‰ªª‰ª∞‰ª≥‰ªΩ‰ºÅ‰ºãÂÖâÂÖáÂÖÜÂÖàÂÖ®"],["a640","ÂÖ±ÂÜçÂÜ∞ÂàóÂàëÂàíÂàéÂàñÂä£ÂåàÂå°Âå†Âç∞Âç±ÂêâÂêèÂêåÂêäÂêêÂêÅÂêãÂêÑÂêëÂêçÂêàÂêÉÂêéÂêÜÂêíÂõ†ÂõûÂõùÂú≥Âú∞Âú®Âú≠Âú¨ÂúØÂú©Â§ôÂ§öÂ§∑Â§∏Â¶ÑÂ•∏Â¶ÉÂ•ΩÂ•πÂ¶ÇÂ¶ÅÂ≠óÂ≠òÂÆáÂÆàÂÆÖÂÆâÂØ∫Â∞ñÂ±πÂ∑ûÂ∏ÜÂπ∂Âπ¥"],["a6a1","ÂºèÂºõÂøôÂøñÊàéÊàåÊàçÊàêÊâ£ÊâõÊâòÊî∂Êó©Êó®Êó¨Êó≠Êõ≤Êõ≥ÊúâÊúΩÊú¥Êú±ÊúµÊ¨°Ê≠§Ê≠ªÊ∞ñÊ±ùÊ±óÊ±ôÊ±üÊ±†Ê±êÊ±ïÊ±°Ê±õÊ±çÊ±éÁÅ∞ÁâüÁâùÁôæÁ´πÁ±≥Á≥∏Áº∂ÁæäÁæΩËÄÅËÄÉËÄåËÄíËÄ≥ËÅøËÇâËÇãËÇåËá£Ëá™Ëá≥ËáºËàåËàõËàüËâÆËâ≤ËâæËô´Ë°ÄË°åË°£Ë•øÈò°‰∏≤‰∫®‰Ωç‰Ωè‰Ωá‰Ωó‰Ωû‰º¥‰Ωõ‰Ωï‰º∞‰Ωê‰Ωë‰ºΩ‰º∫‰º∏‰ΩÉ‰Ωî‰ºº‰ΩÜ‰Ω£"],["a740","‰Ωú‰Ω†‰ºØ‰Ωé‰º∂‰Ωô‰Ωù‰Ωà‰ΩöÂÖåÂÖãÂÖçÂÖµÂÜ∂ÂÜ∑Âà•Âà§Âà©Âà™Âà®Âä´Âä©Âä™Âä¨Âå£Âç≥ÂçµÂêùÂê≠ÂêûÂêæÂê¶ÂëéÂêßÂëÜÂëÉÂê≥ÂëàÂëÇÂêõÂê©ÂëäÂêπÂêªÂê∏ÂêÆÂêµÂê∂Âê†ÂêºÂëÄÂê±Âê´ÂêüÂê¨Âõ™Âõ∞Âõ§Âõ´ÂùäÂùëÂùÄÂùç"],["a7a1","ÂùáÂùéÂúæÂùêÂùèÂúªÂ£ØÂ§æÂ¶ùÂ¶íÂ¶®Â¶ûÂ¶£Â¶ôÂ¶ñÂ¶çÂ¶§Â¶ìÂ¶äÂ¶•Â≠ùÂ≠úÂ≠öÂ≠õÂÆåÂÆãÂÆèÂ∞¨Â±ÄÂ±ÅÂ∞øÂ∞æÂ≤êÂ≤ëÂ≤îÂ≤åÂ∑´Â∏åÂ∫èÂ∫áÂ∫äÂª∑ÂºÑÂºüÂΩ§ÂΩ¢ÂΩ∑ÂΩπÂøòÂøåÂøóÂøçÂø±Âø´Âø∏Âø™ÊàíÊàëÊäÑÊäóÊäñÊäÄÊâ∂ÊäâÊâ≠ÊääÊâºÊâæÊâπÊâ≥ÊäíÊâØÊäòÊâÆÊäïÊäìÊäëÊäÜÊîπÊîªÊî∏Êó±Êõ¥ÊùüÊùéÊùèÊùêÊùëÊùúÊùñÊùûÊùâÊùÜÊù†"],["a840","ÊùìÊùóÊ≠•ÊØèÊ±ÇÊ±ûÊ≤ôÊ≤ÅÊ≤àÊ≤âÊ≤ÖÊ≤õÊ±™Ê±∫Ê≤êÊ±∞Ê≤åÊ±®Ê≤ñÊ≤íÊ±ΩÊ≤ÉÊ±≤Ê±æÊ±¥Ê≤ÜÊ±∂Ê≤çÊ≤îÊ≤òÊ≤ÇÁÅ∂ÁÅºÁÅΩÁÅ∏Áâ¢Áâ°Áâ†ÁãÑÁãÇÁéñÁî¨Áî´Áî∑Áî∏ÁöÇÁõØÁü£ÁßÅÁßÄÁ¶øÁ©∂Á≥ªÁΩïËÇñËÇìËÇùËÇòËÇõËÇöËÇ≤ËâØËäí"],["a8a1","ËäãËäçË¶ãËßíË®ÄË∞∑Ë±ÜË±ïË≤ùËµ§Ëµ∞Ë∂≥Ë∫´ËªäËæõËæ∞ËøÇËøÜËøÖËøÑÂ∑°ÈÇëÈÇ¢ÈÇ™ÈÇ¶ÈÇ£ÈÖâÈáÜÈáåÈò≤ÈòÆÈò±Èò™Èò¨‰∏¶‰πñ‰π≥‰∫ã‰∫õ‰∫û‰∫´‰∫¨‰ΩØ‰æù‰æç‰Ω≥‰Ωø‰Ω¨‰æõ‰æã‰æÜ‰æÉ‰Ω∞‰Ωµ‰æà‰Ω©‰Ωª‰æñ‰Ωæ‰æè‰æë‰Ω∫ÂÖîÂÖíÂÖïÂÖ©ÂÖ∑ÂÖ∂ÂÖ∏ÂÜΩÂáΩÂàªÂà∏Âà∑Âà∫Âà∞ÂàÆÂà∂ÂâÅÂäæÂäªÂçíÂçîÂçìÂçëÂç¶Âç∑Âç∏ÂçπÂèñÂèîÂèóÂë≥Âëµ"],["a940","ÂíñÂë∏ÂíïÂíÄÂëªÂë∑ÂíÑÂííÂíÜÂëºÂíêÂë±Âë∂ÂíåÂíöÂë¢Âë®ÂíãÂëΩÂíéÂõ∫ÂûÉÂù∑Âù™Âù©Âù°Âù¶Âù§ÂùºÂ§úÂ•âÂ•áÂ•àÂ•ÑÂ•îÂ¶æÂ¶ªÂßîÂ¶πÂ¶ÆÂßëÂßÜÂßêÂßçÂßãÂßìÂßäÂ¶ØÂ¶≥ÂßíÂßÖÂ≠üÂ≠§Â≠£ÂÆóÂÆöÂÆòÂÆúÂÆôÂÆõÂ∞öÂ±àÂ±Ö"],["a9a1","Â±ÜÂ≤∑Â≤°Â≤∏Â≤©Â≤´Â≤±Â≤≥Â∏òÂ∏öÂ∏ñÂ∏ïÂ∏õÂ∏ëÂπ∏Â∫öÂ∫óÂ∫úÂ∫ïÂ∫ñÂª∂Âº¶ÂºßÂº©ÂæÄÂæÅÂΩøÂΩºÂøùÂø†ÂøΩÂøµÂøøÊÄèÊÄîÊÄØÊÄµÊÄñÊÄ™ÊÄïÊÄ°ÊÄßÊÄ©ÊÄ´ÊÄõÊàñÊàïÊàøÊàæÊâÄÊâøÊãâÊãåÊãÑÊäøÊãÇÊäπÊãíÊãõÊä´ÊãìÊãîÊããÊãàÊä®ÊäΩÊäºÊãêÊãôÊãáÊãçÊäµÊãöÊä±ÊãòÊãñÊãóÊãÜÊä¨ÊãéÊîæÊñßÊñºÊó∫ÊòîÊòìÊòåÊòÜÊòÇÊòéÊòÄÊòèÊòïÊòä"],["aa40","ÊòáÊúçÊúãÊù≠ÊûãÊûïÊù±ÊûúÊù≥Êù∑ÊûáÊûùÊûóÊùØÊù∞ÊùøÊûâÊùæÊûêÊùµÊûöÊûìÊùºÊù™Êù≤Ê¨£Ê≠¶Ê≠ßÊ≠øÊ∞ìÊ∞õÊ≥£Ê≥®Ê≥≥Ê≤±Ê≥åÊ≥•Ê≤≥Ê≤ΩÊ≤æÊ≤ºÊ≥¢Ê≤´Ê≥ïÊ≥ìÊ≤∏Ê≥ÑÊ≤πÊ≥ÅÊ≤ÆÊ≥óÊ≥ÖÊ≥±Ê≤øÊ≤ªÊ≥°Ê≥õÊ≥äÊ≤¨Ê≥ØÊ≥úÊ≥ñÊ≥†"],["aaa1","ÁÇïÁÇéÁÇíÁÇäÁÇôÁà¨Áà≠Áà∏ÁâàÁâßÁâ©ÁãÄÁãéÁãôÁãóÁãêÁé©Áé®ÁéüÁé´Áé•ÁîΩÁñùÁñôÁñöÁöÑÁõÇÁõ≤Áõ¥Áü•ÁüΩÁ§æÁ•ÄÁ•ÅÁßâÁßàÁ©∫Á©πÁ´∫Á≥æÁΩîÁæåÁæãËÄÖËÇ∫ËÇ•ËÇ¢ËÇ±ËÇ°ËÇ´ËÇ©ËÇ¥ËÇ™ËÇØËá•ËáæËàçËä≥ËäùËäôËä≠ËäΩËäüËäπËä±Ëä¨Ëä•ËäØËä∏Ëä£Ëä∞ËäæËä∑ËôéËô±ÂàùË°®ËªãËøéËøîËøëÈÇµÈÇ∏ÈÇ±ÈÇ∂ÈááÈáëÈï∑ÈñÄÈòúÈôÄÈòøÈòªÈôÑ"],["ab40","ÈôÇÈöπÈõ®ÈùíÈùû‰∫ü‰∫≠‰∫Æ‰ø°‰æµ‰æØ‰æø‰ø†‰øë‰øè‰øù‰øÉ‰æ∂‰øò‰øü‰øä‰øó‰æÆ‰øê‰øÑ‰øÇ‰øö‰øé‰øû‰æ∑ÂÖóÂÜíÂÜëÂÜ†ÂâéÂâÉÂâäÂâçÂâåÂâãÂâáÂãáÂãâÂãÉÂãÅÂåçÂçóÂçªÂéöÂèõÂí¨ÂìÄÂí®ÂìéÂìâÂí∏Âí¶Âí≥ÂìáÂìÇÂíΩÂí™ÂìÅ"],["aba1","ÂìÑÂìàÂíØÂí´Âí±ÂíªÂí©ÂíßÂíøÂõøÂûÇÂûãÂû†Âû£Âû¢ÂüéÂûÆÂûìÂ•ïÂ•ëÂ•èÂ•éÂ•êÂßúÂßòÂßøÂß£Âß®Â®ÉÂß•Âß™ÂßöÂß¶Â®ÅÂßªÂ≠©ÂÆ£ÂÆ¶ÂÆ§ÂÆ¢ÂÆ•Â∞ÅÂ±éÂ±èÂ±çÂ±ãÂ≥ôÂ≥íÂ∑∑Â∏ùÂ∏•Â∏üÂπΩÂ∫†Â∫¶Âª∫ÂºàÂº≠ÂΩ•ÂæàÂæÖÂæäÂæãÂæáÂæåÂæâÊÄíÊÄùÊÄ†ÊÄ•ÊÄéÊÄ®ÊÅçÊÅ∞ÊÅ®ÊÅ¢ÊÅÜÊÅÉÊÅ¨ÊÅ´ÊÅ™ÊÅ§ÊâÅÊãúÊåñÊåâÊãºÊã≠ÊåÅÊãÆÊãΩÊåáÊã±Êã∑"],["ac40","ÊãØÊã¨ÊãæÊã¥ÊåëÊåÇÊîøÊïÖÊñ´ÊñΩÊó¢Êò•Êò≠Êò†ÊòßÊòØÊòüÊò®Êò±Êò§Êõ∑ÊüøÊüìÊü±ÊüîÊüêÊü¨Êû∂ÊûØÊüµÊü©ÊüØÊüÑÊüëÊû¥ÊüöÊü•Êû∏ÊüèÊüûÊü≥Êû∞ÊüôÊü¢ÊüùÊüíÊ≠™ÊÆÉÊÆÜÊÆµÊØíÊØóÊ∞üÊ≥âÊ¥ãÊ¥≤Ê¥™ÊµÅÊ¥•Ê¥åÊ¥±Ê¥ûÊ¥ó"],["aca1","Ê¥ªÊ¥ΩÊ¥æÊ¥∂Ê¥õÊ≥µÊ¥πÊ¥ßÊ¥∏Ê¥©Ê¥ÆÊ¥µÊ¥éÊ¥´ÁÇ´ÁÇ∫ÁÇ≥ÁÇ¨ÁÇØÁÇ≠ÁÇ∏ÁÇÆÁÇ§Áà∞Áâ≤ÁâØÁâ¥Áã©Áã†Áã°Áé∑ÁèäÁéªÁé≤ÁèçÁèÄÁé≥ÁîöÁî≠ÁïèÁïåÁïéÁïãÁñ´Áñ§Áñ•Áñ¢Áñ£Áô∏ÁöÜÁöáÁöàÁõàÁõÜÁõÉÁõÖÁúÅÁõπÁõ∏ÁúâÁúãÁõæÁõºÁúáÁüúÁ†ÇÁ†îÁ†åÁ†çÁ•ÜÁ•âÁ•àÁ•áÁ¶πÁ¶∫ÁßëÁßíÁßãÁ©øÁ™ÅÁ´øÁ´ΩÁ±ΩÁ¥ÇÁ¥ÖÁ¥ÄÁ¥âÁ¥áÁ¥ÑÁ¥ÜÁº∏ÁæéÁæøËÄÑ"],["ad40","ËÄêËÄçËÄëËÄ∂ËÉñËÉ•ËÉöËÉÉËÉÑËÉåËÉ°ËÉõËÉéËÉûËÉ§ËÉùËá¥Ëà¢ËãßËåÉËåÖËã£ËãõËã¶ËåÑËã•ËåÇËåâËãíËãóËã±ËåÅËãúËãîËãëËãûËãìËãüËãØËåÜËôêËôπËôªËô∫Ë°çË°´Ë¶ÅËßîË®àË®ÇË®ÉË≤ûË≤†Ëµ¥Ëµ≥Ë∂¥ËªçËªåËø∞Ëø¶Ëø¢Ëø™Ëø•"],["ada1","Ëø≠Ëø´Ëø§Ëø®ÈÉäÈÉéÈÉÅÈÉÉÈÖãÈÖäÈáçÈñÇÈôêÈôãÈôåÈôçÈù¢Èù©ÈüãÈü≠Èü≥È†ÅÈ¢®È£õÈ£üÈ¶ñÈ¶ô‰πò‰∫≥ÂÄåÂÄçÂÄ£‰øØÂÄ¶ÂÄ•‰ø∏ÂÄ©ÂÄñÂÄÜÂÄºÂÄüÂÄöÂÄíÂÄë‰ø∫ÂÄÄÂÄîÂÄ®‰ø±ÂÄ°ÂÄãÂÄôÂÄò‰ø≥‰øÆÂÄ≠ÂÄ™‰øæÂÄ´ÂÄâÂÖºÂÜ§ÂÜ•ÂÜ¢ÂáçÂáåÂáÜÂáãÂâñÂâúÂâîÂâõÂâùÂå™ÂçøÂéüÂéùÂèüÂì®ÂîêÂîÅÂî∑ÂìºÂì•Âì≤ÂîÜÂì∫ÂîîÂì©Âì≠Âì°ÂîâÂìÆÂì™"],["ae40","Âì¶ÂîßÂîáÂìΩÂîèÂúÉÂúÑÂüÇÂüîÂüãÂüÉÂ†âÂ§èÂ•óÂ•òÂ•öÂ®ëÂ®òÂ®úÂ®üÂ®õÂ®ìÂß¨Â®†Â®£Â®©Â®•Â®åÂ®âÂ≠´Â±òÂÆ∞ÂÆ≥ÂÆ∂ÂÆ¥ÂÆÆÂÆµÂÆπÂÆ∏Â∞ÑÂ±ëÂ±ïÂ±êÂ≥≠Â≥ΩÂ≥ªÂ≥™Â≥®Â≥∞Â≥∂Â¥ÅÂ≥¥Â∑ÆÂ∏≠Â∏´Â∫´Â∫≠Â∫ßÂº±ÂæíÂæëÂæêÊÅô"],["aea1","ÊÅ£ÊÅ•ÊÅêÊÅïÊÅ≠ÊÅ©ÊÅØÊÇÑÊÇüÊÇöÊÇçÊÇîÊÇåÊÇÖÊÇñÊâáÊã≥ÊåàÊãøÊçéÊåæÊåØÊçïÊçÇÊçÜÊçèÊçâÊå∫ÊçêÊåΩÊå™Êå´Êå®ÊççÊçåÊïàÊïâÊñôÊóÅÊóÖÊôÇÊôâÊôèÊôÉÊôíÊôåÊôÖÊôÅÊõ∏ÊúîÊúïÊúóÊ†°Ê†∏Ê°àÊ°ÜÊ°ìÊ†πÊ°ÇÊ°îÊ†©Ê¢≥Ê†óÊ°åÊ°ëÊ†ΩÊü¥Ê°êÊ°ÄÊ†ºÊ°ÉÊ†™Ê°ÖÊ†ìÊ†òÊ°ÅÊÆäÊÆâÊÆ∑Ê∞£Ê∞ßÊ∞®Ê∞¶Ê∞§Ê≥∞Êµ™Ê∂ïÊ∂àÊ∂áÊµ¶Êµ∏Êµ∑ÊµôÊ∂ì"],["af40","Êµ¨Ê∂âÊµÆÊµöÊµ¥Êµ©Ê∂åÊ∂äÊµπÊ∂ÖÊµ•Ê∂îÁÉäÁÉòÁÉ§ÁÉôÁÉàÁÉèÁàπÁâπÁãºÁãπÁãΩÁã∏Áã∑ÁéÜÁè≠ÁêâÁèÆÁè†Áè™ÁèûÁïîÁïùÁïúÁïöÁïôÁñæÁóÖÁóáÁñ≤Áñ≥ÁñΩÁñºÁñπÁóÇÁñ∏ÁöãÁö∞ÁõäÁõçÁõéÁú©ÁúüÁú†Áú®Áü©Á†∞Á†ßÁ†∏Á†ùÁ†¥Á†∑"],["afa1","Á†•Á†≠Á††Á†üÁ†≤Á•ïÁ•êÁ•†Á•üÁ•ñÁ•ûÁ•ùÁ•óÁ•öÁß§Áß£ÁßßÁßüÁß¶Áß©ÁßòÁ™ÑÁ™àÁ´ôÁ¨ÜÁ¨ëÁ≤âÁ¥°Á¥óÁ¥ãÁ¥äÁ¥†Á¥¢Á¥îÁ¥êÁ¥ïÁ¥öÁ¥úÁ¥çÁ¥ôÁ¥õÁº∫ÁΩüÁæîÁøÖÁøÅËÄÜËÄòËÄïËÄôËÄóËÄΩËÄøËÉ±ËÑÇËÉ∞ËÑÖËÉ≠ËÉ¥ËÑÜËÉ∏ËÉ≥ËÑàËÉΩËÑäËÉºËÉØËá≠Ëá¨ËàÄËàêËà™Ëà´Ëà®Ëà¨ËäªËå´ËçíËçîËçäËå∏ËçêËçâËåµËå¥ËçèËå≤ËåπËå∂ËåóËçÄËå±Ëå®ËçÉ"],["b040","ËôîËöäËö™ËöìËö§Ëö©ËöåËö£ËöúË°∞Ë°∑Ë¢ÅË¢ÇË°ΩË°πË®òË®êË®éË®åË®ïË®äË®óË®ìË®ñË®èË®ëË±àË±∫Ë±πË≤°Ë≤¢Ëµ∑Ë∫¨ËªíËªîËªèËæ±ÈÄÅÈÄÜËø∑ÈÄÄËø∫Ëø¥ÈÄÉËøΩÈÄÖËø∏ÈÇïÈÉ°ÈÉùÈÉ¢ÈÖíÈÖçÈÖåÈáòÈáùÈáóÈáúÈáôÈñÉÈô¢Èô£Èô°"],["b0a1","ÈôõÈôùÈô§ÈôòÈôûÈöªÈ£¢È¶¨È™®È´òÈ¨•È¨≤È¨º‰πæÂÅ∫ÂÅΩÂÅúÂÅáÂÅÉÂÅåÂÅöÂÅâÂÅ•ÂÅ∂ÂÅéÂÅïÂÅµÂÅ¥ÂÅ∑ÂÅèÂÄèÂÅØÂÅ≠ÂÖúÂÜïÂá∞Ââ™ÂâØÂãíÂãôÂãòÂãïÂåêÂåèÂåôÂåøÂçÄÂåæÂèÉÊõºÂïÜÂï™Âï¶ÂïÑÂïûÂï°ÂïÉÂïäÂî±ÂïñÂïèÂïïÂîØÂï§Âî∏ÂîÆÂïúÂî¨Âï£Âî≥ÂïÅÂïóÂúàÂúãÂúâÂüüÂ†ÖÂ†äÂ†ÜÂü†Âü§Âü∫Â†ÇÂ†µÂü∑ÂüπÂ§†Â•¢Â®∂Â©ÅÂ©âÂ©¶Â©™Â©Ä"],["b140","Â®ºÂ©¢Â©öÂ©ÜÂ©äÂ≠∞ÂØáÂØÖÂØÑÂØÇÂÆøÂØÜÂ∞âÂ∞àÂ∞áÂ±†Â±úÂ±ùÂ¥áÂ¥ÜÂ¥éÂ¥õÂ¥ñÂ¥¢Â¥ëÂ¥©Â¥îÂ¥ôÂ¥§Â¥ßÂ¥óÂ∑¢Â∏∏Â∏∂Â∏≥Â∏∑Â∫∑Â∫∏Â∫∂Â∫µÂ∫æÂºµÂº∑ÂΩóÂΩ¨ÂΩ©ÂΩ´ÂæóÂæôÂæûÂæòÂæ°Âæ†ÂæúÊÅøÊÇ£ÊÇâÊÇ†ÊÇ®ÊÉãÊÇ¥ÊÉ¶ÊÇΩ"],["b1a1","ÊÉÖÊÇªÊÇµÊÉúÊÇºÊÉòÊÉïÊÉÜÊÉüÊÇ∏ÊÉöÊÉáÊàöÊàõÊâàÊé†ÊéßÊç≤ÊéñÊé¢Êé•Êç∑ÊçßÊéòÊé™Êç±Êé©ÊéâÊéÉÊéõÊç´Êé®ÊéÑÊéàÊéôÊé°Êé¨ÊéíÊéèÊéÄÊçªÊç©Êç®Êç∫ÊïùÊïñÊïëÊïôÊïóÂïüÊïèÊïòÊïïÊïîÊñúÊñõÊñ¨ÊóèÊóãÊóåÊóéÊôùÊôöÊô§Êô®Êô¶ÊôûÊõπÂãóÊúõÊ¢ÅÊ¢ØÊ¢¢Ê¢ìÊ¢µÊ°øÊ°∂Ê¢±Ê¢ßÊ¢óÊ¢∞Ê¢ÉÊ£ÑÊ¢≠Ê¢ÜÊ¢ÖÊ¢îÊ¢ùÊ¢®Ê¢üÊ¢°Ê¢ÇÊ¨≤ÊÆ∫"],["b240","ÊØ´ÊØ¨Ê∞´Ê∂éÊ∂ºÊ∑≥Ê∑ôÊ∂≤Ê∑°Ê∑åÊ∑§Ê∑ªÊ∑∫Ê∏ÖÊ∑áÊ∑ãÊ∂ØÊ∑ëÊ∂ÆÊ∑ûÊ∑πÊ∂∏Ê∑∑Ê∑µÊ∑ÖÊ∑íÊ∏öÊ∂µÊ∑öÊ∑´Ê∑òÊ∑™Ê∑±Ê∑ÆÊ∑®Ê∑ÜÊ∑ÑÊ∂™Ê∑¨Ê∂øÊ∑¶ÁÉπÁÑâÁÑäÁÉΩÁÉØÁàΩÁâΩÁäÅÁåúÁåõÁåñÁåìÁåôÁéáÁêÖÁêäÁêÉÁêÜÁèæÁêçÁì†Áì∂"],["b2a1","Áì∑ÁîúÁî¢Áï•Áï¶Áï¢Áï∞ÁñèÁóîÁóïÁñµÁóäÁóçÁöéÁõîÁõíÁõõÁú∑ÁúæÁúºÁú∂Áú∏Áú∫Á°´Á°ÉÁ°éÁ••Á•®Á•≠ÁßªÁ™íÁ™ïÁ¨†Á¨®Á¨õÁ¨¨Á¨¶Á¨ôÁ¨ûÁ¨ÆÁ≤íÁ≤óÁ≤ïÁµÜÁµÉÁµ±Á¥ÆÁ¥πÁ¥ºÁµÄÁ¥∞Á¥≥ÁµÑÁ¥ØÁµÇÁ¥≤Á¥±ÁºΩÁæûÁæöÁøåÁøéÁøíËÄúËÅäËÅÜËÑØËÑñËÑ£ËÑ´ËÑ©ËÑ∞ËÑ§ËàÇËàµËà∑Ëà∂ËàπËééËéûËéòËç∏Ëé¢ËéñËéΩËé´ËéíËéäËéìËéâËé†Ëç∑ËçªËçº"],["b340","ËéÜËéßËôïÂΩ™ËõáËõÄËö∂ËõÑËöµËõÜËõãËö±ËöØËõâË°ìË¢ûË¢àË¢´Ë¢íË¢ñË¢çË¢ãË¶ìË¶èË®™Ë®ùË®£Ë®•Ë®±Ë®≠Ë®üË®õË®¢Ë±âË±öË≤©Ë≤¨Ë≤´Ë≤®Ë≤™Ë≤ßËµßËµ¶Ë∂æË∂∫ËªõËªüÈÄôÈÄçÈÄöÈÄóÈÄ£ÈÄüÈÄùÈÄêÈÄïÈÄûÈÄ†ÈÄèÈÄ¢ÈÄñÈÄõÈÄî"],["b3a1","ÈÉ®ÈÉ≠ÈÉΩÈÖóÈáéÈáµÈá¶Èá£ÈáßÈá≠Èá©ÈñâÈô™ÈôµÈô≥Èô∏Èô∞Èô¥Èô∂Èô∑Èô¨ÈõÄÈõ™Èõ©Á´†Á´üÈ†ÇÈ†ÉÈ≠öÈ≥•ÈπµÈπøÈ∫•È∫ªÂÇ¢ÂÇçÂÇÖÂÇôÂÇëÂÇÄÂÇñÂÇòÂÇöÊúÄÂá±Ââ≤Ââ¥ÂâµÂâ©ÂãûÂãùÂãõÂçöÂé•ÂïªÂñÄÂñßÂïºÂñäÂñùÂñòÂñÇÂñúÂñ™ÂñîÂñáÂñãÂñÉÂñ≥ÂñÆÂñüÂîæÂñ≤ÂñöÂñªÂñ¨Âñ±ÂïæÂñâÂñ´ÂñôÂúçÂ†ØÂ†™Â†¥Â†§Â†∞Â†±Â†°Â†ùÂ††Â£πÂ£∫Â•†"],["b440","Â©∑Â™öÂ©øÂ™íÂ™õÂ™ßÂ≠≥Â≠±ÂØíÂØåÂØìÂØêÂ∞äÂ∞ãÂ∞±ÂµåÂµêÂ¥¥ÂµáÂ∑ΩÂπÖÂ∏ΩÂπÄÂπÉÂπæÂªäÂªÅÂªÇÂªÑÂººÂΩ≠Âæ©Âæ™Âæ®ÊÉëÊÉ°ÊÇ≤ÊÇ∂ÊÉ†ÊÑúÊÑ£ÊÉ∫ÊÑïÊÉ∞ÊÉªÊÉ¥ÊÖ®ÊÉ±ÊÑéÊÉ∂ÊÑâÊÑÄÊÑíÊàüÊââÊé£ÊéåÊèèÊèÄÊè©ÊèâÊèÜÊèç"],["b4a1","ÊèíÊè£ÊèêÊè°ÊèñÊè≠ÊèÆÊç∂Êè¥Êè™ÊèõÊëíÊèöÊèπÊïûÊï¶Êï¢Êï£ÊñëÊñêÊñØÊôÆÊô∞Êô¥Êô∂ÊôØÊöëÊô∫ÊôæÊô∑ÊõæÊõøÊúüÊúùÊ£∫Ê£ïÊ£†Ê£òÊ£óÊ§ÖÊ£üÊ£µÊ£ÆÊ£ßÊ£πÊ£íÊ£≤Ê££Ê£ãÊ£çÊ§çÊ§íÊ§éÊ£âÊ£öÊ•ÆÊ£ªÊ¨æÊ¨∫Ê¨ΩÊÆòÊÆñÊÆºÊØØÊ∞ÆÊ∞ØÊ∞¨Ê∏ØÊ∏∏ÊπîÊ∏°Ê∏≤ÊπßÊπäÊ∏†Ê∏•Ê∏£Ê∏õÊπõÊπòÊ∏§ÊπñÊπÆÊ∏≠Ê∏¶ÊπØÊ∏¥ÊπçÊ∏∫Ê∏¨ÊπÉÊ∏ùÊ∏æÊªã"],["b540","Ê∫âÊ∏ôÊπéÊπ£ÊπÑÊπ≤Êπ©ÊπüÁÑôÁÑöÁÑ¶ÁÑ∞ÁÑ°ÁÑ∂ÁÖÆÁÑúÁâåÁäÑÁäÄÁå∂Áå•Áå¥Áå©Áê∫Áê™Áê≥Áê¢Áê•ÁêµÁê∂Áê¥ÁêØÁêõÁê¶Áê®Áî•Áî¶Áï´Áï™Áó¢ÁóõÁó£ÁóôÁóòÁóûÁó†ÁôªÁôºÁöñÁöìÁö¥ÁõúÁùèÁü≠Á°ùÁ°¨Á°ØÁ®çÁ®àÁ®ãÁ®ÖÁ®ÄÁ™ò"],["b5a1","Á™óÁ™ñÁ´•Á´£Á≠âÁ≠ñÁ≠ÜÁ≠êÁ≠íÁ≠îÁ≠çÁ≠ãÁ≠èÁ≠ëÁ≤üÁ≤•ÁµûÁµêÁµ®ÁµïÁ¥´ÁµÆÁµ≤Áµ°Áµ¶Áµ¢Áµ∞Áµ≥ÂñÑÁøîÁøïËÄãËÅíËÇÖËÖïËÖîËÖãËÖëËÖéËÑπËÖÜËÑæËÖåËÖìËÖ¥ËàíËàúËè©ËêÉËè∏ËêçËè†ËèÖËêãËèÅËèØËè±Ëè¥ËëóËêäËè∞ËêåËèåËèΩËè≤ËèäËê∏ËêéËêÑËèúËêáËèîËèüËôõËõüËõôËõ≠ËõîËõõËõ§ËõêËõûË°óË£ÅË£ÇË¢±Ë¶ÉË¶ñË®ªË©†Ë©ïË©ûË®ºË©Å"],["b640","Ë©îË©õË©êË©ÜË®¥Ë®∫Ë®∂Ë©ñË±°Ë≤ÇË≤ØË≤ºË≤≥Ë≤ΩË≥ÅË≤ªË≥ÄË≤¥Ë≤∑Ë≤∂Ë≤øË≤∏Ë∂äË∂ÖË∂ÅË∑éË∑ùË∑ãË∑öË∑ëË∑åË∑õË∑ÜËªªËª∏ËªºËæúÈÄÆÈÄµÈÄ±ÈÄ∏ÈÄ≤ÈÄ∂ÈÑÇÈÉµÈÑâÈÉæÈÖ£ÈÖ•ÈáèÈàîÈàïÈà£ÈàâÈàûÈàçÈàêÈàáÈàëÈñîÈñèÈñãÈñë"],["b6a1","ÈñìÈñíÈñéÈöäÈöéÈöãÈôΩÈöÖÈöÜÈöçÈô≤ÈöÑÈõÅÈõÖÈõÑÈõÜÈõáÈõØÈõ≤ÈüåÈ†ÖÈ†ÜÈ†àÈ£ßÈ£™È£ØÈ£©È£≤È£≠È¶ÆÈ¶≠ÈªÉÈªçÈªë‰∫ÇÂÇ≠ÂÇµÂÇ≤ÂÇ≥ÂÉÖÂÇæÂÇ¨ÂÇ∑ÂÇªÂÇØÂÉáÂâøÂâ∑ÂâΩÂãüÂã¶Âã§Âã¢Âã£ÂåØÂóüÂó®ÂóìÂó¶ÂóéÂóúÂóáÂóëÂó£Âó§ÂóØÂóöÂó°ÂóÖÂóÜÂó•ÂóâÂúíÂúìÂ°ûÂ°ëÂ°òÂ°óÂ°öÂ°îÂ°´Â°åÂ°≠Â°äÂ°¢Â°íÂ°ãÂ•ßÂ´ÅÂ´âÂ´åÂ™æÂ™ΩÂ™º"],["b740","Â™≥Â´ÇÂ™≤Âµ©ÂµØÂπåÂππÂªâÂªàÂºíÂΩôÂæ¨ÂæÆÊÑöÊÑèÊÖàÊÑüÊÉ≥ÊÑõÊÉπÊÑÅÊÑàÊÖéÊÖåÊÖÑÊÖçÊÑæÊÑ¥ÊÑßÊÑçÊÑÜÊÑ∑Êà°Êà¢ÊêìÊêæÊêûÊê™Êê≠ÊêΩÊê¨ÊêèÊêúÊêîÊêçÊê∂ÊêñÊêóÊêÜÊï¨ÊñüÊñ∞ÊöóÊöâÊöáÊöàÊöñÊöÑÊöòÊöçÊúÉÊ¶îÊ•≠"],["b7a1","Ê•öÊ•∑Ê•†Ê•îÊ•µÊ§∞Ê¶ÇÊ•äÊ•®Ê•´Ê•ûÊ•ìÊ•πÊ¶ÜÊ•ùÊ•£Ê•õÊ≠áÊ≠≤ÊØÄÊÆøÊØìÊØΩÊ∫¢Ê∫ØÊªìÊ∫∂ÊªÇÊ∫êÊ∫ùÊªáÊªÖÊ∫•Ê∫òÊ∫ºÊ∫∫Ê∫´ÊªëÊ∫ñÊ∫úÊªÑÊªîÊ∫™Ê∫ßÊ∫¥ÁÖéÁÖôÁÖ©ÁÖ§ÁÖâÁÖßÁÖúÁÖ¨ÁÖ¶ÁÖåÁÖ•ÁÖûÁÖÜÁÖ®ÁÖñÁà∫ÁâíÁå∑ÁçÖÁåøÁåæÁëØÁëöÁëïÁëüÁëûÁëÅÁêøÁëôÁëõÁëúÁï∂Áï∏ÁòÄÁó∞ÁòÅÁó≤Áó±Áó∫ÁóøÁó¥Áó≥ÁõûÁõüÁùõÁù´Áù¶ÁùûÁù£"],["b840","ÁùπÁù™Áù¨ÁùúÁù•Áù®Áù¢ÁüÆÁ¢éÁ¢∞Á¢óÁ¢òÁ¢åÁ¢âÁ°ºÁ¢ëÁ¢ìÁ°øÁ•∫Á•øÁ¶ÅËê¨Á¶ΩÁ®úÁ®öÁ®†Á®îÁ®üÁ®ûÁ™üÁ™†Á≠∑ÁØÄÁ≠†Á≠ÆÁ≠ßÁ≤±Á≤≥Á≤µÁ∂ìÁµπÁ∂ëÁ∂ÅÁ∂èÁµõÁΩÆÁΩ©ÁΩ™ÁΩ≤Áæ©Áæ®Áæ§ËÅñËÅòËÇÜËÇÑËÖ±ËÖ∞ËÖ∏ËÖ•ËÖÆËÖ≥ËÖ´"],["b8a1","ËÖπËÖ∫ËÖ¶ËàÖËâáËíÇËë∑ËêΩËê±ËëµËë¶Ëë´ËëâËë¨ËëõËêºËêµËë°Ëë£Ëë©Ëë≠ËëÜËôûËôúËôüËõπËúìËúàËúáËúÄËõæËõªËúÇËúÉËúÜËúäË°ôË£üË£îË£ôË£úË£òË£ùË£°Ë£äË£ïË£íË¶úËß£Ë©´Ë©≤Ë©≥Ë©¶Ë©©Ë©∞Ë™áË©ºË©£Ë™†Ë©±Ë™ÖË©≠Ë©¢Ë©ÆË©¨Ë©πË©ªË®æË©®Ë±¢Ë≤äË≤âË≥äË≥áË≥àË≥ÑË≤≤Ë≥ÉË≥ÇË≥ÖË∑°Ë∑üË∑®Ë∑ØË∑≥Ë∑∫Ë∑™Ë∑§Ë∑¶Ë∫≤ËºÉËºâËªæËºä"],["b940","ËæüËæ≤ÈÅãÈÅäÈÅìÈÅÇÈÅîÈÄºÈÅïÈÅêÈÅáÈÅèÈÅéÈÅçÈÅëÈÄæÈÅÅÈÑíÈÑóÈÖ¨ÈÖ™ÈÖ©ÈáâÈà∑ÈâóÈà∏ÈàΩÈâÄÈàæÈâõÈâãÈâ§ÈâëÈà¥ÈââÈâçÈâÖÈàπÈàøÈâöÈñòÈöòÈöîÈöïÈõçÈõãÈõâÈõäÈõ∑ÈõªÈõπÈõ∂ÈùñÈù¥Èù∂È†êÈ†ëÈ†ìÈ†äÈ†íÈ†åÈ£ºÈ£¥"],["b9a1","È£ΩÈ£æÈ¶≥È¶±È¶¥È´°È≥©È∫ÇÈºéÈºìÈº†ÂÉßÂÉÆÂÉ•ÂÉñÂÉ≠ÂÉöÂÉïÂÉèÂÉëÂÉ±ÂÉéÂÉ©ÂÖ¢Âá≥ÂäÉÂäÇÂå±Âé≠ÂóæÂòÄÂòõÂòóÂóΩÂòîÂòÜÂòâÂòçÂòéÂó∑ÂòñÂòüÂòàÂòêÂó∂ÂúòÂúñÂ°µÂ°æÂ¢ÉÂ¢ìÂ¢äÂ°πÂ¢ÖÂ°ΩÂ£ΩÂ§•Â§¢Â§§Â•™Â•©Â´°Â´¶Â´©Â´óÂ´ñÂ´òÂ´£Â≠µÂØûÂØßÂØ°ÂØ•ÂØ¶ÂØ®ÂØ¢ÂØ§ÂØüÂ∞çÂ±¢Â∂ÑÂ∂áÂπõÂπ£ÂπïÂπóÂπîÂªìÂªñÂºäÂΩÜÂΩ∞ÂæπÊÖá"],["ba40","ÊÑøÊÖãÊÖ∑ÊÖ¢ÊÖ£ÊÖüÊÖöÊÖòÊÖµÊà™ÊíáÊëòÊëîÊí§Êë∏ÊëüÊë∫ÊëëÊëßÊê¥Êë≠ÊëªÊï≤Êñ°ÊóóÊóñÊö¢Êö®ÊöùÊ¶úÊ¶®Ê¶ïÊßÅÊ¶ÆÊßìÊßãÊ¶õÊ¶∑Ê¶ªÊ¶´Ê¶¥ÊßêÊßçÊ¶≠ÊßåÊ¶¶ÊßÉÊ¶£Ê≠âÊ≠åÊ∞≥Êº≥ÊºîÊªæÊºìÊª¥Êº©ÊºæÊº†Êº¨ÊºèÊºÇÊº¢"],["baa1","ÊªøÊªØÊºÜÊº±Êº∏Êº≤Êº£ÊºïÊº´ÊºØÊæàÊº™Êª¨ÊºÅÊª≤ÊªåÊª∑ÁÜîÁÜôÁÖΩÁÜäÁÜÑÁÜíÁàæÁäíÁäñÁçÑÁçêÁë§Áë£Áë™Áë∞Áë≠ÁîÑÁñëÁòßÁòçÁòãÁòâÁòìÁõ°Áõ£ÁûÑÁùΩÁùøÁù°Á£ÅÁ¢üÁ¢ßÁ¢≥Á¢©Á¢£Á¶éÁ¶èÁ¶çÁ®ÆÁ®±Á™™Á™©Á´≠Á´ØÁÆ°ÁÆïÁÆãÁ≠µÁÆóÁÆùÁÆîÁÆèÁÆ∏ÁÆáÁÆÑÁ≤πÁ≤ΩÁ≤æÁ∂ªÁ∂∞Á∂úÁ∂ΩÁ∂æÁ∂†Á∑äÁ∂¥Á∂≤Á∂±Á∂∫Á∂¢Á∂øÁ∂µÁ∂∏Á∂≠Á∑íÁ∑áÁ∂¨"],["bb40","ÁΩ∞Áø†Áø°ÁøüËÅûËÅöËÇáËÖêËÜÄËÜèËÜàËÜäËÖøËÜÇËáßËá∫ËàáËàîËàûËâãËìâËíøËìÜËìÑËíôËíûËí≤ËíúËìãËí∏ËìÄËììËíêËíºËìëËìäËúøËúúËúªËú¢Ëú•Ëú¥ËúòËùïËú∑Ëú©Ë£≥Ë§ÇË£¥Ë£πË£∏Ë£ΩË£®Ë§öË£ØË™¶Ë™åË™ûË™£Ë™çË™°Ë™ìË™§"],["bba1","Ë™™Ë™•Ë™®Ë™òË™ëË™öË™ßË±™Ë≤çË≤åË≥ìË≥ëË≥íËµ´Ë∂ôË∂ïË∑ºËºîËºíËºïËºìËæ£ÈÅ†ÈÅòÈÅúÈÅ£ÈÅôÈÅûÈÅ¢ÈÅùÈÅõÈÑôÈÑòÈÑûÈÖµÈÖ∏ÈÖ∑ÈÖ¥Èâ∏ÈäÄÈäÖÈäòÈäñÈâªÈäìÈäúÈä®ÈâºÈäëÈñ°Èñ®Èñ©Èñ£Èñ•Èñ§ÈöôÈöúÈöõÈõåÈõíÈúÄÈùºÈûÖÈü∂È†óÈ†òÈ¢ØÈ¢±È§ÉÈ§ÖÈ§åÈ§âÈßÅÈ™ØÈ™∞È´¶È≠ÅÈ≠ÇÈ≥¥È≥∂È≥≥È∫ºÈºªÈΩäÂÑÑÂÑÄÂÉªÂÉµÂÉπÂÑÇÂÑàÂÑâÂÑÖÂáú"],["bc40","ÂäáÂäàÂäâÂäçÂääÂã∞Âé≤ÂòÆÂòªÂòπÂò≤ÂòøÂò¥Âò©ÂôìÂôéÂôóÂô¥Âò∂ÂòØÂò∞Â¢ÄÂ¢üÂ¢ûÂ¢≥Â¢úÂ¢ÆÂ¢©Â¢¶Â•≠Â¨âÂ´ªÂ¨ãÂ´µÂ¨åÂ¨àÂØÆÂØ¨ÂØ©ÂØ´Â±§Â±•Â∂ùÂ∂îÂπ¢ÂπüÂπ°Âª¢ÂªöÂªüÂªùÂª£Âª†ÂΩàÂΩ±Âæ∑ÂæµÊÖ∂ÊÖßÊÖÆÊÖùÊÖïÊÜÇ"],["bca1","ÊÖºÊÖ∞ÊÖ´ÊÖæÊÜßÊÜêÊÜ´ÊÜéÊÜ¨ÊÜöÊÜ§ÊÜîÊÜÆÊàÆÊë©ÊëØÊëπÊíûÊí≤ÊíàÊíêÊí∞Êí•ÊíìÊíïÊí©ÊííÊíÆÊí≠Êí´ÊíöÊí¨ÊíôÊí¢Êí≥ÊïµÊï∑Êï∏ÊöÆÊö´Êö¥Êö±Ê®£Ê®üÊß®Ê®ÅÊ®ûÊ®ôÊßΩÊ®°Ê®ìÊ®äÊß≥Ê®ÇÊ®ÖÊß≠Ê®ëÊ≠êÊ≠éÊÆ§ÊØÖÊØÜÊºøÊΩºÊæÑÊΩëÊΩ¶ÊΩîÊæÜÊΩ≠ÊΩõÊΩ∏ÊΩÆÊæéÊΩ∫ÊΩ∞ÊΩ§ÊæóÊΩòÊªïÊΩØÊΩ†ÊΩüÁÜüÁÜ¨ÁÜ±ÁÜ®ÁâñÁäõÁçéÁçóÁë©ÁíãÁíÉ"],["bd40","ÁëæÁíÄÁïøÁò†Áò©ÁòüÁò§Áò¶Áò°Áò¢ÁööÁö∫Áõ§ÁûéÁûáÁûåÁûëÁûãÁ£ãÁ£ÖÁ¢∫Á£äÁ¢æÁ£ïÁ¢ºÁ£êÁ®øÁ®ºÁ©ÄÁ®ΩÁ®∑Á®ªÁ™ØÁ™ÆÁÆ≠ÁÆ±ÁØÑÁÆ¥ÁØÜÁØáÁØÅÁÆ†ÁØåÁ≥äÁ∑†Á∑¥Á∑ØÁ∑ªÁ∑òÁ∑¨Á∑ùÁ∑®Á∑£Á∑öÁ∑ûÁ∑©Á∂ûÁ∑ôÁ∑≤Á∑πÁΩµÁΩ∑ÁæØ"],["bda1","Áø©ËÄ¶ËÜõËÜúËÜùËÜ†ËÜöËÜòËîóËîΩËîöËìÆËî¨Ëî≠ËîìËîëËî£Ëî°ËîîËì¨Ëî•ËìøËîÜËûÇËù¥Ëù∂Ëù†Ëù¶Ëù∏Ëù®ËùôËùóËùåËùìË°õË°ùË§êË§áË§íË§ìË§ïË§äË™ºË´íË´áË´ÑË™ïË´ãË´∏Ë™≤Ë´âË´ÇË™øË™∞Ë´ñË´çË™∂Ë™πË´õË±åË±éË±¨Ë≥†Ë≥ûË≥¶Ë≥§Ë≥¨Ë≥≠Ë≥¢Ë≥£Ë≥úË≥™Ë≥°Ëµ≠Ë∂üË∂£Ë∏´Ë∏êË∏ùË∏¢Ë∏èË∏©Ë∏üË∏°Ë∏ûË∫∫ËºùËºõËºüËº©Ëº¶Ëº™ËºúËºû"],["be40","Ëº•ÈÅ©ÈÅÆÈÅ®ÈÅ≠ÈÅ∑ÈÑ∞ÈÑ≠ÈÑßÈÑ±ÈÜáÈÜâÈÜãÈÜÉÈãÖÈäªÈä∑Èã™Èä¨Èã§ÈãÅÈä≥ÈäºÈãíÈãáÈã∞Èä≤Èñ≠Èñ±ÈúÑÈúÜÈúáÈúâÈù†ÈûçÈûãÈûèÈ†°È†´È†úÈ¢≥È§äÈ§ìÈ§íÈ§òÈßùÈßêÈßüÈßõÈßëÈßïÈßíÈßôÈ™∑È´ÆÈ´ØÈ¨ßÈ≠ÖÈ≠ÑÈ≠∑È≠ØÈ¥ÜÈ¥â"],["bea1","È¥ÉÈ∫©È∫æÈªéÂ¢®ÈΩíÂÑíÂÑòÂÑîÂÑêÂÑïÂÜÄÂÜ™ÂáùÂäëÂäìÂã≥ÂôôÂô´ÂôπÂô©Âô§Âô∏Âô™Âô®Âô•Âô±ÂôØÂô¨Âô¢Âô∂Â£ÅÂ¢æÂ£áÂ£ÖÂ•ÆÂ¨ùÂ¨¥Â≠∏ÂØ∞Â∞éÂΩäÊÜ≤ÊÜëÊÜ©ÊÜäÊáçÊÜ∂ÊÜæÊáäÊáàÊà∞ÊìÖÊìÅÊìãÊíªÊíºÊìöÊìÑÊìáÊìÇÊìçÊíøÊìíÊìîÊíæÊï¥ÊõÜÊõâÊöπÊõÑÊõáÊö∏Ê®ΩÊ®∏Ê®∫Ê©ôÊ©´Ê©òÊ®πÊ©ÑÊ©¢Ê©°Ê©ãÊ©áÊ®µÊ©üÊ©àÊ≠ôÊ≠∑Ê∞ÖÊøÇÊæ±Êæ°"],["bf40","ÊøÉÊæ§ÊøÅÊæßÊæ≥ÊøÄÊæπÊæ∂Êæ¶Êæ†Êæ¥ÁÜæÁáâÁáêÁáíÁáàÁáïÁÜπÁáéÁáôÁáúÁáÉÁáÑÁç®ÁíúÁí£ÁíòÁíüÁíûÁì¢ÁîåÁîçÁò¥Áò∏Áò∫ÁõßÁõ•Áû†ÁûûÁûüÁû•Á£®Á£öÁ£¨Á£ßÁ¶¶Á©çÁ©éÁ©ÜÁ©åÁ©ãÁ™∫ÁØôÁ∞ëÁØâÁØ§ÁØõÁØ°ÁØ©ÁØ¶Á≥ïÁ≥ñÁ∏ä"],["bfa1","Á∏ëÁ∏àÁ∏õÁ∏£Á∏ûÁ∏ùÁ∏âÁ∏êÁΩπÁæ≤Áø∞Áø±ÁøÆËÄ®ËÜ≥ËÜ©ËÜ®ËáªËààËâòËâôËïäËïôËïàËï®Ëï©ËïÉËïâËï≠Ëï™ËïûËûÉËûüËûûËû¢ËûçË°°Ë§™Ë§≤Ë§•Ë§´Ë§°Ë¶™Ë¶¶Ë´¶Ë´∫Ë´´Ë´±Ë¨ÄË´úË´ßË´ÆË´æË¨ÅË¨ÇË´∑Ë´≠Ë´≥Ë´∂Ë´ºË±´Ë±≠Ë≤ìË≥¥ËπÑË∏±Ë∏¥ËπÇË∏πË∏µËºªËºØËº∏Ëº≥Ëæ®Ëæ¶ÈÅµÈÅ¥ÈÅ∏ÈÅ≤ÈÅºÈÅ∫ÈÑ¥ÈÜíÈå†Èå∂Èã∏Èå≥ÈåØÈå¢ÈãºÈå´ÈåÑÈåö"],["c040","ÈåêÈå¶Èå°ÈåïÈåÆÈåôÈñªÈößÈö®Èö™ÈõïÈúéÈúëÈúñÈúçÈúìÈúèÈùõÈùúÈù¶ÈûòÈ†∞È†∏È†ªÈ†∑È†≠È†πÈ†§È§êÈ§®È§ûÈ§õÈ§°È§öÈß≠Èß¢Èß±È™∏È™ºÈ´ªÈ´≠È¨®ÈÆëÈ¥ïÈ¥£È¥¶È¥®È¥íÈ¥õÈªòÈªîÈæçÈæúÂÑ™ÂÑüÂÑ°ÂÑ≤ÂãµÂöéÂöÄÂöêÂöÖÂöá"],["c0a1","ÂöèÂ£ïÂ£ìÂ£ëÂ£éÂ¨∞Â¨™Â¨§Â≠∫Â∞∑Â±®Â∂ºÂ∂∫Â∂ΩÂ∂∏Âπ´ÂΩåÂæΩÊáâÊáÇÊááÊá¶ÊáãÊà≤Êà¥ÊìéÊìäÊìòÊì†Êì∞Êì¶Êì¨Êì±Êì¢Êì≠ÊñÇÊñÉÊõôÊõñÊ™ÄÊ™îÊ™ÑÊ™¢Ê™úÊ´õÊ™£Ê©æÊ™óÊ™êÊ™†Ê≠úÊÆÆÊØöÊ∞àÊøòÊø±ÊøüÊø†ÊøõÊø§Êø´ÊøØÊæÄÊø¨Êø°Êø©ÊøïÊøÆÊø∞ÁáßÁáüÁáÆÁá¶Áá•Áá≠Áá¨Áá¥Áá†ÁàµÁâÜÁç∞Áç≤Áí©Áí∞Áí¶Áí®ÁôÜÁôÇÁôåÁõ™Áû≥Áû™Áû∞Áû¨"],["c140","ÁûßÁû≠ÁüØÁ£∑Á£∫Á£¥Á£ØÁ§ÅÁ¶ßÁ¶™Á©óÁ™øÁ∞áÁ∞çÁØæÁØ∑Á∞åÁØ†Á≥†Á≥úÁ≥ûÁ≥¢Á≥üÁ≥ôÁ≥ùÁ∏ÆÁ∏æÁπÜÁ∏∑Á∏≤ÁπÉÁ∏´Á∏ΩÁ∏±ÁπÖÁπÅÁ∏¥Á∏πÁπàÁ∏µÁ∏øÁ∏ØÁΩÑÁø≥ÁøºËÅ±ËÅ≤ËÅ∞ËÅØËÅ≥ËáÜËáÉËÜ∫ËáÇËáÄËÜøËÜΩËáâËÜæËá®ËàâËâ±Ëñ™"],["c1a1","ËñÑËïæËñúËñëËñîËñØËñõËñáËñ®ËñäËôßËüÄËüëËû≥ËüíËüÜËû´ËûªËû∫ËüàËüãË§ªË§∂Ë•ÑË§∏Ë§ΩË¶¨Ë¨éË¨óË¨ôË¨õË¨äË¨†Ë¨ùË¨ÑË¨êË±ÅË∞øË±≥Ë≥∫Ë≥ΩË≥ºË≥∏Ë≥ªË∂®ËπâËπãËπàËπäËΩÑËºæËΩÇËΩÖËºøÈÅøÈÅΩÈÇÑÈÇÅÈÇÇÈÇÄÈÑπÈÜ£ÈÜûÈÜúÈççÈéÇÈå®ÈçµÈçäÈç•ÈçãÈåòÈçæÈç¨ÈçõÈç∞ÈçöÈçîÈóäÈóãÈóåÈóàÈóÜÈö±Èö∏ÈõñÈúúÈúûÈû†ÈüìÈ°ÜÈ¢∂È§µÈ®Å"],["c240","ÈßøÈÆÆÈÆ´ÈÆ™ÈÆ≠È¥ªÈ¥øÈ∫ãÈªèÈªûÈªúÈªùÈªõÈºæÈΩãÂè¢ÂöïÂöÆÂ£ôÂ£òÂ¨∏ÂΩùÊá£Êà≥Êì¥Êì≤ÊìæÊîÜÊì∫ÊìªÊì∑Êñ∑ÊõúÊú¶Ê™≥Ê™¨Ê´ÉÊ™ªÊ™∏Ê´ÇÊ™ÆÊ™ØÊ≠üÊ≠∏ÊÆØÁÄâÁÄãÊøæÁÄÜÊø∫ÁÄëÁÄèÁáªÁáºÁáæÁá∏Áç∑ÁçµÁíßÁíøÁîïÁôñÁôò"],["c2a1","ÁôíÁûΩÁûøÁûªÁûºÁ§éÁ¶ÆÁ©°Á©¢Á©†Á´ÑÁ´ÖÁ∞´Á∞ßÁ∞™Á∞ûÁ∞£Á∞°Á≥ßÁπîÁπïÁπûÁπöÁπ°ÁπíÁπôÁΩàÁøπÁøªËÅ∑ËÅ∂ËáçËáèËàäËóèËñ©ËóçËóêËóâËñ∞Ëñ∫ËñπËñ¶ËüØËü¨Ëü≤Ëü†Ë¶ÜË¶≤Ëß¥Ë¨®Ë¨πË¨¨Ë¨´Ë±êË¥ÖËπôËπ£Ëπ¶Ëπ§ËπüËπïËªÄËΩâËΩçÈÇáÈÇÉÈÇàÈÜ´ÈÜ¨ÈáêÈéîÈéäÈéñÈé¢Èé≥ÈéÆÈé¨Èé∞ÈéòÈéöÈéóÈóîÈóñÈóêÈóïÈõ¢ÈõúÈõôÈõõÈõûÈú§Èû£Èû¶"],["c340","Èû≠ÈüπÈ°çÈ°èÈ°åÈ°éÈ°ìÈ¢∫È§æÈ§øÈ§ΩÈ§ÆÈ¶•È®éÈ´ÅÈ¨ÉÈ¨ÜÈ≠èÈ≠éÈ≠çÈØäÈØâÈØΩÈØàÈØÄÈµëÈµùÈµ†Èª†ÈºïÈº¨ÂÑ≥Âö•Â£ûÂ£üÂ£¢ÂØµÈæêÂª¨Êá≤Êá∑Êá∂ÊáµÊîÄÊîèÊõ†ÊõùÊ´•Ê´ùÊ´öÊ´ìÁÄõÁÄüÁÄ®ÁÄöÁÄùÁÄïÁÄòÁàÜÁàçÁâòÁä¢Áç∏"],["c3a1","Áç∫ÁíΩÁìäÁì£ÁñáÁñÜÁôüÁô°ÁüáÁ§ôÁ¶±Á©´Á©©Á∞æÁ∞øÁ∞∏Á∞ΩÁ∞∑Á±ÄÁπ´Áπ≠ÁππÁπ©Áπ™ÁæÖÁπ≥Áæ∂ÁæπÁæ∏ËáòËó©ËóùËó™ËóïËó§Ëó•Ëó∑ËüªË†ÖË†çËüπËüæË•†Ë•üË•ñË•ûË≠ÅË≠úË≠òË≠âË≠öË≠éË≠èË≠ÜË≠ôË¥àË¥äËπºËπ≤Ë∫áËπ∂Ëπ¨Ëπ∫Ëπ¥ËΩîËΩéËæ≠ÈÇäÈÇãÈÜ±ÈÜÆÈè°ÈèëÈèüÈèÉÈèàÈèúÈèùÈèñÈè¢ÈèçÈèòÈè§ÈèóÈè®ÈóúÈö¥Èõ£Èú™ÈúßÈù°ÈüúÈüªÈ°û"],["c440","È°òÈ°õÈ¢ºÈ•ÖÈ•âÈ®ñÈ®ôÈ¨çÈØ®ÈØßÈØñÈØõÈ∂âÈµ°Èµ≤Èµ™Èµ¨È∫íÈ∫óÈ∫ìÈ∫¥Âã∏Âö®Âö∑Âö∂Âö¥ÂöºÂ£§Â≠ÄÂ≠ÉÂ≠ΩÂØ∂Â∑âÊá∏Êá∫ÊîòÊîîÊîôÊõ¶ÊúßÊ´¨ÁÄæÁÄ∞ÁÄ≤ÁàêÁçªÁìèÁô¢Áô•Á§¶Á§™Á§¨Á§´Á´áÁ´∂Á±åÁ±ÉÁ±çÁ≥ØÁ≥∞ËæÆÁπΩÁπº"],["c4a1","Á∫ÇÁΩåËÄÄËáöËâ¶ËóªËóπËòëËó∫ËòÜËòãËòáËòäË†îË†ïË•§Ë¶∫Ëß∏Ë≠∞Ë≠¨Ë≠¶Ë≠ØË≠üË≠´Ë¥èË¥çË∫âË∫ÅË∫ÖË∫ÇÈÜ¥ÈáãÈêòÈêÉÈèΩÈó°Èú∞È£ÑÈ•íÈ•ëÈ¶®È®´È®∞È®∑È®µÈ∞ìÈ∞çÈππÈ∫µÈª®ÈºØÈΩüÈΩ£ÈΩ°ÂÑ∑ÂÑ∏ÂõÅÂõÄÂõÇÂ§îÂ±¨Â∑çÊáºÊáæÊîùÊîúÊñïÊõ©Ê´ªÊ¨ÑÊ´∫ÊÆ≤ÁÅåÁàõÁäßÁìñÁìîÁô©ÁüìÁ±êÁ∫èÁ∫åÁæºËòóËò≠ËòöË†£Ë†¢Ë†°Ë†üË•™Ë•¨Ë¶ΩË≠¥"],["c540","Ë≠∑Ë≠ΩË¥ìË∫äË∫çË∫ãËΩüËæØÈÜ∫ÈêÆÈê≥ÈêµÈê∫Èê∏Èê≤Èê´Èó¢Èú∏ÈúπÈú≤ÈüøÈ°ßÈ°•È•óÈ©ÖÈ©ÉÈ©ÄÈ®æÈ´èÈ≠îÈ≠ëÈ∞≠È∞•È∂ØÈ∂¥È∑ÇÈ∂∏È∫ùÈªØÈºôÈΩúÈΩ¶ÈΩßÂÑºÂÑªÂõàÂõäÂõâÂ≠øÂ∑îÂ∑íÂΩéÊáøÊî§Ê¨äÊ≠°ÁÅëÁÅòÁéÄÁì§ÁñäÁôÆÁô¨"],["c5a1","Á¶≥Á±†Á±üËÅæËÅΩËáüË•≤Ë•ØËßºËÆÄË¥ñË¥óË∫ëË∫ìËΩ°ÈÖàÈëÑÈëëÈëíÈúΩÈúæÈüÉÈüÅÈ°´È•ïÈ©ïÈ©çÈ´íÈ¨öÈ±âÈ∞±È∞æÈ∞ªÈ∑ìÈ∑óÈº¥ÈΩ¨ÈΩ™ÈæîÂõåÂ∑ñÊàÄÊî£Êî´Êî™Êõ¨Ê¨êÁìöÁ´äÁ±§Á±£Á±•Á∫ìÁ∫ñÁ∫îËá¢Ëò∏ËòøË†±ËÆäÈÇêÈÇèÈë£Èë†Èë§Èù®È°ØÈ•úÈ©öÈ©õÈ©óÈ´ìÈ´îÈ´ëÈ±îÈ±óÈ±ñÈ∑•È∫üÈª¥ÂõëÂ£©Êî¨ÁÅûÁô±Áô≤ÁüóÁΩêÁæàË†∂Ë†πË°¢ËÆìËÆí"],["c640","ËÆñËâ∑Ë¥õÈáÄÈë™ÈùÇÈùàÈùÑÈüÜÈ°∞È©üÈ¨¢È≠òÈ±üÈ∑πÈ∑∫ÈπºÈπΩÈºáÈΩ∑ÈΩ≤Âª≥Ê¨ñÁÅ£Á±¨Á±ÆË†ªËßÄË∫°ÈáÅÈë≤Èë∞È°±È•ûÈ´ñÈ¨£ÈªåÁÅ§ÁüöËÆöÈë∑ÈüâÈ©¢È©•Á∫úËÆúË∫™ÈáÖÈëΩÈëæÈëºÈ±∑È±∏Èª∑Ë±îÈëøÈ∏öÁà®È©™È¨±È∏õÈ∏ûÁ±≤"],["c940","‰πÇ‰πúÂáµÂåöÂéÇ‰∏á‰∏å‰πá‰∫çÂõóÔ®åÂ±ÆÂΩ≥‰∏èÂÜá‰∏é‰∏Æ‰∫ì‰ªÇ‰ªâ‰ªàÂÜòÂãºÂç¨ÂéπÂú†Â§ÉÂ§¨Â∞êÂ∑øÊó°ÊÆ≥ÊØåÊ∞îÁàø‰∏±‰∏º‰ª®‰ªú‰ª©‰ª°‰ªù‰ªöÂàåÂåúÂçåÂú¢Âú£Â§óÂ§ØÂÆÅÂÆÑÂ∞íÂ∞ªÂ±¥Â±≥Â∏ÑÂ∫ÄÂ∫ÇÂøâÊàâÊâêÊ∞ï"],["c9a1","Ê∞∂Ê±ÉÊ∞øÊ∞ªÁäÆÁä∞ÁéäÁ¶∏ËÇäÈòû‰ºé‰ºò‰º¨‰ªµ‰ºî‰ª±‰ºÄ‰ª∑‰ºà‰ºù‰ºÇ‰ºÖ‰º¢‰ºì‰ºÑ‰ª¥‰ºíÂÜ±ÂàìÂàâÂàêÂä¶Âå¢ÂåüÂççÂéäÂêáÂõ°ÂõüÂúÆÂú™Âú¥Â§ºÂ¶ÄÂ•ºÂ¶ÖÂ•ªÂ•æÂ•∑Â•øÂ≠ñÂ∞ïÂ∞•Â±ºÂ±∫Â±ªÂ±æÂ∑üÂπµÂ∫ÑÂºÇÂºöÂΩ¥ÂøïÂøîÂøèÊâúÊâûÊâ§Êâ°Êâ¶Êâ¢ÊâôÊâ†ÊâöÊâ•ÊóØÊóÆÊúæÊúπÊú∏ÊúªÊú∫ÊúøÊúºÊú≥Ê∞òÊ±ÜÊ±íÊ±úÊ±èÊ±äÊ±îÊ±ã"],["ca40","Ê±åÁÅ±ÁâûÁä¥ÁäµÁééÁî™ÁôøÁ©µÁΩëËâ∏ËâºËäÄËâΩËâøËôçË•æÈÇôÈÇóÈÇòÈÇõÈÇîÈò¢Èò§Èò†Èò£‰Ωñ‰ºª‰Ω¢‰Ωâ‰Ωì‰Ω§‰ºæ‰Ωß‰Ωí‰Ωü‰ΩÅ‰Ωò‰º≠‰º≥‰ºø‰Ω°ÂÜèÂÜπÂàúÂàûÂà°Âä≠ÂäÆÂåâÂç£Âç≤ÂééÂéèÂê∞Âê∑Âê™ÂëîÂëÖÂêôÂêúÂê•Âêò"],["caa1","ÂêΩÂëèÂëÅÂê®Âê§ÂëáÂõÆÂõßÂõ•ÂùÅÂùÖÂùåÂùâÂùãÂùíÂ§ÜÂ•ÄÂ¶¶Â¶òÂ¶†Â¶óÂ¶éÂ¶¢Â¶êÂ¶èÂ¶ßÂ¶°ÂÆéÂÆíÂ∞®Â∞™Â≤çÂ≤èÂ≤àÂ≤ãÂ≤âÂ≤íÂ≤äÂ≤ÜÂ≤ìÂ≤ïÂ∑†Â∏äÂ∏éÂ∫ãÂ∫âÂ∫åÂ∫àÂ∫çÂºÖÂºùÂΩ∏ÂΩ∂ÂøíÂøëÂøêÂø≠Âø®ÂøÆÂø≥Âø°Âø§Âø£Âø∫ÂøØÂø∑ÂøªÊÄÄÂø¥Êà∫ÊäÉÊäåÊäéÊäèÊäîÊäáÊâ±ÊâªÊâ∫Êâ∞ÊäÅÊäàÊâ∑ÊâΩÊâ≤Êâ¥Êî∑Êó∞Êó¥Êó≥Êó≤ÊóµÊùÖÊùá"],["cb40","ÊùôÊùïÊùåÊùàÊùùÊùçÊùöÊùãÊØêÊ∞ôÊ∞öÊ±∏Ê±ßÊ±´Ê≤ÑÊ≤ãÊ≤èÊ±±Ê±ØÊ±©Ê≤öÊ±≠Ê≤áÊ≤ïÊ≤úÊ±¶Ê±≥Ê±•Ê±ªÊ≤éÁÅ¥ÁÅ∫Áâ£ÁäøÁäΩÁãÉÁãÜÁãÅÁä∫ÁãÖÁéïÁéóÁéìÁéîÁéíÁî∫ÁîπÁñîÁñïÁöÅÁ§ΩËÄ¥ËÇïËÇôËÇêËÇíËÇúËäêËäèËäÖËäéËäëËäì"],["cba1","ËääËäÉËäÑË±∏ËøâËæøÈÇüÈÇ°ÈÇ•ÈÇûÈÇßÈÇ†Èò∞Èò®ÈòØÈò≠‰∏≥‰æò‰Ωº‰æÖ‰ΩΩ‰æÄ‰æá‰Ω∂‰Ω¥‰æâ‰æÑ‰Ω∑‰Ωå‰æó‰Ω™‰æö‰Ωπ‰æÅ‰Ω∏‰æê‰æú‰æî‰æû‰æí‰æÇ‰æï‰Ω´‰ΩÆÂÜûÂÜºÂÜæÂàµÂà≤Âà≥ÂâÜÂà±ÂäºÂåäÂåãÂåºÂéíÂéîÂíáÂëøÂíÅÂíëÂíÇÂíàÂë´Âë∫ÂëæÂë•Âë¨Âë¥Âë¶ÂíçÂëØÂë°Âë†ÂíòÂë£ÂëßÂë§Âõ∑ÂõπÂùØÂù≤Âù≠Âù´Âù±Âù∞Âù∂ÂûÄÂùµÂùªÂù≥Âù¥Âù¢"],["cc40","Âù®ÂùΩÂ§åÂ•ÖÂ¶µÂ¶∫ÂßèÂßéÂ¶≤ÂßåÂßÅÂ¶∂Â¶ºÂßÉÂßñÂ¶±Â¶ΩÂßÄÂßàÂ¶¥ÂßáÂ≠¢Â≠•ÂÆìÂÆïÂ±ÑÂ±áÂ≤ÆÂ≤§Â≤†Â≤µÂ≤ØÂ≤®Â≤¨Â≤üÂ≤£Â≤≠Â≤¢Â≤™Â≤ßÂ≤ùÂ≤•Â≤∂Â≤∞Â≤¶Â∏óÂ∏îÂ∏ôÂº®Âº¢Âº£Âº§ÂΩîÂæÇÂΩæÂΩΩÂøûÂø•ÊÄ≠ÊÄ¶ÊÄôÊÄ≤ÊÄã"],["cca1","ÊÄ¥ÊÄäÊÄóÊÄ≥ÊÄöÊÄûÊÄ¨ÊÄ¢ÊÄçÊÄêÊÄÆÊÄìÊÄëÊÄåÊÄâÊÄúÊàîÊàΩÊä≠Êä¥ÊãëÊäæÊä™Êä∂ÊãäÊäÆÊä≥ÊäØÊäªÊä©Êä∞Êä∏ÊîΩÊñ®ÊñªÊòâÊóºÊòÑÊòíÊòàÊóªÊòÉÊòãÊòçÊòÖÊóΩÊòëÊòêÊõ∂ÊúäÊûÖÊù¨ÊûéÊûíÊù∂ÊùªÊûòÊûÜÊûÑÊù¥ÊûçÊûåÊù∫ÊûüÊûëÊûôÊûÉÊùΩÊûÅÊù∏ÊùπÊûîÊ¨•ÊÆÄÊ≠æÊØûÊ∞ùÊ≤ìÊ≥¨Ê≥´Ê≥ÆÊ≥ôÊ≤∂Ê≥îÊ≤≠Ê≥ßÊ≤∑Ê≥êÊ≥ÇÊ≤∫Ê≥ÉÊ≥ÜÊ≥≠Ê≥≤"],["cd40","Ê≥íÊ≥ùÊ≤¥Ê≤äÊ≤ùÊ≤ÄÊ≥ûÊ≥ÄÊ¥∞Ê≥çÊ≥áÊ≤∞Ê≥πÊ≥èÊ≥©Ê≥ëÁÇîÁÇòÁÇÖÁÇìÁÇÜÁÇÑÁÇëÁÇñÁÇÇÁÇöÁÇÉÁâ™ÁãñÁããÁãòÁãâÁãúÁãíÁãîÁãöÁãåÁãëÁé§Áé°Áé≠Áé¶Áé¢Áé†Áé¨ÁéùÁìùÁì®ÁîøÁïÄÁîæÁñåÁñòÁöØÁõ≥Áõ±Áõ∞ÁõµÁü∏ÁüºÁüπÁüªÁü∫"],["cda1","Áü∑Á•ÇÁ§øÁßÖÁ©∏Á©ªÁ´ªÁ±µÁ≥ΩËÄµËÇèËÇÆËÇ£ËÇ∏ËÇµËÇ≠Ëà†Ëä†ËãÄËä´ËäöËäòËäõËäµËäßËäÆËäºËäûËä∫Ëä¥Ëä®Ëä°Ëä©ËãÇËä§ËãÉËä∂Ëä¢Ëô∞ËôØËô≠ËôÆË±ñËøíËøãËøìËøçËøñËøïËøóÈÇ≤ÈÇ¥ÈÇØÈÇ≥ÈÇ∞ÈòπÈòΩÈòºÈò∫ÈôÉ‰øç‰øÖ‰øì‰æ≤‰øâ‰øã‰øÅ‰øî‰øú‰øô‰æª‰æ≥‰øõ‰øá‰øñ‰æ∫‰øÄ‰æπ‰ø¨ÂâÑÂââÂãÄÂãÇÂåΩÂçºÂéóÂéñÂéôÂéòÂí∫Âí°Âí≠Âí•Âìè"],["ce40","ÂìÉËåçÂí∑ÂíÆÂìñÂí∂ÂìÖÂìÜÂí†Âë∞ÂíºÂí¢ÂíæÂë≤ÂìûÂí∞ÂûµÂûûÂûüÂû§ÂûåÂûóÂûùÂûõÂûîÂûòÂûèÂûôÂû•ÂûöÂûïÂ£¥Â§çÂ•ìÂß°ÂßûÂßÆÂ®ÄÂß±ÂßùÂß∫ÂßΩÂßºÂß∂Âß§Âß≤Âß∑ÂßõÂß©Âß≥ÂßµÂß†ÂßæÂß¥Âß≠ÂÆ®Â±åÂ≥êÂ≥òÂ≥åÂ≥óÂ≥ãÂ≥õ"],["cea1","Â≥ûÂ≥öÂ≥âÂ≥áÂ≥äÂ≥ñÂ≥ìÂ≥îÂ≥èÂ≥àÂ≥ÜÂ≥éÂ≥üÂ≥∏Â∑πÂ∏°Â∏¢Â∏£Â∏†Â∏§Â∫∞Â∫§Â∫¢Â∫õÂ∫£Â∫•ÂºáÂºÆÂΩñÂæÜÊÄ∑ÊÄπÊÅîÊÅ≤ÊÅûÊÅÖÊÅìÊÅáÊÅâÊÅõÊÅåÊÅÄÊÅÇÊÅüÊÄ§ÊÅÑÊÅòÊÅ¶ÊÅÆÊâÇÊâÉÊãèÊåçÊåãÊãµÊåéÊåÉÊã´ÊãπÊåèÊååÊã∏Êã∂ÊåÄÊåìÊåîÊã∫ÊåïÊãªÊã∞ÊïÅÊïÉÊñ™ÊñøÊò∂Êò°Êò≤ÊòµÊòúÊò¶Êò¢Êò≥Êò´Êò∫ÊòùÊò¥ÊòπÊòÆÊúèÊúêÊüÅÊü≤ÊüàÊû∫"],["cf40","ÊüúÊûªÊü∏ÊüòÊüÄÊû∑ÊüÖÊü´Êü§ÊüüÊûµÊüçÊû≥Êü∑Êü∂ÊüÆÊü£ÊüÇÊûπÊüéÊüßÊü∞Êû≤ÊüºÊüÜÊü≠ÊüåÊûÆÊü¶ÊüõÊü∫ÊüâÊüäÊüÉÊü™ÊüãÊ¨®ÊÆÇÊÆÑÊÆ∂ÊØñÊØòÊØ†Ê∞†Ê∞°Ê¥®Ê¥¥Ê¥≠Ê¥üÊ¥ºÊ¥øÊ¥íÊ¥äÊ≥öÊ¥≥Ê¥ÑÊ¥ôÊ¥∫Ê¥öÊ¥ëÊ¥ÄÊ¥ùÊµÇ"],["cfa1","Ê¥ÅÊ¥òÊ¥∑Ê¥ÉÊ¥èÊµÄÊ¥áÊ¥†Ê¥¨Ê¥àÊ¥¢Ê¥âÊ¥êÁÇ∑ÁÇüÁÇæÁÇ±ÁÇ∞ÁÇ°ÁÇ¥ÁÇµÁÇ©ÁâÅÁââÁâäÁâ¨Áâ∞Áâ≥ÁâÆÁãäÁã§Áã®Áã´ÁãüÁã™Áã¶Áã£ÁéÖÁèåÁèÇÁèàÁèÖÁéπÁé∂ÁéµÁé¥Áè´ÁéøÁèáÁéæÁèÉÁèÜÁé∏ÁèãÁì¨ÁìÆÁîÆÁïáÁïàÁñßÁñ™ÁôπÁõÑÁúàÁúÉÁúÑÁúÖÁúäÁõ∑ÁõªÁõ∫ÁüßÁü®Á†ÜÁ†ëÁ†íÁ†ÖÁ†êÁ†èÁ†éÁ†âÁ†ÉÁ†ìÁ•äÁ•åÁ•ãÁ•ÖÁ•ÑÁßïÁßçÁßèÁßñÁßéÁ™Ä"],["d040","Á©æÁ´ëÁ¨ÄÁ¨ÅÁ±∫Á±∏Á±πÁ±øÁ≤ÄÁ≤ÅÁ¥ÉÁ¥àÁ¥ÅÁΩòÁæëÁæçÁææËÄáËÄéËÄèËÄîËÄ∑ËÉòËÉáËÉ†ËÉëËÉàËÉÇËÉêËÉÖËÉ£ËÉôËÉúËÉäËÉïËÉâËÉèËÉóËÉ¶ËÉçËáøËà°ËäîËãôËãæËãπËåáËã®ËåÄËãïËå∫Ëã´ËãñËã¥Ëã¨Ëã°Ëã≤ËãµËååËãªËã∂Ëã∞Ëã™"],["d0a1","Ëã§Ëã†Ëã∫Ëã≥Ëã≠Ëô∑Ëô¥ËôºËô≥Ë°ÅË°éË°ßË°™Ë°©ËßìË®ÑË®áËµ≤Ëø£Ëø°ËøÆËø†ÈÉ±ÈÇΩÈÇøÈÉïÈÉÖÈÇæÈÉáÈÉãÈÉàÈáîÈáìÈôîÈôèÈôëÈôìÈôäÈôéÂÄûÂÄÖÂÄáÂÄìÂÄ¢ÂÄ∞ÂÄõ‰øµ‰ø¥ÂÄ≥ÂÄ∑ÂÄ¨‰ø∂‰ø∑ÂÄóÂÄúÂÄ†ÂÄßÂÄµÂÄØÂÄ±ÂÄéÂÖöÂÜîÂÜìÂáäÂáÑÂáÖÂáàÂáéÂâ°ÂâöÂâíÂâûÂâüÂâïÂâ¢ÂãçÂåéÂéûÂî¶Âì¢ÂîóÂîíÂìßÂì≥Âì§ÂîöÂìøÂîÑÂîàÂì´ÂîëÂîÖÂì±"],["d140","ÂîäÂìªÂì∑Âì∏Âì†ÂîéÂîÉÂîãÂúÅÂúÇÂüåÂ†≤ÂüïÂüíÂû∫ÂüÜÂûΩÂûºÂû∏Âû∂ÂûøÂüáÂüêÂûπÂüÅÂ§éÂ•äÂ®ôÂ®ñÂ®≠Â®ÆÂ®ïÂ®èÂ®óÂ®äÂ®ûÂ®≥Â≠¨ÂÆßÂÆ≠ÂÆ¨Â∞ÉÂ±ñÂ±îÂ≥¨Â≥øÂ≥ÆÂ≥±Â≥∑Â¥ÄÂ≥πÂ∏©Â∏®Â∫®Â∫ÆÂ∫™Â∫¨Âº≥Âº∞ÂΩßÊÅùÊÅöÊÅß"],["d1a1","ÊÅÅÊÇ¢ÊÇàÊÇÄÊÇíÊÇÅÊÇùÊÇÉÊÇïÊÇõÊÇóÊÇáÊÇúÊÇéÊàôÊâÜÊã≤ÊåêÊçñÊå¨ÊçÑÊçÖÊå∂ÊçÉÊè§ÊåπÊçãÊçäÊåºÊå©ÊçÅÊå¥ÊçòÊçîÊçôÊå≠ÊçáÊå≥ÊçöÊçëÊå∏ÊçóÊçÄÊçàÊïäÊïÜÊóÜÊóÉÊóÑÊóÇÊôäÊôüÊôáÊôëÊúíÊúìÊ†üÊ†öÊ°âÊ†≤Ê†≥Ê†ªÊ°ãÊ°èÊ†ñÊ†±Ê†úÊ†µÊ†´Ê†≠Ê†ØÊ°éÊ°ÑÊ†¥Ê†ùÊ†íÊ†îÊ†¶Ê†®Ê†ÆÊ°çÊ†∫Ê†•Ê††Ê¨¨Ê¨ØÊ¨≠Ê¨±Ê¨¥Ê≠≠ËÇÇÊÆàÊØ¶ÊØ§"],["d240","ÊØ®ÊØ£ÊØ¢ÊØßÊ∞•Êµ∫Êµ£Êµ§Êµ∂Ê¥çÊµ°Ê∂íÊµòÊµ¢Êµ≠ÊµØÊ∂ëÊ∂çÊ∑ØÊµøÊ∂ÜÊµûÊµßÊµ†Ê∂óÊµ∞ÊµºÊµüÊ∂ÇÊ∂òÊ¥ØÊµ®Ê∂ãÊµæÊ∂ÄÊ∂ÑÊ¥ñÊ∂ÉÊµªÊµΩÊµµÊ∂êÁÉúÁÉìÁÉëÁÉùÁÉãÁºπÁÉ¢ÁÉóÁÉíÁÉûÁÉ†ÁÉîÁÉçÁÉÖÁÉÜÁÉáÁÉöÁÉéÁÉ°ÁâÇÁâ∏"],["d2a1","Áâ∑Áâ∂ÁåÄÁã∫Áã¥ÁãæÁã∂Áã≥ÁãªÁåÅÁèìÁèôÁè•ÁèñÁéºÁèßÁè£Áè©ÁèúÁèíÁèõÁèîÁèùÁèöÁèóÁèòÁè®ÁìûÁìüÁì¥ÁìµÁî°ÁïõÁïüÁñ∞ÁóÅÁñªÁóÑÁóÄÁñøÁñ∂Áñ∫ÁöäÁõâÁúùÁúõÁúêÁúìÁúíÁú£ÁúëÁúïÁúôÁúöÁú¢ÁúßÁ†£Á†¨Á†¢Á†µÁ†ØÁ†®Á†ÆÁ†´Á†°Á†©Á†≥Á†™Á†±Á•îÁ•õÁ•èÁ•úÁ•ìÁ•íÁ•ëÁß´Áß¨Áß†ÁßÆÁß≠Áß™ÁßúÁßûÁßùÁ™ÜÁ™âÁ™ÖÁ™ãÁ™åÁ™äÁ™áÁ´òÁ¨ê"],["d340","Á¨ÑÁ¨ìÁ¨ÖÁ¨èÁ¨àÁ¨äÁ¨éÁ¨âÁ¨íÁ≤ÑÁ≤ëÁ≤äÁ≤åÁ≤àÁ≤çÁ≤ÖÁ¥ûÁ¥ùÁ¥ëÁ¥éÁ¥òÁ¥ñÁ¥ìÁ¥üÁ¥íÁ¥èÁ¥åÁΩúÁΩ°ÁΩûÁΩ†ÁΩùÁΩõÁæñÁæíÁøÉÁøÇÁøÄËÄñËÄæËÄπËÉ∫ËÉ≤ËÉπËÉµËÑÅËÉªËÑÄËàÅËàØËà•Ëå≥Ëå≠ËçÑËåôËçëËå•ËçñËåøËçÅËå¶ËåúËå¢"],["d3a1","ËçÇËçéËåõËå™ËåàËåºËççËåñËå§Ëå†Ëå∑ËåØËå©ËçáËçÖËçåËçìËåûËå¨ËçãËåßËçàËôìËôíËö¢Ëö®ËöñËöçËöëËöûËöáËöóËöÜËöãËööËöÖËö•ËöôËö°ËößËöïËöòËöéËöùËöêËöîË°ÉË°ÑË°≠Ë°µË°∂Ë°≤Ë¢ÄË°±Ë°øË°ØË¢ÉË°æË°¥Ë°ºË®íË±áË±óË±ªË≤§Ë≤£Ëµ∂Ëµ∏Ë∂µË∂∑Ë∂∂ËªëËªìËøæËøµÈÄÇËøøËøªÈÄÑËøºËø∂ÈÉñÈÉ†ÈÉôÈÉöÈÉ£ÈÉüÈÉ•ÈÉòÈÉõÈÉóÈÉúÈÉ§ÈÖê"],["d440","ÈÖéÈÖèÈáïÈá¢ÈáöÈôúÈôüÈöºÈ££È´üÈ¨Ø‰πøÂÅ∞ÂÅ™ÂÅ°ÂÅûÂÅ†ÂÅìÂÅãÂÅùÂÅ≤ÂÅàÂÅçÂÅÅÂÅõÂÅäÂÅ¢ÂÄïÂÅÖÂÅüÂÅ©ÂÅ´ÂÅ£ÂÅ§ÂÅÜÂÅÄÂÅÆÂÅ≥ÂÅóÂÅëÂáêÂâ´Ââ≠Ââ¨ÂâÆÂãñÂãìÂå≠ÂéúÂïµÂï∂ÂîºÂïçÂïêÂî¥Âî™ÂïëÂï¢Âî∂ÂîµÂî∞ÂïíÂïÖ"],["d4a1","ÂîåÂî≤Âï•ÂïéÂîπÂïàÂî≠ÂîªÂïÄÂïãÂúäÂúáÂüªÂ†îÂü¢Âü∂ÂüúÂü¥Â†ÄÂü≠ÂüΩÂ†àÂü∏Â†ãÂü≥ÂüèÂ†áÂüÆÂü£Âü≤Âü•Âü¨Âü°Â†éÂüºÂ†êÂüßÂ†ÅÂ†åÂü±Âü©Âü∞Â†çÂ†ÑÂ•úÂ©†Â©òÂ©ïÂ©ßÂ©ûÂ®∏Â®µÂ©≠Â©êÂ©üÂ©•Â©¨Â©ìÂ©§Â©óÂ©ÉÂ©ùÂ©íÂ©ÑÂ©õÂ©àÂ™éÂ®æÂ©çÂ®πÂ©åÂ©∞Â©©Â©áÂ©ëÂ©ñÂ©ÇÂ©úÂ≠≤Â≠ÆÂØÅÂØÄÂ±ôÂ¥ûÂ¥ãÂ¥ùÂ¥öÂ¥†Â¥åÂ¥®Â¥çÂ¥¶Â¥•Â¥è"],["d540","Â¥∞Â¥íÂ¥£Â¥üÂ¥ÆÂ∏æÂ∏¥Â∫±Â∫¥Â∫πÂ∫≤Â∫≥Âº∂Âº∏ÂæõÂæñÂæüÊÇäÊÇêÊÇÜÊÇæÊÇ∞ÊÇ∫ÊÉìÊÉîÊÉèÊÉ§ÊÉôÊÉùÊÉàÊÇ±ÊÉõÊÇ∑ÊÉäÊÇøÊÉÉÊÉçÊÉÄÊå≤Êç•ÊéäÊéÇÊçΩÊéΩÊéûÊé≠ÊéùÊéóÊé´ÊééÊçØÊéáÊéêÊçÆÊéØÊçµÊéúÊç≠ÊéÆÊçºÊé§ÊåªÊéü"],["d5a1","Êç∏ÊéÖÊéÅÊéëÊéçÊç∞ÊïìÊóçÊô•Êô°ÊôõÊôôÊôúÊô¢ÊúòÊ°πÊ¢áÊ¢êÊ¢úÊ°≠Ê°ÆÊ¢ÆÊ¢´Ê•ñÊ°ØÊ¢£Ê¢¨Ê¢©Ê°µÊ°¥Ê¢≤Ê¢èÊ°∑Ê¢íÊ°ºÊ°´Ê°≤Ê¢™Ê¢ÄÊ°±Ê°æÊ¢õÊ¢ñÊ¢ãÊ¢†Ê¢âÊ¢§Ê°∏Ê°ªÊ¢ëÊ¢åÊ¢äÊ°ΩÊ¨∂Ê¨≥Ê¨∑Ê¨∏ÊÆëÊÆèÊÆçÊÆéÊÆåÊ∞™Ê∑ÄÊ∂´Ê∂¥Ê∂≥Êπ¥Ê∂¨Ê∑©Ê∑¢Ê∂∑Ê∑∂Ê∑îÊ∏ÄÊ∑àÊ∑†Ê∑üÊ∑ñÊ∂æÊ∑•Ê∑úÊ∑ùÊ∑õÊ∑¥Ê∑äÊ∂ΩÊ∑≠Ê∑∞Ê∂∫Ê∑ïÊ∑ÇÊ∑èÊ∑â"],["d640","Ê∑êÊ∑≤Ê∑ìÊ∑ΩÊ∑óÊ∑çÊ∑£Ê∂ªÁÉ∫ÁÑçÁÉ∑ÁÑóÁÉ¥ÁÑåÁÉ∞ÁÑÑÁÉ≥ÁÑêÁÉºÁÉøÁÑÜÁÑìÁÑÄÁÉ∏ÁÉ∂ÁÑãÁÑÇÁÑéÁâæÁâªÁâºÁâøÁåùÁåóÁåáÁåëÁåòÁåäÁåàÁãøÁåèÁåûÁéàÁè∂Áè∏ÁèµÁêÑÁêÅÁèΩÁêáÁêÄÁè∫ÁèºÁèøÁêåÁêãÁè¥ÁêàÁï§Áï£ÁóéÁóíÁóè"],["d6a1","ÁóãÁóåÁóëÁóêÁöèÁöâÁõìÁúπÁúØÁú≠Áú±Áú≤Áú¥Áú≥ÁúΩÁú•ÁúªÁúµÁ°àÁ°íÁ°âÁ°çÁ°äÁ°åÁ†¶Á°ÖÁ°êÁ•§Á•ßÁ•©Á•™Á•£Á•´Á•°Á¶ªÁß∫Áß∏Áß∂Áß∑Á™èÁ™îÁ™êÁ¨µÁ≠áÁ¨¥Á¨•Á¨∞Á¨¢Á¨§Á¨≥Á¨òÁ¨™Á¨ùÁ¨±Á¨´Á¨≠Á¨ØÁ¨≤Á¨∏Á¨öÁ¨£Á≤îÁ≤òÁ≤ñÁ≤£Á¥µÁ¥ΩÁ¥∏Á¥∂Á¥∫ÁµÖÁ¥¨Á¥©ÁµÅÁµáÁ¥æÁ¥øÁµäÁ¥ªÁ¥®ÁΩ£ÁæïÁæúÁæùÁæõÁøäÁøãÁøçÁøêÁøëÁøáÁøèÁøâËÄü"],["d740","ËÄûËÄõËÅáËÅÉËÅàËÑòËÑ•ËÑôËÑõËÑ≠ËÑüËÑ¨ËÑûËÑ°ËÑïËÑßËÑùËÑ¢ËàëËà∏Ëà≥Ëà∫Ëà¥Ëà≤Ëâ¥ËéêËé£Ëé®ËéçËç∫Ëç≥Ëé§Ëç¥ËéèËéÅËéïËéôËçµËéîËé©ËçΩËéÉËéåËéùËéõËé™ËéãËçæËé•ËéØËéàËéóËé∞ËçøËé¶ËéáËéÆËç∂ËéöËôôËôñËöøËö∑"],["d7a1","ËõÇËõÅËõÖËö∫Ëö∞ËõàËöπËö≥Ëö∏ËõåËö¥ËöªËöºËõÉËöΩËöæË°íË¢âË¢ïË¢®Ë¢¢Ë¢™Ë¢öË¢ëË¢°Ë¢üË¢òË¢ßË¢ôË¢õË¢óË¢§Ë¢¨Ë¢åË¢ìË¢éË¶ÇËßñËßôËßïË®∞Ë®ßË®¨Ë®ûË∞πË∞ªË±úË±ùË±ΩË≤•ËµΩËµªËµπË∂ºË∑ÇË∂πË∂øË∑ÅËªòËªûËªùËªúËªóËª†Ëª°ÈÄ§ÈÄãÈÄëÈÄúÈÄåÈÄ°ÈÉØÈÉ™ÈÉ∞ÈÉ¥ÈÉ≤ÈÉ≥ÈÉîÈÉ´ÈÉ¨ÈÉ©ÈÖñÈÖòÈÖöÈÖìÈÖïÈá¨Èá¥Èá±Èá≥Èá∏Èá§ÈáπÈá™"],["d840","Èá´Èá∑Èá®ÈáÆÈï∫ÈñÜÈñàÈôºÈô≠Èô´Èô±ÈôØÈöøÈù™È†ÑÈ£•È¶óÂÇõÂÇïÂÇîÂÇûÂÇãÂÇ£ÂÇÉÂÇåÂÇéÂÇùÂÅ®ÂÇúÂÇíÂÇÇÂÇáÂÖüÂáîÂåíÂåëÂé§ÂéßÂñëÂñ®Âñ•Âñ≠Âï∑ÂôÖÂñ¢ÂñìÂñàÂñèÂñµÂñÅÂñ£ÂñíÂñ§ÂïΩÂñåÂñ¶ÂïøÂñïÂñ°ÂñéÂúåÂ†©Â†∑"],["d8a1","Â†ôÂ†ûÂ†ßÂ†£Â†®ÂüµÂ°àÂ†•Â†úÂ†õÂ†≥Â†øÂ†∂Â†ÆÂ†πÂ†∏Â†≠Â†¨Â†ªÂ•°Â™ØÂ™îÂ™üÂ©∫Â™¢Â™ûÂ©∏Â™¶Â©ºÂ™•Â™¨Â™ïÂ™ÆÂ®∑Â™ÑÂ™äÂ™óÂ™ÉÂ™ãÂ™©Â©ªÂ©ΩÂ™åÂ™úÂ™èÂ™ìÂ™ùÂØ™ÂØçÂØãÂØîÂØëÂØäÂØéÂ∞åÂ∞∞Â¥∑ÂµÉÂµ´ÂµÅÂµãÂ¥øÂ¥µÂµëÂµéÂµïÂ¥≥Â¥∫ÂµíÂ¥ΩÂ¥±ÂµôÂµÇÂ¥πÂµâÂ¥∏Â¥ºÂ¥≤Â¥∂ÂµÄÂµÖÂπÑÂπÅÂΩòÂæ¶Âæ•Âæ´ÊÉâÊÇπÊÉåÊÉ¢ÊÉéÊÉÑÊÑî"],["d940","ÊÉ≤ÊÑäÊÑñÊÑÖÊÉµÊÑìÊÉ∏ÊÉºÊÉæÊÉÅÊÑÉÊÑòÊÑùÊÑêÊÉøÊÑÑÊÑãÊâäÊéîÊé±Êé∞ÊèéÊè•Êè®ÊèØÊèÉÊíùÊè≥ÊèäÊè†Êè∂ÊèïÊè≤ÊèµÊë°ÊèüÊéæÊèùÊèúÊèÑÊèòÊèìÊèÇÊèáÊèåÊèãÊèàÊè∞ÊèóÊèôÊî≤ÊïßÊï™Êï§ÊïúÊï®Êï•ÊñåÊñùÊñûÊñÆÊóêÊóí"],["d9a1","ÊôºÊô¨ÊôªÊöÄÊô±ÊôπÊô™Êô≤ÊúÅÊ§åÊ£ìÊ§ÑÊ£úÊ§™Ê£¨Ê£™Ê£±Ê§èÊ£ñÊ£∑Ê£´Ê£§Ê£∂Ê§ìÊ§êÊ£≥Ê£°Ê§áÊ£åÊ§àÊ•∞Ê¢¥Ê§ëÊ£ØÊ£ÜÊ§îÊ£∏Ê£êÊ£ΩÊ£ºÊ£®Ê§ãÊ§äÊ§óÊ£éÊ£àÊ£ùÊ£ûÊ£¶Ê£¥Ê£ëÊ§ÜÊ£îÊ£©Ê§ïÊ§•Ê£áÊ¨πÊ¨ªÊ¨øÊ¨ºÊÆîÊÆóÊÆôÊÆïÊÆΩÊØ∞ÊØ≤ÊØ≥Ê∞∞Ê∑ºÊπÜÊπáÊ∏üÊπâÊ∫àÊ∏ºÊ∏ΩÊπÖÊπ¢Ê∏´Ê∏øÊπÅÊπùÊπ≥Ê∏úÊ∏≥ÊπãÊπÄÊπëÊ∏ªÊ∏ÉÊ∏ÆÊπû"],["da40","Êπ®ÊπúÊπ°Ê∏±Ê∏®Êπ†Êπ±Êπ´Ê∏πÊ∏¢Ê∏∞ÊπìÊπ•Ê∏ßÊπ∏Êπ§Êπ∑ÊπïÊππÊπíÊπ¶Ê∏µÊ∏∂ÊπöÁÑ†ÁÑûÁÑØÁÉªÁÑÆÁÑ±ÁÑ£ÁÑ•ÁÑ¢ÁÑ≤ÁÑüÁÑ®ÁÑ∫ÁÑõÁâãÁâöÁäàÁäâÁäÜÁäÖÁäãÁåíÁåãÁå∞Áå¢Áå±Áå≥ÁåßÁå≤Áå≠Áå¶Áå£ÁåµÁååÁêÆÁê¨Áê∞Áê´Áêñ"],["daa1","ÁêöÁê°Áê≠Áê±Áê§Áê£ÁêùÁê©Áê†Áê≤ÁìªÁîØÁïØÁï¨ÁóßÁóöÁó°Áó¶ÁóùÁóüÁó§ÁóóÁöïÁöíÁõöÁùÜÁùáÁùÑÁùçÁùÖÁùäÁùéÁùãÁùåÁüûÁü¨Á°†Á°§Á°•Á°úÁ°≠Á°±Á°™Á°ÆÁ°∞Á°©Á°®Á°ûÁ°¢Á•¥Á•≥Á•≤Á•∞Á®ÇÁ®äÁ®ÉÁ®åÁ®ÑÁ™ôÁ´¶Á´§Á≠äÁ¨ªÁ≠ÑÁ≠àÁ≠åÁ≠éÁ≠ÄÁ≠òÁ≠ÖÁ≤¢Á≤ûÁ≤®Á≤°ÁµòÁµØÁµ£ÁµìÁµñÁµßÁµ™ÁµèÁµ≠ÁµúÁµ´ÁµíÁµîÁµ©ÁµëÁµüÁµéÁºæÁºøÁΩ•"],["db40","ÁΩ¶Áæ¢Áæ†Áæ°ÁøóËÅëËÅèËÅêËÉæËÉîËÖÉËÖäËÖíËÖèËÖáËÑΩËÖçËÑ∫Ëá¶ËáÆËá∑Ëá∏ËáπËàÑËàºËàΩËàøËâµËåªËèèËèπËê£ËèÄËè®ËêíËèßËè§ËèºËè∂ËêêËèÜËèàËè´Ëè£ËéøËêÅËèùËè•ËèòËèøËè°ËèãËèéËèñËèµËèâËêâËêèËèûËêëËêÜËèÇËè≥"],["dba1","ËèïËè∫ËèáËèëËè™ËêìËèÉËè¨ËèÆËèÑËèªËèóËè¢ËêõËèõËèæËõòËõ¢Ëõ¶ËõìËõ£ËõöËõ™ËõùËõ´ËõúËõ¨Ëõ©ËõóËõ®ËõëË°àË°ñË°ïË¢∫Ë£óË¢πË¢∏Ë£ÄË¢æË¢∂Ë¢ºË¢∑Ë¢ΩË¢≤Ë§ÅË£âË¶ïË¶òË¶óËßùËßöËßõË©éË©çË®πË©ôË©ÄË©óË©òË©ÑË©ÖË©íË©àË©ëË©äË©åË©èË±üË≤ÅË≤ÄË≤∫Ë≤æË≤∞Ë≤πË≤µË∂ÑË∂ÄË∂âË∑òË∑ìË∑çË∑áË∑ñË∑úË∑èË∑ïË∑ôË∑àË∑óË∑ÖËªØËª∑Ëª∫"],["dc40","ËªπËª¶ËªÆËª•ËªµËªßËª®Ëª∂Ëª´Ëª±Ëª¨Ëª¥Ëª©ÈÄ≠ÈÄ¥ÈÄØÈÑÜÈÑ¨ÈÑÑÈÉøÈÉºÈÑàÈÉπÈÉªÈÑÅÈÑÄÈÑáÈÑÖÈÑÉÈÖ°ÈÖ§ÈÖüÈÖ¢ÈÖ†ÈàÅÈàäÈà•ÈàÉÈàöÈà¶ÈàèÈàåÈàÄÈàíÈáøÈáΩÈàÜÈàÑÈàßÈàÇÈàúÈà§ÈàôÈàóÈàÖÈàñÈïªÈñçÈñåÈñêÈöáÈôæÈöà"],["dca1","ÈöâÈöÉÈöÄÈõÇÈõàÈõÉÈõ±Èõ∞Èù¨Èù∞ÈùÆÈ†áÈ¢©È£´È≥¶Èªπ‰∫É‰∫Ñ‰∫∂ÂÇΩÂÇøÂÉÜÂÇÆÂÉÑÂÉäÂÇ¥ÂÉàÂÉÇÂÇ∞ÂÉÅÂÇ∫ÂÇ±ÂÉãÂÉâÂÇ∂ÂÇ∏ÂáóÂâ∫Ââ∏ÂâªÂâºÂóÉÂóõÂóåÂóêÂóãÂóäÂóùÂóÄÂóîÂóÑÂó©ÂñøÂóíÂñçÂóèÂóïÂó¢ÂóñÂóàÂó≤ÂóçÂóôÂóÇÂúîÂ°ìÂ°®Â°§Â°èÂ°çÂ°âÂ°ØÂ°ïÂ°éÂ°ùÂ°ôÂ°•Â°õÂ†ΩÂ°£Â°±Â£ºÂ´áÂ´ÑÂ´ãÂ™∫Â™∏Â™±Â™µÂ™∞Â™øÂ´àÂ™ªÂ´Ü"],["dd40","Â™∑Â´ÄÂ´äÂ™¥Â™∂Â´çÂ™πÂ™êÂØñÂØòÂØôÂ∞üÂ∞≥Âµ±Âµ£ÂµäÂµ•Âµ≤Âµ¨ÂµûÂµ®ÂµßÂµ¢Â∑∞ÂπèÂπéÂπäÂπçÂπãÂªÖÂªåÂªÜÂªãÂªáÂΩÄÂæØÂæ≠ÊÉ∑ÊÖâÊÖäÊÑ´ÊÖÖÊÑ∂ÊÑ≤ÊÑÆÊÖÜÊÑØÊÖèÊÑ©ÊÖÄÊà†ÈÖ®Êà£Êà•Êà§ÊèÖÊè±Êè´ÊêêÊêíÊêâÊê†Êê§"],["dda1","Êê≥ÊëÉÊêüÊêïÊêòÊêπÊê∑Êê¢Êê£ÊêåÊê¶Êê∞Êê®ÊëÅÊêµÊêØÊêäÊêöÊëÄÊê•ÊêßÊêãÊèßÊêõÊêÆÊê°ÊêéÊïØÊñíÊóìÊöÜÊöåÊöïÊöêÊöãÊöäÊöôÊöîÊô∏Êú†Ê•¶Ê•üÊ§∏Ê•éÊ•¢Ê•±Ê§øÊ•ÖÊ•™Ê§πÊ•ÇÊ•óÊ•ôÊ•∫Ê•àÊ•âÊ§µÊ•¨Ê§≥Ê§ΩÊ••Ê£∞Ê•∏Ê§¥Ê•©Ê•ÄÊ•ØÊ•ÑÊ•∂Ê•òÊ•ÅÊ•¥Ê•åÊ§ªÊ•ãÊ§∑Ê•úÊ•èÊ•ëÊ§≤Ê•íÊ§ØÊ•ªÊ§ºÊ≠ÜÊ≠ÖÊ≠ÉÊ≠ÇÊ≠àÊ≠ÅÊÆõÔ®çÊØªÊØº"],["de40","ÊØπÊØ∑ÊØ∏Ê∫õÊªñÊªàÊ∫èÊªÄÊ∫üÊ∫ìÊ∫îÊ∫†Ê∫±Ê∫πÊªÜÊªíÊ∫ΩÊªÅÊ∫ûÊªâÊ∫∑Ê∫∞ÊªçÊ∫¶ÊªèÊ∫≤Ê∫æÊªÉÊªúÊªòÊ∫ôÊ∫íÊ∫éÊ∫çÊ∫§Ê∫°Ê∫øÊ∫≥ÊªêÊªäÊ∫óÊ∫ÆÊ∫£ÁÖáÁÖîÁÖíÁÖ£ÁÖ†ÁÖÅÁÖùÁÖ¢ÁÖ≤ÁÖ∏ÁÖ™ÁÖ°ÁÖÇÁÖòÁÖÉÁÖãÁÖ∞ÁÖüÁÖêÁÖì"],["dea1","ÁÖÑÁÖçÁÖöÁâèÁäçÁäåÁäëÁäêÁäéÁåºÁçÇÁåªÁå∫ÁçÄÁçäÁçâÁëÑÁëäÁëãÁëíÁëëÁëóÁëÄÁëèÁëêÁëéÁëÇÁëÜÁëçÁëîÁì°ÁìøÁìæÁìΩÁîùÁïπÁï∑Ê¶ÉÁóØÁòèÁòÉÁó∑ÁóæÁóºÁóπÁó∏ÁòêÁóªÁó∂Áó≠ÁóµÁóΩÁöôÁöµÁõùÁùïÁùüÁù†ÁùíÁùñÁùöÁù©ÁùßÁùîÁùôÁù≠Áü†Á¢áÁ¢öÁ¢îÁ¢èÁ¢ÑÁ¢ïÁ¢ÖÁ¢ÜÁ¢°Á¢ÉÁ°πÁ¢ôÁ¢ÄÁ¢ñÁ°ªÁ•ºÁ¶ÇÁ•ΩÁ•πÁ®ëÁ®òÁ®ôÁ®íÁ®óÁ®ïÁ®¢Á®ì"],["df40","Á®õÁ®êÁ™£Á™¢Á™ûÁ´´Á≠¶Á≠§Á≠≠Á≠¥Á≠©Á≠≤Á≠•Á≠≥Á≠±Á≠∞Á≠°Á≠∏Á≠∂Á≠£Á≤≤Á≤¥Á≤ØÁ∂àÁ∂ÜÁ∂ÄÁ∂çÁµøÁ∂ÖÁµ∫Á∂éÁµªÁ∂ÉÁµºÁ∂åÁ∂îÁ∂ÑÁµΩÁ∂íÁΩ≠ÁΩ´ÁΩßÁΩ®ÁΩ¨Áæ¶Áæ•ÁæßÁøõÁøúËÄ°ËÖ§ËÖ†ËÖ∑ËÖúËÖ©ËÖõËÖ¢ËÖ≤Êú°ËÖûËÖ∂ËÖßËÖØ"],["dfa1","ËÖÑËÖ°ËàùËââËâÑËâÄËâÇËâÖËì±ËêøËëñËë∂ËëπËíèËíçËë•ËëëËëÄËíÜËëßËê∞ËëçËëΩËëöËëôËë¥Ëë≥ËëùËîáËëûËê∑Ëê∫Ëê¥Ëë∫ËëÉËë∏Ëê≤ËëÖËê©ËèôËëãËêØËëÇËê≠ËëüËë∞ËêπËëéËëåËëíËëØËìÖËíéËêªËëáËê∂Ëê≥Ëë®ËëæËëÑËê´Ëë†ËëîËëÆËëêËúãËúÑËõ∑ËúåËõ∫ËõñËõµËùçËõ∏ËúéËúâËúÅËõ∂ËúçËúÖË£ñË£ãË£çË£éË£ûË£õË£öË£åË£êË¶ÖË¶õËßüËß•Ëß§"],["e040","Ëß°Ëß†Ëß¢ËßúËß¶Ë©∂Ë™ÜË©øË©°Ë®øË©∑Ë™ÇË™ÑË©µË™ÉË™ÅË©¥Ë©∫Ë∞ºË±ãË±äË±•Ë±§Ë±¶Ë≤ÜË≤ÑË≤ÖË≥åËµ®Ëµ©Ë∂ëË∂åË∂éË∂èË∂çË∂ìË∂îË∂êË∂íË∑∞Ë∑†Ë∑¨Ë∑±Ë∑ÆË∑êË∑©Ë∑£Ë∑¢Ë∑ßË∑≤Ë∑´Ë∑¥ËºÜËªøËºÅËºÄËºÖËºáËºàËºÇËºãÈÅíÈÄø"],["e0a1","ÈÅÑÈÅâÈÄΩÈÑêÈÑçÈÑèÈÑëÈÑñÈÑîÈÑãÈÑéÈÖÆÈÖØÈâàÈâíÈà∞Èà∫Èâ¶Èà≥Èâ•ÈâûÈäÉÈàÆÈâäÈâÜÈâ≠Èâ¨ÈâèÈâ†ÈâßÈâØÈà∂Èâ°Èâ∞Èà±ÈâîÈâ£ÈâêÈâ≤ÈâéÈâìÈâåÈâñÈà≤ÈñüÈñúÈñûÈñõÈöíÈöìÈöëÈöóÈõéÈõ∫ÈõΩÈõ∏ÈõµÈù≥Èù∑Èù∏Èù≤È†èÈ†çÈ†éÈ¢¨È£∂È£πÈ¶ØÈ¶≤È¶∞È¶µÈ™≠È™´È≠õÈ≥™È≥≠È≥ßÈ∫ÄÈªΩÂÉ¶ÂÉîÂÉóÂÉ®ÂÉ≥ÂÉõÂÉ™ÂÉùÂÉ§ÂÉìÂÉ¨ÂÉ∞ÂÉØÂÉ£ÂÉ†"],["e140","ÂáòÂäÄÂäÅÂã©Âã´Âå∞Âé¨ÂòßÂòïÂòåÂòíÂóºÂòèÂòúÂòÅÂòìÂòÇÂó∫ÂòùÂòÑÂóøÂóπÂ¢âÂ°ºÂ¢êÂ¢òÂ¢ÜÂ¢ÅÂ°øÂ°¥Â¢ãÂ°∫Â¢áÂ¢ëÂ¢éÂ°∂Â¢ÇÂ¢àÂ°ªÂ¢îÂ¢èÂ£æÂ•´Â´úÂ´ÆÂ´•Â´ïÂ´™Â´öÂ´≠Â´´Â´≥Â´¢Â´†Â´õÂ´¨Â´ûÂ´ùÂ´ôÂ´®Â´üÂ≠∑ÂØ†"],["e1a1","ÂØ£Â±£Â∂ÇÂ∂ÄÂµΩÂ∂ÜÂµ∫Â∂ÅÂµ∑Â∂äÂ∂âÂ∂àÂµæÂµºÂ∂çÂµπÂµøÂπòÂπôÂπìÂªòÂªëÂªóÂªéÂªúÂªïÂªôÂªíÂªîÂΩÑÂΩÉÂΩØÂæ∂ÊÑ¨ÊÑ®ÊÖÅÊÖûÊÖ±ÊÖ≥ÊÖíÊÖìÊÖ≤ÊÖ¨ÊÜÄÊÖ¥ÊÖîÊÖ∫ÊÖõÊÖ•ÊÑªÊÖ™ÊÖ°ÊÖñÊà©ÊàßÊà´Êê´ÊëçÊëõÊëùÊë¥Êë∂Êë≤Êë≥ÊëΩÊëµÊë¶Êí¶ÊëéÊíÇÊëûÊëúÊëãÊëìÊë†ÊëêÊëøÊêøÊë¨Êë´ÊëôÊë•Êë∑Êï≥Êñ†Êö°Êö†ÊöüÊúÖÊúÑÊú¢Ê¶±Ê¶∂Êßâ"],["e240","Ê¶†ÊßéÊ¶ñÊ¶∞Ê¶¨Ê¶ºÊ¶ëÊ¶ôÊ¶éÊ¶ßÊ¶çÊ¶©Ê¶æÊ¶ØÊ¶øÊßÑÊ¶ΩÊ¶§ÊßîÊ¶πÊßäÊ¶öÊßèÊ¶≥Ê¶ìÊ¶™Ê¶°Ê¶ûÊßôÊ¶óÊ¶êÊßÇÊ¶µÊ¶•ÊßÜÊ≠äÊ≠çÊ≠ãÊÆûÊÆüÊÆ†ÊØÉÊØÑÊØæÊªéÊªµÊª±ÊºÉÊº•Êª∏Êº∑ÊªªÊºÆÊºâÊΩéÊºôÊºöÊºßÊºòÊºªÊºíÊª≠Êºä"],["e2a1","Êº∂ÊΩ≥ÊªπÊªÆÊº≠ÊΩÄÊº∞ÊººÊºµÊª´ÊºáÊºéÊΩÉÊºÖÊªΩÊª∂ÊºπÊºúÊªºÊº∫ÊºüÊºçÊºûÊºàÊº°ÁÜáÁÜêÁÜâÁÜÄÁÜÖÁÜÇÁÜèÁÖªÁÜÜÁÜÅÁÜóÁâÑÁâìÁäóÁäïÁäìÁçÉÁççÁçëÁçåÁë¢Áë≥Áë±ÁëµÁë≤ÁëßÁëÆÁîÄÁîÇÁîÉÁïΩÁñêÁòñÁòàÁòåÁòïÁòëÁòäÁòîÁö∏ÁûÅÁùºÁûÖÁûÇÁùÆÁûÄÁùØÁùæÁûÉÁ¢≤Á¢™Á¢¥Á¢≠Á¢®Á°æÁ¢´Á¢ûÁ¢•Á¢†Á¢¨Á¢¢Á¢§Á¶òÁ¶äÁ¶ãÁ¶ñÁ¶ïÁ¶îÁ¶ì"],["e340","Á¶óÁ¶àÁ¶íÁ¶êÁ®´Á©äÁ®∞Á®ØÁ®®Á®¶Á™®Á™´Á™¨Á´ÆÁÆàÁÆúÁÆäÁÆëÁÆêÁÆñÁÆçÁÆåÁÆõÁÆéÁÆÖÁÆòÂäÑÁÆôÁÆ§ÁÆÇÁ≤ªÁ≤øÁ≤ºÁ≤∫Á∂ßÁ∂∑Á∑ÇÁ∂£Á∂™Á∑ÅÁ∑ÄÁ∑ÖÁ∂ùÁ∑éÁ∑ÑÁ∑ÜÁ∑ãÁ∑åÁ∂ØÁ∂πÁ∂ñÁ∂ºÁ∂üÁ∂¶Á∂ÆÁ∂©Á∂°Á∑âÁΩ≥Áø¢Áø£Áø•Áøû"],["e3a1","ËÄ§ËÅùËÅúËÜâËÜÜËÜÉËÜáËÜçËÜåËÜãËàïËíóËí§Ëí°ËíüËí∫ËìéËìÇËí¨ËíÆËí´ËíπËí¥ËìÅËìçËí™ËíöËí±ËìêËíùËíßËíªËí¢ËíîËìáËìåËíõËí©ËíØËí®ËìñËíòËí∂ËìèËí†ËìóËìîËìíËìõËí∞ËíëËô°Ëú≥Ëú£Ëú®Ëù´ËùÄËúÆËúûËú°ËúôËúõËùÉËú¨ËùÅËúæËùÜËú†Ëú≤Ëú™Ëú≠ËúºËúíËú∫Ëú±ËúµËùÇËú¶ËúßËú∏Ëú§ËúöËú∞ËúëË£∑Ë£ßË£±Ë£≤Ë£∫Ë£æË£ÆË£ºË£∂Ë£ª"],["e440","Ë£∞Ë£¨Ë£´Ë¶ùË¶°Ë¶üË¶ûËß©Ëß´Ëß®Ë™´Ë™ôË™ãË™íË™èË™ñË∞ΩË±®Ë±©Ë≥ïË≥èË≥óË∂ñË∏âË∏ÇË∑øË∏çË∑ΩË∏äË∏ÉË∏áË∏ÜË∏ÖË∑æË∏ÄË∏ÑËºêËºëËºéËºçÈÑ£ÈÑúÈÑ†ÈÑ¢ÈÑüÈÑùÈÑöÈÑ§ÈÑ°ÈÑõÈÖ∫ÈÖ≤ÈÖπÈÖ≥Èä•Èä§Èâ∂ÈäõÈâ∫Èä†ÈäîÈä™Èäç"],["e4a1","Èä¶ÈäöÈä´ÈâπÈäóÈâøÈä£ÈãÆÈäéÈäÇÈäïÈä¢ÈâΩÈäàÈä°ÈääÈäÜÈäåÈäôÈäßÈâæÈäáÈä©ÈäùÈäãÈà≠ÈöûÈö°ÈõøÈùòÈùΩÈù∫ÈùæÈûÉÈûÄÈûÇÈùªÈûÑÈûÅÈùøÈüéÈüçÈ†ñÈ¢≠È¢ÆÈ§ÇÈ§ÄÈ§áÈ¶ùÈ¶úÈßÉÈ¶πÈ¶ªÈ¶∫ÈßÇÈ¶ΩÈßáÈ™±È´£È´ßÈ¨æÈ¨øÈ≠†È≠°È≠üÈ≥±È≥≤È≥µÈ∫ßÂÉøÂÑÉÂÑ∞ÂÉ∏ÂÑÜÂÑáÂÉ∂ÂÉæÂÑãÂÑåÂÉΩÂÑäÂäãÂäåÂã±ÂãØÂôàÂôÇÂôåÂòµÂôÅÂôäÂôâÂôÜÂôò"],["e540","ÂôöÂôÄÂò≥ÂòΩÂò¨ÂòæÂò∏Âò™Âò∫ÂúöÂ¢´Â¢ùÂ¢±Â¢†Â¢£Â¢ØÂ¢¨Â¢•Â¢°Â£øÂ´øÂ´¥Â´ΩÂ´∑Â´∂Â¨ÉÂ´∏Â¨ÇÂ´πÂ¨ÅÂ¨áÂ¨ÖÂ¨èÂ±ßÂ∂ôÂ∂óÂ∂üÂ∂íÂ∂¢Â∂ìÂ∂ïÂ∂†Â∂úÂ∂°Â∂öÂ∂ûÂπ©ÂπùÂπ†ÂπúÁ∑≥ÂªõÂªûÂª°ÂΩâÂæ≤ÊÜãÊÜÉÊÖπÊÜ±ÊÜ∞ÊÜ¢ÊÜâ"],["e5a1","ÊÜõÊÜìÊÜØÊÜ≠ÊÜüÊÜíÊÜ™ÊÜ°ÊÜçÊÖ¶ÊÜ≥Êà≠ÊëÆÊë∞ÊíñÊí†ÊíÖÊíóÊíúÊíèÊíãÊíäÊíåÊí£ÊíüÊë®Êí±ÊíòÊï∂Êï∫ÊïπÊïªÊñ≤Êñ≥ÊöµÊö∞Êö©Êö≤Êö∑Êö™ÊöØÊ®ÄÊ®ÜÊ®óÊß•Êß∏Ê®ïÊß±Êß§Ê®†ÊßøÊß¨Êß¢Ê®õÊ®ùÊßæÊ®ßÊß≤ÊßÆÊ®îÊß∑ÊßßÊ©ÄÊ®àÊß¶ÊßªÊ®çÊßºÊß´Ê®âÊ®ÑÊ®òÊ®•Ê®èÊß∂Ê®¶Ê®áÊß¥Ê®ñÊ≠ëÊÆ•ÊÆ£ÊÆ¢ÊÆ¶Ê∞ÅÊ∞ÄÊØøÊ∞ÇÊΩÅÊº¶ÊΩæÊæáÊøÜÊæí"],["e640","ÊæçÊæâÊæåÊΩ¢ÊΩèÊæÖÊΩöÊæñÊΩ∂ÊΩ¨ÊæÇÊΩïÊΩ≤ÊΩíÊΩêÊΩóÊæîÊæìÊΩùÊºÄÊΩ°ÊΩ´ÊΩΩÊΩßÊæêÊΩìÊæãÊΩ©ÊΩøÊæïÊΩ£ÊΩ∑ÊΩ™ÊΩªÁÜ≤ÁÜØÁÜõÁÜ∞ÁÜ†ÁÜöÁÜ©ÁÜµÁÜùÁÜ•ÁÜûÁÜ§ÁÜ°ÁÜ™ÁÜúÁÜßÁÜ≥ÁäòÁäöÁçòÁçíÁçûÁçüÁç†ÁçùÁçõÁç°ÁçöÁçô"],["e6a1","Áç¢ÁíáÁíâÁíäÁíÜÁíÅÁëΩÁíÖÁíàÁëºÁëπÁîàÁîáÁïæÁò•ÁòûÁòôÁòùÁòúÁò£ÁòöÁò®ÁòõÁöúÁöùÁöûÁöõÁûçÁûèÁûâÁûàÁ£çÁ¢ªÁ£èÁ£åÁ£ëÁ£éÁ£îÁ£àÁ£ÉÁ£ÑÁ£âÁ¶öÁ¶°Á¶†Á¶úÁ¶¢Á¶õÊ≠∂Á®πÁ™≤Á™¥Á™≥ÁÆ∑ÁØãÁÆæÁÆ¨ÁØéÁÆØÁÆπÁØäÁÆµÁ≥ÖÁ≥àÁ≥åÁ≥ãÁ∑∑Á∑õÁ∑™Á∑ßÁ∑óÁ∑°Á∏ÉÁ∑∫Á∑¶Á∑∂Á∑±Á∑∞Á∑ÆÁ∑üÁΩ∂Áæ¨Áæ∞Áæ≠Áø≠Áø´Áø™Áø¨Áø¶Áø®ËÅ§ËÅßËÜ£ËÜü"],["e740","ËÜûËÜïËÜ¢ËÜôËÜóËàñËâèËâìËâíËâêËâéËâëËî§ËîªËîèËîÄËî©ËîéËîâËîçËîüËîäËîßËîúËìªËî´Ëì∫ËîàËîåËì¥Ëî™Ëì≤ËîïËì∑Ëì´Ëì≥ËìºËîíËì™Ëì©ËîñËìæËî®ËîùËîÆËîÇËìΩËîûËì∂Ëî±Ëî¶ËìßËì®Ëì∞ËìØËìπËîòËî†Ëî∞ËîãËîôËîØËô¢"],["e7a1","ËùñËù£Ëù§Ëù∑Ëü°Ëù≥ËùòËùîËùõËùíËù°ËùöËùëËùûËù≠Ëù™ËùêËùéËùüËùùËùØËù¨Ëù∫ËùÆËùúËù•ËùèËùªËùµËù¢ËùßËù©Ë°öË§ÖË§åË§îË§ãË§óË§òË§ôË§ÜË§ñË§ëË§éË§âË¶¢Ë¶§Ë¶£Ëß≠Ëß∞Ëß¨Ë´èË´ÜË™∏Ë´ìË´ëË´îË´ïË™ªË´óË™æË´ÄË´ÖË´òË´ÉË™∫Ë™ΩË´ôË∞æË±çË≤èË≥•Ë≥üË≥ôË≥®Ë≥öË≥ùË≥ßË∂†Ë∂úË∂°Ë∂õË∏†Ë∏£Ë∏•Ë∏§Ë∏ÆË∏ïË∏õË∏ñË∏ëË∏ôË∏¶Ë∏ß"],["e840","Ë∏îË∏íË∏òË∏ìË∏úË∏óË∏öËº¨Ëº§ËºòËºöËº†Ëº£ËºñËºóÈÅ≥ÈÅ∞ÈÅØÈÅßÈÅ´ÈÑØÈÑ´ÈÑ©ÈÑ™ÈÑ≤ÈÑ¶ÈÑÆÈÜÖÈÜÜÈÜäÈÜÅÈÜÇÈÜÑÈÜÄÈãêÈãÉÈãÑÈãÄÈãôÈä∂ÈãèÈã±ÈãüÈãòÈã©ÈãóÈãùÈãåÈãØÈãÇÈã®ÈãäÈãàÈãéÈã¶ÈãçÈãïÈãâÈã†ÈãûÈãßÈãëÈãì"],["e8a1","ÈäµÈã°ÈãÜÈä¥ÈïºÈñ¨Èñ´ÈñÆÈñ∞Èö§Èö¢ÈõìÈúÖÈúàÈúÇÈùöÈûäÈûéÈûàÈüêÈüèÈ†ûÈ†ùÈ†¶È†©È†®È††È†õÈ†ßÈ¢≤È§àÈ£∫È§ëÈ§îÈ§ñÈ§óÈ§ïÈßúÈßçÈßèÈßìÈßîÈßéÈßâÈßñÈßòÈßãÈßóÈßåÈ™≥È´¨È´´È´≥È´≤È´±È≠ÜÈ≠ÉÈ≠ßÈ≠¥È≠±È≠¶È≠∂È≠µÈ≠∞È≠®È≠§È≠¨È≥ºÈ≥∫È≥ΩÈ≥øÈ≥∑È¥áÈ¥ÄÈ≥πÈ≥ªÈ¥àÈ¥ÖÈ¥ÑÈ∫ÉÈªìÈºèÈºêÂÑúÂÑìÂÑóÂÑöÂÑëÂáûÂå¥Âè°Âô∞Âô†ÂôÆ"],["e940","Âô≥Âô¶Âô£Âô≠Âô≤ÂôûÂô∑ÂúúÂúõÂ£àÂ¢ΩÂ£âÂ¢øÂ¢∫Â£ÇÂ¢ºÂ£ÜÂ¨óÂ¨ôÂ¨õÂ¨°Â¨îÂ¨ìÂ¨êÂ¨ñÂ¨®Â¨öÂ¨†Â¨ûÂØØÂ∂¨Â∂±Â∂©Â∂ßÂ∂µÂ∂∞Â∂ÆÂ∂™Â∂®Â∂≤Â∂≠Â∂ØÂ∂¥ÂπßÂπ®Âπ¶ÂπØÂª©ÂªßÂª¶Âª®Âª•ÂΩãÂæºÊÜùÊÜ®ÊÜñÊáÖÊÜ¥ÊáÜÊáÅÊáåÊÜ∫"],["e9a1","ÊÜøÊÜ∏ÊÜåÊìóÊìñÊìêÊìèÊìâÊíΩÊíâÊìÉÊìõÊì≥ÊìôÊî≥ÊïøÊïºÊñ¢ÊõàÊöæÊõÄÊõäÊõãÊõèÊöΩÊöªÊö∫ÊõåÊú£Ê®¥Ê©¶Ê©âÊ©ßÊ®≤Ê©®Ê®æÊ©ùÊ©≠Ê©∂Ê©õÊ©ëÊ®®Ê©öÊ®ªÊ®øÊ©ÅÊ©™Ê©§Ê©êÊ©èÊ©îÊ©ØÊ©©Ê©†Ê®ºÊ©ûÊ©ñÊ©ïÊ©çÊ©éÊ©ÜÊ≠ïÊ≠îÊ≠ñÊÆßÊÆ™ÊÆ´ÊØàÊØáÊ∞ÑÊ∞ÉÊ∞ÜÊæ≠ÊøãÊæ£ÊøáÊæºÊøéÊøàÊΩûÊøÑÊæΩÊæûÊøäÊæ®ÁÄÑÊæ•ÊæÆÊæ∫Êæ¨Êæ™ÊøèÊæøÊæ∏"],["ea40","Êæ¢ÊøâÊæ´ÊøçÊæØÊæ≤Êæ∞ÁáÖÁáÇÁÜøÁÜ∏ÁáñÁáÄÁáÅÁáãÁáîÁáäÁááÁáèÁÜΩÁáòÁÜºÁáÜÁáöÁáõÁäùÁäûÁç©Áç¶ÁçßÁç¨Áç•Áç´Áç™ÁëøÁíöÁí†ÁíîÁííÁíïÁí°ÁîãÁñÄÁòØÁò≠Áò±ÁòΩÁò≥ÁòºÁòµÁò≤Áò∞ÁöªÁõ¶ÁûöÁûùÁû°ÁûúÁûõÁû¢Áû£ÁûïÁûô"],["eaa1","ÁûóÁ£ùÁ£©Á£•Á£™Á£ûÁ££Á£õÁ£°Á£¢Á£≠Á£üÁ£†Á¶§Á©ÑÁ©àÁ©áÁ™∂Á™∏Á™µÁ™±Á™∑ÁØûÁØ£ÁØßÁØùÁØïÁØ•ÁØöÁØ®ÁØπÁØîÁØ™ÁØ¢ÁØúÁØ´ÁØòÁØüÁ≥íÁ≥îÁ≥óÁ≥êÁ≥ëÁ∏íÁ∏°Á∏óÁ∏åÁ∏üÁ∏†Á∏ìÁ∏éÁ∏úÁ∏ïÁ∏öÁ∏¢Á∏ãÁ∏èÁ∏ñÁ∏çÁ∏îÁ∏•Á∏§ÁΩÉÁΩªÁΩºÁΩ∫Áæ±ÁøØËÄ™ËÄ©ËÅ¨ËÜ±ËÜ¶ËÜÆËÜπËÜµËÜ´ËÜ∞ËÜ¨ËÜ¥ËÜ≤ËÜ∑ËÜßËá≤ËâïËâñËâóËïñËïÖËï´ËïçËïìËï°Ëïò"],["eb40","ËïÄËïÜËï§ËïÅËï¢ËïÑËïëËïáËï£ËîæËïõËï±ËïéËïÆËïµËïïËïßËï†ËñåËï¶ËïùËïîËï•Ëï¨Ëô£Ëô•Ëô§ËûõËûèËûóËûìËûíËûàËûÅËûñËûòËùπËûáËû£ËûÖËûêËûëËûùËûÑËûîËûúËûöËûâË§ûË§¶Ë§∞Ë§≠Ë§ÆË§ßË§±Ë§¢Ë§©Ë§£Ë§ØË§¨Ë§üËß±Ë´†"],["eba1","Ë´¢Ë´≤Ë´¥Ë´µË´ùË¨îË´§Ë´üË´∞Ë´àË´ûË´°Ë´®Ë´øË´ØË´ªË≤ëË≤íË≤êË≥µË≥ÆË≥±Ë≥∞Ë≥≥Ëµ¨ËµÆË∂•Ë∂ßË∏≥Ë∏æË∏∏ËπÄËπÖË∏∂Ë∏ºË∏ΩËπÅË∏∞Ë∏øË∫ΩËº∂ËºÆËºµËº≤ËºπËº∑Ëº¥ÈÅ∂ÈÅπÈÅªÈÇÜÈÉ∫ÈÑ≥ÈÑµÈÑ∂ÈÜìÈÜêÈÜëÈÜçÈÜèÈåßÈåûÈåàÈåüÈåÜÈåèÈç∫Èå∏ÈåºÈåõÈå£ÈåíÈåÅÈçÜÈå≠ÈåéÈåçÈããÈåùÈã∫Èå•ÈåìÈãπÈã∑Èå¥ÈåÇÈå§ÈãøÈå©ÈåπÈåµÈå™ÈåîÈåå"],["ec40","ÈåãÈãæÈåâÈåÄÈãªÈåñÈñºÈóçÈñæÈñπÈñ∫Èñ∂ÈñøÈñµÈñΩÈö©ÈõîÈúãÈúíÈúêÈûôÈûóÈûîÈü∞Èü∏È†µÈ†ØÈ†≤È§§È§üÈ§ßÈ§©È¶ûÈßÆÈß¨Èß•Èß§Èß∞Èß£Èß™Èß©ÈßßÈ™πÈ™øÈ™¥È™ªÈ´∂È´∫È´πÈ´∑È¨≥ÈÆÄÈÆÖÈÆáÈ≠ºÈ≠æÈ≠ªÈÆÇÈÆìÈÆíÈÆêÈ≠∫ÈÆï"],["eca1","È≠ΩÈÆàÈ¥•È¥óÈ¥†È¥ûÈ¥îÈ¥©È¥ùÈ¥òÈ¥¢È¥êÈ¥ôÈ¥üÈ∫àÈ∫ÜÈ∫áÈ∫ÆÈ∫≠ÈªïÈªñÈª∫ÈºíÈºΩÂÑ¶ÂÑ•ÂÑ¢ÂÑ§ÂÑ†ÂÑ©Âã¥ÂöìÂöåÂöçÂöÜÂöÑÂöÉÂôæÂöÇÂôøÂöÅÂ£ñÂ£îÂ£èÂ£íÂ¨≠Â¨•Â¨≤Â¨£Â¨¨Â¨ßÂ¨¶Â¨ØÂ¨ÆÂ≠ªÂØ±ÂØ≤Â∂∑Âπ¨Âπ™ÂææÂæªÊáÉÊÜµÊÜºÊáßÊá†Êá•Êá§Êá®ÊáûÊìØÊì©Êì£Êì´Êì§Êì®ÊñÅÊñÄÊñ∂ÊóöÊõíÊ™çÊ™ñÊ™ÅÊ™•Ê™âÊ™üÊ™õÊ™°Ê™ûÊ™áÊ™ìÊ™é"],["ed40","Ê™ïÊ™ÉÊ™®Ê™§Ê™ëÊ©øÊ™¶Ê™öÊ™ÖÊ™åÊ™íÊ≠õÊÆ≠Ê∞âÊøåÊæ©Êø¥ÊøîÊø£ÊøúÊø≠ÊøßÊø¶ÊøûÊø≤ÊøùÊø¢Êø®Áá°Áá±Áá®Áá≤Áá§Áá∞Áá¢Áç≥ÁçÆÁçØÁíóÁí≤Áí´ÁíêÁí™Áí≠Áí±Áí•ÁíØÁîêÁîëÁîíÁîèÁñÑÁôÉÁôàÁôâÁôáÁö§Áõ©ÁûµÁû´Áû≤Áû∑Áû∂"],["eda1","Áû¥Áû±Áû®Áü∞Á£≥Á£ΩÁ§ÇÁ£ªÁ£ºÁ£≤Á§ÖÁ£πÁ£æÁ§ÑÁ¶´Á¶®Á©úÁ©õÁ©ñÁ©òÁ©îÁ©öÁ™æÁ´ÄÁ´ÅÁ∞ÖÁ∞èÁØ≤Á∞ÄÁØøÁØªÁ∞éÁØ¥Á∞ãÁØ≥Á∞ÇÁ∞âÁ∞ÉÁ∞ÅÁØ∏ÁØΩÁ∞ÜÁØ∞ÁØ±Á∞êÁ∞äÁ≥®Á∏≠Á∏ºÁπÇÁ∏≥È°àÁ∏∏Á∏™ÁπâÁπÄÁπáÁ∏©ÁπåÁ∏∞Á∏ªÁ∏∂ÁπÑÁ∏∫ÁΩÖÁΩøÁΩæÁΩΩÁø¥Áø≤ËÄ¨ËÜªËáÑËáåËáäËáÖËááËÜºËá©ËâõËâöËâúËñÉËñÄËñèËñßËñïËñ†ËñãËñ£ËïªËñ§ËñöËñû"],["ee40","Ëï∑ËïºËñâËñ°Ëï∫Ëï∏ËïóËñéËññËñÜËñçËñôËñùËñÅËñ¢ËñÇËñàËñÖËïπËï∂ËñòËñêËñüËô®ËûæËû™Ëû≠ËüÖËû∞Ëû¨ËûπËûµËûºËûÆËüâËüÉËüÇËüåËû∑ËûØËüÑËüäËû¥Ëû∂ËûøËû∏ËûΩËüûËû≤Ë§µË§≥Ë§ºË§æË•ÅË•íË§∑Ë•ÇË¶≠Ë¶ØË¶ÆËß≤Ëß≥Ë¨û"],["eea1","Ë¨òË¨ñË¨ëË¨ÖË¨ãË¨¢Ë¨èË¨íË¨ïË¨áË¨çË¨àË¨ÜË¨úË¨ìË¨öË±èË±∞Ë±≤Ë±±Ë±ØË≤ïË≤îË≥πËµØËπéËπçËπìËπêËπåËπáËΩÉËΩÄÈÇÖÈÅæÈÑ∏ÈÜöÈÜ¢ÈÜõÈÜôÈÜüÈÜ°ÈÜùÈÜ†Èé°ÈéÉÈéØÈç§ÈçñÈçáÈçºÈçòÈçúÈç∂ÈçâÈçêÈçëÈç†Èç≠ÈéèÈçåÈç™ÈçπÈçóÈçïÈçíÈçèÈç±Èç∑ÈçªÈç°ÈçûÈç£ÈçßÈéÄÈçéÈçôÈóáÈóÄÈóâÈóÉÈóÖÈñ∑ÈöÆÈö∞Èö¨Èú†ÈúüÈúòÈúùÈúôÈûöÈû°Èûú"],["ef40","ÈûûÈûùÈüïÈüîÈü±È°ÅÈ°ÑÈ°äÈ°âÈ°ÖÈ°ÉÈ§•È§´È§¨È§™È§≥È§≤È§ØÈ§≠È§±È§∞È¶òÈ¶£È¶°È®ÇÈß∫Èß¥Èß∑ÈßπÈß∏Èß∂ÈßªÈßΩÈßæÈßºÈ®ÉÈ™æÈ´æÈ´ΩÈ¨ÅÈ´ºÈ≠àÈÆöÈÆ®ÈÆûÈÆõÈÆ¶ÈÆ°ÈÆ•ÈÆ§ÈÆÜÈÆ¢ÈÆ†ÈÆØÈ¥≥ÈµÅÈµßÈ¥∂È¥ÆÈ¥ØÈ¥±È¥∏È¥∞"],["efa1","ÈµÖÈµÇÈµÉÈ¥æÈ¥∑ÈµÄÈ¥ΩÁøµÈ¥≠È∫äÈ∫âÈ∫çÈ∫∞ÈªàÈªöÈªªÈªøÈº§Èº£Èº¢ÈΩîÈæ†ÂÑ±ÂÑ≠ÂÑÆÂöòÂöúÂöóÂööÂöùÂöôÂ•∞Â¨ºÂ±©Â±™Â∑ÄÂπ≠ÂπÆÊáòÊáüÊá≠ÊáÆÊá±Êá™Êá∞Êá´ÊáñÊá©ÊìøÊîÑÊìΩÊì∏ÊîÅÊîÉÊìºÊñîÊóõÊõöÊõõÊõòÊ´ÖÊ™πÊ™ΩÊ´°Ê´ÜÊ™∫Ê™∂Ê™∑Ê´áÊ™¥Ê™≠Ê≠ûÊØâÊ∞ãÁÄáÁÄåÁÄçÁÄÅÁÄÖÁÄîÁÄéÊøøÁÄÄÊøªÁÄ¶ÊøºÊø∑ÁÄäÁàÅÁáøÁáπÁàÉÁáΩÁç∂"],["f040","Áí∏ÁìÄÁíµÁìÅÁíæÁí∂ÁíªÁìÇÁîîÁîìÁôúÁô§ÁôôÁôêÁôìÁôóÁôöÁö¶ÁöΩÁõ¨ÁüÇÁû∫Á£øÁ§åÁ§ìÁ§îÁ§âÁ§êÁ§íÁ§ëÁ¶≠Á¶¨Á©üÁ∞úÁ∞©Á∞ôÁ∞†Á∞üÁ∞≠Á∞ùÁ∞¶Á∞®Á∞¢Á∞•Á∞∞ÁπúÁπêÁπñÁπ£ÁπòÁπ¢ÁπüÁπëÁπ†ÁπóÁπìÁæµÁæ≥Áø∑Áø∏ËÅµËáëËáí"],["f0a1","ËáêËâüËâûËñ¥ËóÜËóÄËóÉËóÇËñ≥ËñµËñΩËóáËóÑËñøËóãËóéËóàËóÖËñ±Ëñ∂ËóíËò§Ëñ∏Ëñ∑ËñæËô©ËüßËü¶Ëü¢ËüõËü´Ëü™Ëü•ËüüËü≥Ëü§ËüîËüúËüìËü≠ËüòËü£Ëû§ËüóËüôË†ÅËü¥Ëü®ËüùË•ìË•ãË•èË•åË•ÜË•êË•ëË•âË¨™Ë¨ßË¨£Ë¨≥Ë¨∞Ë¨µË≠áË¨ØË¨ºË¨æË¨±Ë¨•Ë¨∑Ë¨¶Ë¨∂Ë¨ÆË¨§Ë¨ªË¨ΩË¨∫Ë±ÇË±µË≤ôË≤òË≤óË≥æË¥ÑË¥ÇË¥ÄËπúËπ¢Ëπ†ËπóËπñËπûËπ•Ëπß"],["f140","ËπõËπöËπ°ËπùËπ©ËπîËΩÜËΩáËΩàËΩãÈÑ®ÈÑ∫ÈÑªÈÑæÈÜ®ÈÜ•ÈÜßÈÜØÈÜ™ÈéµÈéåÈéíÈé∑ÈéõÈéùÈéâÈéßÈééÈé™ÈéûÈé¶ÈéïÈéàÈéôÈéüÈéçÈé±ÈéëÈé≤Èé§Èé®Èé¥Èé£Èé•ÈóíÈóìÈóëÈö≥ÈõóÈõöÂ∑ÇÈõüÈõòÈõùÈú£Èú¢Èú•Èû¨ÈûÆÈû®Èû´Èû§Èû™"],["f1a1","Èû¢Èû•ÈüóÈüôÈüñÈüòÈü∫È°êÈ°ëÈ°íÈ¢∏È•ÅÈ§ºÈ§∫È®èÈ®ãÈ®âÈ®çÈ®ÑÈ®ëÈ®äÈ®ÖÈ®áÈ®ÜÈ´ÄÈ´úÈ¨àÈ¨ÑÈ¨ÖÈ¨©È¨µÈ≠äÈ≠åÈ≠ãÈØáÈØÜÈØÉÈÆøÈØÅÈÆµÈÆ∏ÈØìÈÆ∂ÈØÑÈÆπÈÆΩÈµúÈµìÈµèÈµäÈµõÈµãÈµôÈµñÈµåÈµóÈµíÈµîÈµüÈµòÈµöÈ∫éÈ∫åÈªüÈºÅÈºÄÈºñÈº•Èº´Èº™Èº©Èº®ÈΩåÈΩïÂÑ¥ÂÑµÂäñÂã∑Âé¥Âö´Âö≠Âö¶ÂößÂö™Âö¨Â£öÂ£ùÂ£õÂ§íÂ¨ΩÂ¨æÂ¨øÂ∑ÉÂπ∞"],["f240","ÂæøÊáªÊîáÊîêÊîçÊîâÊîåÊîéÊñÑÊóûÊóùÊõûÊ´ßÊ´†Ê´åÊ´ëÊ´ôÊ´ãÊ´üÊ´úÊ´êÊ´´Ê´èÊ´çÊ´ûÊ≠†ÊÆ∞Ê∞åÁÄôÁÄßÁÄ†ÁÄñÁÄ´ÁÄ°ÁÄ¢ÁÄ£ÁÄ©ÁÄóÁÄ§ÁÄúÁÄ™ÁàåÁàäÁàáÁàÇÁàÖÁä•Áä¶Áä§Áä£Áä°ÁìãÁìÖÁí∑ÁìÉÁîñÁô†ÁüâÁüäÁüÑÁü±Á§ùÁ§õ"],["f2a1","Á§°Á§úÁ§óÁ§ûÁ¶∞Á©ßÁ©®Á∞≥Á∞ºÁ∞πÁ∞¨Á∞ªÁ≥¨Á≥™Áπ∂ÁπµÁπ∏Áπ∞Áπ∑ÁπØÁπ∫Áπ≤Áπ¥Áπ®ÁΩãÁΩäÁæÉÁæÜÁæ∑ÁøΩÁøæËÅ∏ËáóËáïËâ§Ëâ°Ëâ£Ëó´Ëó±Ëó≠ËóôËó°Ëó®ËóöËóóËó¨Ëó≤Ëó∏ËóòËóüËó£ËóúËóëËó∞Ëó¶ËóØËóûËó¢Ë†ÄËü∫Ë†ÉËü∂Ëü∑Ë†âË†åË†ãË†ÜËüºË†àËüøË†äË†ÇË•¢Ë•öË•õË•óË•°Ë•úË•òË•ùË•ôË¶àË¶∑Ë¶∂Ëß∂Ë≠êË≠àË≠äË≠ÄË≠ìË≠ñË≠îË≠ãË≠ï"],["f340","Ë≠ëË≠ÇË≠íË≠óË±ÉË±∑Ë±∂Ë≤öË¥ÜË¥áË¥âË∂¨Ë∂™Ë∂≠Ë∂´Ëπ≠Ëπ∏Ëπ≥Ëπ™ËπØËπªËªÇËΩíËΩëËΩèËΩêËΩìËæ¥ÈÖÄÈÑøÈÜ∞ÈÜ≠ÈèûÈèáÈèèÈèÇÈèöÈèêÈèπÈè¨ÈèåÈèôÈé©Èè¶ÈèäÈèîÈèÆÈè£ÈèïÈèÑÈèéÈèÄÈèíÈèßÈïΩÈóöÈóõÈõ°Èú©Èú´Èú¨Èú®Èú¶"],["f3a1","Èû≥Èû∑Èû∂ÈüùÈüûÈüüÈ°úÈ°ôÈ°ùÈ°óÈ¢øÈ¢ΩÈ¢ªÈ¢æÈ•àÈ•áÈ•ÉÈ¶¶È¶ßÈ®öÈ®ïÈ®•È®ùÈ®§È®õÈ®¢È®†È®ßÈ®£È®ûÈ®úÈ®îÈ´ÇÈ¨ãÈ¨äÈ¨éÈ¨åÈ¨∑ÈØ™ÈØ´ÈØ†ÈØûÈØ§ÈØ¶ÈØ¢ÈØ∞ÈØîÈØóÈØ¨ÈØúÈØôÈØ•ÈØïÈØ°ÈØöÈµ∑È∂ÅÈ∂äÈ∂ÑÈ∂àÈµ±È∂ÄÈµ∏È∂ÜÈ∂ãÈ∂åÈµΩÈµ´Èµ¥ÈµµÈµ∞Èµ©È∂ÖÈµ≥ÈµªÈ∂ÇÈµØÈµπÈµøÈ∂áÈµ®È∫îÈ∫ëÈªÄÈªºÈº≠ÈΩÄÈΩÅÈΩçÈΩñÈΩóÈΩòÂå∑Âö≤"],["f440","ÂöµÂö≥Â££Â≠ÖÂ∑ÜÂ∑áÂªÆÂªØÂøÄÂøÅÊáπÊîóÊîñÊîïÊîìÊóüÊõ®Êõ£Êõ§Ê´≥Ê´∞Ê´™Ê´®Ê´πÊ´±Ê´ÆÊ´ØÁÄºÁÄµÁÄØÁÄ∑ÁÄ¥ÁÄ±ÁÅÇÁÄ∏ÁÄøÁÄ∫ÁÄπÁÅÄÁÄªÁÄ≥ÁÅÅÁàìÁàîÁä®ÁçΩÁçºÁí∫Áö´Áö™ÁöæÁõ≠ÁüåÁüéÁüèÁüçÁü≤Á§•Á§£Á§ßÁ§®Á§§Á§©"],["f4a1","Á¶≤Á©ÆÁ©¨Á©≠Á´∑Á±âÁ±àÁ±äÁ±áÁ±ÖÁ≥ÆÁπªÁπæÁ∫ÅÁ∫ÄÁæ∫ÁøøËÅπËáõËáôËàãËâ®Ëâ©Ëò¢ËóøËòÅËóæËòõËòÄËó∂ËòÑËòâËòÖËòåËóΩË†ôË†êË†ëË†óË†ìË†ñË•£Ë•¶Ë¶πËß∑Ë≠†Ë≠™Ë≠ùË≠®Ë≠£Ë≠•Ë≠ßË≠≠Ë∂ÆË∫ÜË∫àË∫ÑËΩôËΩñËΩóËΩïËΩòËΩöÈÇçÈÖÉÈÖÅÈÜ∑ÈÜµÈÜ≤ÈÜ≥ÈêãÈêìÈèªÈê†ÈêèÈêîÈèæÈêïÈêêÈê®ÈêôÈêçÈèµÈêÄÈè∑ÈêáÈêéÈêñÈêíÈè∫ÈêâÈè∏ÈêäÈèø"],["f540","ÈèºÈêåÈè∂ÈêëÈêÜÈóûÈó†ÈóüÈúÆÈúØÈûπÈûªÈüΩÈüæÈ°†È°¢È°£È°üÈ£ÅÈ£ÇÈ•êÈ•éÈ•ôÈ•åÈ•ãÈ•ìÈ®≤È®¥È®±È®¨È®™È®∂È®©È®ÆÈ®∏È®≠È´áÈ´äÈ´ÜÈ¨êÈ¨íÈ¨ëÈ∞ãÈ∞àÈØ∑È∞ÖÈ∞íÈØ∏È±ÄÈ∞áÈ∞éÈ∞ÜÈ∞óÈ∞îÈ∞âÈ∂üÈ∂ôÈ∂§È∂ùÈ∂íÈ∂òÈ∂êÈ∂õ"],["f5a1","È∂†È∂îÈ∂úÈ∂™È∂óÈ∂°È∂öÈ∂¢È∂®È∂ûÈ∂£È∂øÈ∂©È∂ñÈ∂¶È∂ßÈ∫ôÈ∫õÈ∫öÈª•Èª§ÈªßÈª¶Èº∞ÈºÆÈΩõÈΩ†ÈΩûÈΩùÈΩôÈæëÂÑ∫ÂÑπÂäòÂäóÂõÉÂöΩÂöæÂ≠àÂ≠áÂ∑ãÂ∑èÂª±ÊáΩÊîõÊ¨ÇÊ´ºÊ¨ÉÊ´∏Ê¨ÄÁÅÉÁÅÑÁÅäÁÅàÁÅâÁÅÖÁÅÜÁàùÁàöÁàôÁçæÁîóÁô™ÁüêÁ§≠Á§±Á§ØÁ±îÁ±ìÁ≥≤Á∫äÁ∫áÁ∫àÁ∫ãÁ∫ÜÁ∫çÁΩçÁæªËÄ∞ËáùËòòËò™Ëò¶ËòüËò£ËòúËòôËòßËòÆËò°Ëò†Ëò©ËòûËò•"],["f640","Ë†©Ë†ùË†õË††Ë†§Ë†úË†´Ë°äË•≠Ë•©Ë•ÆË•´Ëß∫Ë≠πË≠∏Ë≠ÖË≠∫Ë≠ªË¥êË¥îË∂ØË∫éË∫åËΩûËΩõËΩùÈÖÜÈÖÑÈÖÖÈÜπÈêøÈêªÈê∂Èê©ÈêΩÈêºÈê∞ÈêπÈê™Èê∑Èê¨ÈëÄÈê±Èó•Èó§Èó£ÈúµÈú∫ÈûøÈü°È°§È£âÈ£ÜÈ£ÄÈ•òÈ•ñÈ®πÈ®ΩÈ©ÜÈ©ÑÈ©ÇÈ©ÅÈ®∫"],["f6a1","È®øÈ´çÈ¨ïÈ¨óÈ¨òÈ¨ñÈ¨∫È≠íÈ∞´È∞ùÈ∞úÈ∞¨È∞£È∞®È∞©È∞§È∞°È∂∑È∂∂È∂ºÈ∑ÅÈ∑áÈ∑äÈ∑èÈ∂æÈ∑ÖÈ∑ÉÈ∂ªÈ∂µÈ∑éÈ∂πÈ∂∫È∂¨È∑àÈ∂±È∂≠È∑åÈ∂≥È∑çÈ∂≤Èπ∫È∫úÈª´ÈªÆÈª≠ÈºõÈºòÈºöÈº±ÈΩéÈΩ•ÈΩ§Èæí‰∫πÂõÜÂõÖÂõãÂ•±Â≠ãÂ≠åÂ∑ïÂ∑ëÂª≤Êî°Êî†Êî¶Êî¢Ê¨ãÊ¨àÊ¨âÊ∞çÁÅïÁÅñÁÅóÁÅíÁàûÁàüÁä©ÁçøÁìòÁìïÁìôÁìóÁô≠Áö≠Á§µÁ¶¥Á©∞Á©±Á±óÁ±úÁ±ôÁ±õÁ±ö"],["f740","Á≥¥Á≥±Á∫ëÁΩèÁæáËáûËâ´Ëò¥ËòµËò≥Ëò¨Ëò≤Ëò∂Ë†¨Ë†®Ë†¶Ë†™Ë†•Ë•±Ë¶øË¶æËßªË≠æËÆÑËÆÇËÆÜËÆÖË≠øË¥ïË∫ïË∫îË∫öË∫íË∫êË∫ñË∫óËΩ†ËΩ¢ÈÖáÈëåÈëêÈëäÈëãÈëèÈëáÈëÖÈëàÈëâÈëÜÈúøÈü£È°™È°©È£ãÈ•îÈ•õÈ©éÈ©ìÈ©îÈ©åÈ©èÈ©àÈ©ä"],["f7a1","È©âÈ©íÈ©êÈ´êÈ¨ôÈ¨´È¨ªÈ≠ñÈ≠ïÈ±ÜÈ±àÈ∞øÈ±ÑÈ∞πÈ∞≥È±ÅÈ∞ºÈ∞∑È∞¥È∞≤È∞ΩÈ∞∂È∑õÈ∑íÈ∑ûÈ∑öÈ∑ãÈ∑êÈ∑úÈ∑ëÈ∑üÈ∑©È∑ôÈ∑òÈ∑ñÈ∑µÈ∑ïÈ∑ùÈ∫∂Èª∞ÈºµÈº≥Èº≤ÈΩÇÈΩ´ÈæïÈæ¢ÂÑΩÂäôÂ£®Â£ßÂ•≤Â≠çÂ∑òË†ØÂΩèÊàÅÊàÉÊàÑÊî©Êî•ÊññÊõ´Ê¨ëÊ¨íÊ¨èÊØäÁÅõÁÅöÁà¢ÁéÇÁéÅÁéÉÁô∞ÁüîÁ±ßÁ±¶Á∫ïËâ¨Ëò∫ËôÄËòπËòºËò±ËòªËòæË†∞Ë†≤Ë†ÆË†≥Ë•∂Ë•¥Ë•≥Ëßæ"],["f840","ËÆåËÆéËÆãËÆàË±ÖË¥ôË∫òËΩ§ËΩ£ÈÜºÈë¢ÈëïÈëùÈëóÈëûÈüÑÈüÖÈ†ÄÈ©ñÈ©ôÈ¨ûÈ¨üÈ¨†È±íÈ±òÈ±êÈ±äÈ±çÈ±ãÈ±ïÈ±ôÈ±åÈ±éÈ∑ªÈ∑∑È∑ØÈ∑£È∑´È∑∏È∑§È∑∂È∑°È∑ÆÈ∑¶È∑≤È∑∞È∑¢È∑¨È∑¥È∑≥È∑®È∑≠ÈªÇÈªêÈª≤Èª≥ÈºÜÈºúÈº∏Èº∑Èº∂ÈΩÉÈΩè"],["f8a1","ÈΩ±ÈΩ∞ÈΩÆÈΩØÂõìÂõçÂ≠éÂ±≠Êî≠Êõ≠ÊõÆÊ¨ìÁÅüÁÅ°ÁÅùÁÅ†Áà£ÁìõÁì•ÁüïÁ§∏Á¶∑Á¶∂Á±™Á∫óÁæâËâ≠ËôÉË†∏Ë†∑Ë†µË°ãËÆîËÆïË∫ûË∫üË∫†Ë∫ùÈÜæÈÜΩÈáÇÈë´Èë®Èë©Èõ•ÈùÜÈùÉÈùáÈüáÈü•È©ûÈ´ïÈ≠ôÈ±£È±ßÈ±¶È±¢È±ûÈ±†È∏ÇÈ∑æÈ∏áÈ∏ÉÈ∏ÜÈ∏ÖÈ∏ÄÈ∏ÅÈ∏âÈ∑øÈ∑ΩÈ∏ÑÈ∫†ÈºûÈΩÜÈΩ¥ÈΩµÈΩ∂ÂõîÊîÆÊñ∏Ê¨òÊ¨ôÊ¨óÊ¨öÁÅ¢Áà¶Áä™ÁüòÁüôÁ§πÁ±©Á±´Á≥∂Á∫ö"],["f940","Á∫òÁ∫õÁ∫ôËá†Ëá°ËôÜËôáËôàË•πË•∫Ë•ºË•ªËßøËÆòËÆôË∫•Ë∫§Ë∫£ÈëÆÈë≠ÈëØÈë±Èë≥ÈùâÈ°≤È•üÈ±®È±ÆÈ±≠È∏ãÈ∏çÈ∏êÈ∏èÈ∏íÈ∏ëÈ∫°ÈªµÈºâÈΩáÈΩ∏ÈΩªÈΩ∫ÈΩπÂúûÁÅ¶Á±ØË†ºË∂≤Ë∫¶ÈáÉÈë¥Èë∏Èë∂ÈëµÈ©†È±¥È±≥È±±È±µÈ∏îÈ∏ìÈª∂Èºä"],["f9a1","Èæ§ÁÅ®ÁÅ•Á≥∑Ëô™Ë†æË†ΩË†øËÆûË≤úË∫©ËªâÈùãÈ°≥È°¥È£åÈ•°È¶´È©§È©¶È©ßÈ¨§È∏ïÈ∏óÈΩàÊàáÊ¨ûÁàßËôåË∫®ÈíÇÈíÄÈíÅÈ©©È©®È¨ÆÈ∏ôÁà©ËôãËÆüÈíÉÈ±πÈ∫∑ÁôµÈ©´È±∫È∏ùÁÅ©ÁÅ™È∫§ÈΩæÈΩâÈæòÁ¢ÅÈäπË£èÂ¢ªÊÅíÁ≤ßÂ´∫‚ïî‚ï¶‚ïó‚ï†‚ï¨‚ï£‚ïö‚ï©‚ïù‚ïí‚ï§‚ïï‚ïû‚ï™‚ï°‚ïò‚ïß‚ïõ‚ïì‚ï•‚ïñ‚ïü‚ï´‚ï¢‚ïô‚ï®‚ïú‚ïë‚ïê‚ï≠‚ïÆ‚ï∞‚ïØ‚ñì"]]');

/***/ }),
/* 102 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[["8740","‰è∞‰∞≤‰òÉ‰ñ¶‰ï∏ßâß‰µ∑‰ñ≥ß≤±‰≥¢ß≥Ö„Æï‰ú∂‰ùÑ‰±á‰±Ä§äø£òóßçí¶∫ãßÉí‰±ó™çë‰ùè‰óö‰≤Öß±¨‰¥á‰™§‰ö°¶¨£Áà••©î°©££∏Ü£Ω°ÊôçÂõª"],["8767","Á∂ïÂ§ù®Æπ„∑¥Èú¥ßØØÂØõ°µûÂ™§„ò•©∫∞Â´ëÂÆ∑Â≥ºÊùÆËñì©•ÖÁë°Áíù„°µ°µì£öû¶Ä°„ª¨"],["87a1","•£û„´µÁ´ºÈæó§Ö°®§ç£á™†™ä£âû‰åäËíÑÈæñÈêØ‰§∞ËòìÂ¢ñÈùäÈàòÁßêÁ®≤Êô†Ê®©Ë¢ùÁëåÁØÖÊûÇÁ®¨ÂâèÈÅÜ„ì¶ÁèÑ•∂πÁìÜÈøáÂû≥‰§ØÂëå‰Ñ±£öéÂ†òÁ©≤ß≠•ËÆè‰öÆ¶∫à‰ÜÅ•∂ôÁÆÆ¢íºÈøà¢ìÅ¢ìâ¢ìåÈøâËîÑ£ñª‰Ç¥Èøä‰ì°™∑øÊãÅÁÅÆÈøã"],["8840","„áÄ",4,"†Ñå„áÖ†Éë†Éç„áÜ„áá†Éã°ø®„áà†Éä„áâ„áä„áã„áå†Ñé„áç„áéƒÄ√Å«ç√Äƒí√âƒö√à≈å√ì«ë√í‡øø√äÃÑ·∫æ‡øø√äÃå·ªÄ√äƒÅ√°«é√†…ëƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö"],["88a1","«ú√º‡øø√™ÃÑ·∫ø‡øø√™Ãå·ªÅ√™…°‚èö‚èõ"],["8940","™é©°ÖÖ"],["8943","Êîä"],["8946","‰∏ΩÊªùÈµéÈáü"],["894c","ßúµÊíë‰ºö‰º®‰æ®ÂÖñÂÖ¥ÂÜúÂá§Âä°Âä®ÂåªÂçéÂèëÂèòÂõ¢Â£∞Â§ÑÂ§áÂ§≤Â§¥Â≠¶ÂÆûÂÆüÂ≤öÂ∫ÜÊÄªÊñâÊüæÊ†ÑÊ°•ÊµéÁÇºÁîµÁ∫§Á∫¨Á∫∫ÁªáÁªèÁªüÁºÜÁº∑Ëâ∫ËãèËçØËßÜËÆæËØ¢ËΩ¶ËΩßËΩÆ"],["89a1","ÁêëÁ≥ºÁ∑çÊ•ÜÁ´âÂàß"],["89ab","ÈÜåÁ¢∏ÈÖûËÇº"],["89b0","Ë¥ãËÉ∂†ßß"],["89b5","ËÇüÈªá‰≥çÈ∑âÈ∏å‰∞æ©∑∂ßÄéÈ∏ä™Ñ≥„óÅ"],["89c1","Ê∫öËàæÁîô"],["89c5","‰§ëÈ©¨È™èÈæôÁ¶á®ë¨°∑ä†óê¢´¶‰∏§‰∫Å‰∫Ä‰∫á‰∫ø‰ª´‰º∑„ëå‰æΩ„πàÂÄÉÂÇà„ëΩ„íì„í•ÂÜÜÂ§ÖÂáõÂáºÂàÖ‰∫âÂâπÂäêÂåß„óáÂé©„ïëÂé∞„ïìÂèÇÂê£„ï≠„ï≤„öÅÂíìÂí£Âí¥ÂíπÂìêÂìØÂîòÂî£Âî®„ñòÂîø„ñ•„ñøÂóó„óÖ"],["8a40","ß∂ÑÂî•"],["8a43","†±Ç†¥ï•Ñ´Âñê¢≥Ü„ß¨†çÅËπÜ§∂∏©ì•‰Åì®ÇæÁù∫¢∞∏„®¥‰üï®Öù¶ß≤§∑™Êìù†µº†æ¥†≥ï°É¥ÊíçËπæ†∫ñ†∞ã†Ω§¢≤©®âñ§ìì"],["8a64","†µÜ©©ç®É©‰ü¥§∫ß¢≥ÇÈ™≤„©ß©ó¥„ø≠„îÜ•ãá©üîß£à¢µÑÈµÆÈ†ï"],["8a76","‰èô¶Ç•Êí¥Âì£¢µå¢Øä°Å∑„ßª°ÅØ"],["8aa1","¶õö¶úñß¶†Êì™•Åí†±ÉËπ®¢Ü°®≠å†ú±"],["8aac","‰†ã†Ü©„ø∫Â°≥¢∂ç"],["8ab2","§óà†ìº¶Çó†Ωå†∂ñÂïπ‰Çª‰é∫"],["8abb","‰™¥¢©¶°ÇùËÜ™È£µ†∂úÊçπ„ßæ¢ùµË∑ÄÂö°Êëº„πÉ"],["8ac9","™òÅ†∏â¢´è¢≥â"],["8ace","°Éà£ßÇ„¶í„®Ü®äõ„ï∏•πâ¢ÉáÂôí†º±¢≤≤©ú†„íºÊ∞Ω§∏ª"],["8adf","ßï¥¢∫ã¢àà™ôõ®≥ç†π∫†∞¥¶†úÁæì°Éè¢†É¢§π„óª•á£†∫å†æç†∫™„æì†º∞†µá°Öè†πå"],["8af6","†∫´†Æ©†µà°ÉÄ°ÑΩ„øπ¢öñÊê≤†æ≠"],["8b40","£è¥ßòπ¢Øé†µæ†µø¢±ë¢±ï„®ò†∫ò°Éá†ºÆ™ò≤¶≠ê®≥í®∂ô®≥äÈñ™ÂìåËãÑÂñπ"],["8b55","©ªÉÈ∞¶È™∂ßùû¢∑ÆÁÖÄËÖ≠ËÉ¨Â∞ú¶ï≤ËÑ¥„ûóÂçü®ÇΩÈÜ∂†ª∫†∏è†π∑†ªª„óù§∑´„òâ†≥ñÂöØ¢ûµ°Éâ†∏ê†π∏°Å∏°Öà®àá°ëï†ππ§πê¢∂§Â©î°Äù°Äû°Éµ°É∂Âûú†∏ë"],["8ba1","ßöî®ãç†æµ†πª•Öæ„úÉ†æ∂°ÜÄ•ãò™äΩ§ßö°†∫§Ö∑®âºÂ¢ôÂâ®„òö•úΩÁÆ≤Â≠®‰†Ä‰¨¨Èºß‰ßßÈ∞üÈÆç•≠¥£ÑΩÂóª„ó≤Âöâ‰∏®Â§Ç°ØÅØ°∏Èùë†ÇÜ‰πõ‰∫ª„îæÂ∞£ÂΩëÂøÑ„£∫ÊâåÊîµÊ≠∫Ê∞µÊ∞∫ÁÅ¨Áà´‰∏¨Áä≠§£©ÁΩíÁ§ªÁ≥πÁΩì¶â™„ìÅ"],["8bde","¶çãËÄÇËÇÄ¶òí¶•ëÂçùË°§ËßÅß¢≤ËÆ†Ë¥ùÈíÖÈï∏ÈïøÈó®®∏èÈü¶È°µÈ£éÈ£ûÈ•£©†êÈ±ºÈ∏üÈªÑÊ≠ØÔ§á‰∏∑†ÇáÈòùÊà∑Èí¢"],["8c40","ÂÄªÊ∑æ©±≥Èæ¶„∑âË¢è§ÖéÁÅ∑Â≥µ‰¨†•áç„ïô•¥∞ÊÑ¢®®≤ËæßÈá∂ÁÜëÊúôÁé∫£äÅ™Ñá„≤ã°¶Ä‰¨êÁ£§ÁêÇÂÜÆ®úè‰ÄâÊ©£™ä∫‰à£Ëòè†©ØÁ®™©•á®´™ÈùïÁÅçÂå§¢ÅæÈè¥Áõô®ß£ÈæßÁüù‰∫£‰ø∞ÂÇº‰∏Ø‰ºóÈæ®Âê¥Á∂ãÂ¢íÂ£ê°∂∂Â∫íÂ∫ôÂøÇ¢úíÊñã"],["8ca1","£èπÊ§ôÊ©É£±£Ê≥ø"],["8ca7","ÁàÄ§îÖÁéå„ªõ§®ìÂ¨ïÁíπËÆÉ•≤§•öïÁ™ìÁØ¨Á≥ÉÁπ¨Ëã∏ËñóÈæ©Ë¢êÈæ™Ë∫πÈæ´ËøèËïüÈß†Èà°Èæ¨®∂π°êø‰Å±‰ä¢Â®ö"],["8cc9","È°®Êù´‰â∂ÂúΩ"],["8cce","Ëóñ§•ªËäøßÑç‰≤Å¶µ¥Âµª¶¨ï¶ææÈæ≠ÈæÆÂÆñÈæØÊõßÁπõÊπóÁßä„∂à‰ìÉ£âñ¢ûñ‰éö‰î∂"],["8ce6","Â≥ï£¨öË´πÂ±∏„¥í£ïëÂµ∏Èæ≤ÁÖó‰ïò§É¨°∏£‰±∑„•∏„ëä†Ü§¶±ÅË´å‰æ¥†àπÂ¶øËÖ¨È°ñ©£∫Âºª"],["8d40","†Æü"],["8d42","¢áÅ®•≠‰ÑÇ‰öª©Åπ„ºáÈæ≥™Üµ‰É∏„üñ‰õ∑¶±Ü‰Öº®ö≤ßèø‰ï≠„£î•íö‰ï°‰îõ‰∂â‰±ª‰µ∂‰ó™„øà§¨è„ô°‰ìû‰íΩ‰á≠Â¥æÂµàÂµñ„∑º„†èÂ∂§Â∂π„††„†∏ÂπÇÂ∫ΩÂº•ÂæÉ„§à„§î„§ø„•çÊÉóÊÑΩÂ≥•„¶âÊÜ∑ÊÜπÊáè„¶∏Êà¨ÊäêÊã•Êåò„ß∏Âö±"],["8da1","„®ÉÊè¢ÊèªÊêáÊëö„©ãÊìÄÂ¥ïÂò°Èæü„™óÊñÜ„™ΩÊóøÊôì„´≤Êöí„¨¢Êúñ„≠ÇÊû§Ê†Ä„≠òÊ°äÊ¢Ñ„≠≤„≠±„≠ªÊ§âÊ•ÉÁâúÊ•§Ê¶üÊ¶Ö„ÆºÊßñ„ØùÊ©•Ê©¥Ê©±Ê™Ç„Ø¨Ê™ô„Ø≤Ê™´Ê™µÊ´îÊ´∂ÊÆÅÊØÅÊØ™Ê±µÊ≤™„≥ãÊ¥ÇÊ¥ÜÊ¥¶Ê∂Å„≥ØÊ∂§Ê∂±Ê∏ïÊ∏òÊ∏©Ê∫Ü®ßÄÊ∫ªÊª¢ÊªöÈΩøÊª®Êª©Êº§Êº¥„µÜ£ΩÅÊæÅÊææ„µ™„µµÁÜ∑Â≤ô„∂äÁÄ¨„∂ëÁÅêÁÅîÁÅØÁÅøÁÇâ†å•‰èÅ„ó±†ªò"],["8e40","£ªóÂûæ¶ªìÁÑæ•ü†„ôéÊ¶¢®Ø©Â≠¥Á©â•£°©ìôÁ©•Á©Ω•¶¨Á™ªÁ™∞Á´ÇÁ´ÉÁáë¶íç‰áäÁ´öÁ´ùÁ´™‰áØÂí≤•∞ÅÁ¨ãÁ≠ïÁ¨©•åé•≥æÁÆ¢Á≠ØËéú•Æ¥¶±øÁØêËê°ÁÆíÁÆ∏•¥†„∂≠•±•ËííÁØ∫Á∞ÜÁ∞µ•≥ÅÁ±ÑÁ≤É§¢ÇÁ≤¶ÊôΩ§ï∏Á≥âÁ≥áÁ≥¶Á±¥Á≥≥Á≥µÁ≥é"],["8ea1","Áπß‰îù¶πÑÁµù¶ªñÁíçÁ∂âÁ∂´ÁÑµÁ∂≥Á∑í§Åó¶Ä©Á∑§„¥ìÁ∑µ°üπÁ∑•®ç≠Á∏ù¶Ñ°¶ÖöÁπÆÁ∫í‰å´Èë¨Á∏ßÁΩÄÁΩÅÁΩáÁ§∂¶ãêÈß°Áæó¶çëÁæ£°ô°†Å®‰ïú£ù¶‰îÉ®å∫Áø∫¶íâËÄÖËÄàËÄùËÄ®ËÄØ™Çá¶≥ÉËÄªËÄºËÅ°¢úî‰¶â¶ò¶£∑£¶õ®Êú•ËÇß®©àËÑáËÑöÂ¢∞¢õ∂Ê±ø¶íò§æ∏Êìß°íäËàò°°ûÊ©ì§©•§™ï‰ë∫Ëà©†¨ç¶©í£µæ‰øπ°ìΩËì¢Ëç¢¶¨ä§¶ß£î∞°ù≥£∑∏Ëä™Ê§õØ¶î‰áõ"],["8f40","ËïãËãêËåö†∏ñ°û¥„õÅ£ÖΩ£ïöËâªËã¢Ëåò£∫ã¶∂£¶¨Ö¶Æó£óé„∂øËåùÂó¨ËéÖ‰îã¶∂•Ëé¨ËèÅËèì„ëæ¶ªîÊ©óËïö„íñ¶πÇ¢ªØËëò•Ø§Ëë±„∑ì‰ì§Ê™ßËëä£≤µÁ•òËí®¶Æñ¶π∑¶πÉËìûËêèËéë‰í†ËíìËì§•≤ë‰âÄ•≥Ä‰ïÉËî¥Â´≤¶∫ô‰îßËï≥‰îñÊûøËòñ"],["8fa1","®ò•®òªËóÅßÇàËòÇ°ñÇßÉçØ¶≤‰ï™Ëò®„ôà°¢¢Âè∑ßéöËôæËù±™É∏ËüÆ¢∞ßËû±ËüöË†èÂô°Ëô¨Ê°ñ‰òèË°ÖË°Üßó†£∂πßó§Ë°ûË¢ú‰ôõË¢¥Ë¢µÊèÅË£ÖÁù∑ßúèË¶áË¶äË¶¶Ë¶©Ë¶ßË¶º®®•Ëßßß§§ß™ΩË™úÁûìÈáæË™êß©ôÁ´©ß¨∫£æè‰úìß¨∏ÁÖºË¨åË¨ü•ê∞•ï•Ë¨øË≠åË≠çË™©§©∫ËÆêËÆõË™Ø°õü‰òïË°èË≤õßµîß∂èØßî„ú•ßµìË≥ñß∂òß∂ΩË¥íË¥É°§êË≥õÁÅúË¥ë§≥â„ªêËµ∑"],["9040","Ë∂©®ÄÇ°Äî§¶ä„≠º®ÜºßÑåÁ´ßË∫≠Ë∫∂ËªÉÈãîËºôËº≠®ç•®êíËæ•ÈåÉ™äü†©êËæ≥‰§™®ßû®îΩ£∂ªÂª∏£â¢Ëøπ™Äî®öº®îÅ¢å•„¶Ä¶ªóÈÄ∑®îºß™æÈÅ°®ï¨®òãÈÇ®®úìÈÉÑ®õ¶ÈÇÆÈÉΩÈÖß„´∞ÈÜ©ÈáÑÁ≤¨®§≥°∫âÈàéÊ≤üÈâÅÈâ¢•ñπÈäπ®´Ü£≤õ®¨å•óõ"],["90a1","†¥±Èå¨Èç´®´°®Ø´ÁÇèÂ´É®´¢®´•‰••ÈâÑ®Ø¨®∞π®ØøÈç≥ÈëõË∫ºÈñÖÈñ¶Èê¶Èñ†Êø∂‰äπ¢ô∫®õò°âº£∏Æ‰ßüÊ∞úÈôªÈöñ‰Ö¨Èö£¶ªïÊáöÈö∂Á£µ®´†ÈöΩÂèå‰¶°¶≤∏†â¥¶êê©ÇØ©É•§´ë°§ï£åäÈú±ËôÇÈú∂‰®è‰îΩ‰ñÖ§´©ÁÅµÂ≠ÅÈúõÈùú©áïÈùóÂ≠ä©á´ÈùüÈê•ÂÉê£Ç∑£ÇºÈûâÈûüÈû±ÈûæÈüÄÈüíÈü†•ë¨ÈüÆÁêú©ê≥ÈüøÈüµ©êùß•∫‰´ëÈ†¥È†≥È°ãÈ°¶„¨éßÖµ„µë†ò∞§Öú"],["9140","•úÜÈ£äÈ¢∑È£àÈ£á‰´ø¶¥ß°õìÂñ∞È£°È£¶È£¨Èç∏È§π§®©‰≠≤©°ó©§ÖÈßµÈ®åÈ®ªÈ®êÈ©ò•ú•„õÑ©Ç±©ØïÈ´†È´¢©¨ÖÈ´¥‰∞éÈ¨îÈ¨≠®òÄÂÄ¥È¨¥¶¶®„£É£ÅΩÈ≠êÈ≠Ä©¥æÂ©Ö°°£ÈÆé§âãÈ∞ÇÈØøÈ∞å©π®È∑î©æ∑™Üí™Ü´™É°™Ñ£™áüÈµæÈ∂É™Ñ¥È∏éÊ¢à"],["91a1","È∑Ñ¢Öõ™Üì™à†°§ª™à≥È¥π™Çπ™ä¥È∫êÈ∫ïÈ∫ûÈ∫¢‰¥¥È∫™È∫Ø§ç§ÈªÅ„≠†„ß•„¥ù‰º≤„ûæ®∞´ÈºÇÈºà‰ÆñÈê§¶∂¢ÈºóÈºñÈºπÂöüÂöäÈΩÖÈ¶∏©ÇãÈü≤ËëøÈΩ¢ÈΩ©Á´úÈæéÁàñ‰Ææ§•µ§¶ªÁÖ∑§ß∏§çà§©ëÁéû®Øö°£∫Á¶ü®•æ®∏∂Èç©Èè≥®©ÑÈã¨ÈéÅÈèã®•¨§íπÁàó„ª´Áù≤Á©ÉÁÉê§ë≥§è∏ÁÖæ°üØÁÇ£°¢æ£ñô„ªá°¢Ö•êØ°ü∏„ú¢°õª°†π„õ°°ù¥°£ë•Ωã„ú£°õÄÂùõ§®•°èæ°ä®"],["9240","°èÜ°í∂ËîÉ£ö¶ËîÉËëï§¶îßÖ•£∏±•ïú£ªªßÅí‰ì¥£õÆ©¶ù¶º¶Êüπ„ú≥„∞ï„∑ßÂ°¨°§¢Ê†ê‰Åó£úø§É°§Çã§Ñè¶∞°ÂìãÂöû¶ö±Âöí†øü†Æ®†∏çÈèÜ®¨ìÈéú‰ª∏ÂÑ´„†ô§ê∂‰∫º†ë•†çø‰Ωã‰æä•ôëÂ©®†Ü´†èã„¶ô†åä†êî„êµ‰º©†ãÄ®∫≥†âµË´ö†àå‰∫ò"],["92a1","ÂÉçÂÑç‰æ¢‰ºÉ§®é£∫ä‰ΩÇÂÄÆÂÅ¨ÂÇÅ‰øå‰ø•ÂÅòÂÉºÂÖôÂÖõÂÖùÂÖûÊπ∂£ñï£∏π£∫øÊµ≤°¢Ñ£∫âÂÜ®ÂáÉ†ó†‰ìù†í£†íí†íëËµ∫®™ú†úéÂâôÂä§†°≥Âã°ÈçÆ‰ô∫ÁÜå§éå†∞†§¶¨°É§Êßë†∏ùÁëπ„ªûÁíôÁêîÁëñÁéò‰Æé§™º§ÇçÂèê„ñÑÁàè§ÉâÂñ¥†çÖÂìç†ØÜÂúùÈâùÈõ¥Èç¶ÂüùÂûçÂùø„òæÂ£ãÂ™ô®©Ü°õ∫°ùØ°úêÂ®¨Â¶∏ÈäèÂ©æÂ´èÂ®í••Ü°ß≥°°°§äï„õµÊ¥ÖÁëÉÂ®°•∫É"],["9340","Â™Å®Øó†êìÈè†Áíå°åÉÁÑÖ‰•≤Èêà®ßªÈéΩ„û†Â∞ûÂ≤ûÂπûÂπà°¶ñ°•º£´ÆÂªçÂ≠è°§É°§Ñ„úÅ°¢†„õù°õæ„õìËÑ™®©á°∂∫£ë≤®¶®ÂºåÂºé°§ß°û´Â©´°úªÂ≠ÑËòîßóΩË°†ÊÅæ¢°†¢ò´Âøõ„∫∏¢ñØ¢ñæ©Çà¶Ω≥ÊáÄ†Äæ†ÅÜ¢òõÊÜôÊÜòÊÅµ¢≤õ¢¥á§õî©Öç"],["93a1","Êë±§ô•¢≠™„®©¢¨¢£ëê©£™¢π∏Êå∑™ëõÊí∂Êå±Êèë§ß£¢µßÊä§¢≤°ÊêªÊï´Ê•≤„Ø¥£Çé£ä≠§¶â£ä´Âîç£ã†°£ô©êøÊõé£äâ£Ü≥„´†‰Üê•ñÑ®¨¢•ñè°õº•ïõ•ê•Á£Æ£ÑÉ°†™£à¥„ë§£àè£ÜÇ§ãâÊöé¶¥§Êô´‰ÆìÊò∞ß°∞°∑´Êô££ãí£ã°Êòû•°≤„£ë£†∫£ûº„Æô£û¢£èæÁìê„ÆñÊûè§ò™Ê¢∂Ê†û„ØÑÊ™æ„°££üï§íáÊ®≥Ê©íÊ´âÊ¨Ö°§íÊîëÊ¢òÊ©å„ØóÊ©∫Ê≠ó£øÄ£≤öÈé†Èã≤®Ø™®´ã"],["9440","Èäâ®Äû®ßúÈëßÊ∂•Êºã§ß¨Êµß£Ωø„∂èÊ∏Ñ§ÄºÂ®ΩÊ∏äÂ°áÊ¥§Á°ÇÁÑª§åö§â∂ÁÉ±ÁâêÁäáÁäî§ûè§ú•ÂÖπ§™§†ó´Áë∫£ª∏£ôü§©ä§§ó•ø°„ºÜ„∫±§´ü®∞££ºµÊÇß„ª≥ÁìåÁêºÈéáÁê∑‰íü¶∑™‰ïëÁñÉ„Ω£§≥ô§¥Ü„ΩòÁïïÁô≥™óÜ„¨ôÁë®®´å§¶´§¶é„´ª"],["94a1","„∑ç§©é„ªø§ßÖ§£≥Èá∫Âú≤ÈçÇ®´£°°§ÂÉü•à°•áßÁù∏£à≤ÁúéÁúèÁùª§öó£ûÅ„©û§£∞Áê∏Áíõ„∫ø§™∫§´á‰Éà§™ñ¶ÜÆÈåá•ñÅÁ†ûÁ¢çÁ¢àÁ£íÁèêÁ•ôßùÅ•õ£‰ÑéÁ¶õËíñÁ¶•Ê®≠£ª∫Á®∫Áß¥‰ÖÆ°õ¶‰Ñ≤ÈàµÁß±†µå§¶å†äô£∂∫°ùÆ„ñóÂï´„ï∞„ö™†áî†∞çÁ´¢Â©ô¢õµ•™Ø•™úÂ®ç†âõÁ£∞Â®™•ØÜÁ´æ‰áπÁ±ùÁ±≠‰àë•Æ≥•∫º•∫¶Á≥ç§ßπ°û∞Á≤éÁ±ºÁ≤ÆÊ™≤Á∑úÁ∏áÁ∑ìÁΩé¶â°"],["9540","¶Öúß≠àÁ∂ó•∫Ç‰â™¶≠µ†§ñÊüñ†Åé£óèÂüÑ¶êí¶è∏§•¢ÁøùÁ¨ß††¨•´©•µÉÁ¨å•∏éÈß¶ËôÖÈ©£Ê®ú£êø„ß¢§ß∑¶ñ≠È®ü¶ñ†ËíÄßÑß¶≥ë‰ì™ËÑ∑‰êÇËÉÜËÑâËÖÇ¶û¥È£É¶©ÇËâ¢Ëâ•¶©ëËëì¶∂ßËòêßàõÂ™Ü‰Öø°°ÄÂ¨´°¢°Â´§°£òËö†Ø¶º£∂èË†≠ßê¢Â®Ç"],["95a1","Ë°Æ‰ΩÖË¢áË¢øË£¶Ë••Ë•ç•öÉË•îßûÖßûÑ®Øµ®Øô®Æú®ßπ„∫≠Ëí£‰õµ‰õè„ü≤Ë®ΩË®ú©ëàÂΩçÈà´§äÑÊóîÁÑ©ÁÉÑ°°ÖÈµ≠Ë≤üË≥©ß∑úÂ¶öÁüÉÂß∞‰çÆ„õîË∏™Ë∫ß§∞âËº∞ËΩä‰ã¥Ê±òÊæª¢å°‰¢õÊΩπÊ∫ã°üöÈØ©„öµ§§ØÈÇªÈÇóÂï±‰§ÜÈÜªÈêÑ®©ã‰Å¢®´ºÈêß®∞ù®∞ªËì•Ë®´ÈñôÈñßÈñóÈññ®¥¥ÁëÖ„ªÇ§£ø§©Ç§è™„ªß£à•Èöè®ªß®π¶®π•„ªå§ß≠§©∏£øÆÁêíÁë´„ªºÈùÅ©Ç∞"],["9640","Ê°á‰®ù©Çì•üüÈùùÈç®®¶â®∞¶®¨Ø¶éæÈä∫Â¨ëË≠©‰§ºÁèπ§àõÈûõÈù±È§∏†º¶Â∑Å®ØÖ§™≤È†ü©ìöÈã∂©óóÈá•‰ìÄ®≠ê§©ß®≠§È£ú®©Ö„ºÄÈà™‰§•ËêîÈ§ªÈ•çß¨Ü„∑ΩÈ¶õ‰≠ØÈ¶™È©ú®≠••£àÊ™èÈ®°Â´æÈ®Ø©£±‰Æê©•àÈ¶º‰ÆΩ‰ÆóÈçΩÂ°≤°åÇÂ†¢§¶∏"],["96a1","°ì®Á°Ñ¢úü£∂∏Ê£Ö„µΩÈëò„§ßÊÖê¢ûÅ¢•´ÊÑáÈ±èÈ±ìÈ±ªÈ∞µÈ∞êÈ≠øÈØè©∏≠ÈÆü™áµ™ÉæÈ¥°‰≤Æ§ÑÑÈ∏ò‰≤∞È¥å™Ü¥™É≠™É≥©§ØÈ∂•ËíΩ¶∏í¶øü¶ÆÇËóº‰î≥¶∂§¶∫Ñ¶∑∞Ëê†ËóÆ¶∏Ä£üó¶Å§Áß¢£ñú£ôÄ‰§≠§ßû„µ¢ÈèõÈäæÈçà†äøÁ¢πÈâ∑Èëç‰ø§„ëÄÈÅ§•ïùÁ†ΩÁ°îÁ¢∂Á°ã°ùó£áâ§•Å„öö‰Ω≤ÊøöÊøôÁÄûÁÄûÂêî§ÜµÂûªÂ£≥ÂûäÈ¥ñÂüóÁÑ¥„íØ§Ü¨Áá´¶±Ä§æóÂ¨®°ûµ®©â"],["9740","ÊÑåÂ´éÂ®ã‰äº§íà„ú¨‰≠ª®ßºÈéªÈé∏°£ñ†ºùËë≤¶≥Ä°êì§ã∫¢∞¶§èÅÂ¶î£∂∑¶ùÅÁ∂®¶Öõ¶Ç§§¶π§¶ã®ß∫Èã•Áè¢„ª©Áí¥®≠£°¢ü„ª°§™≥Ê´òÁè≥Áèª„ªñ§®æ§™î°üô§©¶†éß°ê§§ß•Áëà§§ñÁÇ•§•∂ÈäÑÁè¶Èçü†ìæÈå±®´é®®ñÈéÜ®Øß•óï‰§µ®™ÇÁÖ´"],["97a1","§•É†≥øÂö§†òö†Ø´†≤∏ÂîÇÁßÑ°ü∫Á∑æ°õÇ§©ê°°í‰îÆÈêÅ„úä®´Ä§¶≠Â¶∞°¢ø°¢ÉßíÑÂ™°„õ¢£µõ„ö∞ÈâüÂ©π®™Å°°¢Èç¥„≥ç†™¥‰™ñ„¶äÂÉ¥„µ©„µå°éúÁÖµ‰ãª®àòÊ∏è©É§‰ì´ÊµóßπèÁÅßÊ≤Ø„≥ñ£ø≠£∏≠Ê∏ÇÊºå„µØ†èµÁïë„öº„ìà‰öÄ„ªö‰°±ÂßÑÈâÆ‰§æËΩÅ®∞ú¶ØÄÂ†íÂüà„õñ°ëíÁÉæ§ç¢§©±¢ø£°ä∞¢éΩÊ¢πÊ•ß°éò£ì•ßØ¥£õü®™É£üñ£è∫§≤üÊ®ö£ö≠¶≤∑Ëêæ‰ìü‰ìé"],["9840","¶¥¶¶µë¶≤Ç¶øûÊºóßÑâËåΩ°ú∫Ëè≠¶≤ÄßÅì°üõÂ¶âÂ™Ç°û≥Â©°Â©±°§Ö§áº„ú≠ÂßØ°úº„õáÁÜéÈéêÊöö§ä•Â©ÆÂ®´§äìÊ®´£ªπßú∂§ëõ§ãäÁÑù§âô®ß°‰æ∞¶¥®Â≥Ç§ìéßπç§éΩÊ®å§âñ°åÑÁÇ¶ÁÑ≥§è©„∂•Ê≥üØ†•§©èÁπ•Âß´Â¥Ø„∑≥ÂΩú§©ù°üüÁ∂§Ëê¶"],["98a1","ÂíÖ£´∫£åÄ†àîÂùæ†£ï†òô„ø•°æû™ä∂ÁÄÉ©ÖõÂµ∞ÁéèÁ≥ì®©ô©ê†‰øàÁøßÁãçÁåêß´¥Áå∏Áåπ•õ∂ÁçÅÁçà„∫©ß¨òÈÅ¨Ááµ§£≤Áè°Ëá∂„ªäÁúå„ªëÊ≤¢ÂõΩÁêôÁêûÁêü„ª¢„ª∞„ª¥„ª∫Áìì„ºé„ΩìÁïÇÁï≠Áï≤Áñç„ΩºÁóàÁóú„øÄÁôç„øóÁô¥„øúÁô∫§ΩúÁÜàÂò£Ë¶ÄÂ°©‰ÄùÁùÉ‰ÄπÊù°‰ÅÖ„óõÁûò‰Å™‰ÅØÂ±ûÁûæÁüãÂ£≤Á†òÁÇπÁ†ú‰Ç®Á†πÁ°áÁ°ëÁ°¶Ëëà•îµÁ§≥Ê†ÉÁ§≤‰ÑÉ"],["9940","‰ÑâÁ¶ëÁ¶ôËæªÁ®ÜËæº‰ÖßÁ™ë‰Ü≤Á™ºËâπ‰áÑÁ´èÁ´õ‰áè‰∏°Á≠¢Á≠¨Á≠ªÁ∞íÁ∞õ‰â†‰â∫Á±ªÁ≤ú‰äåÁ≤∏‰äîÁ≥≠ËæìÁÉÄ†≥èÁ∑èÁ∑îÁ∑êÁ∑ΩÁæÆÁæ¥Áäü‰éóËÄ†ËÄ•Á¨πËÄÆËÄ±ËÅî„∑åÂû¥ÁÇ†ËÇ∑ËÉ©‰è≠ËÑåÁå™ËÑéËÑíÁï†ËÑî‰êÅ„¨πËÖñËÖôËÖö"],["99a1","‰êìÂ†∫ËÖºËÜÑ‰ê•ËÜì‰ê≠ËÜ•ÂüØËáÅËá§Ëâî‰íèËä¶Ëâ∂ËãäËãòËãø‰í∞ËçóÈô©Ê¶äËêÖÁÉµËë§ÊÉ£Ëíà‰îÑËíæËì°Ëì∏ËîêËî∏Ëïí‰îªËïØËï∞Ëó†‰ï∑Ëô≤ËöíËö≤ËõØÈôÖËûã‰òÜ‰òóË¢ÆË£øË§§Ë•áË¶ëß•ßË®©Ë®∏Ë™îË™¥Ë±ëË≥îË≥≤Ë¥ú‰ûòÂ°üË∑É‰ü≠‰ªÆË∏∫ÂóòÂùîËπ±ÂóµË∫∞‰†∑ËªéËª¢Ëª§Ëª≠Ëª≤Ëæ∑ËøÅËøäËøåÈÄ≥ÈßÑ‰¢≠È£†Èàì‰§ûÈà®ÈâòÈâ´Èä±ÈäÆÈäø"],["9a40","Èã£Èã´Èã≥Èã¥ÈãΩÈçÉÈéÑÈé≠‰•Ö‰•ëÈ∫øÈêóÂåÅÈêùÈê≠Èêæ‰•™ÈëîÈëπÈî≠Èñ¢‰¶ßÈó¥Èò≥‰ß•Êû†‰®§ÈùÄ‰®µÈû≤ÈüÇÂôî‰´§ÊÉ®È¢π‰¨ôÈ£±Â°ÑÈ§éÈ§ôÂÜ¥È§úÈ§∑È•ÇÈ•ùÈ•¢‰≠∞ÈßÖ‰ÆùÈ®ºÈ¨èÁ™ÉÈ≠©ÈÆÅÈØùÈØ±ÈØ¥‰±≠È∞†„ùØ°ØÇÈµâÈ∞∫"],["9aa1","ÈªæÂôêÈ∂ìÈ∂ΩÈ∑ÄÈ∑ºÈì∂Ëæ∂ÈπªÈ∫¨È∫±È∫ΩÈªÜÈìúÈª¢Èª±Èª∏Á´àÈΩÑ†Çî†ä∑†é†Ê§öÈìÉÂ¶¨†ìóÂ°ÄÈìÅ„ûπ†óï†òï†ô∂°ö∫ÂùóÁÖ≥†´Ç†´ç†ÆøÂë™Ø†ª†ØãÂíû†Øª†∞ª†±ì†±•†±ºÊÉß†≤çÂô∫†≤µ†≥ù†≥≠†µØ†∂≤†∑àÊ•ïÈ∞ØËû•†∏Ñ†∏é†ªó†æê†º≠†π≥Â∞††æºÂ∏ã°Åú°Åè°Å∂Êúû°Åª°Çà°Çñ„ôá°Çø°Éì°ÑØ°ÑªÂç§Ëí≠°ã£°çµ°å∂ËÆÅ°ï∑°òô°üÉ°üá‰π∏ÁÇª°†≠°•™"],["9b40","°®≠°©Ö°∞™°±∞°≤¨°ªàÊãÉ°ªï°ºïÁÜòÊ°ï¢ÅÖÊß©„õà¢âº¢èó¢è∫¢ú™¢°±¢•èËãΩ¢•ß¢¶ì¢´ïË¶•¢´®Ëæ†¢¨éÈû∏¢¨øÈ°áÈ™Ω¢±å"],["9b62","¢≤à¢≤∑•Ø®¢¥à¢¥í¢∂∑¢∂ï¢πÇ¢Ω¥¢øå£Ä≥£Å¶£åü£èûÂæ±ÊôàÊöøß©π£ïß£ó≥ÁàÅ§¶∫Áüó£òö£úñÁ∫á†çÜÂ¢µÊúé"],["9ba1","Ê§ò£™ßßôó•ø¢£∏ë£∫πßóæ¢Çö‰£ê‰™∏§Ñô®™ö§ãÆ§åç§Äª§å¥§éñ§©Ö†óäÂáí†òëÂ¶ü°∫®„Ææ£≥ø§êÑ§ìñÂûà§ô¥„¶õ§úØ®ó®©ßâ„ù¢¢áÉË≠û®≠éÈßñ§†í§£ª§®ïÁàâ§´Ä†±∏Â••§∫•§æÜ†ùπËªö•Ä¨ÂäèÂúøÁÖ±•äô•êô£Ωä§™ßÂñº•ëÜ•ëÆ¶≠íÈáî„ë≥•îøßò≤•ïû‰úò•ï¢•ï¶•üá§§ø•°ùÂÅ¶„ìª£èåÊÉû•§É‰ùº®•à•™Æ•Æâ•∞Ü°∂êÂû°ÁÖëÊæ∂¶ÑÇß∞íÈÅñ¶Ü≤§æöË≠¢¶êÇ¶ëä"],["9c40","Âµõ¶Ø∑Ëº∂¶íÑ°§úË´™§ß∂¶íà£øØ¶îí‰ØÄ¶ñø¶öµ¢úõÈë••ü°ÊÜïÂ®ßØ£ç‰æªÂöπ§î°¶õº‰π™§§¥ÈôñÊ∂è¶≤Ω„òòË•∑¶ûô¶°Æ¶êë¶°ûÁáü¶£áÁ≠Ç©ÉÄ†®ë¶§¶ÈÑÑ¶§πÁ©ÖÈ∑∞¶ß∫È®¶¶®≠„ôü¶ë©†Ä°Á¶É¶®¥¶≠õÂ¥¨£îôËèè¶Æù‰õê¶≤§ÁîªË°•¶∂ÆÂ¢∂"],["9ca1","„úú¢ñçßÅãßáç„±îßäÄßäÖÈäÅ¢Ö∫ßäãÈå∞ßã¶§ßêÊ∞πÈíüßëê†ª∏Ë†ßË£µ¢§¶®ë≥°û±Ê∫∏§®™°††„¶§„öπÂ∞êÁß£‰îøÊö∂©≤≠©¢§Ë•Éßüåß°òÂõñ‰Éü°òä„¶°£úØ®É®°èÖÁÜ≠Ëç¶ßßù©Ü®Â©ß‰≤∑ßÇØ®¶´ßßΩß®äß¨ãßµ¶§Ö∫Á≠ÉÁ•æ®ÄâÊæµ™ãüÊ®É®åòÂé¢¶∏áÈéøÊ†∂Èùù®ÖØ®Ä£¶¶µ°è≠£àØ®ÅàÂ∂Ö®∞∞®ÇÉÂúïÈ†£®•âÂ∂´§¶àÊñæÊßïÂèí§™•£æÅ„∞ëÊú∂®Çê®É¥®ÑÆ°æ°®Öè"],["9d40","®Üâ®ÜØ®àö®åÜ®åØ®éä„óä®ë®®ö™‰£∫Êè¶®•ñÁ†àÈâï®¶∏‰è≤®ßß‰èü®ß®®≠Ü®ØîÂß∏®∞âËºã®øÖ©É¨Á≠ë©Ñê©Ñº„∑∑©Öû§´äËøêÁäèÂöã©ìß©ó©©ñ∞©ñ∏©ú≤©£ë©•â©•™©ßÉ©®®©¨é©µö©∂õÁ∫ü©ª∏©º£‰≤§Èïá™äìÁÜ¢™ãø‰∂ëÈÄí™óã‰∂ú†≤úËææÂóÅ"],["9da1","Ëæ∫¢í∞Ëæπ§™ì‰îâÁπøÊΩñÊ™±‰ª™„ì§®¨¨ß¢ù„ú∫Ë∫Ä°üµ®Ä§®≠¨®Æôß®æ¶öØ„∑´ßôï£≤∑•òµ••ñ‰∫ö•∫Å¶âòÂöø†π≠Ë∏éÂ≠≠£∫à§≤ûÊèûÊãê°ü∂°°ªÊî∞Âò≠•±äÂêö•åë„∑Ü©∂ò‰±ΩÂò¢ÂòûÁΩâ•ªòÂ•µ£µÄËù∞‰∏ú†ø™†µâ£ö∫ËÑóÈµûË¥òÁòªÈ±ÖÁôéÁûπÈçÖÂê≤ËÖàËã∑Âò•ËÑ≤ËêòËÇΩÂó™Á•¢ÂôÉÂêñ†∫ù„óéÂòÖÂó±Êõ±®ã¢„ò≠Áî¥Âó∞Âñ∫ÂíóÂï≤†±Å†≤ñÂªê•Öà†π∂¢±¢"],["9e40","†∫¢È∫´ÁµöÂóû°ÅµÊäùÈù≠ÂíîË≥çÁá∂ÈÖ∂ÊèºÊéπÊèæÂï©¢≠ÉÈ±≤¢∫≥ÂÜö„ìü†∂ßÂÜßÂëçÂîûÂîìÁô¶Ë∏≠¶¢äÁñ±ËÇ∂Ë†ÑËûÜË£áËÜ∂Ëêú°ÉÅ‰ì¨ÁåÑ§úÜÂÆêËåã¶¢ìÂôª¢õ¥ß¥Ø§Ü£ßµ≥¶ªêßä∂ÈÖ∞°áôÈàà£≥º™ö©†∫¨†ªπÁâ¶°≤¢‰ùé§øÇßøπ†ø´‰É∫"],["9ea1","È±ùÊîü¢∂†‰£≥§ü†©µº†ø¨†∏äÊÅ¢ßñ£†ø≠"],["9ead","¶Åà°ÜáÁÜ£Á∫éÈµê‰∏ö‰∏Ñ„ï∑Â¨çÊ≤≤Âçß„ö¨„ßúÂçΩ„ö•§òòÂ¢ö§≠ÆËà≠ÂëãÂû™•™ï†•π"],["9ec5","„©í¢ë•Áç¥©∫¨‰¥âÈØ≠£≥æ©º∞‰±õ§æ©©ñû©øûËëú£∂∂ßä≤¶û≥£ú†ÊåÆÁ¥•£ª∑£∏¨„®™ÈÄàÂãå„π¥„ô∫‰ó©†íéÁôÄÂ´∞†∫∂Á°∫ßºÆÂ¢ß‰ÇøÂôºÈÆãÂµ¥Áôî™ê¥È∫Ö‰≥°Áóπ„üªÊÑô£Éö§è≤"],["9ef5","Âôù°ä©Âûß§•£©∏ÜÂà¥ßÇÆ„ñ≠Ê±äÈµº"],["9f40","Á±ñÈ¨πÂüû°ù¨Â±ìÊìì©ìê¶åµßÖ§Ëö≠†¥®¶¥¢§´¢†µ±"],["9f4f","Âáæ°ºèÂ∂éÈúÉ°∑ëÈ∫ÅÈÅåÁ¨üÈ¨ÇÂ≥ëÁÆ£Êâ®ÊåµÈ´øÁØèÈ¨™Á±æÈ¨ÆÁ±ÇÁ≤ÜÈ∞ïÁØºÈ¨âÈºóÈ∞õ§§æÈΩöÂï≥ÂØÉ‰øΩÈ∫ò‰ø≤Ââ†„∏ÜÂãëÂùßÂÅñÂ¶∑Â∏íÈüàÈ∂´ËΩúÂë©Èû¥È•ÄÈû∫Âå¨ÊÑ∞"],["9fa1","Ê§¨ÂèöÈ∞äÈ¥Ç‰∞ªÈôÅÊ¶ÄÂÇ¶ÁïÜ°ù≠ÈßöÂâ≥"],["9fae","ÈÖôÈöÅÈÖú"],["9fb2","ÈÖë®∫óÊçø¶¥£Ê´äÂòëÈÜéÁï∫ÊäÖ†èºÁçèÁ±∞•∞°£≥Ω"],["9fc1","§§ôÁõñÈÆù‰∏™†≥îËéæË°Ç"],["9fc9","Â±äÊßÄÂÉ≠Âù∫ÂàüÂ∑µ‰ªéÊ∞±†á≤‰ºπÂíúÂìöÂäöË∂Ç„óæÂºå„ó≥"],["9fdb","Ê≠íÈÖºÈæ•ÈÆóÈ†ÆÈ¢¥È™∫È∫®È∫ÑÁÖ∫Á¨î"],["9fe7","ÊØ∫Ë†òÁΩ∏"],["9feb","Âò†™ôäËπ∑ÈΩì"],["9ff0","Ë∑îËπèÈ∏úË∏ÅÊäÇ®çΩË∏®ËπµÁ´ì§©∑Á®æÁ£òÊ≥™Ë©ßÁòá"],["a040","®©öÈº¶Ê≥éËüñÁóÉ™ä≤Á°ìØ°ÄË¥åÁã¢Áç±Ë¨≠ÁåÇÁì±Ë≥´§™ªËòØÂæ∫Ë¢†‰í∑"],["a055","°†ª¶∏Ö"],["a058","Ë©æ¢îõ"],["a05b","ÊÉΩÁôßÈ´óÈµÑÈçÆÈÆèËüµ"],["a063","Ë†èË≥∑Áå¨Èú°ÈÆ∞„óñÁä≤‰∞áÁ±ëÈ•ä¶ÖôÊÖô‰∞ÑÈ∫ñÊÖΩ"],["a073","ÂùüÊÖØÊä¶ÊàπÊãé„©úÊá¢Âé™£èµÊç§Ê†Ç„óí"],["a0a1","Âµó®ØÇËøö®∏π"],["a0a6","ÂÉô°µÜÁ§ÜÂå≤Èò∏†ºª‰Å•"],["a0ae","Áüæ"],["a0b0","Á≥Ç•ºöÁ≥öÁ®≠ËÅ¶ËÅ£ÁµçÁîÖÁì≤Ë¶îËàöÊúåËÅ¢ßíÜËÅõÁì∞ËÑÉÁú§Ë¶â¶üåÁïì¶ªëËû©ËüéËáàËûåË©âË≤≠Ë≠ÉÁú´Áì∏Ëìö„òµÊ¶≤Ë∂¶"],["a0d4","Ë¶©Áë®Ê∂πËüÅ§ÄëÁìß„∑õÁÖ∂ÊÇ§ÊÜú„≥ëÁÖ¢ÊÅ∑"],["a0e2","ÁΩ±®¨≠ÁâêÊÉ©‰≠æÂà†„∞ò£≥á•ªóßôñ•î±°•Ñ°ãæ©§É¶∑úßÇ≠Â≥Å¶Ü≠®®è£ô∑†ÉÆ¶°Ü§ºé‰ï¢Â¨ü¶çåÈΩêÈ∫¶¶â´"],["a3c0","‚êÄ",31,"‚ê°"],["c6a1","‚ë†",9,"‚ë¥",9,"‚Ö∞",9,"‰∏∂‰∏ø‰∫Ö‰∫†ÂÜÇÂÜñÂÜ´ÂãπÂå∏Âç©Âé∂Â§äÂÆÄÂ∑õ‚º≥ÂπøÂª¥ÂΩêÂΩ°Êî¥Êó†ÁñíÁô∂ËæµÈö∂¬®ÀÜ„ÉΩ„Éæ„Çù„Çû„ÄÉ‰ªù„ÄÖ„ÄÜ„Äá„ÉºÔºªÔºΩ‚úΩ„ÅÅ",23],["c740","„Åô",58,"„Ç°„Ç¢„Ç£„Ç§"],["c7a1","„Ç•",81,"–ê",5,"–Å–ñ",4],["c840","–õ",26,"—ë–∂",25,"‚áß‚Ü∏‚Üπ„áè†Éå‰πö†ÇäÂàÇ‰íë"],["c8a1","Èæ∞ÂÜàÈæ±ßòá"],["c8cd","Ôø¢Ôø§ÔºáÔºÇ„à±‚Ññ‚Ñ°„Çõ„Çú‚∫Ä‚∫Ñ‚∫Ü‚∫á‚∫à‚∫ä‚∫å‚∫ç‚∫ï‚∫ú‚∫ù‚∫•‚∫ß‚∫™‚∫¨‚∫Æ‚∫∂‚∫º‚∫æ‚ªÜ‚ªä‚ªå‚ªç‚ªè‚ªñ‚ªó‚ªû‚ª£"],["c8f5"," É…ê…õ…î…µ≈ì√∏≈ã ä…™"],["f9fe","Ôø≠"],["fa40","†ïáÈãõ†óü£øÖËïå‰äµÁèØÂÜµ„ôâ§•Ç®ß§ÈçÑ°ßõËãÆ£≥àÁ†ºÊùÑÊãü§§≥®¶™†ä†¶Æ≥°åÖ‰æ´¢ì≠ÂÄà¶¥©ß™Ñ£òÄ§™±¢îìÂÄ©†çæÂæ§†éÄ†çáÊªõ†êüÂÅΩÂÑÅ„ë∫ÂÑéÈ°¨„ùÉËêñ§¶§†íáÂÖ†£é¥ÂÖ™†Øø¢Éº†ã•¢î∞†ñé£à≥°¶ÉÂÆÇËùΩ†ñ≥£≤ôÂÜ≤ÂÜ∏"],["faa1","È¥¥ÂáâÂáèÂáë„≥úÂáì§™¶ÂÜ≥Âá¢ÂçÇÂá≠ËèçÊ§æ£ú≠ÂΩªÂàãÂà¶ÂàºÂäµÂâóÂäîÂäπÂãÖÁ∞ïËïÇÂã†Ëòç¶¨ìÂåÖ®´ûÂïâÊªô£æÄ†•î£ø¨Âå≥ÂçÑ†Ø¢Ê≥ã°ú¶Ê†õÁèïÊÅä„∫™„£å°õ®Ááù‰í¢Âç≠Âç¥®ö´ÂçæÂçø°ññ°òìÁü¶Âéì®™õÂé†Âé´ÂéÆÁéß•ù≤„ΩôÁéúÂèÅÂèÖÊ±â‰πâÂüæÂèô„™´†ÆèÂè†£ø´¢∂£Âè∂†±∑ÂêìÁÅπÂî´ÊôóÊµõÂë≠¶≠ì†µ¥ÂïùÂíèÂí§‰û¶°úç†ªù„∂¥†µç"],["fb40","®¶º¢öòÂïá‰≥≠ÂêØÁêóÂñÜÂñ©ÂòÖ°£ó§Ä∫‰ïí§êµÊö≥°Ç¥Âò∑Êõç£ääÊö§Êö≠ÂôçÂôèÁ£±Âõ±ÈûáÂèæÂúÄÂõØÂõ≠®≠¶„ò£°âèÂùÜ§Ü•Ê±ÆÁÇãÂùÇ„ö±¶±æÂü¶°êñÂ†É°ëî§ç£Â†¶§ØµÂ°úÂ¢™„ï°Â£†Â£ú°àºÂ£ªÂØøÂùÉ™Öê§â∏Èèì„ñ°Â§üÊ¢¶„õÉÊπô"],["fba1","°òæÂ®§Âïì°öíËîÖÂßâ†µé¶≤Å¶¥™°üúÂßô°üª°û≤¶∂¶Êµ±°†®°õïÂßπ¶πÖÂ™´Â©£„õ¶§¶©Â©∑„úàÂ™ñÁë•Â´ì¶æ°¢ïî„∂Ö°§ë„ú≤°ö∏Â∫ÉÂãêÂ≠∂ÊñàÂ≠ºß®é‰ÄÑ‰°ù†àÑÂØïÊÖ†°®¥•ßå†ñ•ÂØ≥ÂÆù‰¥êÂ∞Ö°≠ÑÂ∞ìÁèéÂ∞î°≤•¶¨®Â±â‰£ùÂ≤ÖÂ≥©Â≥ØÂ∂ã°∑π°∏∑Â¥êÂ¥òÂµÜ°∫§Â≤∫Â∑óËãº„†≠§§Å¢Åâ¢Ö≥Ëäá„†∂„ØÇÂ∏ÆÊ™äÂπµÂπ∫§íº†≥ìÂé¶‰∫∑ÂªêÂé®°ù±Â∏âÂª¥®íÇ"],["fc40","ÂªπÂªª„¢†ÂªºÊ†æÈêõÂºç†áÅØ¢î„´û‰¢Æ°å∫Âº∫¶¢à¢èêÂΩò¢ë±ÂΩ£ÈûΩ¶πÆÂΩ≤ÈçÄ®®∂ÂæßÂ∂∂„µü•âê°Ω™ßÉ∏¢ô®Èáñ†äû®®©ÊÄ±ÊöÖ°°∑„•£„∑á„òπÂûê¢û¥Á•±„πÄÊÇûÊÇ§ÊÇ≥§¶Ç§¶èß©ìÁí§ÂÉ°Â™†ÊÖ§Ëê§ÊÖÇØ¢¶¶ªíÊÜÅÂá¥†ôñÊÜáÂÆ™£æ∑"],["fca1","¢°üÊáì®Æù©•ùÊáê„§≤¢¶Ä¢£ÅÊÄ£ÊÖúÊîûÊéã†ÑòÊãÖ°ù∞Êãï¢∏çÊç¨§ßü„®óÊê∏Êè∏°éé°üºÊíêÊæä¢∏∂È†î§Çå•úùÊì°Êì•Èëª„©¶Êê∫„©óÊïçÊºñ§®®§®£ÊñÖÊï≠Êïü£ÅæÊñµ§•Ä‰¨∑Êóë‰Éò°†©Êó†Êó£Âøü£êÄÊòò£á∑£á∏ÊôÑ£Ü§£Ü•Êôã†πµÊôß•á¶Êô≥Êô¥°∏Ω£à±®ó¥£áà•åìÁüÖ¢£∑È¶§ÊúÇ§éú§®°„¨´Êß∫£üÇÊùûÊùßÊù¢§áç©É≠Êüó‰ì©Ê†¢ÊπêÈàºÊ†Å£è¶¶∂†Ê°ù"],["fd40","£ëØÊß°Ê®ã®´üÊ•≥Ê£É£óçÊ§ÅÊ§Ä„¥≤„®Å£òº„ÆÄÊû¨Ê•°®©ä‰ãºÊ§∂Ê¶ò„Æ°†èâËç£ÂÇêÊßπ£ôô¢Ñ™Ê©Ö£úÉÊ™ù„Ø≥Êû±Ê´à©Üú„∞çÊ¨ù†§£ÊÉûÊ¨µÊ≠¥¢üçÊ∫µ£´õ†éµ°•ò„ùÄÂê°£≠öÊØ°£ªºÊØúÊ∞∑¢íã§£±¶≠ëÊ±öËà¶Ê±π£∂º‰ìÖ£∂Ω§Ü§§§å§§Ä"],["fda1","£≥â„õ•„≥´†¥≤ÈÆÉ£áπ¢íëÁæèÊ†∑¶¥•¶∂°¶∑´Ê∂ñÊµúÊπºÊºÑ§•ø§ÇÖ¶π≤Ëî≥¶Ω¥ÂááÊ≤úÊ∏ùËêÆ®¨°Ê∏Ø£∏ØÁëì£æÇÁßåÊπèÂ™ë£ÅãÊø∏„úçÊæù£∏∞Êª∫°íó§ÄΩ‰ïïÈè∞ÊΩÑÊΩú„µéÊΩ¥©Ö∞„¥ªÊæü§ÖÑÊøì§Çë§Öï§Äπ£ø∞£æ¥§ÑøÂáü§Öñ§Öó§ÖÄ¶áùÁÅãÁÅæÁÇßÁÇÅÁÉåÁÉïÁÉñÁÉü‰ÑÑ„∑®ÁÜ¥ÁÜñ§â∑ÁÑ´ÁÖÖÂ™àÁÖäÁÖÆÂ≤ú§ç•ÁÖèÈç¢§ãÅÁÑ¨§ëö§®ß§®¢ÁÜ∫®Ø®ÁÇΩÁàé"],["fe40","ÈëÇÁàïÂ§ëÈëÉÁà§ÈçÅ•òÖÁàÆÁâÄ§•¥Ê¢ΩÁâïÁâó„πï£ÅÑÊ†çÊºΩÁäÇÁå™Áå´§†£®†´‰£≠®†ÑÁå®ÁåÆÁèèÁé™†∞∫¶®ÆÁèâÁëâ§á¢°õß§®§Êò£„õÖ§¶∑§¶ç§ßªÁè∑ÁêïÊ§É§®¶Áêπ†óÉ„ªóÁëú¢¢≠Áë†®∫≤ÁëáÁè§Áë∂ËéπÁë¨„ú∞Áë¥Èè±Ê®¨ÁíÇ‰•ì§™å"],["fea1","§Öü§©π®ÆèÂ≠Ü®∞É°¢ûÁìà°¶àÁîéÁì©Áîû®ªô°©ãÂØó®∫¨ÈéÖÁïçÁïäÁïßÁïÆ§æÇ„ºÑ§¥ìÁñéÁëùÁñûÁñ¥ÁòÇÁò¨ÁôëÁôèÁôØÁô∂¶èµÁöêËáØ„ü∏¶§ë¶§éÁö°Áö•Áö∑Áõå¶æüËë¢•Çù•ÖΩ°∏úÁúûÁú¶ÁùÄÊíØ•à†Áùò£ä¨ÁûØ®•§®•®°õÅÁü¥Á†â°ç∂§®íÊ£äÁ¢ØÁ£áÁ£ìÈö•Á§Æ•ó†Á£óÁ§¥Á¢±ßòåËæ∏Ë¢Ñ®¨´¶ÇÉ¢òúÁ¶ÜË§ÄÊ§ÇÁ¶Ä•°óÁ¶ùß¨πÁ§ºÁ¶©Ê∏™ßÑ¶„∫®ÁßÜ©ÑçÁßî"]]');

/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Buffer = (__webpack_require__(81).Buffer);

// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), 
// we opt to dependency-inject it instead of creating a hard dependency.
module.exports = function(stream_module) {
    var Transform = stream_module.Transform;

    // == Encoder stream =======================================================

    function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
        Transform.call(this, options);
    }

    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
    });

    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != 'string')
            return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    }

    IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    }

    IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on('error', cb);
        this.on('data', function(chunk) { chunks.push(chunk); });
        this.on('end', function() {
            cb(null, Buffer.concat(chunks));
        });
        return this;
    }


    // == Decoder stream =======================================================

    function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = 'utf8'; // We output strings.
        Transform.call(this, options);
    }

    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
    });

    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array))
            return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
        }
        catch (e) {
            done(e);
        }
    }

    IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);                
            done();
        }
        catch (e) {
            done(e);
        }
    }

    IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = '';
        this.on('error', cb);
        this.on('data', function(chunk) { res += chunk; });
        this.on('end', function() {
            cb(null, res);
        });
        return this;
    }

    return {
        IconvLiteEncoderStream: IconvLiteEncoderStream,
        IconvLiteDecoderStream: IconvLiteDecoderStream,
    };
};


/***/ }),
/* 104 */
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),
/* 105 */
/***/ ((module) => {

"use strict";
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = unpipe

/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */

function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data')

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true
    }
  }

  return false
}

/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */

function unpipe(stream) {
  if (!stream) {
    throw new TypeError('argument stream is required')
  }

  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe()
    return
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return
  }

  var listener
  var listeners = stream.listeners('close')

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i]

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream)
  }
}


/***/ }),
/* 106 */
/***/ ((module) => {

"use strict";
module.exports = require("node:zlib");

/***/ }),
/* 107 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var contentType = __webpack_require__(108)
var mime = __webpack_require__(109)
var typer = __webpack_require__(113)

/**
 * Module exports.
 * @public
 */

module.exports = typeofrequest
module.exports.is = typeis
module.exports.hasBody = hasbody
module.exports.normalize = normalize
module.exports.match = mimeMatch

/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */

function typeis (value, types_) {
  var i
  var types = types_

  // remove parameters and normalize
  var val = tryNormalizeType(value)

  // no type or invalid
  if (!val) {
    return false
  }

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1)
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1]
    }
  }

  // no types, return the content type
  if (!types || !types.length) {
    return val
  }

  var type
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1
        ? val
        : type
    }
  }

  // no matches
  return false
}

/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */

function hasbody (req) {
  return req.headers['transfer-encoding'] !== undefined ||
    !isNaN(req.headers['content-length'])
}

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {Object} req
 * @param {(String|Array)} types...
 * @return {(String|false|null)}
 * @public
 */

function typeofrequest (req, types_) {
  // no body
  if (!hasbody(req)) return null
  // support flattened arguments
  var types = arguments.length > 2
    ? Array.prototype.slice.call(arguments, 1)
    : types_
  // request content type
  var value = req.headers['content-type']

  return typeis(value, types)
}

/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @return {String|false|null}
 * @public
 */

function normalize (type) {
  if (typeof type !== 'string') {
    // invalid type
    return false
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded'
    case 'multipart':
      return 'multipart/*'
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '*/*' + type
  }

  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @public
 */

function mimeMatch (expected, actual) {
  // invalid type
  if (expected === false) {
    return false
  }

  // split types
  var actualParts = actual.split('/')
  var expectedParts = expected.split('/')

  // invalid format
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false
  }

  // validate type
  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false
  }

  // validate suffix wildcard
  if (expectedParts[1].slice(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 &&
      expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length)
  }

  // validate subtype
  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false
  }

  return true
}

/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {(string|null)}
 * @private
 */
function normalizeType (value) {
  // Parse the type
  var type = contentType.parse(value).type

  return typer.test(type) ? type : null
}

/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {(string|null)}
 * @private
 */
function tryNormalizeType (value) {
  try {
    return value ? normalizeType(value) : null
  } catch (err) {
    return null
  }
}


/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/ // eslint-disable-line no-control-regex
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */
var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
 * Module exports.
 * @public
 */

exports.format = format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format (obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var parameters = obj.parameters
  var type = obj.type

  if (!type || !TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  var string = type

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      if (!TOKEN_REGEXP.test(param)) {
        throw new TypeError('invalid parameter name')
      }

      string += '; ' + param + '=' + qstring(parameters[param])
    }
  }

  return string
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */

function parse (string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  // support req/res-like objects as argument
  var header = typeof string === 'object'
    ? getcontenttype(string)
    : string

  if (typeof header !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var index = header.indexOf(';')
  var type = index !== -1
    ? header.slice(0, index).trim()
    : header.trim()

  if (!TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid media type')
  }

  var obj = new ContentType(type.toLowerCase())

  // parse parameters
  if (index !== -1) {
    var key
    var match
    var value

    PARAM_REGEXP.lastIndex = index

    while ((match = PARAM_REGEXP.exec(header))) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format')
      }

      index += match[0].length
      key = match[1].toLowerCase()
      value = match[2]

      if (value.charCodeAt(0) === 0x22 /* " */) {
        // remove quotes
        value = value.slice(1, -1)

        // remove escapes
        if (value.indexOf('\\') !== -1) {
          value = value.replace(QESC_REGEXP, '$1')
        }
      }

      obj.parameters[key] = value
    }

    if (index !== header.length) {
      throw new TypeError('invalid parameter format')
    }
  }

  return obj
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */

function getcontenttype (obj) {
  var header

  if (typeof obj.getHeader === 'function') {
    // res-like
    header = obj.getHeader('content-type')
  } else if (typeof obj.headers === 'object') {
    // req-like
    header = obj.headers && obj.headers['content-type']
  }

  if (typeof header !== 'string') {
    throw new TypeError('content-type header is missing from object')
  }

  return header
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  // no need to quote tokens
  if (TOKEN_REGEXP.test(str)) {
    return str
  }

  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
    throw new TypeError('invalid parameter value')
  }

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Class to represent a content type.
 * @private
 */
function ContentType (type) {
  this.parameters = Object.create(null)
  this.type = type
}


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(110)
var extname = (__webpack_require__(49).extname)
var mimeScore = __webpack_require__(112)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)
exports._extensionConflicts = []

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .slice(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]
      types[extension] = _preferredType(extension, types[extension], type)

      // DELETE (eventually): Capture extension->type maps that change as a
      // result of switching to mime-score.  This is just to help make reviewing
      // PR #119 easier, and can be removed once that PR is approved.
      const legacyType = _preferredTypeLegacy(
        extension,
        types[extension],
        type
      )
      if (legacyType !== types[extension]) {
        exports._extensionConflicts.push([extension, legacyType, types[extension]])
      }
    }
  })
}

// Resolve type conflict using mime-score
function _preferredType (ext, type0, type1) {
  var score0 = type0 ? mimeScore(type0, db[type0].source) : 0
  var score1 = type1 ? mimeScore(type1, db[type1].source) : 0

  return score0 > score1 ? type0 : type1
}

// Resolve type conflict using pre-mime-score logic
function _preferredTypeLegacy (ext, type0, type1) {
  var SOURCE_RANK = ['nginx', 'apache', undefined, 'iana']

  var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0
  var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0

  if (
    exports.types[extension] !== 'application/octet-stream' &&
    (score0 > score1 ||
      (score0 === score1 &&
        exports.types[extension]?.slice(0, 12) === 'application/'))
  ) {
    return type0
  }

  return score0 > score1 ? type0 : type1
}


/***/ }),
/* 110 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(111)


/***/ }),
/* 111 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/ace+json":{"source":"iana","compressible":true},"application/ace-groupcomm+cbor":{"source":"iana"},"application/ace-trl+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/aif+cbor":{"source":"iana"},"application/aif+json":{"source":"iana","compressible":true},"application/alto-cdni+json":{"source":"iana","compressible":true},"application/alto-cdnifilter+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-propmap+json":{"source":"iana","compressible":true},"application/alto-propmapparams+json":{"source":"iana","compressible":true},"application/alto-tips+json":{"source":"iana","compressible":true},"application/alto-tipsparams+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/appinstaller":{"compressible":false,"extensions":["appinstaller"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/appx":{"compressible":false,"extensions":["appx"]},"application/appxbundle":{"compressible":false,"extensions":["appxbundle"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/automationml-aml+xml":{"source":"iana","compressible":true,"extensions":["aml"]},"application/automationml-amlx+zip":{"source":"iana","compressible":false,"extensions":["amlx"]},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/bufr":{"source":"iana"},"application/c2pa":{"source":"iana"},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/ce+cbor":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/cid-edhoc+cbor-seq":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/city+json-seq":{"source":"iana"},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-eap":{"source":"iana"},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/concise-problem-details+cbor":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cose-x509":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwl":{"source":"iana","extensions":["cwl"]},"application/cwl+json":{"source":"iana","compressible":true},"application/cwl+yaml":{"source":"iana"},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana","extensions":["dcm"]},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dpop+jwt":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/eat+cwt":{"source":"iana"},"application/eat+jwt":{"source":"iana"},"application/eat-bun+cbor":{"source":"iana"},"application/eat-bun+json":{"source":"iana","compressible":true},"application/eat-ucs+cbor":{"source":"iana"},"application/eat-ucs+json":{"source":"iana","compressible":true},"application/ecmascript":{"source":"apache","compressible":true,"extensions":["ecma"]},"application/edhoc+cbor-seq":{"source":"iana"},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.legacyesn+json":{"source":"iana","compressible":true},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/entity-statement+jwt":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdf":{"source":"iana","extensions":["fdf"]},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geopose+json":{"source":"iana","compressible":true},"application/geoxacml+json":{"source":"iana","compressible":true},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gnap-binding-jws":{"source":"iana"},"application/gnap-binding-jwsd":{"source":"iana"},"application/gnap-binding-rotation-jws":{"source":"iana"},"application/gnap-binding-rotation-jwsd":{"source":"iana"},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/grib":{"source":"iana"},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"iana","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"apache","charset":"UTF-8","compressible":true,"extensions":["js"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/jscontact+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jsonpath":{"source":"iana"},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwk-set+jwt":{"source":"iana"},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/linkset":{"source":"iana"},"application/linkset+json":{"source":"iana","compressible":true},"application/load-control+xml":{"source":"iana","compressible":true},"application/logout+jwt":{"source":"iana"},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4","mpg4","mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msix":{"compressible":false,"extensions":["msix"]},"application/msixbundle":{"compressible":false,"extensions":["msixbundle"]},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":true,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/ohttp-keys":{"source":"iana"},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg","one","onea"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["sig","asc"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/private-token-issuer-directory":{"source":"iana"},"application/private-token-request":{"source":"iana"},"application/private-token-response":{"source":"iana"},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/provided-claims+jwt":{"source":"iana"},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.implied-document+xml":{"source":"iana","compressible":true},"application/prs.implied-executable":{"source":"iana"},"application/prs.implied-object+json":{"source":"iana","compressible":true},"application/prs.implied-object+json-seq":{"source":"iana"},"application/prs.implied-object+yaml":{"source":"iana"},"application/prs.implied-structure":{"source":"iana"},"application/prs.mayfile":{"source":"iana"},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.vcfbzip2":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true,"extensions":["xsf"]},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"apache"},"application/reputon+json":{"source":"iana","compressible":true},"application/resolve-response+jwt":{"source":"iana"},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-checklist":{"source":"iana"},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-signed-tal":{"source":"iana"},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"apache"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana","extensions":["sql"]},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/sslkeylogfile":{"source":"iana"},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/st2110-41":{"source":"iana"},"application/stix+json":{"source":"iana","compressible":true},"application/stratum":{"source":"iana"},"application/swid+cbor":{"source":"iana"},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tm+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/toc+cbor":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"source":"iana","compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/trust-chain+json":{"source":"iana","compressible":true},"application/trust-mark+jwt":{"source":"iana"},"application/trust-mark-delegation+jwt":{"source":"iana"},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/uccs+cbor":{"source":"iana"},"application/ujcs+json":{"source":"iana","compressible":true},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vc":{"source":"iana"},"application/vc+cose":{"source":"iana"},"application/vc+jwt":{"source":"iana"},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.1ob":{"source":"iana"},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3a+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ach+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc8+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.5gsa2x":{"source":"iana"},"application/vnd.3gpp.5gsa2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gsv2x":{"source":"iana"},"application/vnd.3gpp.5gsv2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.crs+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.current-location-discovery+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-regroup+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.pinapp-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.seal-group-doc+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-network-qos-management-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-ue-config-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-unicast-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.seal-user-profile-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.v2x":{"source":"iana"},"application/vnd.3gpp.vae-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acm.addressxfer+json":{"source":"iana","compressible":true},"application/vnd.acm.chatbot+json":{"source":"iana","compressible":true},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"apache","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"apache"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.parquet":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.apexlang":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"apache"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autodesk.fbx":{"extensions":["fbx"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.belightsoft.lhzd+zip":{"source":"iana","compressible":false},"application/vnd.belightsoft.lhzl+zip":{"source":"iana","compressible":false},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.bzip3":{"source":"iana"},"application/vnd.c3voc.schedule+xml":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.cncf.helm.chart.content.v1.tar+gzip":{"source":"iana"},"application/vnd.cncf.helm.chart.provenance.v1.prov":{"source":"iana"},"application/vnd.cncf.helm.config.v1+json":{"source":"iana","compressible":true},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datalog":{"source":"iana"},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.dcmp+xml":{"source":"iana","compressible":true,"extensions":["dcmp"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.eln+zip":{"source":"iana","compressible":false},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.erofs":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"apache","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.fdsn.stationxml+xml":{"source":"iana","charset":"XML-BASED","compressible":true},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.freelog.comic":{"source":"iana"},"application/vnd.frogans.fnc":{"source":"apache","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"apache","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.ga4gh.passport+jwt":{"source":"iana"},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.genozip":{"source":"iana"},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.gentoo.catmetadata+xml":{"source":"iana","compressible":true},"application/vnd.gentoo.ebuild":{"source":"iana"},"application/vnd.gentoo.eclass":{"source":"iana"},"application/vnd.gentoo.gpkg":{"source":"iana"},"application/vnd.gentoo.manifest":{"source":"iana"},"application/vnd.gentoo.pkgmetadata+xml":{"source":"iana","compressible":true},"application/vnd.gentoo.xpak":{"source":"iana"},"application/vnd.geo+json":{"source":"apache","compressible":true},"application/vnd.geocube+xml":{"source":"apache","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.pinboard":{"source":"iana"},"application/vnd.geogebra.slides":{"source":"iana","extensions":["ggs"]},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.gnu.taler.exchange+json":{"source":"iana","compressible":true},"application/vnd.gnu.taler.merchant+json":{"source":"iana","compressible":true},"application/vnd.google-apps.audio":{},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.drawing":{"compressible":false,"extensions":["gdraw"]},"application/vnd.google-apps.drive-sdk":{"compressible":false},"application/vnd.google-apps.file":{},"application/vnd.google-apps.folder":{"compressible":false},"application/vnd.google-apps.form":{"compressible":false,"extensions":["gform"]},"application/vnd.google-apps.fusiontable":{},"application/vnd.google-apps.jam":{"compressible":false,"extensions":["gjam"]},"application/vnd.google-apps.mail-layout":{},"application/vnd.google-apps.map":{"compressible":false,"extensions":["gmap"]},"application/vnd.google-apps.photo":{},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.script":{"compressible":false,"extensions":["gscript"]},"application/vnd.google-apps.shortcut":{},"application/vnd.google-apps.site":{"compressible":false,"extensions":["gsite"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-apps.unknown":{},"application/vnd.google-apps.video":{},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"apache","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true,"extensions":["xdcf"]},"application/vnd.gpxsee.map+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.hsl":{"source":"iana"},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"apache"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"apache","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"apache"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.ipfs.ipns-record":{"source":"iana"},"application/vnd.ipld.car":{"source":"iana"},"application/vnd.ipld.dag-cbor":{"source":"iana"},"application/vnd.ipld.dag-json":{"source":"iana"},"application/vnd.ipld.raw":{"source":"iana"},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kdl":{"source":"iana"},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.keyman.kmp+zip":{"source":"iana","compressible":false},"application/vnd.keyman.kmx":{"source":"iana"},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.ldev.productlicensing":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.mdl":{"source":"iana"},"application/vnd.mdl-mbsdf":{"source":"iana"},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.medicalholodeck.recordxr":{"source":"iana"},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mermaid":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.modl":{"source":"iana"},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-visio.viewer":{"extensions":["vdx"]},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msgpack":{"source":"iana"},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.nato.bindingdataobject+cbor":{"source":"iana"},"application/vnd.nato.bindingdataobject+json":{"source":"iana","compressible":true},"application/vnd.nato.bindingdataobject+xml":{"source":"iana","compressible":true,"extensions":["bdo"]},"application/vnd.nato.openxmlformats-package.iepd+zip":{"source":"iana","compressible":false},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"apache","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oai.workflows":{"source":"iana"},"application/vnd.oai.workflows+json":{"source":"iana","compressible":true},"application/vnd.oai.workflows+yaml":{"source":"iana"},"application/vnd.oasis.opendocument.base":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"apache","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-master-template":{"source":"iana"},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"apache","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"apache","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.onvif.metadata":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openvpi.dspx+json":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.procrate.brushset":{"extensions":["brushset"]},"application/vnd.procreate.brush":{"extensions":["brush"]},"application/vnd.procreate.dream":{"extensions":["drm"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.pt.mundusmundi":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true,"extensions":["xhtm"]},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.relpipe":{"source":"iana"},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.sketchometry":{"source":"iana"},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.smintio.portals.archive":{"source":"iana"},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sybyl.mol2":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uic.osdm+json":{"source":"iana","compressible":true},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml","uo"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.veraison.tsm-report+cbor":{"source":"iana"},"application/vnd.veraison.tsm-report+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw","vsdx","vtx"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vocalshaper.vsp4":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.wasmflow.wafl":{"source":"iana"},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordlift":{"source":"iana"},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xarin.cpj":{"source":"iana"},"application/vnd.xecrets-encrypted":{"source":"iana"},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/voucher-jws+json":{"source":"iana","compressible":true},"application/vp":{"source":"iana"},"application/vp+cose":{"source":"iana"},"application/vp+jwt":{"source":"iana"},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blender":{"extensions":["blend"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-compressed":{"extensions":["rar"]},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-ipynb+json":{"compressible":true,"extensions":["ipynb"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zip-compressed":{"extensions":["zip"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xfdf":{"source":"iana","extensions":["xfdf"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yaml":{"source":"iana"},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+cbor":{"source":"iana"},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yang-sid+json":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zip+dotlottie":{"extensions":["lottie"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana","extensions":["adts","aac"]},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flac":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/matroska":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/midi-clip":{"source":"iana"},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a","m4b"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"apache"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"source":"iana","compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp","dib"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/dpx":{"source":"iana","extensions":["dpx"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/j2c":{"source":"iana"},"image/jaii":{"source":"iana","extensions":["jaii"]},"image/jais":{"source":"iana","extensions":["jais"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpg","jpeg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm","jpgm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxl":{"source":"iana","extensions":["jxl"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false,"extensions":["jfif"]},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif","btf"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.clip":{"source":"iana"},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"iana","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-adobe-dng":{"extensions":["dng"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-emf":{"source":"iana"},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-wmf":{"source":"iana"},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/bhttp":{"source":"iana"},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/mls":{"source":"iana"},"message/news":{"source":"apache"},"message/ohttp-req":{"source":"iana"},"message/ohttp-res":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime","mht","mhtml"]},"message/s-http":{"source":"apache"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"apache"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/jt":{"source":"iana","extensions":["jt"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/prc":{"source":"iana","extensions":["prc"]},"model/step":{"source":"iana","extensions":["step","stp","stpnc","p21","210"]},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/u3d":{"source":"iana","extensions":["u3d"]},"model/vnd.bary":{"source":"iana","extensions":["bary"]},"model/vnd.cld":{"source":"iana","extensions":["cld"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana","extensions":["pyo","pyox"]},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usda":{"source":"iana","extensions":["usda"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"apache"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/hl7v2":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["md","markdown"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/prs.texi":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.exchangeable":{"source":"iana"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"apache"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.vcf":{"source":"iana"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vnd.zoo.kcl":{"source":"iana"},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/wgsl":{"source":"iana","extensions":["wgsl"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/evc":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/h266":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/lottie+json":{"source":"iana","compressible":true},"video/matroska":{"source":"iana"},"video/matroska-3d":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts","m2t","m2ts","mts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.planar":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"apache"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),
/* 112 */
/***/ ((module) => {

// 'mime-score' back-ported to CommonJS

// Score RFC facets (see https://tools.ietf.org/html/rfc6838#section-3)
var FACET_SCORES = {
  'prs.': 100,
  'x-': 200,
  'x.': 300,
  'vnd.': 400,
  default: 900
}

// Score mime source (Logic originally from `jshttp/mime-types` module)
var SOURCE_SCORES = {
  nginx: 10,
  apache: 20,
  iana: 40,
  default: 30 // definitions added by `jshttp/mime-db` project?
}

var TYPE_SCORES = {
  // prefer application/xml over text/xml
  // prefer application/rtf over text/rtf
  application: 1,

  // prefer font/woff over application/font-woff
  font: 2,

  default: 0
}

/**
 * Get each component of the score for a mime type.  The sum of these is the
 * total score.  The higher the score, the more "official" the type.
 */
module.exports = function mimeScore (mimeType, source = 'default') {
  if (mimeType === 'application/octet-stream') {
    return 0
  }

  const [type, subtype] = mimeType.split('/')

  const facet = subtype.replace(/(\.|x-).*/, '$1')

  const facetScore = FACET_SCORES[facet] || FACET_SCORES.default
  const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default
  const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default

  // All else being equal prefer shorter types
  const lengthScore = 1 - mimeType.length / 100

  return facetScore + sourceScore + typeScore + lengthScore
}


/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */
var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/

/**
 * Module exports.
 */

exports.format = format
exports.parse = parse
exports.test = test

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format (obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required')
  }

  var subtype = obj.subtype
  var suffix = obj.suffix
  var type = obj.type

  if (!type || !TYPE_NAME_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
    throw new TypeError('invalid subtype')
  }

  // format as type/subtype
  var string = type + '/' + subtype

  // append +suffix
  if (suffix) {
    if (!TYPE_NAME_REGEXP.test(suffix)) {
      throw new TypeError('invalid suffix')
    }

    string += '+' + suffix
  }

  return string
}

/**
 * Test media type.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function test (string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  return TYPE_REGEXP.test(string.toLowerCase())
}

/**
 * Parse media type to object.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function parse (string) {
  if (!string) {
    throw new TypeError('argument string is required')
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string')
  }

  var match = TYPE_REGEXP.exec(string.toLowerCase())

  if (!match) {
    throw new TypeError('invalid media type')
  }

  var type = match[1]
  var subtype = match[2]
  var suffix

  // suffix after last +
  var index = subtype.lastIndexOf('+')
  if (index !== -1) {
    suffix = subtype.substr(index + 1)
    subtype = subtype.substr(0, index)
  }

  return new MediaType(type, subtype, suffix)
}

/**
 * Class for MediaType object.
 * @public
 */

function MediaType (type, subtype, suffix) {
  this.type = type
  this.subtype = subtype
  this.suffix = suffix
}


/***/ }),
/* 114 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 */

var bytes = __webpack_require__(79)
var contentType = __webpack_require__(108)
var typeis = __webpack_require__(107)

/**
 * Module exports.
 */

module.exports = {
  getCharset,
  normalizeOptions
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset (req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase()
  } catch {
    return undefined
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string | string[]} type
 * @return {function}
 */

function typeChecker (type) {
  return function checkType (req) {
    return Boolean(typeis(req, type))
  }
}

/**
 * Normalizes the common options for all parsers.
 *
 * @param {object} options options to normalize
 * @param {string | string[] | function} defaultType default content type(s) or a function to determine it
 * @returns {object}
 */
function normalizeOptions (options, defaultType) {
  if (!defaultType) {
    // Parsers must define a default content type
    throw new TypeError('defaultType must be provided')
  }

  var inflate = options?.inflate !== false
  var limit = typeof options?.limit !== 'number'
    ? bytes.parse(options?.limit || '100kb')
    : options?.limit
  var type = options?.type || defaultType
  var verify = options?.verify || false

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  return {
    inflate,
    limit,
    verify,
    shouldParse
  }
}


/***/ }),
/* 115 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var debug = __webpack_require__(65)('body-parser:raw')
var isFinished = (__webpack_require__(74).isFinished)
var read = __webpack_require__(77)
var typeis = __webpack_require__(107)
var { normalizeOptions } = __webpack_require__(114)

/**
 * Module exports.
 */

module.exports = raw

/**
 * Create a middleware to parse raw bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function raw (options) {
  var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'application/octet-stream')

  function parse (buf) {
    return buf
  }

  return function rawParser (req, res, next) {
    if (isFinished(req)) {
      debug('body already parsed')
      next()
      return
    }

    if (!('body' in req)) {
      req.body = undefined
    }

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: null,
      inflate,
      limit,
      verify
    })
  }
}


/***/ }),
/* 116 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 */

var debug = __webpack_require__(65)('body-parser:text')
var isFinished = (__webpack_require__(74).isFinished)
var read = __webpack_require__(77)
var typeis = __webpack_require__(107)
var { getCharset, normalizeOptions } = __webpack_require__(114)

/**
 * Module exports.
 */

module.exports = text

/**
 * Create a middleware to parse text bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function text (options) {
  var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'text/plain')

  var defaultCharset = options?.defaultCharset || 'utf-8'

  function parse (buf) {
    return buf
  }

  return function textParser (req, res, next) {
    if (isFinished(req)) {
      debug('body already parsed')
      next()
      return
    }

    if (!('body' in req)) {
      req.body = undefined
    }

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // get charset
    var charset = getCharset(req) || defaultCharset

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate,
      limit,
      verify
    })
  }
}


/***/ }),
/* 117 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(56)
var debug = __webpack_require__(65)('body-parser:urlencoded')
var isFinished = (__webpack_require__(74).isFinished)
var read = __webpack_require__(77)
var typeis = __webpack_require__(107)
var qs = __webpack_require__(118)
var { getCharset, normalizeOptions } = __webpack_require__(114)

/**
 * Module exports.
 */

module.exports = urlencoded

/**
 * Create a middleware to parse urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function urlencoded (options) {
  var { inflate, limit, verify, shouldParse } = normalizeOptions(options, 'application/x-www-form-urlencoded')

  var defaultCharset = options?.defaultCharset || 'utf-8'
  if (defaultCharset !== 'utf-8' && defaultCharset !== 'iso-8859-1') {
    throw new TypeError('option defaultCharset must be either utf-8 or iso-8859-1')
  }

  // create the appropriate query parser
  var queryparse = createQueryParser(options)

  function parse (body, encoding) {
    return body.length
      ? queryparse(body, encoding)
      : {}
  }

  return function urlencodedParser (req, res, next) {
    if (isFinished(req)) {
      debug('body already parsed')
      next()
      return
    }

    if (!('body' in req)) {
      req.body = undefined
    }

    // skip requests without bodies
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    debug('content-type %j', req.headers['content-type'])

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // assert charset
    var charset = getCharset(req) || defaultCharset
    if (charset !== 'utf-8' && charset !== 'iso-8859-1') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // read
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate,
      limit,
      verify
    })
  }
}

/**
 * Get the extended query parser.
 *
 * @param {object} options
 */

function createQueryParser (options) {
  var extended = Boolean(options?.extended)
  var parameterLimit = options?.parameterLimit !== undefined
    ? options?.parameterLimit
    : 1000
  var charsetSentinel = options?.charsetSentinel
  var interpretNumericEntities = options?.interpretNumericEntities
  var depth = extended ? (options?.depth !== undefined ? options?.depth : 32) : 0

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number')
  }

  if (isNaN(depth) || depth < 0) {
    throw new TypeError('option depth must be a zero or a positive number')
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0
  }

  return function queryparse (body, encoding) {
    var paramCount = parameterCount(body, parameterLimit)

    if (paramCount === undefined) {
      debug('too many parameters')
      throw createError(413, 'too many parameters', {
        type: 'parameters.too.many'
      })
    }

    var arrayLimit = extended ? Math.max(100, paramCount) : 0

    debug('parse ' + (extended ? 'extended ' : '') + 'urlencoding')
    try {
      return qs.parse(body, {
        allowPrototypes: true,
        arrayLimit: arrayLimit,
        depth: depth,
        charsetSentinel: charsetSentinel,
        interpretNumericEntities: interpretNumericEntities,
        charset: encoding,
        parameterLimit: parameterLimit,
        strictDepth: true
      })
    } catch (err) {
      if (err instanceof RangeError) {
        throw createError(400, 'The input exceeded the depth', {
          type: 'querystring.parse.rangeError'
        })
      } else {
        throw err
      }
    }
  }
}

/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */

function parameterCount (body, limit) {
  var len = body.split('&').length

  return len > limit ? undefined : len - 1
}


/***/ }),
/* 118 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(119);
var parse = __webpack_require__(163);
var formats = __webpack_require__(162);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 119 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(120);
var utils = __webpack_require__(161);
var formats = __webpack_require__(162);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: void undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'
            ? key.value
            : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];

        if (options.skipNulls && value === null) {
            continue;
        }
        pushToArray(keys, stringify(
            value,
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('‚úì')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 120 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $TypeError = __webpack_require__(121);
var inspect = __webpack_require__(122);
var getSideChannelList = __webpack_require__(124);
var getSideChannelMap = __webpack_require__(125);
var getSideChannelWeakMap = __webpack_require__(160);

var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @typedef {ReturnType<typeof getSideChannel>} Channel */

	/** @type {Channel | undefined} */ var $channelData;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			return !!$channelData && $channelData['delete'](key);
		},
		get: function (key) {
			return $channelData && $channelData.get(key);
		},
		has: function (key) {
			return !!$channelData && $channelData.has(key);
		},
		set: function (key, value) {
			if (!$channelData) {
				$channelData = makeChannel();
			}

			$channelData.set(key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),
/* 121 */
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),
/* 122 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(123);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof global !== 'undefined' && obj === global)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
function isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
function isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),
/* 123 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(62).inspect;


/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var inspect = __webpack_require__(122);

var $TypeError = __webpack_require__(121);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode} */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	// eslint-disable-next-line eqeqeq
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
			}
			return curr;
		}
	}
};

/** @type {import('./list.d.ts').listGet} */
var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	}
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('./list.d.ts').listHas} */
var listHas = function (objects, key) {
	if (!objects) {
		return false;
	}
	return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	}
};

/** @type {import('.')} */
module.exports = function getSideChannelList() {
	/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			}
			return !!deletedNode;
		},
		get: function (key) {
			return listGet($o, key);
		},
		has: function (key) {
			return listHas($o, key);
		},
		set: function (key, value) {
			if (!$o) {
				// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
				$o = {
					next: void undefined
				};
			}
			// eslint-disable-next-line no-extra-parens
			listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};


/***/ }),
/* 125 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(126);
var callBound = __webpack_require__(159);
var inspect = __webpack_require__(122);

var $TypeError = __webpack_require__(121);
var $Map = GetIntrinsic('%Map%', true);

/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
var $mapGet = callBound('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
var $mapSet = callBound('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapHas = callBound('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapDelete = callBound('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */
var $mapSize = callBound('Map.prototype.size', true);

/** @type {import('.')} */
module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
	/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {Map<K, V> | undefined} */ var $m;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			if ($m) {
				var result = $mapDelete($m, key);
				if ($mapSize($m) === 0) {
					$m = void undefined;
				}
				return result;
			}
			return false;
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($m) {
				return $mapGet($m, key);
			}
		},
		has: function (key) {
			if ($m) {
				return $mapHas($m, key);
			}
			return false;
		},
		set: function (key, value) {
			if (!$m) {
				// @ts-expect-error TS can't handle narrowing a variable inside a closure
				$m = new $Map();
			}
			$mapSet($m, key, value);
		}
	};

	// @ts-expect-error TODO: figure out why TS is erroring here
	return channel;
};


/***/ }),
/* 126 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(127);

var $Error = __webpack_require__(128);
var $EvalError = __webpack_require__(129);
var $RangeError = __webpack_require__(130);
var $ReferenceError = __webpack_require__(131);
var $SyntaxError = __webpack_require__(132);
var $TypeError = __webpack_require__(121);
var $URIError = __webpack_require__(133);

var abs = __webpack_require__(134);
var floor = __webpack_require__(135);
var max = __webpack_require__(136);
var min = __webpack_require__(137);
var pow = __webpack_require__(138);
var round = __webpack_require__(139);
var sign = __webpack_require__(140);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(142);
var $defineProperty = __webpack_require__(144);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(145)();

var getProto = __webpack_require__(147);
var $ObjectGPO = __webpack_require__(149);
var $ReflectGPO = __webpack_require__(148);

var $apply = __webpack_require__(156);
var $call = __webpack_require__(154);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(152);
var hasOwn = __webpack_require__(158);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),
/* 127 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),
/* 128 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),
/* 129 */
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),
/* 130 */
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),
/* 131 */
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),
/* 132 */
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),
/* 133 */
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),
/* 134 */
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),
/* 135 */
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),
/* 136 */
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),
/* 137 */
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),
/* 138 */
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),
/* 139 */
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),
/* 140 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(141);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),
/* 141 */
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),
/* 142 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(143);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),
/* 143 */
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),
/* 144 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),
/* 145 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(146);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),
/* 146 */
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 147 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(148);
var originalGetProto = __webpack_require__(149);

var getDunderProto = __webpack_require__(150);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),
/* 148 */
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),
/* 149 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(127);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),
/* 150 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(151);
var gOPD = __webpack_require__(142);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),
/* 151 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(152);
var $TypeError = __webpack_require__(121);

var $call = __webpack_require__(154);
var $actualApply = __webpack_require__(155);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),
/* 152 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(153);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 153 */
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 154 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),
/* 155 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(152);

var $apply = __webpack_require__(156);
var $call = __webpack_require__(154);
var $reflectApply = __webpack_require__(157);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),
/* 156 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),
/* 157 */
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),
/* 158 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(152);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),
/* 159 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(126);

var callBindBasic = __webpack_require__(151);

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};


/***/ }),
/* 160 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(126);
var callBound = __webpack_require__(159);
var inspect = __webpack_require__(122);
var getSideChannelMap = __webpack_require__(125);

var $TypeError = __webpack_require__(121);
var $WeakMap = GetIntrinsic('%WeakMap%', true);

/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

/** @type {import('.')} */
module.exports = $WeakMap
	? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapDelete($wm, key);
					}
				} else if (getSideChannelMap) {
					if ($m) {
						return $m['delete'](key);
					}
				}
				return false;
			},
			get: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				}
				return $m && $m.get(key);
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				}
				return !!$m && $m.has(key);
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap) {
					if (!$m) {
						$m = getSideChannelMap();
					}
					// eslint-disable-next-line no-extra-parens
					/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
				}
			}
		};

		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	}
	: getSideChannelMap;


/***/ }),
/* 161 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(162);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object' && typeof source !== 'function') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (
                (options && (options.plainObjects || options.allowPrototypes))
                || !has.call(Object.prototype, source)
            ) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),
/* 162 */
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),
/* 163 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(161);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }

    return val;
};

// This is what browsers will submit when the ‚úì character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ‚úì character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('‚úì')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');

    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
    );

    if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }

    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key;
        var val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');

            val = utils.maybeMap(
                parseArrayValue(
                    part.slice(pos + 1),
                    options,
                    isArray(obj[key]) ? obj[key].length : 0
                ),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(String(val));
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
        var parentKey = chain.slice(0, -1).join('');
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }

    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : utils.combine([], leaf);
        } else {
            obj = options.plainObjects ? { __proto__: null } : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }

    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? { __proto__: null } : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),
/* 164 */
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),
/* 165 */
/***/ ((module) => {

"use strict";


function mergeDescriptors(destination, source, overwrite = true) {
	if (!destination) {
		throw new TypeError('The `destination` argument is required.');
	}

	if (!source) {
		throw new TypeError('The `source` argument is required.');
	}

	for (const name of Object.getOwnPropertyNames(source)) {
		if (!overwrite && Object.hasOwn(destination, name)) {
			// Skip descriptor
			continue;
		}

		// Copy descriptor
		const descriptor = Object.getOwnPropertyDescriptor(source, name);
		Object.defineProperty(destination, name, descriptor);
	}

	return destination;
}

module.exports = mergeDescriptors;


/***/ }),
/* 166 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var finalhandler = __webpack_require__(167);
var debug = __webpack_require__(65)('express:application');
var View = __webpack_require__(174);
var http = __webpack_require__(178);
var methods = (__webpack_require__(179).methods);
var compileETag = (__webpack_require__(179).compileETag);
var compileQueryParser = (__webpack_require__(179).compileQueryParser);
var compileTrust = (__webpack_require__(179).compileTrust);
var resolve = (__webpack_require__(175).resolve);
var once = __webpack_require__(186)
var Router = __webpack_require__(188);

/**
 * Module variables.
 * @private
 */

var slice = Array.prototype.slice;
var flatten = Array.prototype.flat;

/**
 * Application prototype.
 */

var app = exports = module.exports = {};

/**
 * Variable for trust proxy inheritance back-compat
 * @private
 */

var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @private
 */

app.init = function init() {
  var router = null;

  this.cache = Object.create(null);
  this.engines = Object.create(null);
  this.settings = Object.create(null);

  this.defaultConfiguration();

  // Setup getting to lazily add base router
  Object.defineProperty(this, 'router', {
    configurable: true,
    enumerable: true,
    get: function getrouter() {
      if (router === null) {
        router = new Router({
          caseSensitive: this.enabled('case sensitive routing'),
          strict: this.enabled('strict routing')
        });
      }

      return router;
    }
  });
};

/**
 * Initialize application configuration.
 * @private
 */

app.defaultConfiguration = function defaultConfiguration() {
  var env = process.env.NODE_ENV || 'development';

  // default settings
  this.enable('x-powered-by');
  this.set('etag', 'weak');
  this.set('env', env);
  this.set('query parser', 'simple')
  this.set('subdomain offset', 2);
  this.set('trust proxy', false);

  // trust proxy inherit back-compat
  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
    configurable: true,
    value: true
  });

  debug('booting in %s mode', env);

  this.on('mount', function onmount(parent) {
    // inherit trust proxy
    if (this.settings[trustProxyDefaultSymbol] === true
      && typeof parent.settings['trust proxy fn'] === 'function') {
      delete this.settings['trust proxy'];
      delete this.settings['trust proxy fn'];
    }

    // inherit protos
    Object.setPrototypeOf(this.request, parent.request)
    Object.setPrototypeOf(this.response, parent.response)
    Object.setPrototypeOf(this.engines, parent.engines)
    Object.setPrototypeOf(this.settings, parent.settings)
  });

  // setup locals
  this.locals = Object.create(null);

  // top-most app is mounted at /
  this.mountpath = '/';

  // default locals
  this.locals.settings = this.settings;

  // default configuration
  this.set('view', View);
  this.set('views', resolve('views'));
  this.set('jsonp callback name', 'callback');

  if (env === 'production') {
    this.enable('view cache');
  }
};

/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @private
 */

app.handle = function handle(req, res, callback) {
  // final handler
  var done = callback || finalhandler(req, res, {
    env: this.get('env'),
    onerror: logerror.bind(this)
  });

  // set powered by header
  if (this.enabled('x-powered-by')) {
    res.setHeader('X-Powered-By', 'Express');
  }

  // set circular references
  req.res = res;
  res.req = req;

  // alter the prototypes
  Object.setPrototypeOf(req, this.request)
  Object.setPrototypeOf(res, this.response)

  // setup locals
  if (!res.locals) {
    res.locals = Object.create(null);
  }

  this.router.handle(req, res, done);
};

/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @public
 */

app.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate app.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var fns = flatten.call(slice.call(arguments, offset), Infinity);

  if (fns.length === 0) {
    throw new TypeError('app.use() requires a middleware function')
  }

  // get router
  var router = this.router;

  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      return router.use(path, fn);
    }

    debug('.use app under %s', path);
    fn.mountpath = path;
    fn.parent = this;

    // restore .app property on req and res
    router.use(path, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        Object.setPrototypeOf(req, orig.request)
        Object.setPrototypeOf(res, orig.response)
        next(err);
      });
    });

    // mounted an app
    fn.emit('mount', this);
  }, this);

  return this;
};

/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @public
 */

app.route = function route(path) {
  return this.router.route(path);
};

/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.ejs" file Express will invoke the following internally:
 *
 *     app.engine('ejs', require('ejs').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you don't need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/tj/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.engine = function engine(ext, fn) {
  if (typeof fn !== 'function') {
    throw new Error('callback function required');
  }

  // get file extension
  var extension = ext[0] !== '.'
    ? '.' + ext
    : ext;

  // store engine
  this.engines[extension] = fn;

  return this;
};

/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.param = function param(name, fn) {
  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this.router.param(name, fn);

  return this;
};

/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.set('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @public
 */

app.set = function set(setting, val) {
  if (arguments.length === 1) {
    // app.get(setting)
    return this.settings[setting];
  }

  debug('set "%s" to %o', setting, val);

  // set value
  this.settings[setting] = val;

  // trigger matched settings
  switch (setting) {
    case 'etag':
      this.set('etag fn', compileETag(val));
      break;
    case 'query parser':
      this.set('query parser fn', compileQueryParser(val));
      break;
    case 'trust proxy':
      this.set('trust proxy fn', compileTrust(val));

      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: false
      });

      break;
  }

  return this;
};

/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @private
 */

app.path = function path() {
  return this.parent
    ? this.parent.path() + this.mountpath
    : '';
};

/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.enabled = function enabled(setting) {
  return Boolean(this.set(setting));
};

/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.disabled = function disabled(setting) {
  return !this.set(setting);
};

/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.enable = function enable(setting) {
  return this.set(setting, true);
};

/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.disable = function disable(setting) {
  return this.set(setting, false);
};

/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */

methods.forEach(function (method) {
  app[method] = function (path) {
    if (method === 'get' && arguments.length === 1) {
      // app.get(setting)
      return this.set(path);
    }

    var route = this.route(path);
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @public
 */

app.all = function all(path) {
  var route = this.route(path);
  var args = slice.call(arguments, 1);

  for (var i = 0; i < methods.length; i++) {
    route[methods[i]].apply(route, args);
  }

  return this;
};

/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {Object|Function} options or fn
 * @param {Function} callback
 * @public
 */

app.render = function render(name, options, callback) {
  var cache = this.cache;
  var done = callback;
  var engines = this.engines;
  var opts = options;
  var view;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge options
  var renderOptions = { ...this.locals, ...opts._locals, ...opts };

  // set .cache unless explicitly provided
  if (renderOptions.cache == null) {
    renderOptions.cache = this.enabled('view cache');
  }

  // primed cache
  if (renderOptions.cache) {
    view = cache[name];
  }

  // view
  if (!view) {
    var View = this.get('view');

    view = new View(name, {
      defaultEngine: this.get('view engine'),
      root: this.get('views'),
      engines: engines
    });

    if (!view.path) {
      var dirs = Array.isArray(view.root) && view.root.length > 1
        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
        : 'directory "' + view.root + '"'
      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
      err.view = view;
      return done(err);
    }

    // prime the cache
    if (renderOptions.cache) {
      cache[name] = view;
    }
  }

  // render
  tryRender(view, renderOptions, done);
};

/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('node:http')
 *      , https = require('node:https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @public
 */

app.listen = function listen() {
  var server = http.createServer(this)
  var args = Array.prototype.slice.call(arguments)
  if (typeof args[args.length - 1] === 'function') {
    var done = args[args.length - 1] = once(args[args.length - 1])
    server.once('error', done)
  }
  return server.listen.apply(server, args)
}

/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */

function logerror(err) {
  /* istanbul ignore next */
  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
}

/**
 * Try rendering a view.
 * @private
 */

function tryRender(view, options, callback) {
  try {
    view.render(options, callback);
  } catch (err) {
    callback(err);
  }
}


/***/ }),
/* 167 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(65)('finalhandler')
var encodeUrl = __webpack_require__(168)
var escapeHtml = __webpack_require__(169)
var onFinished = __webpack_require__(74)
var parseUrl = __webpack_require__(170)
var statuses = __webpack_require__(172)

/**
 * Module variables.
 * @private
 */

var isFinished = onFinished.isFinished

/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */

function createHtmlDocument (message) {
  var body = escapeHtml(message)
    .replaceAll('\n', '<br>')
    .replaceAll('  ', ' &nbsp;')

  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>Error</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Module exports.
 * @public
 */

module.exports = finalhandler

/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function finalhandler (req, res, options) {
  var opts = options || {}

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development'

  // get error callback
  var onerror = opts.onerror

  return function (err) {
    var headers
    var msg
    var status

    // ignore 404 on in-flight response
    if (!err && res.headersSent) {
      debug('cannot 404 after headers sent')
      return
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err)

      if (status === undefined) {
        // fallback to status code on response
        status = getResponseStatusCode(res)
      } else {
        // respect headers from error
        headers = getErrorHeaders(err)
      }

      // get error message
      msg = getErrorMessage(err, status, env)
    } else {
      // not found
      status = 404
      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))
    }

    debug('default %s', status)

    // schedule onerror callback
    if (err && onerror) {
      setImmediate(onerror, err, req, res)
    }

    // cannot actually respond
    if (res.headersSent) {
      debug('cannot %d after headers sent', status)
      if (req.socket) {
        req.socket.destroy()
      }
      return
    }

    // send response
    send(req, res, status, headers, msg)
  }
}

/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */

function getErrorHeaders (err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined
  }

  return { ...err.headers }
}

/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */

function getErrorMessage (err, status, env) {
  var msg

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString()
    }
  }

  return msg || statuses.message[status]
}

/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */

function getErrorStatusCode (err) {
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
    return err.status
  }

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode
  }

  return undefined
}

/**
 * Get resource name for the request.
 *
 * This is typically just the original pathname of the request
 * but will fallback to "resource" is that cannot be determined.
 *
 * @param {IncomingMessage} req
 * @return {string}
 * @private
 */

function getResourceName (req) {
  try {
    return parseUrl.original(req).pathname
  } catch (e) {
    return 'resource'
  }
}

/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */

function getResponseStatusCode (res) {
  var status = res.statusCode

  // default status code to 500 if outside valid range
  if (typeof status !== 'number' || status < 400 || status > 599) {
    status = 500
  }

  return status
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */

function send (req, res, status, headers, message) {
  function write () {
    // response body
    var body = createHtmlDocument(message)

    // response status
    res.statusCode = status

    if (req.httpVersionMajor < 2) {
      res.statusMessage = statuses.message[status]
    }

    // remove any content headers
    res.removeHeader('Content-Encoding')
    res.removeHeader('Content-Language')
    res.removeHeader('Content-Range')

    // response headers
    for (const [key, value] of Object.entries(headers ?? {})) {
      res.setHeader(key, value)
    }

    // security headers
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

    if (req.method === 'HEAD') {
      res.end()
      return
    }

    res.end(body, 'utf8')
  }

  if (isFinished(req)) {
    write()
    return
  }

  // unpipe everything from the request
  req.unpipe()

  // flush the request
  onFinished(req, write)
  req.resume()
}


/***/ }),
/* 168 */
/***/ ((module) => {

"use strict";
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = encodeUrl

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl (url) {
  return String(url)
    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
    .replace(ENCODE_CHARS_REGEXP, encodeURI)
}


/***/ }),
/* 169 */
/***/ ((module) => {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),
/* 170 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var url = __webpack_require__(171)
var parse = url.parse
var Url = url.Url

/**
 * Module exports.
 * @public
 */

module.exports = parseurl
module.exports.original = originalurl

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedUrl = parsed)
};

/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url)
  parsed._raw = url

  return (req._parsedOriginalUrl = parsed)
};

/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse(str)
  }

  var pathname = str
  var query = null
  var search = null

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i)
          query = str.substring(i + 1)
          search = str.substring(i)
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {}

  url.path = str
  url.href = str
  url.pathname = pathname

  if (search !== null) {
    url.query = query
    url.search = search
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}


/***/ }),
/* 171 */
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),
/* 172 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var codes = __webpack_require__(173)

/**
 * Module exports.
 * @public
 */

module.exports = status

// status code to message map
status.message = codes

// status message (lower-case) to code map
status.code = createMessageToStatusCodeMap(codes)

// array of status codes
status.codes = createStatusCodeList(codes)

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
}

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
}

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
}

/**
 * Create a map of message to status code.
 * @private
 */

function createMessageToStatusCodeMap (codes) {
  var map = {}

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code]
    var status = Number(code)

    // populate map
    map[message.toLowerCase()] = status
  })

  return map
}

/**
 * Create a list of all status codes.
 * @private
 */

function createStatusCodeList (codes) {
  return Object.keys(codes).map(function mapCode (code) {
    return Number(code)
  })
}

/**
 * Get the status code for given message.
 * @private
 */

function getStatusCode (message) {
  var msg = message.toLowerCase()

  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"')
  }

  return status.code[msg]
}

/**
 * Get the status message for given code.
 * @private
 */

function getStatusMessage (code) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
    throw new Error('invalid status code: ' + code)
  }

  return status.message[code]
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    return getStatusMessage(code)
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10)
  if (!isNaN(n)) {
    return getStatusMessage(n)
  }

  return getStatusCode(code)
}


/***/ }),
/* 173 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a Teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Too Early","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');

/***/ }),
/* 174 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var debug = __webpack_require__(65)('express:view');
var path = __webpack_require__(175);
var fs = __webpack_require__(176);

/**
 * Module variables.
 * @private
 */

var dirname = path.dirname;
var basename = path.basename;
var extname = path.extname;
var join = path.join;
var resolve = path.resolve;

/**
 * Module exports.
 * @public
 */

module.exports = View;

/**
 * Initialize a new `View` with the given `name`.
 *
 * Options:
 *
 *   - `defaultEngine` the default template engine name
 *   - `engines` template engine require() cache
 *   - `root` root path for view lookup
 *
 * @param {string} name
 * @param {object} options
 * @public
 */

function View(name, options) {
  var opts = options || {};

  this.defaultEngine = opts.defaultEngine;
  this.ext = extname(name);
  this.name = name;
  this.root = opts.root;

  if (!this.ext && !this.defaultEngine) {
    throw new Error('No default engine was specified and no extension was provided.');
  }

  var fileName = name;

  if (!this.ext) {
    // get extension from default engine name
    this.ext = this.defaultEngine[0] !== '.'
      ? '.' + this.defaultEngine
      : this.defaultEngine;

    fileName += this.ext;
  }

  if (!opts.engines[this.ext]) {
    // load engine
    var mod = this.ext.slice(1)
    debug('require "%s"', mod)

    // default engine export
    var fn = __webpack_require__(177)(mod).__express

    if (typeof fn !== 'function') {
      throw new Error('Module "' + mod + '" does not provide a view engine.')
    }

    opts.engines[this.ext] = fn
  }

  // store loaded engine
  this.engine = opts.engines[this.ext];

  // lookup path
  this.path = this.lookup(fileName);
}

/**
 * Lookup view by the given `name`
 *
 * @param {string} name
 * @private
 */

View.prototype.lookup = function lookup(name) {
  var path;
  var roots = [].concat(this.root);

  debug('lookup "%s"', name);

  for (var i = 0; i < roots.length && !path; i++) {
    var root = roots[i];

    // resolve the path
    var loc = resolve(root, name);
    var dir = dirname(loc);
    var file = basename(loc);

    // resolve the file
    path = this.resolve(dir, file);
  }

  return path;
};

/**
 * Render with the given options.
 *
 * @param {object} options
 * @param {function} callback
 * @private
 */

View.prototype.render = function render(options, callback) {
  var sync = true;

  debug('render "%s"', this.path);

  // render, normalizing sync callbacks
  this.engine(this.path, options, function onRender() {
    if (!sync) {
      return callback.apply(this, arguments);
    }

    // copy arguments
    var args = new Array(arguments.length);
    var cntx = this;

    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    // force callback to be async
    return process.nextTick(function renderTick() {
      return callback.apply(cntx, args);
    });
  });

  sync = false;
};

/**
 * Resolve the file within the given directory.
 *
 * @param {string} dir
 * @param {string} file
 * @private
 */

View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;

  // <path>.<ext>
  var path = join(dir, file);
  var stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }

  // <path>/index.<ext>
  path = join(dir, basename(file, ext), 'index' + ext);
  stat = tryStat(path);

  if (stat && stat.isFile()) {
    return path;
  }
};

/**
 * Return a stat, maybe.
 *
 * @param {string} path
 * @return {fs.Stats}
 * @private
 */

function tryStat(path) {
  debug('stat "%s"', path);

  try {
    return fs.statSync(path);
  } catch (e) {
    return undefined;
  }
}


/***/ }),
/* 175 */
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),
/* 176 */
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),
/* 177 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 177;
module.exports = webpackEmptyContext;

/***/ }),
/* 178 */
/***/ ((module) => {

"use strict";
module.exports = require("node:http");

/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @api private
 */

var { METHODS } = __webpack_require__(178);
var contentType = __webpack_require__(108);
var etag = __webpack_require__(180);
var mime = __webpack_require__(109)
var proxyaddr = __webpack_require__(182);
var qs = __webpack_require__(118);
var querystring = __webpack_require__(185);

/**
 * A list of lowercased HTTP methods that are supported by Node.js.
 * @api private
 */
exports.methods = METHODS.map((method) => method.toLowerCase());

/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.etag = createETagGenerator({ weak: false })

/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.wetag = createETagGenerator({ weak: true })

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: (mime.lookup(type) || 'application/octet-stream'), params: {} }
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types) {
  return types.map(exports.normalizeType);
};


/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams (str) {
  var length = str.length;
  var colonIndex = str.indexOf(';');
  var index = colonIndex === -1 ? length : colonIndex;
  var ret = { value: str.slice(0, index).trim(), quality: 1, params: {} };

  while (index < length) {
    var splitIndex = str.indexOf('=', index);
    if (splitIndex === -1) break;

    var colonIndex = str.indexOf(';', index);
    var endIndex = colonIndex === -1 ? length : colonIndex;

    if (splitIndex > endIndex) {
      index = str.lastIndexOf(';', splitIndex - 1) + 1;
      continue;
    }

    var key = str.slice(index, splitIndex).trim();
    var value = str.slice(splitIndex + 1, endIndex).trim();

    if (key === 'q') {
      ret.quality = parseFloat(value);
    } else {
      ret.params[key] = value;
    }

    index = endIndex + 1;
  }

  return ret;
}

/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileETag = function(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'weak':
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  }

  return fn;
}

/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileQueryParser = function compileQueryParser(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
    case 'simple':
      fn = querystring.parse;
      break;
    case false:
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  }

  return fn;
}

/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */

exports.compileTrust = function(val) {
  if (typeof val === 'function') return val;

  if (val === true) {
    // Support plain true/false
    return function(){ return true };
  }

  if (typeof val === 'number') {
    // Support trusting hop count
    return function(a, i){ return i < val };
  }

  if (typeof val === 'string') {
    // Support comma-separated values
    val = val.split(',')
      .map(function (v) { return v.trim() })
  }

  return proxyaddr.compile(val || []);
}

/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */

exports.setCharset = function setCharset(type, charset) {
  if (!type || !charset) {
    return type;
  }

  // parse type
  var parsed = contentType.parse(type);

  // set charset
  parsed.parameters.charset = charset;

  // format type
  return contentType.format(parsed);
};

/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param {object} options
 * @return {function}
 * @private
 */

function createETagGenerator (options) {
  return function generateETag (body, encoding) {
    var buf = !Buffer.isBuffer(body)
      ? Buffer.from(body, encoding)
      : body

    return etag(buf, options)
  }
}

/**
 * Parse an extended query string with qs.
 *
 * @param {String} str
 * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return qs.parse(str, {
    allowPrototypes: true
  });
}


/***/ }),
/* 180 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = etag

/**
 * Module dependencies.
 * @private
 */

var crypto = __webpack_require__(50)
var Stats = (__webpack_require__(181).Stats)

/**
 * Module variables.
 * @private
 */

var toString = Object.prototype.toString

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag (entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"'
  }

  // compute hash of entity
  var hash = crypto
    .createHash('sha1')
    .update(entity, 'utf8')
    .digest('base64')
    .substring(0, 27)

  // compute length of entity
  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length

  return '"' + len.toString(16) + '-' + hash + '"'
}

/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */

function etag (entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required')
  }

  // support fs.Stats object
  var isStats = isstats(entity)
  var weak = options && typeof options.weak === 'boolean'
    ? options.weak
    : isStats

  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  // generate entity tag
  var tag = isStats
    ? stattag(entity)
    : entitytag(entity)

  return weak
    ? 'W/' + tag
    : tag
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats (obj) {
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
    return true
  }

  // quack quack
  return obj && typeof obj === 'object' &&
    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&
    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&
    'ino' in obj && typeof obj.ino === 'number' &&
    'size' in obj && typeof obj.size === 'number'
}

/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag (stat) {
  var mtime = stat.mtime.getTime().toString(16)
  var size = stat.size.toString(16)

  return '"' + size + '-' + mtime + '"'
}


/***/ }),
/* 181 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 182 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = proxyaddr
module.exports.all = alladdrs
module.exports.compile = compile

/**
 * Module dependencies.
 * @private
 */

var forwarded = __webpack_require__(183)
var ipaddr = __webpack_require__(184)

/**
 * Variables.
 * @private
 */

var DIGIT_REGEXP = /^[0-9]+$/
var isip = ipaddr.isValid
var parseip = ipaddr.parse

/**
 * Pre-defined IP ranges.
 * @private
 */

var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
}

/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */

function alladdrs (req, trust) {
  // get addresses
  var addrs = forwarded(req)

  if (!trust) {
    // Return all addresses
    return addrs
  }

  if (typeof trust !== 'function') {
    trust = compile(trust)
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue

    addrs.length = i + 1
  }

  return addrs
}

/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */

function compile (val) {
  if (!val) {
    throw new TypeError('argument is required')
  }

  var trust

  if (typeof val === 'string') {
    trust = [val]
  } else if (Array.isArray(val)) {
    trust = val.slice()
  } else {
    throw new TypeError('unsupported trust argument')
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i]

    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue
    }

    // Splice in pre-defined range
    val = IP_RANGES[val]
    trust.splice.apply(trust, [i, 1].concat(val))
    i += val.length - 1
  }

  return compileTrust(compileRangeSubnets(trust))
}

/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */

function compileRangeSubnets (arr) {
  var rangeSubnets = new Array(arr.length)

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i])
  }

  return rangeSubnets
}

/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */

function compileTrust (rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length
  return len === 0
    ? trustNone
    : len === 1
      ? trustSingle(rangeSubnets[0])
      : trustMulti(rangeSubnets)
}

/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */

function parseipNotation (note) {
  var pos = note.lastIndexOf('/')
  var str = pos !== -1
    ? note.substring(0, pos)
    : note

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str)
  }

  var ip = parseip(str)

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address()
  }

  var max = ip.kind() === 'ipv6'
    ? 128
    : 32

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null

  if (range === null) {
    range = max
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10)
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range)
  } else {
    range = null
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note)
  }

  return [ip, range]
}

/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */

function parseNetmask (netmask) {
  var ip = parseip(netmask)
  var kind = ip.kind()

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null
}

/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */

function proxyaddr (req, trust) {
  if (!req) {
    throw new TypeError('req argument is required')
  }

  if (!trust) {
    throw new TypeError('trust argument is required')
  }

  var addrs = alladdrs(req, trust)
  var addr = addrs[addrs.length - 1]

  return addr
}

/**
 * Static trust function to trust nothing.
 *
 * @private
 */

function trustNone () {
  return false
}

/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */

function trustMulti (subnets) {
  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var ipconv
    var kind = ip.kind()

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i]
      var subnetip = subnet[0]
      var subnetkind = subnetip.kind()
      var subnetrange = subnet[1]
      var trusted = ip

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          continue
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4'
            ? ip.toIPv4Address()
            : ip.toIPv4MappedAddress()
        }

        trusted = ipconv
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true
      }
    }

    return false
  }
}

/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */

function trustSingle (subnet) {
  var subnetip = subnet[0]
  var subnetkind = subnetip.kind()
  var subnetisipv4 = subnetkind === 'ipv4'
  var subnetrange = subnet[1]

  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var kind = ip.kind()

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
        return false
      }

      // Convert IP to match subnet IP kind
      ip = subnetisipv4
        ? ip.toIPv4Address()
        : ip.toIPv4MappedAddress()
    }

    return ip.match(subnetip, subnetrange)
  }
}


/***/ }),
/* 183 */
/***/ ((module) => {

"use strict";
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = forwarded

/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */

function forwarded (req) {
  if (!req) {
    throw new TypeError('argument req is required')
  }

  // simple header parsing
  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')
  var socketAddr = getSocketAddr(req)
  var addrs = [socketAddr].concat(proxyAddrs)

  // return all addresses
  return addrs
}

/**
 * Get the socket address for a request.
 *
 * @param {object} req
 * @return {string}
 * @private
 */

function getSocketAddr (req) {
  return req.socket
    ? req.socket.remoteAddress
    : req.connection.remoteAddress
}

/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */

function parse (header) {
  var end = header.length
  var list = []
  var start = header.length

  // gather addresses, backwards
  for (var i = header.length - 1; i >= 0; i--) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(header.substring(start, end))
        }
        start = end = i
        break
      default:
        start = i
        break
    }
  }

  // final address
  if (start !== end) {
    list.push(header.substring(start, end))
  }

  return list
}


/***/ }),
/* 184 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

  ipaddr = {};

  root = this;

  if (( true && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var k, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (k = 0, len = rangeSubnets.length; k < len; k++) {
        subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var k, len, octet;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (k = 0, len = octets.length; k < len; k++) {
        octet = octets[k];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toNormalizedString = function() {
      return this.toString();
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 3; k >= 0; i = k += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseIntAuto(part));
        }
        return results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var k, results;
        results = [];
        for (shift = k = 0; k <= 24; shift = k += 8) {
          results.push((value >> shift) & 0xff);
        }
        return results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts, zoneId) {
      var i, k, l, len, part, ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = k = 0; k <= 14; i = k += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      ref = this.parts;
      for (l = 0, len = ref.length; l < len; l++) {
        part = ref[l];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
      if (zoneId) {
        this.zoneId = zoneId;
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    };

    IPv6.prototype.toRFC5952String = function() {
      var bestMatchIndex, bestMatchLength, match, regex, string;
      regex = /((^|:)(0(:|$)){2,})/g;
      string = this.toNormalizedString();
      bestMatchIndex = 0;
      bestMatchLength = -1;
      while ((match = regex.exec(string))) {
        if (match[0].length > bestMatchLength) {
          bestMatchIndex = match.index;
          bestMatchLength = match[0].length;
        }
      }
      if (bestMatchLength < 0) {
        return string;
      }
      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.toFixedLengthString = function() {
      var addr, part, suffix;
      addr = ((function() {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16).padStart(4, '0'));
        }
        return results;
      }).call(this)).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    IPv6.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = {
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 7; k >= 0; i = k += -1) {
        part = this.parts[i];
        if (part in zerotable) {
          zeros = zerotable[part];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 16) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 128 - cidr;
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  zoneIndex = "%[0-9a-z]{1,}";

  ipv6Regexes = {
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
    if (zoneId) {
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    parts = (function() {
      var k, len, ref, results;
      ref = string.split(":");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        results.push(parseInt(part, 16));
      }
      return results;
    })();
    return {
      parts: parts,
      zoneId: zoneId
    };
  };

  ipaddr.IPv6.parser = function(string) {
    var addr, k, len, match, octet, octets, zoneId;
    if (ipv6Regexes['native'].test(string)) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
      if (addr.parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return {
          parts: addr.parts,
          zoneId: addr.zoneId
        };
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function(string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var addr, e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    } catch (error1) {
      e = error1;
      return false;
    }
  };

  ipaddr.IPv4.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv6.parse = function(string) {
    var addr;
    addr = this.parser(string);
    if (addr.parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(addr.parts, addr.zoneId);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);
    if (prefix < 0 || prefix > 32) {
      throw new Error('ipaddr: invalid IPv4 prefix length');
    }
    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);
    while (j < filledOctetCount) {
      octets[j] = 255;
      j++;
    }
    if (filledOctetCount < 4) {
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);
    }
    return new this(octets);
  };

  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv4.networkAddressFromCIDR = function(string) {
    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      }
      return new this(octets);
    } catch (error1) {
      error = error1;
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match, parsed;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        parsed = [this.parse(match[1]), maskLength];
        Object.defineProperty(parsed, 'toString', {
          value: function() {
            return this.join('/');
          }
        });
        return parsed;
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error1) {
      e = error1;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);


/***/ }),
/* 185 */
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),
/* 186 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(187)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),
/* 187 */
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),
/* 188 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

const isPromise = __webpack_require__(189)
const Layer = __webpack_require__(190)
const { METHODS } = __webpack_require__(178)
const parseUrl = __webpack_require__(170)
const Route = __webpack_require__(192)
const debug = __webpack_require__(65)('router')
const deprecate = __webpack_require__(57)('router')

/**
 * Module variables.
 * @private
 */

const slice = Array.prototype.slice
const flatten = Array.prototype.flat
const methods = METHODS.map((method) => method.toLowerCase())

/**
 * Expose `Router`.
 */

module.exports = Router

/**
 * Expose `Route`.
 */

module.exports.Route = Route

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {object} [options]
 * @return {Router} which is a callable function
 * @public
 */

function Router (options) {
  if (!(this instanceof Router)) {
    return new Router(options)
  }

  const opts = options || {}

  function router (req, res, next) {
    router.handle(req, res, next)
  }

  // inherit from the correct prototype
  Object.setPrototypeOf(router, this)

  router.caseSensitive = opts.caseSensitive
  router.mergeParams = opts.mergeParams
  router.params = {}
  router.strict = opts.strict
  router.stack = []

  return router
}

/**
 * Router prototype inherits from a Function.
 */

/* istanbul ignore next */
Router.prototype = function () {}

/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code.
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  router.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err)
 *      } else if (!user) {
 *        return next(new Error('failed to load user'))
 *      }
 *      req.user = user
 *      next()
 *    })
 *  })
 *
 * @param {string} name
 * @param {function} fn
 * @public
 */

Router.prototype.param = function param (name, fn) {
  if (!name) {
    throw new TypeError('argument name is required')
  }

  if (typeof name !== 'string') {
    throw new TypeError('argument name must be a string')
  }

  if (!fn) {
    throw new TypeError('argument fn is required')
  }

  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function')
  }

  let params = this.params[name]

  if (!params) {
    params = this.params[name] = []
  }

  params.push(fn)

  return this
}

/**
 * Dispatch a req, res into the router.
 *
 * @private
 */

Router.prototype.handle = function handle (req, res, callback) {
  if (!callback) {
    throw new TypeError('argument callback is required')
  }

  debug('dispatching %s %s', req.method, req.url)

  let idx = 0
  let methods
  const protohost = getProtohost(req.url) || ''
  let removed = ''
  const self = this
  let slashAdded = false
  let sync = 0
  const paramcalled = {}

  // middleware and routes
  const stack = this.stack

  // manage inter-router variables
  const parentParams = req.params
  const parentUrl = req.baseUrl || ''
  let done = restore(callback, req, 'baseUrl', 'next', 'params')

  // setup next layer
  req.next = next

  // for options requests, respond with a default if nothing else responds
  if (req.method === 'OPTIONS') {
    methods = []
    done = wrap(done, generateOptionsResponder(res, methods))
  }

  // setup basic req values
  req.baseUrl = parentUrl
  req.originalUrl = req.originalUrl || req.url

  next()

  function next (err) {
    let layerError = err === 'route'
      ? null
      : err

    // remove added slash
    if (slashAdded) {
      req.url = req.url.slice(1)
      slashAdded = false
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl
      req.url = protohost + removed + req.url.slice(protohost.length)
      removed = ''
    }

    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null)
      return
    }

    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError)
      return
    }

    // max sync stack
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    // get pathname of request
    const path = getPathname(req)

    if (path == null) {
      return done(layerError)
    }

    // find next matching layer
    let layer
    let match
    let route

    while (match !== true && idx < stack.length) {
      layer = stack[idx++]
      match = matchLayer(layer, path)
      route = layer.route

      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match
      }

      if (match !== true) {
        continue
      }

      if (!route) {
        // process non-route handlers normally
        continue
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false
        continue
      }

      const method = req.method
      const hasMethod = route._handlesMethod(method)

      // build up automatic options response
      if (!hasMethod && method === 'OPTIONS' && methods) {
        methods.push.apply(methods, route._methods())
      }

      // don't even bother matching route
      if (!hasMethod && method !== 'HEAD') {
        match = false
      }
    }

    // no match
    if (match !== true) {
      return done(layerError)
    }

    // store route for dispatch on change
    if (route) {
      req.route = route
    }

    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params
    const layerPath = layer.path

    // this should be done for the layer
    processParams(self.params, layer, paramcalled, req, res, function (err) {
      if (err) {
        next(layerError || err)
      } else if (route) {
        layer.handleRequest(req, res, next)
      } else {
        trimPrefix(layer, layerError, layerPath, path)
      }

      sync = 0
    })
  }

  function trimPrefix (layer, layerError, layerPath, path) {
    if (layerPath.length !== 0) {
      // Validate path is a prefix match
      if (layerPath !== path.substring(0, layerPath.length)) {
        next(layerError)
        return
      }

      // Validate path breaks on a path separator
      const c = path[layerPath.length]
      if (c && c !== '/') {
        next(layerError)
        return
      }

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug('trim prefix (%s) from url %s', layerPath, req.url)
      removed = layerPath
      req.url = protohost + req.url.slice(protohost.length + removed.length)

      // Ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url
        slashAdded = true
      }

      // Setup base URL (no trailing slash)
      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
        ? removed.substring(0, removed.length - 1)
        : removed)
    }

    debug('%s %s : %s', layer.name, layerPath, req.originalUrl)

    if (layerError) {
      layer.handleError(layerError, req, res, next)
    } else {
      layer.handleRequest(req, res, next)
    }
  }
}

/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */

Router.prototype.use = function use (handler) {
  let offset = 0
  let path = '/'

  // default path to '/'
  // disambiguate router.use([handler])
  if (typeof handler !== 'function') {
    let arg = handler

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0]
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1
      path = handler
    }
  }

  const callbacks = flatten.call(slice.call(arguments, offset), Infinity)

  if (callbacks.length === 0) {
    throw new TypeError('argument handler is required')
  }

  for (let i = 0; i < callbacks.length; i++) {
    const fn = callbacks[i]

    if (typeof fn !== 'function') {
      throw new TypeError('argument handler must be a function')
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    const layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn)

    layer.route = undefined

    this.stack.push(layer)
  }

  return this
}

/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {string} path
 * @return {Route}
 * @public
 */

Router.prototype.route = function route (path) {
  const route = new Route(path)

  const layer = new Layer(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, handle)

  function handle (req, res, next) {
    route.dispatch(req, res, next)
  }

  layer.route = route

  this.stack.push(layer)
  return route
}

// create Router#VERB functions
methods.concat('all').forEach(function (method) {
  Router.prototype[method] = function (path) {
    const route = this.route(path)
    route[method].apply(route, slice.call(arguments, 1))
    return this
  }
})

/**
 * Generate a callback that will make an OPTIONS response.
 *
 * @param {OutgoingMessage} res
 * @param {array} methods
 * @private
 */

function generateOptionsResponder (res, methods) {
  return function onDone (fn, err) {
    if (err || methods.length === 0) {
      return fn(err)
    }

    trySendOptionsResponse(res, methods, fn)
  }
}

/**
 * Get pathname of request.
 *
 * @param {IncomingMessage} req
 * @private
 */

function getPathname (req) {
  try {
    return parseUrl(req).pathname
  } catch (err) {
    return undefined
  }
}

/**
 * Get get protocol + host for a URL.
 *
 * @param {string} url
 * @private
 */

function getProtohost (url) {
  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
    return undefined
  }

  const searchIndex = url.indexOf('?')
  const pathLength = searchIndex !== -1
    ? searchIndex
    : url.length
  const fqdnIndex = url.substring(0, pathLength).indexOf('://')

  return fqdnIndex !== -1
    ? url.substring(0, url.indexOf('/', 3 + fqdnIndex))
    : undefined
}

/**
 * Match path to a layer.
 *
 * @param {Layer} layer
 * @param {string} path
 * @private
 */

function matchLayer (layer, path) {
  try {
    return layer.match(path)
  } catch (err) {
    return err
  }
}

/**
 * Merge params with parent params
 *
 * @private
 */

function mergeParams (params, parent) {
  if (typeof parent !== 'object' || !parent) {
    return params
  }

  // make copy of parent for base
  const obj = Object.assign({}, parent)

  // simple non-numeric merging
  if (!(0 in params) || !(0 in parent)) {
    return Object.assign(obj, params)
  }

  let i = 0
  let o = 0

  // determine numeric gap in params
  while (i in params) {
    i++
  }

  // determine numeric gap in parent
  while (o in parent) {
    o++
  }

  // offset numeric indices in params before merge
  for (i--; i >= 0; i--) {
    params[i + o] = params[i]

    // create holes for the merge when necessary
    if (i < o) {
      delete params[i]
    }
  }

  return Object.assign(obj, params)
}

/**
 * Process any parameters for the layer.
 *
 * @private
 */

function processParams (params, layer, called, req, res, done) {
  // captured parameters from the layer, keys and values
  const keys = layer.keys

  // fast track
  if (!keys || keys.length === 0) {
    return done()
  }

  let i = 0
  let paramIndex = 0
  let key
  let paramVal
  let paramCallbacks
  let paramCalled

  // process params in order
  // param callbacks can be async
  function param (err) {
    if (err) {
      return done(err)
    }

    if (i >= keys.length) {
      return done()
    }

    paramIndex = 0
    key = keys[i++]
    paramVal = req.params[key]
    paramCallbacks = params[key]
    paramCalled = called[key]

    if (paramVal === undefined || !paramCallbacks) {
      return param()
    }

    // param previously called with same value or error occurred
    if (paramCalled && (paramCalled.match === paramVal ||
      (paramCalled.error && paramCalled.error !== 'route'))) {
      // restore value
      req.params[key] = paramCalled.value

      // next param
      return param(paramCalled.error)
    }

    called[key] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    }

    paramCallback()
  }

  // single param callbacks
  function paramCallback (err) {
    const fn = paramCallbacks[paramIndex++]

    // store updated value
    paramCalled.value = req.params[key]

    if (err) {
      // store error
      paramCalled.error = err
      param(err)
      return
    }

    if (!fn) return param()

    try {
      const ret = fn(req, res, paramCallback, paramVal, key)
      if (isPromise(ret)) {
        if (!(ret instanceof Promise)) {
          deprecate('parameters that are Promise-like are deprecated, use a native Promise instead')
        }

        ret.then(null, function (error) {
          paramCallback(error || new Error('Rejected promise'))
        })
      }
    } catch (e) {
      paramCallback(e)
    }
  }

  param()
}

/**
 * Restore obj props after function
 *
 * @private
 */

function restore (fn, obj) {
  const props = new Array(arguments.length - 2)
  const vals = new Array(arguments.length - 2)

  for (let i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2]
    vals[i] = obj[props[i]]
  }

  return function () {
    // restore vals
    for (let i = 0; i < props.length; i++) {
      obj[props[i]] = vals[i]
    }

    return fn.apply(this, arguments)
  }
}

/**
 * Send an OPTIONS response.
 *
 * @private
 */

function sendOptionsResponse (res, methods) {
  const options = Object.create(null)

  // build unique method map
  for (let i = 0; i < methods.length; i++) {
    options[methods[i]] = true
  }

  // construct the allow list
  const allow = Object.keys(options).sort().join(', ')

  // send response
  res.setHeader('Allow', allow)
  res.setHeader('Content-Length', Buffer.byteLength(allow))
  res.setHeader('Content-Type', 'text/plain')
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.end(allow)
}

/**
 * Try to send an OPTIONS response.
 *
 * @private
 */

function trySendOptionsResponse (res, methods, next) {
  try {
    sendOptionsResponse(res, methods)
  } catch (err) {
    next(err)
  }
}

/**
 * Wrap a function
 *
 * @private
 */

function wrap (old, fn) {
  return function proxy () {
    const args = new Array(arguments.length + 1)

    args[0] = old
    for (let i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i]
    }

    fn.apply(this, args)
  }
}


/***/ }),
/* 189 */
/***/ ((module) => {

module.exports = isPromise;
module.exports["default"] = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}


/***/ }),
/* 190 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

const isPromise = __webpack_require__(189)
const pathRegexp = __webpack_require__(191)
const debug = __webpack_require__(65)('router:layer')
const deprecate = __webpack_require__(57)('router')

/**
 * Module variables.
 * @private
 */

const TRAILING_SLASH_REGEXP = /\/+$/
const MATCHING_GROUP_REGEXP = /\((?:\?<(.*?)>)?(?!\?)/g

/**
 * Expose `Layer`.
 */

module.exports = Layer

function Layer (path, options, fn) {
  if (!(this instanceof Layer)) {
    return new Layer(path, options, fn)
  }

  debug('new %o', path)
  const opts = options || {}

  this.handle = fn
  this.keys = []
  this.name = fn.name || '<anonymous>'
  this.params = undefined
  this.path = undefined
  this.slash = path === '/' && opts.end === false

  function matcher (_path) {
    if (_path instanceof RegExp) {
      const keys = []
      let name = 0
      let m
      // eslint-disable-next-line no-cond-assign
      while (m = MATCHING_GROUP_REGEXP.exec(_path.source)) {
        keys.push({
          name: m[1] || name++,
          offset: m.index
        })
      }

      return function regexpMatcher (p) {
        const match = _path.exec(p)
        if (!match) {
          return false
        }

        const params = {}
        for (let i = 1; i < match.length; i++) {
          const key = keys[i - 1]
          const prop = key.name
          const val = decodeParam(match[i])

          if (val !== undefined) {
            params[prop] = val
          }
        }

        return {
          params,
          path: match[0]
        }
      }
    }

    return pathRegexp.match((opts.strict ? _path : loosen(_path)), {
      sensitive: opts.sensitive,
      end: opts.end,
      trailing: !opts.strict,
      decode: decodeParam
    })
  }
  this.matchers = Array.isArray(path) ? path.map(matcher) : [matcher(path)]
}

/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handleError = function handleError (error, req, res, next) {
  const fn = this.handle

  if (fn.length !== 4) {
    // not a standard error handler
    return next(error)
  }

  try {
    // invoke function
    const ret = fn(error, req, res, next)

    // wait for returned promise
    if (isPromise(ret)) {
      if (!(ret instanceof Promise)) {
        deprecate('handlers that are Promise-like are deprecated, use a native Promise instead')
      }

      ret.then(null, function (error) {
        next(error || new Error('Rejected promise'))
      })
    }
  } catch (err) {
    next(err)
  }
}

/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handleRequest = function handleRequest (req, res, next) {
  const fn = this.handle

  if (fn.length > 3) {
    // not a standard request handler
    return next()
  }

  try {
    // invoke function
    const ret = fn(req, res, next)

    // wait for returned promise
    if (isPromise(ret)) {
      if (!(ret instanceof Promise)) {
        deprecate('handlers that are Promise-like are deprecated, use a native Promise instead')
      }

      ret.then(null, function (error) {
        next(error || new Error('Rejected promise'))
      })
    }
  } catch (err) {
    next(err)
  }
}

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Layer.prototype.match = function match (path) {
  let match

  if (path != null) {
    // fast path non-ending match for / (any path matches)
    if (this.slash) {
      this.params = {}
      this.path = ''
      return true
    }

    let i = 0
    while (!match && i < this.matchers.length) {
      // match the path
      match = this.matchers[i](path)
      i++
    }
  }

  if (!match) {
    this.params = undefined
    this.path = undefined
    return false
  }

  // store values
  this.params = match.params
  this.path = match.path
  this.keys = Object.keys(match.params)

  return true
}

/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function decodeParam (val) {
  if (typeof val !== 'string' || val.length === 0) {
    return val
  }

  try {
    return decodeURIComponent(val)
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\''
      err.status = 400
    }

    throw err
  }
}

/**
 * Loosens the given path for path-to-regexp matching.
 */
function loosen (path) {
  if (path instanceof RegExp || path === '/') {
    return path
  }

  return Array.isArray(path)
    ? path.map(function (p) { return loosen(p) })
    : String(path).replace(TRAILING_SLASH_REGEXP, '')
}


/***/ }),
/* 191 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenData = void 0;
exports.parse = parse;
exports.compile = compile;
exports.match = match;
exports.pathToRegexp = pathToRegexp;
exports.stringify = stringify;
const DEFAULT_DELIMITER = "/";
const NOOP_VALUE = (value) => value;
const ID_START = /^[$_\p{ID_Start}]$/u;
const ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
const DEBUG_URL = "https://git.new/pathToRegexpError";
const SIMPLE_TOKENS = {
    // Groups.
    "{": "{",
    "}": "}",
    // Reserved.
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!",
};
/**
 * Escape text for stringify to path.
 */
function escapeText(str) {
    return str.replace(/[{}()\[\]+?!:*]/g, "\\$&");
}
/**
 * Escape a regular expression string.
 */
function escape(str) {
    return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
}
/**
 * Tokenize input string.
 */
function* lexer(str) {
    const chars = [...str];
    let i = 0;
    function name() {
        let value = "";
        if (ID_START.test(chars[++i])) {
            value += chars[i];
            while (ID_CONTINUE.test(chars[++i])) {
                value += chars[i];
            }
        }
        else if (chars[i] === '"') {
            let pos = i;
            while (i < chars.length) {
                if (chars[++i] === '"') {
                    i++;
                    pos = 0;
                    break;
                }
                if (chars[i] === "\\") {
                    value += chars[++i];
                }
                else {
                    value += chars[i];
                }
            }
            if (pos) {
                throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);
            }
        }
        if (!value) {
            throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);
        }
        return value;
    }
    while (i < chars.length) {
        const value = chars[i];
        const type = SIMPLE_TOKENS[value];
        if (type) {
            yield { type, index: i++, value };
        }
        else if (value === "\\") {
            yield { type: "ESCAPED", index: i++, value: chars[i++] };
        }
        else if (value === ":") {
            const value = name();
            yield { type: "PARAM", index: i, value };
        }
        else if (value === "*") {
            const value = name();
            yield { type: "WILDCARD", index: i, value };
        }
        else {
            yield { type: "CHAR", index: i, value: chars[i++] };
        }
    }
    return { type: "END", index: i, value: "" };
}
class Iter {
    constructor(tokens) {
        this.tokens = tokens;
    }
    peek() {
        if (!this._peek) {
            const next = this.tokens.next();
            this._peek = next.value;
        }
        return this._peek;
    }
    tryConsume(type) {
        const token = this.peek();
        if (token.type !== type)
            return;
        this._peek = undefined; // Reset after consumed.
        return token.value;
    }
    consume(type) {
        const value = this.tryConsume(type);
        if (value !== undefined)
            return value;
        const { type: nextType, index } = this.peek();
        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`);
    }
    text() {
        let result = "";
        let value;
        while ((value = this.tryConsume("CHAR") || this.tryConsume("ESCAPED"))) {
            result += value;
        }
        return result;
    }
}
/**
 * Tokenized path instance.
 */
class TokenData {
    constructor(tokens) {
        this.tokens = tokens;
    }
}
exports.TokenData = TokenData;
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options = {}) {
    const { encodePath = NOOP_VALUE } = options;
    const it = new Iter(lexer(str));
    function consume(endType) {
        const tokens = [];
        while (true) {
            const path = it.text();
            if (path)
                tokens.push({ type: "text", value: encodePath(path) });
            const param = it.tryConsume("PARAM");
            if (param) {
                tokens.push({
                    type: "param",
                    name: param,
                });
                continue;
            }
            const wildcard = it.tryConsume("WILDCARD");
            if (wildcard) {
                tokens.push({
                    type: "wildcard",
                    name: wildcard,
                });
                continue;
            }
            const open = it.tryConsume("{");
            if (open) {
                tokens.push({
                    type: "group",
                    tokens: consume("}"),
                });
                continue;
            }
            it.consume(endType);
            return tokens;
        }
    }
    const tokens = consume("END");
    return new TokenData(tokens);
}
/**
 * Compile a string to a template function for the path.
 */
function compile(path, options = {}) {
    const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const data = path instanceof TokenData ? path : parse(path, options);
    const fn = tokensToFunction(data.tokens, delimiter, encode);
    return function path(data = {}) {
        const [path, ...missing] = fn(data);
        if (missing.length) {
            throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
        }
        return path;
    };
}
function tokensToFunction(tokens, delimiter, encode) {
    const encoders = tokens.map((token) => tokenToFunction(token, delimiter, encode));
    return (data) => {
        const result = [""];
        for (const encoder of encoders) {
            const [value, ...extras] = encoder(data);
            result[0] += value;
            result.push(...extras);
        }
        return result;
    };
}
/**
 * Convert a single token into a path building function.
 */
function tokenToFunction(token, delimiter, encode) {
    if (token.type === "text")
        return () => [token.value];
    if (token.type === "group") {
        const fn = tokensToFunction(token.tokens, delimiter, encode);
        return (data) => {
            const [value, ...missing] = fn(data);
            if (!missing.length)
                return [value];
            return [""];
        };
    }
    const encodeValue = encode || NOOP_VALUE;
    if (token.type === "wildcard" && encode !== false) {
        return (data) => {
            const value = data[token.name];
            if (value == null)
                return ["", token.name];
            if (!Array.isArray(value) || value.length === 0) {
                throw new TypeError(`Expected "${token.name}" to be a non-empty array`);
            }
            return [
                value
                    .map((value, index) => {
                    if (typeof value !== "string") {
                        throw new TypeError(`Expected "${token.name}/${index}" to be a string`);
                    }
                    return encodeValue(value);
                })
                    .join(delimiter),
            ];
        };
    }
    return (data) => {
        const value = data[token.name];
        if (value == null)
            return ["", token.name];
        if (typeof value !== "string") {
            throw new TypeError(`Expected "${token.name}" to be a string`);
        }
        return [encodeValue(value)];
    };
}
/**
 * Transform a path into a match function.
 */
function match(path, options = {}) {
    const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const { regexp, keys } = pathToRegexp(path, options);
    const decoders = keys.map((key) => {
        if (decode === false)
            return NOOP_VALUE;
        if (key.type === "param")
            return decode;
        return (value) => value.split(delimiter).map(decode);
    });
    return function match(input) {
        const m = regexp.exec(input);
        if (!m)
            return false;
        const path = m[0];
        const params = Object.create(null);
        for (let i = 1; i < m.length; i++) {
            if (m[i] === undefined)
                continue;
            const key = keys[i - 1];
            const decoder = decoders[i - 1];
            params[key.name] = decoder(m[i]);
        }
        return { path, params };
    };
}
function pathToRegexp(path, options = {}) {
    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true, } = options;
    const keys = [];
    const sources = [];
    const flags = sensitive ? "" : "i";
    const paths = Array.isArray(path) ? path : [path];
    const items = paths.map((path) => path instanceof TokenData ? path : parse(path, options));
    for (const { tokens } of items) {
        for (const seq of flatten(tokens, 0, [])) {
            const regexp = sequenceToRegExp(seq, delimiter, keys);
            sources.push(regexp);
        }
    }
    let pattern = `^(?:${sources.join("|")})`;
    if (trailing)
        pattern += `(?:${escape(delimiter)}$)?`;
    pattern += end ? "$" : `(?=${escape(delimiter)}|$)`;
    const regexp = new RegExp(pattern, flags);
    return { regexp, keys };
}
/**
 * Generate a flat list of sequence tokens from the given tokens.
 */
function* flatten(tokens, index, init) {
    if (index === tokens.length) {
        return yield init;
    }
    const token = tokens[index];
    if (token.type === "group") {
        const fork = init.slice();
        for (const seq of flatten(token.tokens, 0, fork)) {
            yield* flatten(tokens, index + 1, seq);
        }
    }
    else {
        init.push(token);
    }
    yield* flatten(tokens, index + 1, init);
}
/**
 * Transform a flat sequence of tokens into a regular expression.
 */
function sequenceToRegExp(tokens, delimiter, keys) {
    let result = "";
    let backtrack = "";
    let isSafeSegmentParam = true;
    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.type === "text") {
            result += escape(token.value);
            backtrack += token.value;
            isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));
            continue;
        }
        if (token.type === "param" || token.type === "wildcard") {
            if (!isSafeSegmentParam && !backtrack) {
                throw new TypeError(`Missing text after "${token.name}": ${DEBUG_URL}`);
            }
            if (token.type === "param") {
                result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
            }
            else {
                result += `([\\s\\S]+)`;
            }
            keys.push(token);
            backtrack = "";
            isSafeSegmentParam = false;
            continue;
        }
    }
    return result;
}
function negate(delimiter, backtrack) {
    if (backtrack.length < 2) {
        if (delimiter.length < 2)
            return `[^${escape(delimiter + backtrack)}]`;
        return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;
    }
    if (delimiter.length < 2) {
        return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;
    }
    return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\s\\S])`;
}
/**
 * Stringify token data into a path string.
 */
function stringify(data) {
    return data.tokens
        .map(function stringifyToken(token, index, tokens) {
        if (token.type === "text")
            return escapeText(token.value);
        if (token.type === "group") {
            return `{${token.tokens.map(stringifyToken).join("")}}`;
        }
        const isSafe = isNameSafe(token.name) && isNextNameSafe(tokens[index + 1]);
        const key = isSafe ? token.name : JSON.stringify(token.name);
        if (token.type === "param")
            return `:${key}`;
        if (token.type === "wildcard")
            return `*${key}`;
        throw new TypeError(`Unexpected token: ${token}`);
    })
        .join("");
}
function isNameSafe(name) {
    const [first, ...rest] = name;
    if (!ID_START.test(first))
        return false;
    return rest.every((char) => ID_CONTINUE.test(char));
}
function isNextNameSafe(token) {
    if ((token === null || token === void 0 ? void 0 : token.type) !== "text")
        return true;
    return !ID_CONTINUE.test(token.value[0]);
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 192 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * router
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

const debug = __webpack_require__(65)('router:route')
const Layer = __webpack_require__(190)
const { METHODS } = __webpack_require__(178)

/**
 * Module variables.
 * @private
 */

const slice = Array.prototype.slice
const flatten = Array.prototype.flat
const methods = METHODS.map((method) => method.toLowerCase())

/**
 * Expose `Route`.
 */

module.exports = Route

/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @api private
 */

function Route (path) {
  debug('new %o', path)
  this.path = path
  this.stack = []

  // route handlers for various http methods
  this.methods = Object.create(null)
}

/**
 * @private
 */

Route.prototype._handlesMethod = function _handlesMethod (method) {
  if (this.methods._all) {
    return true
  }

  // normalize name
  let name = typeof method === 'string'
    ? method.toLowerCase()
    : method

  if (name === 'head' && !this.methods.head) {
    name = 'get'
  }

  return Boolean(this.methods[name])
}

/**
 * @return {array} supported HTTP methods
 * @private
 */

Route.prototype._methods = function _methods () {
  const methods = Object.keys(this.methods)

  // append automatic head
  if (this.methods.get && !this.methods.head) {
    methods.push('head')
  }

  for (let i = 0; i < methods.length; i++) {
    // make upper case
    methods[i] = methods[i].toUpperCase()
  }

  return methods
}

/**
 * dispatch req, res into this route
 *
 * @private
 */

Route.prototype.dispatch = function dispatch (req, res, done) {
  let idx = 0
  const stack = this.stack
  let sync = 0

  if (stack.length === 0) {
    return done()
  }

  let method = typeof req.method === 'string'
    ? req.method.toLowerCase()
    : req.method

  if (method === 'head' && !this.methods.head) {
    method = 'get'
  }

  req.route = this

  next()

  function next (err) {
    // signal to exit route
    if (err && err === 'route') {
      return done()
    }

    // signal to exit router
    if (err && err === 'router') {
      return done(err)
    }

    // no more matching layers
    if (idx >= stack.length) {
      return done(err)
    }

    // max sync stack
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    let layer
    let match

    // find next matching layer
    while (match !== true && idx < stack.length) {
      layer = stack[idx++]
      match = !layer.method || layer.method === method
    }

    // no match
    if (match !== true) {
      return done(err)
    }

    if (err) {
      layer.handleError(err, req, res, next)
    } else {
      layer.handleRequest(req, res, next)
    }

    sync = 0
  }
}

/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next()
 *   }
 *
 *   function validate_user(req, res, next){
 *     next()
 *   }
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world')
 *   })
 *
 * @param {array|function} handler
 * @return {Route} for chaining
 * @api public
 */

Route.prototype.all = function all (handler) {
  const callbacks = flatten.call(slice.call(arguments), Infinity)

  if (callbacks.length === 0) {
    throw new TypeError('argument handler is required')
  }

  for (let i = 0; i < callbacks.length; i++) {
    const fn = callbacks[i]

    if (typeof fn !== 'function') {
      throw new TypeError('argument handler must be a function')
    }

    const layer = Layer('/', {}, fn)
    layer.method = undefined

    this.methods._all = true
    this.stack.push(layer)
  }

  return this
}

methods.forEach(function (method) {
  Route.prototype[method] = function (handler) {
    const callbacks = flatten.call(slice.call(arguments), Infinity)

    if (callbacks.length === 0) {
      throw new TypeError('argument handler is required')
    }

    for (let i = 0; i < callbacks.length; i++) {
      const fn = callbacks[i]

      if (typeof fn !== 'function') {
        throw new TypeError('argument handler must be a function')
      }

      debug('%s %s', method, this.path)

      const layer = Layer('/', {}, fn)
      layer.method = method

      this.methods[method] = true
      this.stack.push(layer)
    }

    return this
  }
})


/***/ }),
/* 193 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var accepts = __webpack_require__(194);
var isIP = (__webpack_require__(200).isIP);
var typeis = __webpack_require__(107);
var http = __webpack_require__(178);
var fresh = __webpack_require__(201);
var parseRange = __webpack_require__(202);
var parse = __webpack_require__(170);
var proxyaddr = __webpack_require__(182);

/**
 * Request prototype.
 * @public
 */

var req = Object.create(http.IncomingMessage.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = req

/**
 * Return request header.
 *
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 *
 * Examples:
 *
 *     req.get('Content-Type');
 *     // => "text/plain"
 *
 *     req.get('content-type');
 *     // => "text/plain"
 *
 *     req.get('Something');
 *     // => undefined
 *
 * Aliased as `req.header()`.
 *
 * @param {String} name
 * @return {String}
 * @public
 */

req.get =
req.header = function header(name) {
  if (!name) {
    throw new TypeError('name argument is required to req.get');
  }

  if (typeof name !== 'string') {
    throw new TypeError('name must be a string to req.get');
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case 'referer':
    case 'referrer':
      return this.headers.referrer
        || this.headers.referer;
    default:
      return this.headers[lc];
  }
};

/**
 * To do: update docs.
 *
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single MIME type string
 * such as "application/json", an extension name
 * such as "json", a comma-delimited list such as "json, html, text/plain",
 * an argument list such as `"json", "html", "text/plain"`,
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given, the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html', 'json');
 *     req.accepts('html, json');
 *     // => "json"
 *
 * @param {String|Array} type(s)
 * @return {String|Array|Boolean}
 * @public
 */

req.accepts = function(){
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};

/**
 * Check if the given `encoding`s are accepted.
 *
 * @param {String} ...encoding
 * @return {String|Array}
 * @public
 */

req.acceptsEncodings = function(){
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};

/**
 * Check if the given `charset`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...charset
 * @return {String|Array}
 * @public
 */

req.acceptsCharsets = function(){
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};

/**
 * Check if the given `lang`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...lang
 * @return {String|Array}
 * @public
 */

req.acceptsLanguages = function(){
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};

/**
 * Parse Range header field, capping to the given `size`.
 *
 * Unspecified ranges such as "0-" require knowledge of your resource length. In
 * the case of a byte range this is of course the total number of bytes. If the
 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
 * and `-2` when syntactically invalid.
 *
 * When ranges are returned, the array has a "type" property which is the type of
 * range that is required (most commonly, "bytes"). Each array element is an object
 * with a "start" and "end" property for the portion of the range.
 *
 * The "combine" option can be set to `true` and overlapping & adjacent ranges
 * will be combined into a single range.
 *
 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
 * should respond with 4 users when available, not 3.
 *
 * @param {number} size
 * @param {object} [options]
 * @param {boolean} [options.combine=false]
 * @return {number|array}
 * @public
 */

req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return parseRange(size, range, options);
};

/**
 * Parse the query string of `req.url`.
 *
 * This uses the "query parser" setting to parse the raw
 * string into an object.
 *
 * @return {String}
 * @api public
 */

defineGetter(req, 'query', function query(){
  var queryparse = this.app.get('query parser fn');

  if (!queryparse) {
    // parsing is disabled
    return Object.create(null);
  }

  var querystring = parse(this).query;

  return queryparse(querystring);
});

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the given mime `type`.
 *
 * Examples:
 *
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 *
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 *
 *      req.is('html');
 *      // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

req.is = function is(types) {
  var arr = types;

  // support flattened arguments
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }

  return typeis(this, arr);
};

/**
 * Return the protocol string "http" or "https"
 * when requested with TLS. When the "trust proxy"
 * setting trusts the socket address, the
 * "X-Forwarded-Proto" header field will be trusted
 * and used if present.
 *
 * If you're running behind a reverse proxy that
 * supplies https for you this may be enabled.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'protocol', function protocol(){
  var proto = this.connection.encrypted
    ? 'https'
    : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto
  var index = header.indexOf(',')

  return index !== -1
    ? header.substring(0, index).trim()
    : header.trim()
});

/**
 * Short-hand for:
 *
 *    req.protocol === 'https'
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'secure', function secure(){
  return this.protocol === 'https';
});

/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
});

/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
});

/**
 * Return subdomains as an array.
 *
 * Subdomains are the dot-separated parts of the host before the main domain of
 * the app. By default, the domain of the app is assumed to be the last two
 * parts of the host. This can be changed by setting "subdomain offset".
 *
 * For example, if the domain is "tobi.ferrets.example.com":
 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname];

  return subdomains.slice(offset);
});

/**
 * Short-hand for `url.parse(req.url).pathname`.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'path', function path() {
  return parse(this).pathname;
});

/**
 * Parse the "Host" header field to a host.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'host', function host(){
  var trust = this.app.get('trust proxy fn');
  var val = this.get('X-Forwarded-Host');

  if (!val || !trust(this.connection.remoteAddress, 0)) {
    val = this.get('Host');
  } else if (val.indexOf(',') !== -1) {
    // Note: X-Forwarded-Host is normally only ever a
    //       single value, but this is to be safe.
    val = val.substring(0, val.indexOf(',')).trimRight()
  }

  return val || undefined;
});

/**
 * Parse the "Host" header field to a hostname.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @api public
 */

defineGetter(req, 'hostname', function hostname(){
  var host = this.host;

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0;
  var index = host.indexOf(':', offset);

  return index !== -1
    ? host.substring(0, index)
    : host;
});

/**
 * Check if the request is fresh, aka
 * Last-Modified or the ETag
 * still match.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'fresh', function(){
  var method = this.method;
  var res = this.res
  var status = res.statusCode

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if ((status >= 200 && status < 300) || 304 === status) {
    return fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
  }

  return false;
});

/**
 * Check if the request is stale, aka
 * "Last-Modified" and / or the "ETag" for the
 * resource has changed.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'stale', function stale(){
  return !this.fresh;
});

/**
 * Check if the request was an _XMLHttpRequest_.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'xhr', function xhr(){
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
});

/**
 * Helper function for creating a getter on an object.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} getter
 * @private
 */
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}


/***/ }),
/* 194 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var Negotiator = __webpack_require__(195)
var mime = __webpack_require__(109)

/**
 * Module exports.
 * @public
 */

module.exports = Accepts

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts (req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req)
  }

  this.headers = req.headers
  this.negotiator = new Negotiator(req)
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type =
Accepts.prototype.types = function (types_) {
  var types = types_

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length)
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i]
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes()
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0]
  }

  var mimes = types.map(extToMime)
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))
  var first = accepts[0]

  return first
    ? types[mimes.indexOf(first)]
    : false
}

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding =
Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length)
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i]
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings()
  }

  return this.negotiator.encodings(encodings)[0] || false
}

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset =
Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length)
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i]
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets()
  }

  return this.negotiator.charsets(charsets)[0] || false
}

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = function (languages_) {
  var languages = languages_

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length)
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i]
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages()
  }

  return this.negotiator.languages(languages)[0] || false
}

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime (type) {
  return type.indexOf('/') === -1
    ? mime.lookup(type)
    : type
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {Boolean}
 * @private
 */

function validMime (type) {
  return typeof type === 'string'
}


/***/ }),
/* 195 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



var preferredCharsets = __webpack_require__(196)
var preferredEncodings = __webpack_require__(197)
var preferredLanguages = __webpack_require__(198)
var preferredMediaTypes = __webpack_require__(199)

/**
 * Module exports.
 * @public
 */

module.exports = Negotiator;
module.exports.Negotiator = Negotiator;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available, opts) {
  var set = this.encodings(available, opts);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available, options) {
  var opts = options || {};
  return preferredEncodings(this.request.headers['accept-encoding'], available, opts.preferred);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;


/***/ }),
/* 196 */
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify(charset, spec, index) {
  var s = 0;
  if(spec.charset.toLowerCase() === charset.toLowerCase()){
    s |= 1;
  } else if (spec.charset !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),
/* 197 */
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = {encoding: encoding, o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify(encoding, spec, index) {
  var s = 0;
  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
    s |= 1;
  } else if (spec.encoding !== '*' ) {
    return null
  }

  return {
    encoding: encoding,
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided, preferred) {
  var accepts = parseAcceptEncoding(accept || '');

  var comparator = preferred ? function comparator (a, b) {
    if (a.q !== b.q) {
      return b.q - a.q // higher quality first
    }

    var aPreferred = preferred.indexOf(a.encoding)
    var bPreferred = preferred.indexOf(b.encoding)

    if (aPreferred === -1 && bPreferred === -1) {
      // consider the original specifity/order
      return (b.s - a.s) || (a.o - b.o) || (a.i - b.i)
    }

    if (aPreferred !== -1 && bPreferred !== -1) {
      return aPreferred - bPreferred // consider the preferred order
    }

    return aPreferred === -1 ? 1 : -1 // preferred first
  } : compareSpecs;

  if (!provided) {
    // sorted list of all encodings
    return accepts
      .filter(isQuality)
      .sort(comparator)
      .map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality).sort(comparator).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i);
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),
/* 198 */
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1]
  var suffix = match[2]
  var full = prefix

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';')
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify(language, spec, index) {
  var p = parseLanguage(language)
  if (!p) return null;
  var s = 0;
  if(spec.full.toLowerCase() === p.full.toLowerCase()){
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*' ) {
    return null
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  }
};

/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}


/***/ }),
/* 199 */
/***/ ((module) => {

"use strict";
/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"'
        ? val.slice(1, -1)
        : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = {o: -1, q: 0, s: 0};

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4
  } else if(spec.type != '*') {
    return null;
  }

  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2
  } else if(spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1
    } else {
      return null
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s,
  }
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts
      .filter(isQuality)
      .sort(compareSpecs)
      .map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.slice(0, index);
    val = str.slice(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}


/***/ }),
/* 200 */
/***/ ((module) => {

"use strict";
module.exports = require("node:net");

/***/ }),
/* 201 */
/***/ ((module) => {

"use strict";
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * RegExp to check for no-cache token in Cache-Control.
 * @private
 */

var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/

/**
 * Module exports.
 * @public
 */

module.exports = fresh

/**
 * Check freshness of the response using request and response headers.
 *
 * @param {Object} reqHeaders
 * @param {Object} resHeaders
 * @return {Boolean}
 * @public
 */

function fresh (reqHeaders, resHeaders) {
  // fields
  var modifiedSince = reqHeaders['if-modified-since']
  var noneMatch = reqHeaders['if-none-match']

  // unconditional request
  if (!modifiedSince && !noneMatch) {
    return false
  }

  // Always return stale when Cache-Control: no-cache
  // to support end-to-end reload requests
  // https://tools.ietf.org/html/rfc2616#section-14.9.4
  var cacheControl = reqHeaders['cache-control']
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false
  }

  // if-none-match takes precedent over if-modified-since
  if (noneMatch) {
    if (noneMatch === '*') {
      return true
    }
    var etag = resHeaders.etag

    if (!etag) {
      return false
    }

    var matches = parseTokenList(noneMatch)
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i]
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
        return true
      }
    }

    return false
  }

  // if-modified-since
  if (modifiedSince) {
    var lastModified = resHeaders['last-modified']
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))

    if (modifiedStale) {
      return false
    }
  }

  return true
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  // istanbul ignore next: guard against date.js Date.parse patching
  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(str.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(str.substring(start, end))

  return list
}


/***/ }),
/* 202 */
/***/ ((module) => {

"use strict";
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = rangeParser

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser (size, str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string')
  }

  var index = str.indexOf('=')

  if (index === -1) {
    return -2
  }

  // split the range string
  var arr = str.slice(index + 1).split(',')
  var ranges = []

  // add ranges type
  ranges.type = str.slice(0, index)

  // parse all ranges
  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // -nnn
    if (isNaN(start)) {
      start = size - end
      end = size - 1
    // nnn-
    } else if (isNaN(end)) {
      end = size - 1
    }

    // limit last-byte-pos to current length
    if (end > size - 1) {
      end = size - 1
    }

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue
    }

    // add range
    ranges.push({
      start: start,
      end: end
    })
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1
  }

  return options && options.combine
    ? combineRanges(ranges)
    : ranges
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges (ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i]
    var current = ordered[j]

    if (range.start > current.end + 1) {
      // next range
      ordered[++j] = range
    } else if (range.end > current.end) {
      // extend range
      current.end = range.end
      current.index = Math.min(current.index, range.index)
    }
  }

  // trim ordered array
  ordered.length = j + 1

  // generate combined range
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)

  // copy ranges type
  combined.type = ranges.type

  return combined
}

/**
 * Map function to add index value to ranges.
 * @private
 */

function mapWithIndex (range, index) {
  return {
    start: range.start,
    end: range.end,
    index: index
  }
}

/**
 * Map function to remove index value from ranges.
 * @private
 */

function mapWithoutIndex (range) {
  return {
    start: range.start,
    end: range.end
  }
}

/**
 * Sort function to sort ranges by index.
 * @private
 */

function sortByRangeIndex (a, b) {
  return a.index - b.index
}

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart (a, b) {
  return a.start - b.start
}


/***/ }),
/* 203 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var contentDisposition = __webpack_require__(204);
var createError = __webpack_require__(56)
var encodeUrl = __webpack_require__(168);
var escapeHtml = __webpack_require__(169);
var http = __webpack_require__(178);
var onFinished = __webpack_require__(74);
var mime = __webpack_require__(109)
var path = __webpack_require__(175);
var pathIsAbsolute = (__webpack_require__(175).isAbsolute);
var statuses = __webpack_require__(172)
var sign = (__webpack_require__(206).sign);
var normalizeType = (__webpack_require__(179).normalizeType);
var normalizeTypes = (__webpack_require__(179).normalizeTypes);
var setCharset = (__webpack_require__(179).setCharset);
var cookie = __webpack_require__(207);
var send = __webpack_require__(208);
var extname = path.extname;
var resolve = path.resolve;
var vary = __webpack_require__(209);

/**
 * Response prototype.
 * @public
 */

var res = Object.create(http.ServerResponse.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = res

/**
 * Set the HTTP status code for the response.
 *
 * Expects an integer value between 100 and 999 inclusive.
 * Throws an error if the provided status code is not an integer or if it's outside the allowable range.
 *
 * @param {number} code - The HTTP status code to set.
 * @return {ServerResponse} - Returns itself for chaining methods.
 * @throws {TypeError} If `code` is not an integer.
 * @throws {RangeError} If `code` is outside the range 100 to 999.
 * @public
 */

res.status = function status(code) {
  // Check if the status code is not an integer
  if (!Number.isInteger(code)) {
    throw new TypeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be an integer.`);
  }
  // Check if the status code is outside of Node's valid range
  if (code < 100 || code > 999) {
    throw new RangeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be greater than 99 and less than 1000.`);
  }

  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5',
 *      pages: [
 *        'http://api.example.com/users?page=1',
 *        'http://api.example.com/users?page=2'
 *      ]
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */

res.links = function(links) {
  var link = this.get('Link') || '';
  if (link) link += ', ';
  return this.set('Link', link + Object.keys(links).map(function(rel) {
    // Allow multiple links if links[rel] is an array
    if (Array.isArray(links[rel])) {
      return links[rel].map(function (singleLink) {
        return `<${singleLink}>; rel="${rel}"`;
      }).join(', ');
    } else {
      return `<${links[rel]}>; rel="${rel}"`;
    }
  }).join(', '));
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('<p>some html</p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */

res.send = function send(body) {
  var chunk = body;
  var encoding;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  switch (typeof chunk) {
    // string defaulting to html
    case 'string':
      if (!this.get('Content-Type')) {
        this.type('html');
      }
      break;
    case 'boolean':
    case 'number':
    case 'object':
      if (chunk === null) {
        chunk = '';
      } else if (ArrayBuffer.isView(chunk)) {
        if (!this.get('Content-Type')) {
          this.type('bin');
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === 'string') {
    encoding = 'utf8';
    type = this.get('Content-Type');

    // reflect this in content-type
    if (typeof type === 'string') {
      this.set('Content-Type', setCharset(type, 'utf-8'));
    }
  }

  // determine if ETag should be generated
  var etagFn = app.get('etag fn')
  var generateETag = !this.get('ETag') && typeof etagFn === 'function'

  // populate Content-Length
  var len
  if (chunk !== undefined) {
    if (Buffer.isBuffer(chunk)) {
      // get length of Buffer
      len = chunk.length
    } else if (!generateETag && chunk.length < 1000) {
      // just calculate length when no ETag + small chunk
      len = Buffer.byteLength(chunk, encoding)
    } else {
      // convert chunk to Buffer and calculate
      chunk = Buffer.from(chunk, encoding)
      encoding = undefined;
      len = chunk.length
    }

    this.set('Content-Length', len);
  }

  // populate ETag
  var etag;
  if (generateETag && len !== undefined) {
    if ((etag = etagFn(chunk, encoding))) {
      this.set('ETag', etag);
    }
  }

  // freshness
  if (req.fresh) this.status(304);

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader('Content-Type');
    this.removeHeader('Content-Length');
    this.removeHeader('Transfer-Encoding');
    chunk = '';
  }

  // alter headers for 205
  if (this.statusCode === 205) {
    this.set('Content-Length', '0')
    this.removeHeader('Transfer-Encoding')
    chunk = ''
  }

  if (req.method === 'HEAD') {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.json = function json(obj) {
  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(obj, replacer, spaces, escape)

  // content-type
  if (!this.get('Content-Type')) {
    this.set('Content-Type', 'application/json');
  }

  return this.send(body);
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.jsonp = function jsonp(obj) {
  // settings
  var app = this.app;
  var escape = app.get('json escape')
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify(obj, replacer, spaces, escape)
  var callback = this.req.query[app.get('jsonp callback name')];

  // content-type
  if (!this.get('Content-Type')) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'application/json');
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === 'string' && callback.length !== 0) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'text/javascript');

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, '');

    if (body === undefined) {
      // empty argument
      body = ''
    } else if (typeof body === 'string') {
      // replace chars not allowed in JavaScript that are in JSON
      body = body
        .replace(/\u2028/g, '\\u2028')
        .replace(/\u2029/g, '\\u2029')
    }

    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
    // the typeof check is just to reduce client error noise
    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
  }

  return this.send(body);
};

/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */

res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode)

  this.status(statusCode);
  this.type('txt');

  return this.send(body);
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendFile = function sendFile(path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path) {
    throw new TypeError('path argument is required to res.sendFile');
  }

  if (typeof path !== 'string') {
    throw new TypeError('path must be a string to res.sendFile')
  }

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  if (!opts.root && !pathIsAbsolute(path)) {
    throw new TypeError('path must be absolute or specify root to res.sendFile');
  }

  // create file stream
  var pathname = encodeURI(path);

  // wire application etag option to send
  opts.etag = this.app.enabled('etag');
  var file = send(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * occurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */

res.download = function download (path, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null

  // support function as second or third arg
  if (typeof filename === 'function') {
    done = filename;
    name = null;
    opts = null
  } else if (typeof options === 'function') {
    done = options
    opts = null
  }

  // support optional filename, where options may be in it's place
  if (typeof filename === 'object' &&
    (typeof options === 'function' || options === undefined)) {
    name = null
    opts = filename
  }

  // set Content-Disposition when file is sent
  var headers = {
    'Content-Disposition': contentDisposition(name || path)
  };

  // merge user-provided headers
  if (opts && opts.headers) {
    var keys = Object.keys(opts.headers)
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]
      if (key.toLowerCase() !== 'content-disposition') {
        headers[key] = opts.headers[key]
      }
    }
  }

  // merge user-provided options
  opts = Object.create(opts)
  opts.headers = headers

  // Resolve the full path for sendFile
  var fullPath = !opts.root
    ? resolve(path)
    : path

  // send file
  return this.sendFile(fullPath, opts, done)
};

/**
 * Set _Content-Type_ response header with `type` through `mime.contentType()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 * When no mapping is found though `mime.contentType()`, the type is set to
 * "application/octet-stream".
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */

res.contentType =
res.type = function contentType(type) {
  var ct = type.indexOf('/') === -1
    ? (mime.contentType(type) || 'application/octet-stream')
    : type;

  return this.set('Content-Type', ct);
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      'application/json': function () {
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */

res.format = function(obj){
  var req = this.req;
  var next = req.next;

  var keys = Object.keys(obj)
    .filter(function (v) { return v !== 'default' })

  var key = keys.length > 0
    ? req.accepts(keys)
    : false;

  this.vary("Accept");

  if (key) {
    this.set('Content-Type', normalizeType(key).value);
    obj[key](req, this, next);
  } else if (obj.default) {
    obj.default(req, this, next)
  } else {
    next(createError(406, {
      types: normalizeTypes(keys).map(function (o) { return o.value })
    }))
  }

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */

res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }

  this.set('Content-Disposition', contentDisposition(filename));

  return this;
};

/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *    res.append('Warning', '199 Miscellaneous warning');
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.append = function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val)
      : Array.isArray(val) ? [prev].concat(val)
        : [prev, val]
  }

  return this.set(field, value);
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * When the set header is "Content-Type", the type is expanded to include
 * the charset if not present using `mime.contentType()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.set =
res.header = function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === 'content-type') {
      if (Array.isArray(value)) {
        throw new TypeError('Content-Type cannot be set to an Array');
      }
      value = mime.contentType(value)
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */

res.get = function(field){
  return this.getHeader(field);
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.clearCookie = function clearCookie(name, options) {
  // Force cookie expiration by setting expires to the past
  const opts = { path: '/', ...options, expires: new Date(1)};
  // ensure maxAge is not passed
  delete opts.maxAge

  return this.cookie(name, '', opts);
};

/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // same as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.cookie = function (name, value, options) {
  var opts = { ...options };
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }

  var val = typeof value === 'object'
    ? 'j:' + JSON.stringify(value)
    : String(value);

  if (signed) {
    val = 's:' + sign(val, secret);
  }

  if (opts.maxAge != null) {
    var maxAge = opts.maxAge - 0

    if (!isNaN(maxAge)) {
      opts.expires = new Date(Date.now() + maxAge)
      opts.maxAge = Math.floor(maxAge / 1000)
    }
  }

  if (opts.path == null) {
    opts.path = '/';
  }

  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

  return this;
};

/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */

res.location = function location(url) {
  return this.set('Location', encodeUrl(url));
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @public
 */

res.redirect = function redirect(url) {
  var address = url;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    status = arguments[0]
    address = arguments[1]
  }

  // Set location header
  address = this.location(address).get('Location');

  // Support text/{plain,html} by default
  this.format({
    text: function(){
      body = statuses.message[status] + '. Redirecting to ' + address
    },

    html: function(){
      var u = escapeHtml(address);
      body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>'
    },

    default: function(){
      body = '';
    }
  });

  // Respond
  this.status(status);
  this.set('Content-Length', Buffer.byteLength(body));

  if (this.req.method === 'HEAD') {
    this.end();
  } else {
    this.end(body);
  }
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */

res.vary = function(field){
  vary(this, field);

  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */

res.render = function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
};

// pipe the send file stream
function sendfile(res, file, options, callback) {
  var done = false;
  var streaming;

  // request aborted
  function onaborted() {
    if (done) return;
    done = true;

    var err = new Error('Request aborted');
    err.code = 'ECONNABORTED';
    callback(err);
  }

  // directory
  function ondirectory() {
    if (done) return;
    done = true;

    var err = new Error('EISDIR, read');
    err.code = 'EISDIR';
    callback(err);
  }

  // errors
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }

  // ended
  function onend() {
    if (done) return;
    done = true;
    callback();
  }

  // file
  function onfile() {
    streaming = false;
  }

  // finished
  function onfinish(err) {
    if (err && err.code === 'ECONNRESET') return onaborted();
    if (err) return onerror(err);
    if (done) return;

    setImmediate(function () {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }

      if (done) return;
      done = true;
      callback();
    });
  }

  // streaming
  function onstream() {
    streaming = true;
  }

  file.on('directory', ondirectory);
  file.on('end', onend);
  file.on('error', onerror);
  file.on('file', onfile);
  file.on('stream', onstream);
  onFinished(res, onfinish);

  if (options.headers) {
    // set headers on successful transfer
    file.on('headers', function headers(res) {
      var obj = options.headers;
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  // pipe
  file.pipe(res);
}

/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replacer
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */

function stringify (value, replacer, spaces, escape) {
  // v8 checks arguments.length for optimizing simple call
  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
  var json = replacer || spaces
    ? JSON.stringify(value, replacer, spaces)
    : JSON.stringify(value);

  if (escape && typeof json === 'string') {
    json = json.replace(/[<>&]/g, function (c) {
      switch (c.charCodeAt(0)) {
        case 0x3c:
          return '\\u003c'
        case 0x3e:
          return '\\u003e'
        case 0x26:
          return '\\u0026'
        /* istanbul ignore next: unreachable default */
        default:
          return c
      }
    })
  }

  return json
}


/***/ }),
/* 204 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

module.exports = contentDisposition
module.exports.parse = parse

/**
 * Module dependencies.
 * @private
 */

var basename = (__webpack_require__(49).basename)
var Buffer = (__webpack_require__(205).Buffer)

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 * @private
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g

/**
 * RegExp to match non-latin1 characters.
 * @private
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */

var QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */

var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */

var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @public
 */

function contentDisposition (filename, options) {
  var opts = options || {}

  // get type
  var type = opts.type || 'attachment'

  // get parameters
  var params = createparams(filename, opts.fallback)

  // format into string
  return format(new ContentDisposition(type, params))
}

/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @private
 */

function createparams (filename, fallback) {
  if (filename === undefined) {
    return
  }

  var params = {}

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string')
  }

  // fallback defaults to true
  if (fallback === undefined) {
    fallback = true
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean')
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string')
  }

  // restrict to file base name
  var name = basename(filename)

  // determine if name is suitable for quoted string
  var isQuotedString = TEXT_REGEXP.test(name)

  // generate fallback name
  var fallbackName = typeof fallback !== 'string'
    ? fallback && getlatin1(name)
    : basename(fallback)
  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name

  // set extended filename parameter
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params['filename*'] = name
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback
      ? fallbackName
      : name
  }

  return params
}

/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @private
 */

function format (obj) {
  var parameters = obj.parameters
  var type = obj.type

  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {
    throw new TypeError('invalid type')
  }

  // start with normalized type
  var string = String(type).toLowerCase()

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param
    var params = Object.keys(parameters).sort()

    for (var i = 0; i < params.length; i++) {
      param = params[i]

      var val = param.slice(-1) === '*'
        ? ustring(parameters[param])
        : qstring(parameters[param])

      string += '; ' + param + '=' + val
    }
  }

  return string
}

/**
 * Decode a RFC 5987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function decodefield (str) {
  var match = EXT_VALUE_REGEXP.exec(str)

  if (!match) {
    throw new TypeError('invalid extended field value')
  }

  var charset = match[1].toLowerCase()
  var encoded = match[2]
  var value

  // to binary string
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)

  switch (charset) {
    case 'iso-8859-1':
      value = getlatin1(binary)
      break
    case 'utf-8':
    case 'utf8':
      value = Buffer.from(binary, 'binary').toString('utf8')
      break
    default:
      throw new TypeError('unsupported charset in extended field')
  }

  return value
}

/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function getlatin1 (val) {
  // simple Unicode -> ISO-8859-1 transformation
  return String(val).replace(NON_LATIN1_REGEXP, '?')
}

/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function parse (string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required')
  }

  var match = DISPOSITION_TYPE_REGEXP.exec(string)

  if (!match) {
    throw new TypeError('invalid type format')
  }

  // normalize type
  var index = match[0].length
  var type = match[1].toLowerCase()

  var key
  var names = []
  var params = {}
  var value

  // calculate index to start at
  index = PARAM_REGEXP.lastIndex = match[0].slice(-1) === ';'
    ? index - 1
    : index

  // match parameters
  while ((match = PARAM_REGEXP.exec(string))) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter')
    }

    names.push(key)

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      key = key.slice(0, -1)
      value = decodefield(value)

      // overwrite existing value
      params[key] = value
      continue
    }

    if (typeof params[key] === 'string') {
      continue
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .slice(1, -1)
        .replace(QESC_REGEXP, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  return new ContentDisposition(type, params)
}

/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @private
 */

function pdecode (str, hex) {
  return String.fromCharCode(parseInt(hex, 16))
}

/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @private
 */

function pencode (char) {
  return '%' + String(char)
    .charCodeAt(0)
    .toString(16)
    .toUpperCase()
}

/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring (val) {
  var str = String(val)

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"'
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function ustring (val) {
  var str = String(val)

  // percent encode as UTF-8
  var encoded = encodeURIComponent(str)
    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)

  return 'UTF-8\'\'' + encoded
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 *
 * @public
 * @param {string} type
 * @param {object} parameters
 * @constructor
 */

function ContentDisposition (type, parameters) {
  this.type = type
  this.parameters = parameters
}


/***/ }),
/* 205 */
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(82)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 206 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var crypto = __webpack_require__(50);

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret){
  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
  if (null == secret) throw new TypeError("Secret key must be provided.");
  return val + '.' + crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `input` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} input
 * @param {String|NodeJS.ArrayBufferView|crypto.KeyObject} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(input, secret){
  if ('string' != typeof input) throw new TypeError("Signed cookie string must be provided.");
  if (null == secret) throw new TypeError("Secret key must be provided.");
  var tentativeValue = input.slice(0, input.lastIndexOf('.')),
      expectedInput = exports.sign(tentativeValue, secret),
      expectedBuffer = Buffer.from(expectedInput),
      inputBuffer = Buffer.from(input);
  return (
    expectedBuffer.length === inputBuffer.length &&
    crypto.timingSafeEqual(expectedBuffer, inputBuffer)
   ) ? tentativeValue : false;
};


/***/ }),
/* 207 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString
var __hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 */

var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */

var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */

var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [opt]
 * @return {object}
 * @public
 */

function parse(str, opt) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var len = str.length;
  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
  if (len < 2) return obj;

  var dec = (opt && opt.decode) || decode;
  var index = 0;
  var eqIdx = 0;
  var endIdx = 0;

  do {
    eqIdx = str.indexOf('=', index);
    if (eqIdx === -1) break; // No more cookie pairs.

    endIdx = str.indexOf(';', index);

    if (endIdx === -1) {
      endIdx = len;
    } else if (eqIdx > endIdx) {
      // backtrack on prior semicolon
      index = str.lastIndexOf(';', eqIdx - 1) + 1;
      continue;
    }

    var keyStartIdx = startIndex(str, index, eqIdx);
    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
    var key = str.slice(keyStartIdx, keyEndIdx);

    // only assign once
    if (!__hasOwnProperty.call(obj, key)) {
      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
      var valEndIdx = endIndex(str, endIdx, valStartIdx);

      if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
        valStartIdx++;
        valEndIdx--;
      }

      var val = str.slice(valStartIdx, valEndIdx);
      obj[key] = tryDecode(val, dec);
    }

    index = endIdx + 1
  } while (index < len);

  return obj;
}

function startIndex(str, index, max) {
  do {
    var code = str.charCodeAt(index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
  } while (++index < max);
  return max;
}

function endIndex(str, index, min) {
  while (index > min) {
    var code = str.charCodeAt(--index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
  }
  return min;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [opt]
 * @return {string}
 * @public
 */

function serialize(name, val, opt) {
  var enc = (opt && opt.encode) || encodeURIComponent;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!cookieNameRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (!cookieValueRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;
  if (!opt) return str;

  if (null != opt.maxAge) {
    var maxAge = Math.floor(opt.maxAge);

    if (!isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid')
    }

    str += '; Max-Age=' + maxAge;
  }

  if (opt.domain) {
    if (!domainValueRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!pathValueRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    var expires = opt.expires

    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + expires.toUTCString()
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.partitioned) {
    str += '; Partitioned'
  }

  if (opt.priority) {
    var priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase() : opt.priority;

    switch (priority) {
      case 'low':
        str += '; Priority=Low'
        break
      case 'medium':
        str += '; Priority=Medium'
        break
      case 'high':
        str += '; Priority=High'
        break
      default:
        throw new TypeError('option priority is invalid')
    }
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */

function decode (str) {
  return str.indexOf('%') !== -1
    ? decodeURIComponent(str)
    : str
}

/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */

function isDate (val) {
  return __toString.call(val) === '[object Date]';
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}


/***/ }),
/* 208 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var createError = __webpack_require__(56)
var debug = __webpack_require__(65)('send')
var encodeUrl = __webpack_require__(168)
var escapeHtml = __webpack_require__(169)
var etag = __webpack_require__(180)
var fresh = __webpack_require__(201)
var fs = __webpack_require__(181)
var mime = __webpack_require__(109)
var ms = __webpack_require__(68)
var onFinished = __webpack_require__(74)
var parseRange = __webpack_require__(202)
var path = __webpack_require__(49)
var statuses = __webpack_require__(172)
var Stream = __webpack_require__(104)
var util = __webpack_require__(62)

/**
 * Path function references.
 * @private
 */

var extname = path.extname
var join = path.join
var normalize = path.normalize
var resolve = path.resolve
var sep = path.sep

/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */

var BYTES_RANGE_REGEXP = /^ *bytes=/

/**
 * Maximum value allowed for the max age.
 * @private
 */

var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year

/**
 * Regular expression to match a path with a directory up component.
 * @private
 */

var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/

/**
 * Module exports.
 * @public
 */

module.exports = send

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */

function send (req, path, options) {
  return new SendStream(req, path, options)
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */

function SendStream (req, path, options) {
  Stream.call(this)

  var opts = options || {}

  this.options = opts
  this.path = path
  this.req = req

  this._acceptRanges = opts.acceptRanges !== undefined
    ? Boolean(opts.acceptRanges)
    : true

  this._cacheControl = opts.cacheControl !== undefined
    ? Boolean(opts.cacheControl)
    : true

  this._etag = opts.etag !== undefined
    ? Boolean(opts.etag)
    : true

  this._dotfiles = opts.dotfiles !== undefined
    ? opts.dotfiles
    : 'ignore'

  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
  }

  this._extensions = opts.extensions !== undefined
    ? normalizeList(opts.extensions, 'extensions option')
    : []

  this._immutable = opts.immutable !== undefined
    ? Boolean(opts.immutable)
    : false

  this._index = opts.index !== undefined
    ? normalizeList(opts.index, 'index option')
    : ['index.html']

  this._lastModified = opts.lastModified !== undefined
    ? Boolean(opts.lastModified)
    : true

  this._maxage = opts.maxAge || opts.maxage
  this._maxage = typeof this._maxage === 'string'
    ? ms(this._maxage)
    : Number(this._maxage)
  this._maxage = !isNaN(this._maxage)
    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
    : 0

  this._root = opts.root
    ? resolve(opts.root)
    : null
}

/**
 * Inherits from `Stream`.
 */

util.inherits(SendStream, Stream)

/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */

SendStream.prototype.error = function error (status, err) {
  // emit if listeners instead of responding
  if (hasListeners(this, 'error')) {
    return this.emit('error', createHttpError(status, err))
  }

  var res = this.res
  var msg = statuses.message[status] || String(status)
  var doc = createHtmlDocument('Error', escapeHtml(msg))

  // clear existing headers
  clearHeaders(res)

  // add error headers
  if (err && err.headers) {
    setHeaders(res, err.headers)
  }

  // send basic response
  res.statusCode = status
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.end(doc)
}

/**
 * Check if the pathname ends with "/".
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
  return this.path[this.path.length - 1] === '/'
}

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function isConditionalGET () {
  return this.req.headers['if-match'] ||
    this.req.headers['if-unmodified-since'] ||
    this.req.headers['if-none-match'] ||
    this.req.headers['if-modified-since']
}

/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {
  var req = this.req
  var res = this.res

  // if-match
  var match = req.headers['if-match']
  if (match) {
    var etag = res.getHeader('ETag')
    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {
      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag
    }))
  }

  // if-unmodified-since
  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))
    return isNaN(lastModified) || lastModified > unmodifiedSince
  }

  return false
}

/**
 * Strip various content header fields for a change in entity.
 *
 * @private
 */

SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
  var res = this.res

  res.removeHeader('Content-Encoding')
  res.removeHeader('Content-Language')
  res.removeHeader('Content-Length')
  res.removeHeader('Content-Range')
  res.removeHeader('Content-Type')
}

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function notModified () {
  var res = this.res
  debug('not modified')
  this.removeContentHeaderFields()
  res.statusCode = 304
  res.end()
}

/**
 * Raise error that headers already sent.
 *
 * @api private
 */

SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
  var err = new Error('Can\'t set headers after they are sent.')
  debug('headers already sent')
  this.error(500, err)
}

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function isCachable () {
  var statusCode = this.res.statusCode
  return (statusCode >= 200 && statusCode < 300) ||
    statusCode === 304
}

/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */

SendStream.prototype.onStatError = function onStatError (error) {
  switch (error.code) {
    case 'ENAMETOOLONG':
    case 'ENOENT':
    case 'ENOTDIR':
      this.error(404, error)
      break
    default:
      this.error(500, error)
      break
  }
}

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function isFresh () {
  return fresh(this.req.headers, {
    etag: this.res.getHeader('ETag'),
    'last-modified': this.res.getHeader('Last-Modified')
  })
}

/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isRangeFresh = function isRangeFresh () {
  var ifRange = this.req.headers['if-range']

  if (!ifRange) {
    return true
  }

  // if-range as etag
  if (ifRange.indexOf('"') !== -1) {
    var etag = this.res.getHeader('ETag')
    return Boolean(etag && ifRange.indexOf(etag) !== -1)
  }

  // if-range as modified date
  var lastModified = this.res.getHeader('Last-Modified')
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)
}

/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */

SendStream.prototype.redirect = function redirect (path) {
  var res = this.res

  if (hasListeners(this, 'directory')) {
    this.emit('directory', res, path)
    return
  }

  if (this.hasTrailingSlash()) {
    this.error(403)
    return
  }

  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))
  var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc))

  // redirect
  res.statusCode = 301
  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
  res.setHeader('Content-Length', Buffer.byteLength(doc))
  res.setHeader('Content-Security-Policy', "default-src 'none'")
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('Location', loc)
  res.end(doc)
}

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function pipe (res) {
  // root path
  var root = this._root

  // references
  this.res = res

  // decode the path
  var path = decode(this.path)
  if (path === -1) {
    this.error(400)
    return res
  }

  // null byte(s)
  if (~path.indexOf('\0')) {
    this.error(400)
    return res
  }

  var parts
  if (root !== null) {
    // normalize
    if (path) {
      path = normalize('.' + sep + path)
    }

    // malicious path
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = path.split(sep)

    // join / normalize from optional root dir
    path = normalize(join(root, path))
  } else {
    // ".." is malicious without "root"
    if (UP_PATH_REGEXP.test(path)) {
      debug('malicious path "%s"', path)
      this.error(403)
      return res
    }

    // explode path parts
    parts = normalize(path).split(sep)

    // resolve the path
    path = resolve(path)
  }

  // dotfile handling
  if (containsDotFile(parts)) {
    debug('%s dotfile "%s"', this._dotfiles, path)
    switch (this._dotfiles) {
      case 'allow':
        break
      case 'deny':
        this.error(403)
        return res
      case 'ignore':
      default:
        this.error(404)
        return res
    }
  }

  // index file support
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path)
    return res
  }

  this.sendFile(path)
  return res
}

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function send (path, stat) {
  var len = stat.size
  var options = this.options
  var opts = {}
  var res = this.res
  var req = this.req
  var ranges = req.headers.range
  var offset = options.start || 0

  if (res.headersSent) {
    // impossible to send now
    this.headersAlreadySent()
    return
  }

  debug('pipe "%s"', path)

  // set header fields
  this.setHeader(path, stat)

  // set content-type
  this.type(path)

  // conditional GET support
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412)
      return
    }

    if (this.isCachable() && this.isFresh()) {
      this.notModified()
      return
    }
  }

  // adjust len to start/end options
  len = Math.max(0, len - offset)
  if (options.end !== undefined) {
    var bytes = options.end - offset + 1
    if (len > bytes) len = bytes
  }

  // Range support
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    // parse
    ranges = parseRange(len, ranges, {
      combine: true
    })

    // If-Range support
    if (!this.isRangeFresh()) {
      debug('range stale')
      ranges = -2
    }

    // unsatisfiable
    if (ranges === -1) {
      debug('range unsatisfiable')

      // Content-Range
      res.setHeader('Content-Range', contentRange('bytes', len))

      // 416 Requested Range Not Satisfiable
      return this.error(416, {
        headers: { 'Content-Range': res.getHeader('Content-Range') }
      })
    }

    // valid (syntactically invalid/multiple ranges are treated as a regular response)
    if (ranges !== -2 && ranges.length === 1) {
      debug('range %j', ranges)

      // Content-Range
      res.statusCode = 206
      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))

      // adjust for requested range
      offset += ranges[0].start
      len = ranges[0].end - ranges[0].start + 1
    }
  }

  // clone options
  for (var prop in options) {
    opts[prop] = options[prop]
  }

  // set read options
  opts.start = offset
  opts.end = Math.max(offset, offset + len - 1)

  // content-length
  res.setHeader('Content-Length', len)

  // HEAD support
  if (req.method === 'HEAD') {
    res.end()
    return
  }

  this.stream(path, opts)
}

/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendFile = function sendFile (path) {
  var i = 0
  var self = this

  debug('stat "%s"', path)
  fs.stat(path, function onstat (err, stat) {
    var pathEndsWithSep = path[path.length - 1] === sep
    if (err && err.code === 'ENOENT' && !extname(path) && !pathEndsWithSep) {
      // not found, check extensions
      return next(err)
    }
    if (err) return self.onStatError(err)
    if (stat.isDirectory()) return self.redirect(path)
    if (pathEndsWithSep) return self.error(404)
    self.emit('file', path, stat)
    self.send(path, stat)
  })

  function next (err) {
    if (self._extensions.length <= i) {
      return err
        ? self.onStatError(err)
        : self.error(404)
    }

    var p = path + '.' + self._extensions[i++]

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }
}

/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendIndex = function sendIndex (path) {
  var i = -1
  var self = this

  function next (err) {
    if (++i >= self._index.length) {
      if (err) return self.onStatError(err)
      return self.error(404)
    }

    var p = join(path, self._index[i])

    debug('stat "%s"', p)
    fs.stat(p, function (err, stat) {
      if (err) return next(err)
      if (stat.isDirectory()) return next()
      self.emit('file', p, stat)
      self.send(p, stat)
    })
  }

  next()
}

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function stream (path, options) {
  var self = this
  var res = this.res

  // pipe
  var stream = fs.createReadStream(path, options)
  this.emit('stream', stream)
  stream.pipe(res)

  // cleanup
  function cleanup () {
    stream.destroy()
  }

  // response finished, cleanup
  onFinished(res, cleanup)

  // error handling
  stream.on('error', function onerror (err) {
    // clean up stream early
    cleanup()

    // error
    self.onStatError(err)
  })

  // end
  stream.on('end', function onend () {
    self.emit('end')
  })
}

/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function type (path) {
  var res = this.res

  if (res.getHeader('Content-Type')) return

  var ext = extname(path)
  var type = mime.contentType(ext) || 'application/octet-stream'

  debug('content-type %s', type)
  res.setHeader('Content-Type', type)
}

/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function setHeader (path, stat) {
  var res = this.res

  this.emit('headers', res, path, stat)

  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
    debug('accept ranges')
    res.setHeader('Accept-Ranges', 'bytes')
  }

  if (this._cacheControl && !res.getHeader('Cache-Control')) {
    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)

    if (this._immutable) {
      cacheControl += ', immutable'
    }

    debug('cache-control %s', cacheControl)
    res.setHeader('Cache-Control', cacheControl)
  }

  if (this._lastModified && !res.getHeader('Last-Modified')) {
    var modified = stat.mtime.toUTCString()
    debug('modified %s', modified)
    res.setHeader('Last-Modified', modified)
  }

  if (this._etag && !res.getHeader('ETag')) {
    var val = etag(stat)
    debug('etag %s', val)
    res.setHeader('ETag', val)
  }
}

/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */

function clearHeaders (res) {
  for (const header of res.getHeaderNames()) {
    res.removeHeader(header)
  }
}

/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] !== '/') {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */

function containsDotFile (parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i]
    if (part.length > 1 && part[0] === '.') {
      return true
    }
  }

  return false
}

/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */

function contentRange (type, size, range) {
  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a HttpError object from simple arguments.
 *
 * @param {number} status
 * @param {Error|object} err
 * @private
 */

function createHttpError (status, err) {
  if (!err) {
    return createError(status)
  }

  return err instanceof Error
    ? createError(status, err, { expose: false })
    : createError(status, err)
}

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */

function decode (path) {
  try {
    return decodeURIComponent(path)
  } catch (err) {
    return -1
  }
}

/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.10
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function hasListeners (emitter, type) {
  var count = typeof emitter.listenerCount !== 'function'
    ? emitter.listeners(type).length
    : emitter.listenerCount(type)

  return count > 0
}

/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */

function normalizeList (val, name) {
  var list = [].concat(val || [])

  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== 'string') {
      throw new TypeError(name + ' must be array of strings or false')
    }
  }

  return list
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate (date) {
  var timestamp = date && Date.parse(date)

  return typeof timestamp === 'number'
    ? timestamp
    : NaN
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList (str) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        if (start !== end) {
          list.push(str.substring(start, end))
        }
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  if (start !== end) {
    list.push(str.substring(start, end))
  }

  return list
}

/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeaders (res, headers) {
  var keys = Object.keys(headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    res.setHeader(key, headers[key])
  }
}


/***/ }),
/* 209 */
/***/ ((module) => {

"use strict";
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module exports.
 */

module.exports = vary
module.exports.append = append

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse(String(field))
    : field

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header
  var vals = parse(header.toLowerCase())

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase()

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld)
      val = val
        ? val + ', ' + fields[i]
        : fields[i]
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse (header) {
  var end = 0
  var list = []
  var start = 0

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end))
        start = end = i + 1
        break
      default:
        end = i + 1
        break
    }
  }

  // final token
  list.push(header.substring(start, end))

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || ''
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val)

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val)
  }
}


/***/ }),
/* 210 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var encodeUrl = __webpack_require__(168)
var escapeHtml = __webpack_require__(169)
var parseUrl = __webpack_require__(170)
var resolve = (__webpack_require__(49).resolve)
var send = __webpack_require__(208)
var url = __webpack_require__(171)

/**
 * Module exports.
 * @public
 */

module.exports = serveStatic

/**
 * @param {string} root
 * @param {object} [options]
 * @return {function}
 * @public
 */

function serveStatic (root, options) {
  if (!root) {
    throw new TypeError('root path required')
  }

  if (typeof root !== 'string') {
    throw new TypeError('root path must be a string')
  }

  // copy options object
  var opts = Object.create(options || null)

  // fall-though
  var fallthrough = opts.fallthrough !== false

  // default redirect
  var redirect = opts.redirect !== false

  // headers listener
  var setHeaders = opts.setHeaders

  if (setHeaders && typeof setHeaders !== 'function') {
    throw new TypeError('option setHeaders must be function')
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0
  opts.root = resolve(root)

  // construct directory listener
  var onDirectory = redirect
    ? createRedirectDirectoryListener()
    : createNotFoundDirectoryListener()

  return function serveStatic (req, res, next) {
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      if (fallthrough) {
        return next()
      }

      // method not allowed
      res.statusCode = 405
      res.setHeader('Allow', 'GET, HEAD')
      res.setHeader('Content-Length', '0')
      res.end()
      return
    }

    var forwardError = !fallthrough
    var originalUrl = parseUrl.original(req)
    var path = parseUrl(req).pathname

    // make sure redirect occurs at mount
    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
      path = ''
    }

    // create send stream
    var stream = send(req, path, opts)

    // add directory handler
    stream.on('directory', onDirectory)

    // add headers listener
    if (setHeaders) {
      stream.on('headers', setHeaders)
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on('file', function onFile () {
        // once file is determined, always forward error
        forwardError = true
      })
    }

    // forward errors
    stream.on('error', function error (err) {
      if (forwardError || !(err.statusCode < 500)) {
        next(err)
        return
      }

      next()
    })

    // pipe
    stream.pipe(res)
  }
}

/**
 * Collapse all leading slashes into a single slash
 * @private
 */
function collapseLeadingSlashes (str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) !== 0x2f /* / */) {
      break
    }
  }

  return i > 1
    ? '/' + str.substr(i)
    : str
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument (title, body) {
  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>' + title + '</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Create a directory listener that just 404s.
 * @private
 */

function createNotFoundDirectoryListener () {
  return function notFound () {
    this.error(404)
  }
}

/**
 * Create a directory listener that performs a redirect.
 * @private
 */

function createRedirectDirectoryListener () {
  return function redirect (res) {
    if (this.hasTrailingSlash()) {
      this.error(404)
      return
    }

    // get original URL
    var originalUrl = parseUrl.original(this.req)

    // append trailing slash
    originalUrl.path = null
    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')

    // reformat the URL
    var loc = encodeUrl(url.format(originalUrl))
    var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc))

    // send redirect response
    res.statusCode = 301
    res.setHeader('Content-Type', 'text/html; charset=UTF-8')
    res.setHeader('Content-Length', Buffer.byteLength(doc))
    res.setHeader('Content-Security-Policy', "default-src 'none'")
    res.setHeader('X-Content-Type-Options', 'nosniff')
    res.setHeader('Location', loc)
    res.end(doc)
  }
}


/***/ }),
/* 211 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CartModule = void 0;
const common_1 = __webpack_require__(2);
const cart_controller_1 = __webpack_require__(212);
const cart_service_1 = __webpack_require__(213);
const prisma_module_1 = __webpack_require__(9);
const fees_module_1 = __webpack_require__(219);
let CartModule = class CartModule {
};
exports.CartModule = CartModule;
exports.CartModule = CartModule = __decorate([
    (0, common_1.Module)({
        imports: [prisma_module_1.PrismaModule, fees_module_1.FeesModule],
        controllers: [cart_controller_1.CartController],
        providers: [cart_service_1.CartService],
        exports: [cart_service_1.CartService],
    })
], CartModule);


/***/ }),
/* 212 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CartController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const cart_service_1 = __webpack_require__(213);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const add_to_cart_dto_1 = __webpack_require__(216);
const cart_response_dto_1 = __webpack_require__(217);
const client_1 = __webpack_require__(11);
const sync_cart_dto_1 = __webpack_require__(218);
let CartController = class CartController {
    constructor(cartService) {
        this.cartService = cartService;
    }
    async addToCart(req, dto, acceptLanguage) {
        const lang = this.detectLanguage(acceptLanguage);
        return this.cartService.addToCart(req.user.id, dto, lang);
    }
    async getCart(req, acceptLanguage) {
        const lang = this.detectLanguage(acceptLanguage);
        return this.cartService.getCart(req.user.id, lang);
    }
    async removeFromCart(req, itemId, acceptLanguage) {
        const lang = this.detectLanguage(acceptLanguage);
        return this.cartService.removeFromCart(req.user.id, itemId, lang);
    }
    async clearCart(req, acceptLanguage) {
        const lang = this.detectLanguage(acceptLanguage);
        return this.cartService.clearCart(req.user.id, lang);
    }
    async migrateTemporaryCart(req, temporaryItems, acceptLanguage) {
        const lang = this.detectLanguage(acceptLanguage);
        return this.cartService.migrateTemporaryCart(req.user.id, temporaryItems, lang);
    }
    async syncCart(req, dto, acceptLanguage) {
        const lang = this.detectLanguage(acceptLanguage);
        return this.cartService.syncCart(req.user.id, dto, lang);
    }
    detectLanguage(acceptLanguage) {
        if (!acceptLanguage)
            return 'en';
        const spanishPatterns = ['es', 'es-', 'spanish', 'espa√±ol'];
        const lowerLang = acceptLanguage.toLowerCase();
        return spanishPatterns.some(pattern => lowerLang.includes(pattern)) ? 'es' : 'en';
    }
};
exports.CartController = CartController;
__decorate([
    (0, common_1.Post)('add'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Agregar producto al carrito',
        description: 'Agrega un producto al carrito del usuario. Solo usuarios BUYER pueden usar esta funcionalidad.'
    }),
    (0, swagger_1.ApiHeader)({
        name: 'accept-language',
        description: 'Idioma preferido (en, es)',
        required: false,
        example: 'es'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto agregado exitosamente',
        type: cart_response_dto_1.CartResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Error de validaci√≥n (carrito lleno, producto ya existe, etc.)'
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Solo compradores pueden agregar productos al carrito'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Producto no encontrado'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Headers)('accept-language')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_b = typeof add_to_cart_dto_1.AddToCartDto !== "undefined" && add_to_cart_dto_1.AddToCartDto) === "function" ? _b : Object, String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], CartController.prototype, "addToCart", null);
__decorate([
    (0, common_1.Get)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener carrito del usuario',
        description: 'Retorna el carrito actual del usuario con totales calculados y productos v√°lidos.'
    }),
    (0, swagger_1.ApiHeader)({
        name: 'accept-language',
        description: 'Idioma preferido (en, es)',
        required: false,
        example: 'es'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Carrito obtenido exitosamente',
        type: cart_response_dto_1.CartResponseDto
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Headers)('accept-language')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], CartController.prototype, "getCart", null);
__decorate([
    (0, common_1.Delete)('items/:itemId'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Remover producto del carrito',
        description: 'Elimina un producto espec√≠fico del carrito del usuario.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'itemId',
        description: 'ID del item en el carrito'
    }),
    (0, swagger_1.ApiHeader)({
        name: 'accept-language',
        description: 'Idioma preferido (en, es)',
        required: false,
        example: 'es'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto removido exitosamente',
        type: cart_response_dto_1.CartResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Item no encontrado en el carrito'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Param)('itemId')),
    __param(2, (0, common_1.Headers)('accept-language')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], CartController.prototype, "removeFromCart", null);
__decorate([
    (0, common_1.Delete)('clear'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Limpiar carrito completo',
        description: 'Elimina todos los productos del carrito del usuario.'
    }),
    (0, swagger_1.ApiHeader)({
        name: 'accept-language',
        description: 'Idioma preferido (en, es)',
        required: false,
        example: 'es'
    }),
    (0, swagger_1.ApiResponse)({
        status: 204,
        description: 'Carrito limpiado exitosamente'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Headers)('accept-language')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], CartController.prototype, "clearCart", null);
__decorate([
    (0, common_1.Post)('migrate'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Migrar carrito temporal',
        description: 'Migra productos del carrito temporal (localStorage) al carrito persistente despu√©s del login.'
    }),
    (0, swagger_1.ApiHeader)({
        name: 'accept-language',
        description: 'Idioma preferido (en, es)',
        required: false,
        example: 'es'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Carrito migrado exitosamente',
        type: cart_response_dto_1.CartResponseDto
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Headers)('accept-language')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Array, String]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], CartController.prototype, "migrateTemporaryCart", null);
__decorate([
    (0, common_1.Post)('sync'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Sincronizar carrito desde el cliente',
        description: 'Sincroniza el carrito local del cliente con el carrito del servidor. √ötil despu√©s del login o para sincronizar entre dispositivos.'
    }),
    (0, swagger_1.ApiHeader)({
        name: 'accept-language',
        description: 'Idioma preferido (en, es)',
        required: false,
        example: 'es'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Carrito sincronizado exitosamente',
        type: cart_response_dto_1.CartResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Solo compradores pueden sincronizar el carrito'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Headers)('accept-language')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_h = typeof sync_cart_dto_1.SyncCartDto !== "undefined" && sync_cart_dto_1.SyncCartDto) === "function" ? _h : Object, String]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], CartController.prototype, "syncCart", null);
exports.CartController = CartController = __decorate([
    (0, swagger_1.ApiTags)('Cart'),
    (0, common_1.Controller)('cart'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof cart_service_1.CartService !== "undefined" && cart_service_1.CartService) === "function" ? _a : Object])
], CartController);


/***/ }),
/* 213 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CartService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const fees_service_1 = __webpack_require__(214);
const translation_helper_1 = __webpack_require__(215);
const client_1 = __webpack_require__(11);
let CartService = class CartService {
    constructor(prisma, feesService) {
        this.prisma = prisma;
        this.feesService = feesService;
    }
    async addToCart(userId, dto, lang = 'en') {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            include: { buyerProfile: true }
        });
        if (!user || !user.buyerProfile) {
            throw new common_1.ForbiddenException(translation_helper_1.TranslationHelper.t('cart.buyerOnly', lang));
        }
        const product = await this.prisma.product.findUnique({
            where: { id: dto.productId },
            include: { seller: true }
        });
        if (!product) {
            throw new common_1.NotFoundException(translation_helper_1.TranslationHelper.t('products.notFound', lang));
        }
        if (product.status !== client_1.ProductStatus.APPROVED) {
            throw new common_1.BadRequestException(translation_helper_1.TranslationHelper.t('products.notAvailable', lang));
        }
        if (product.sellerId === userId) {
            throw new common_1.BadRequestException(translation_helper_1.TranslationHelper.t('cart.ownProduct', lang));
        }
        const currentCartCount = await this.prisma.cartItem.count({
            where: { userId }
        });
        if (currentCartCount >= 10) {
            throw new common_1.BadRequestException(translation_helper_1.TranslationHelper.t('cart.limitExceeded', lang));
        }
        const existingItem = await this.prisma.cartItem.findUnique({
            where: {
                userId_productId: {
                    userId,
                    productId: dto.productId
                }
            }
        });
        if (existingItem) {
            throw new common_1.BadRequestException(translation_helper_1.TranslationHelper.t('cart.alreadyExists', lang));
        }
        await this.prisma.cartItem.create({
            data: {
                userId,
                productId: dto.productId,
                priceSnapshot: product.price,
                quantity: 1
            }
        });
        return this.getCart(userId, lang);
    }
    async getCart(userId, lang = 'en') {
        const cartItems = await this.prisma.cartItem.findMany({
            where: { userId },
            include: {
                product: {
                    include: {
                        seller: {
                            include: {
                                sellerProfile: true
                            }
                        }
                    }
                }
            },
            orderBy: { addedAt: 'desc' }
        });
        const validItems = cartItems.filter(item => item.product &&
            item.product.status === client_1.ProductStatus.APPROVED);
        const invalidItemIds = cartItems
            .filter(item => !validItems.includes(item))
            .map(item => item.id);
        if (invalidItemIds.length > 0) {
            await this.prisma.cartItem.deleteMany({
                where: { id: { in: invalidItemIds } }
            });
        }
        const getProductImage = async (product) => {
            try {
                const imageFileIds = JSON.parse(product.imageFileIds || '[]');
                if (imageFileIds.length > 0) {
                    const imageFile = await this.prisma.file.findFirst({
                        where: {
                            id: { in: imageFileIds },
                            type: 'IMAGE',
                            status: 'ACTIVE'
                        }
                    });
                    return imageFile?.url;
                }
            }
            catch (error) {
                console.warn('Error parsing imageFileIds:', error);
            }
            return undefined;
        };
        const items = await Promise.all(validItems.map(async (item) => {
            const imageUrl = await getProductImage(item.product);
            return {
                id: item.id,
                productId: item.productId,
                productTitle: item.product.title,
                productSlug: item.product.slug,
                priceSnapshot: item.priceSnapshot,
                currentPrice: item.product.price,
                quantity: item.quantity,
                addedAt: item.addedAt,
                seller: {
                    id: item.product.seller.id,
                    name: `${item.product.seller.firstName} ${item.product.seller.lastName}`,
                    storeName: item.product.seller.sellerProfile?.storeName || 'Tienda'
                },
                product: {
                    id: item.product.id,
                    title: item.product.title,
                    slug: item.product.slug,
                    price: item.product.price,
                    category: item.product.category,
                    status: item.product.status,
                    imageUrl
                }
            };
        }));
        const subtotal = items.reduce((sum, item) => sum + item.currentPrice, 0);
        const feeBreakdown = await this.feesService.calculateFees(subtotal, items);
        const platformFee = feeBreakdown.reduce((sum, fee) => sum + fee.amount, 0);
        const totalAmount = subtotal + platformFee;
        return {
            items,
            summary: {
                subtotal,
                platformFeeRate: feeBreakdown.find(f => f.type === 'PLATFORM_FEE')?.rate || 0.10,
                platformFee,
                totalAmount,
                itemCount: items.length,
                feeBreakdown
            },
            userId,
            updatedAt: new Date()
        };
    }
    async removeFromCart(userId, cartItemId, lang = 'en') {
        const cartItem = await this.prisma.cartItem.findFirst({
            where: {
                id: cartItemId,
                userId
            }
        });
        if (!cartItem) {
            throw new common_1.NotFoundException(translation_helper_1.TranslationHelper.t('cart.itemNotFound', lang));
        }
        await this.prisma.cartItem.delete({
            where: { id: cartItemId }
        });
        return this.getCart(userId, lang);
    }
    async clearCart(userId, lang = 'en') {
        await this.prisma.cartItem.deleteMany({
            where: { userId }
        });
    }
    async migrateTemporaryCart(userId, temporaryItems, lang = 'en') {
        if (!temporaryItems || temporaryItems.length === 0) {
            return this.getCart(userId, lang);
        }
        const existingCart = await this.getCart(userId, lang);
        const existingProductIds = existingCart.items.map(item => item.productId);
        const newProductIds = temporaryItems
            .filter(item => !existingProductIds.includes(item.productId))
            .slice(0, 10 - existingCart.items.length)
            .map(item => item.productId);
        for (const productId of newProductIds) {
            try {
                await this.addToCart(userId, { productId }, lang);
            }
            catch (error) {
                console.warn(`Failed to migrate product ${productId}:`, error.message);
            }
        }
        return this.getCart(userId, lang);
    }
    async updateCartPrices(productId, newPrice) {
        await this.prisma.cartItem.updateMany({
            where: { productId },
            data: { priceSnapshot: newPrice }
        });
    }
    async cleanupAbandonedCarts() {
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const result = await this.prisma.cartItem.deleteMany({
            where: {
                addedAt: {
                    lt: thirtyDaysAgo
                }
            }
        });
        return result.count;
    }
    async syncCart(userId, dto, lang = 'en') {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            include: { buyerProfile: true }
        });
        if (!user || !user.buyerProfile) {
            throw new common_1.ForbiddenException(translation_helper_1.TranslationHelper.t('cart.buyerOnly', lang));
        }
        const currentCart = await this.getCart(userId, lang);
        const currentProductIds = currentCart.items.map(item => item.productId);
        const newItems = dto.items.filter(clientItem => !currentProductIds.includes(clientItem.productId));
        const availableSlots = 10 - currentCart.items.length;
        const itemsToSync = newItems.slice(0, availableSlots);
        const syncResults = [];
        for (const item of itemsToSync) {
            try {
                const product = await this.prisma.product.findUnique({
                    where: { id: item.productId },
                    include: { seller: true }
                });
                if (!product) {
                    syncResults.push({
                        productId: item.productId,
                        success: false,
                        error: 'Product not found'
                    });
                    continue;
                }
                if (product.status !== client_1.ProductStatus.APPROVED) {
                    syncResults.push({
                        productId: item.productId,
                        success: false,
                        error: 'Product not available'
                    });
                    continue;
                }
                if (product.sellerId === userId) {
                    syncResults.push({
                        productId: item.productId,
                        success: false,
                        error: 'Cannot add own product'
                    });
                    continue;
                }
                await this.prisma.cartItem.create({
                    data: {
                        userId,
                        productId: item.productId,
                        priceSnapshot: product.price,
                        quantity: 1
                    }
                });
                syncResults.push({
                    productId: item.productId,
                    success: true,
                    error: null
                });
            }
            catch (error) {
                syncResults.push({
                    productId: item.productId,
                    success: false,
                    error: error.message
                });
            }
        }
        const updatedCart = await this.getCart(userId, lang);
        return {
            ...updatedCart,
            syncResults: {
                totalItemsReceived: dto.items.length,
                itemsAlreadyInCart: dto.items.length - newItems.length,
                itemsSynced: syncResults.filter(r => r.success).length,
                itemsSkipped: syncResults.filter(r => !r.success).length,
                availableSlots: availableSlots,
                results: syncResults
            }
        };
    }
};
exports.CartService = CartService;
exports.CartService = CartService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof fees_service_1.FeesService !== "undefined" && fees_service_1.FeesService) === "function" ? _b : Object])
], CartService);


/***/ }),
/* 214 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var FeesService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeesService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const client_1 = __webpack_require__(11);
let FeesService = FeesService_1 = class FeesService {
    constructor(prisma) {
        this.prisma = prisma;
        this.logger = new common_1.Logger(FeesService_1.name);
        this.feeConfigCache = new Map();
        this.cacheExpiry = 5 * 60 * 1000;
        this.lastCacheUpdate = 0;
    }
    async calculateFees(subtotal, items, country, paymentMethod) {
        const fees = [];
        const feeConfigs = await this.prisma.feeConfig.findMany({
            where: {
                isActive: true,
                OR: [
                    { country: null },
                    { country },
                ]
            },
            orderBy: { priority: 'desc' }
        });
        const platformFeeConfig = feeConfigs.find(config => config.type === client_1.FeeType.PLATFORM_FEE && !config.category);
        if (platformFeeConfig) {
            const feeAmount = this.calculateFeeAmount(subtotal, platformFeeConfig);
            fees.push({
                type: 'PLATFORM_FEE',
                description: platformFeeConfig.description || 'Fee de plataforma',
                amount: feeAmount,
                rate: platformFeeConfig.isPercentage ? platformFeeConfig.value : undefined
            });
        }
        else {
            const defaultFee = subtotal * 0.10;
            fees.push({
                type: 'PLATFORM_FEE',
                description: 'Fee de plataforma (10%)',
                amount: defaultFee,
                rate: 0.10
            });
        }
        for (const item of items) {
            const categoryFeeConfig = feeConfigs.find(config => config.type === client_1.FeeType.PLATFORM_FEE &&
                config.category === item.product.category);
            if (categoryFeeConfig) {
                const feeAmount = this.calculateFeeAmount(item.currentPrice, categoryFeeConfig);
                fees.push({
                    type: 'CATEGORY_FEE',
                    description: `Fee categor√≠a ${item.product.category}`,
                    amount: feeAmount,
                    rate: categoryFeeConfig.isPercentage ? categoryFeeConfig.value : undefined
                });
            }
        }
        if (paymentMethod) {
            const paymentFeeConfig = feeConfigs.find(config => config.type === client_1.FeeType.PAYMENT_PROCESSING &&
                config.paymentMethod === paymentMethod);
            if (paymentFeeConfig) {
                const feeAmount = this.calculateFeeAmount(subtotal, paymentFeeConfig);
                fees.push({
                    type: 'PAYMENT_FEE',
                    description: `Fee procesamiento ${paymentMethod}`,
                    amount: feeAmount,
                    rate: paymentFeeConfig.isPercentage ? paymentFeeConfig.value : undefined
                });
            }
        }
        return fees;
    }
    async calculateFeesForSeller(input) {
        const { sellerId, amount, country, category, paymentMethod } = input;
        const seller = await this.prisma.user.findUnique({
            where: { id: sellerId },
            include: {
                sellerProfile: true,
                transactions: {
                    where: { type: 'SALE', status: 'COMPLETED' },
                    select: { amount: true }
                }
            }
        });
        if (!seller) {
            throw new Error(`Seller ${sellerId} not found`);
        }
        const sellerTier = this.determineSellerTier(seller);
        return this.calculateAdvancedFees({
            amount,
            country,
            category,
            paymentMethod,
            sellerTier
        });
    }
    async calculateAdvancedFees(input) {
        const { amount, country, category, paymentMethod, sellerTier } = input;
        const feeConfigs = await this.getApplicableFeeConfigs({
            country,
            category,
            paymentMethod,
            sellerTier
        });
        let platformFee = 0;
        let stripeFee = 0;
        const feeBreakdown = [];
        for (const config of feeConfigs) {
            const feeAmount = this.calculateIndividualFee(amount, config);
            if (config.type === 'PLATFORM_FEE') {
                platformFee += feeAmount;
            }
            else if (config.type === 'PAYMENT_PROCESSING') {
                stripeFee += feeAmount;
            }
            if (feeAmount > 0.01) {
                feeBreakdown.push({
                    name: config.name,
                    type: config.type,
                    amount: feeAmount,
                    percentage: config.isPercentage ? config.value * 100 : undefined,
                    description: config.description
                });
            }
        }
        if (platformFee === 0) {
            platformFee = amount * 0.10;
            feeBreakdown.push({
                name: 'Platform Fee (Default)',
                type: 'PLATFORM_FEE',
                amount: platformFee,
                percentage: 10,
                description: 'Default platform fee'
            });
        }
        if (stripeFee === 0) {
            stripeFee = this.calculateStripeFee(amount, paymentMethod);
            feeBreakdown.push({
                name: 'Stripe Processing Fee',
                type: 'PAYMENT_PROCESSING',
                amount: stripeFee,
                description: 'Stripe payment processing fee'
            });
        }
        const sellerEarning = amount - platformFee - stripeFee;
        this.logger.log(`Fee calculation completed`, {
            amount,
            platformFee,
            stripeFee,
            sellerEarning,
            country,
            category,
            sellerTier
        });
        return {
            platformFee: Number(platformFee.toFixed(2)),
            stripeFee: Number(stripeFee.toFixed(2)),
            sellerEarning: Number(sellerEarning.toFixed(2)),
            feeBreakdown
        };
    }
    calculateFeeAmount(amount, config) {
        let feeAmount = config.isPercentage
            ? amount * config.value
            : config.value;
        if (config.minAmount && feeAmount < config.minAmount) {
            feeAmount = config.minAmount;
        }
        if (config.maxAmount && feeAmount > config.maxAmount) {
            feeAmount = config.maxAmount;
        }
        return Math.round(feeAmount * 100) / 100;
    }
    calculateIndividualFee(amount, config) {
        let fee = 0;
        if (config.isPercentage) {
            fee = amount * config.value;
        }
        else {
            fee = config.value;
        }
        if (config.minAmount && fee < config.minAmount) {
            fee = config.minAmount;
        }
        if (config.maxAmount && fee > config.maxAmount) {
            fee = config.maxAmount;
        }
        return fee;
    }
    determineSellerTier(seller) {
        const totalSales = seller.transactions?.reduce((sum, t) => sum + Number(t.amount), 0) || 0;
        const salesCount = seller.transactions?.length || 0;
        if (totalSales >= 10000 && salesCount >= 100) {
            return 'PLATINUM';
        }
        else if (totalSales >= 5000 && salesCount >= 50) {
            return 'GOLD';
        }
        else if (totalSales >= 1000 && salesCount >= 10) {
            return 'SILVER';
        }
        else {
            return 'BRONZE';
        }
    }
    async getApplicableFeeConfigs(criteria) {
        const cacheKey = JSON.stringify(criteria);
        const now = Date.now();
        if (this.feeConfigCache.has(cacheKey) && (now - this.lastCacheUpdate) < this.cacheExpiry) {
            return this.feeConfigCache.get(cacheKey);
        }
        const where = {
            isActive: true,
            OR: []
        };
        where.OR.push({
            country: null,
            category: null,
            paymentMethod: null,
            sellerTier: null
        });
        if (criteria.country) {
            where.OR.push({ country: criteria.country });
        }
        if (criteria.category) {
            where.OR.push({ category: criteria.category });
        }
        if (criteria.paymentMethod) {
            where.OR.push({ paymentMethod: criteria.paymentMethod });
        }
        if (criteria.sellerTier) {
            where.OR.push({ sellerTier: criteria.sellerTier });
        }
        const configs = await this.prisma.feeConfig.findMany({
            where,
            orderBy: { priority: 'desc' }
        });
        const resolvedConfigs = this.resolveFeeConflicts(configs, criteria);
        this.feeConfigCache.set(cacheKey, resolvedConfigs);
        this.lastCacheUpdate = now;
        return resolvedConfigs;
    }
    resolveFeeConflicts(configs, criteria) {
        const configsByType = new Map();
        configs.forEach(config => {
            if (!configsByType.has(config.type)) {
                configsByType.set(config.type, []);
            }
            configsByType.get(config.type).push(config);
        });
        const resolvedConfigs = [];
        configsByType.forEach((typeConfigs, type) => {
            const mostSpecific = this.findMostSpecificConfig(typeConfigs, criteria);
            if (mostSpecific) {
                resolvedConfigs.push(mostSpecific);
            }
        });
        return resolvedConfigs;
    }
    findMostSpecificConfig(configs, criteria) {
        let mostSpecific = null;
        let maxSpecificity = -1;
        configs.forEach(config => {
            const specificity = this.calculateSpecificity(config, criteria);
            if (specificity > maxSpecificity) {
                maxSpecificity = specificity;
                mostSpecific = config;
            }
        });
        return mostSpecific;
    }
    calculateSpecificity(config, criteria) {
        let specificity = 0;
        if (config.sellerTier && config.sellerTier === criteria.sellerTier) {
            specificity += 4;
        }
        if (config.country && config.country === criteria.country) {
            specificity += 3;
        }
        if (config.category && config.category === criteria.category) {
            specificity += 2;
        }
        if (config.paymentMethod && config.paymentMethod === criteria.paymentMethod) {
            specificity += 1;
        }
        if (!config.country && !config.category && !config.paymentMethod && !config.sellerTier) {
            specificity = 0;
        }
        return specificity;
    }
    calculateStripeFee(amount, paymentMethod) {
        const stripeFees = {
            'card': 0.029 + 0.30,
            'card_international': 0.039 + 0.30,
            'bancontact': 0.014,
            'ideal': 0.008,
            'sepa_debit': 0.008,
            'default': 0.029 + 0.30
        };
        const feeStructure = stripeFees[paymentMethod] || stripeFees.default;
        if (typeof feeStructure === 'number') {
            return amount * feeStructure;
        }
        else {
            return (amount * 0.029) + 0.30;
        }
    }
    async createFeeConfig(config) {
        const feeConfig = await this.prisma.feeConfig.create({
            data: {
                name: config.name,
                type: config.type,
                country: config.country || null,
                category: config.category,
                paymentMethod: config.paymentMethod || null,
                sellerTier: config.sellerTier || null,
                isPercentage: config.isPercentage,
                value: config.value,
                minAmount: config.minAmount || null,
                maxAmount: config.maxAmount || null,
                priority: config.priority || 100,
                description: config.description || null,
                validFrom: config.validFrom || null,
                validUntil: config.validUntil || null,
                isActive: true
            }
        });
        this.clearFeeCache();
        this.logger.log(`Fee config created: ${feeConfig.name}`, {
            id: feeConfig.id,
            type: feeConfig.type,
            value: feeConfig.value
        });
        return feeConfig;
    }
    async getFeeConfigs(filters) {
        const where = {};
        if (filters?.type)
            where.type = filters.type;
        if (filters?.country)
            where.country = filters.country;
        if (filters?.category)
            where.category = filters.category;
        if (filters?.isActive !== undefined)
            where.isActive = filters.isActive;
        return this.prisma.feeConfig.findMany({
            where,
            orderBy: [
                { priority: 'desc' },
                { createdAt: 'desc' }
            ]
        });
    }
    async updateFeeConfig(id, updates) {
        const validUpdates = {};
        if (updates.name !== undefined)
            validUpdates.name = updates.name;
        if (updates.type !== undefined)
            validUpdates.type = updates.type;
        if (updates.country !== undefined)
            validUpdates.country = updates.country;
        if (updates.category !== undefined)
            validUpdates.category = updates.category;
        if (updates.paymentMethod !== undefined)
            validUpdates.paymentMethod = updates.paymentMethod;
        if (updates.sellerTier !== undefined)
            validUpdates.sellerTier = updates.sellerTier;
        if (updates.isPercentage !== undefined)
            validUpdates.isPercentage = updates.isPercentage;
        if (updates.value !== undefined)
            validUpdates.value = updates.value;
        if (updates.minAmount !== undefined)
            validUpdates.minAmount = updates.minAmount;
        if (updates.maxAmount !== undefined)
            validUpdates.maxAmount = updates.maxAmount;
        if (updates.priority !== undefined)
            validUpdates.priority = updates.priority;
        if (updates.description !== undefined)
            validUpdates.description = updates.description;
        if (updates.validFrom !== undefined)
            validUpdates.validFrom = updates.validFrom;
        if (updates.validUntil !== undefined)
            validUpdates.validUntil = updates.validUntil;
        if (updates.isActive !== undefined)
            validUpdates.isActive = updates.isActive;
        const feeConfig = await this.prisma.feeConfig.update({
            where: { id },
            data: validUpdates
        });
        this.clearFeeCache();
        this.logger.log(`Fee config updated: ${feeConfig.name}`, {
            id: feeConfig.id,
            updates: Object.keys(validUpdates)
        });
        return feeConfig;
    }
    async deactivateFeeConfig(id) {
        await this.prisma.feeConfig.update({
            where: { id },
            data: { isActive: false }
        });
        this.clearFeeCache();
        this.logger.log(`Fee config deactivated: ${id}`);
    }
    clearFeeCache() {
        this.feeConfigCache.clear();
        this.lastCacheUpdate = 0;
        this.logger.log('Fee cache cleared');
    }
    validateFeeConfig(config) {
        const errors = [];
        if (!config.name || config.name.trim().length === 0) {
            errors.push('Name is required');
        }
        if (!config.type || !['PLATFORM_FEE', 'PAYMENT_PROCESSING', 'TAX', 'REGIONAL_FEE'].includes(config.type)) {
            errors.push('Valid type is required');
        }
        if (typeof config.value !== 'number' || config.value < 0) {
            errors.push('Value must be a positive number');
        }
        if (config.isPercentage && config.value > 1) {
            errors.push('Percentage value should be between 0 and 1 (e.g., 0.10 for 10%)');
        }
        if (config.minAmount && config.maxAmount && config.minAmount > config.maxAmount) {
            errors.push('Minimum amount cannot be greater than maximum amount');
        }
        if (config.validFrom && config.validUntil && config.validFrom > config.validUntil) {
            errors.push('Valid from date cannot be after valid until date');
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
};
exports.FeesService = FeesService;
exports.FeesService = FeesService = FeesService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object])
], FeesService);


/***/ }),
/* 215 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TranslationHelper = void 0;
class TranslationHelper {
    static t(key, lang = 'en', args) {
        let text = this.translations[lang]?.[key] || this.translations['en'][key] || key;
        if (args) {
            Object.keys(args).forEach(argKey => {
                text = text.replace(`{${argKey}}`, args[argKey]);
            });
        }
        return text;
    }
}
exports.TranslationHelper = TranslationHelper;
TranslationHelper.translations = {
    en: {
        'cart.buyerOnly': 'Only buyers can add products to cart',
        'cart.limitExceeded': 'Cart limit exceeded (10 products max)',
        'cart.alreadyExists': 'Product already in cart',
        'cart.ownProduct': 'You cannot buy your own product',
        'cart.itemNotFound': 'Item not found in cart',
        'products.notFound': 'Product not found',
        'products.notAvailable': 'Product not available for purchase',
        'orders.notFound': 'Order not found',
        'orders.cannotCancel': 'Order cannot be cancelled'
    },
    es: {
        'cart.buyerOnly': 'Solo los compradores pueden agregar productos al carrito',
        'cart.limitExceeded': 'L√≠mite de carrito excedido (m√°ximo 10 productos)',
        'cart.alreadyExists': 'El producto ya est√° en tu carrito',
        'cart.ownProduct': 'No puedes comprar tu propio producto',
        'cart.itemNotFound': 'Producto no encontrado en el carrito',
        'products.notFound': 'Producto no encontrado',
        'products.notAvailable': 'Producto no disponible para compra',
        'orders.notFound': 'Orden no encontrada',
        'orders.cannotCancel': 'La orden no se puede cancelar'
    }
};


/***/ }),
/* 216 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddToCartDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class AddToCartDto {
}
exports.AddToCartDto = AddToCartDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID del producto a agregar al carrito',
        example: 'clrk123456789'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AddToCartDto.prototype, "productId", void 0);


/***/ }),
/* 217 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CartResponseDto = exports.CartSummaryDto = exports.CartItemResponseDto = void 0;
const swagger_1 = __webpack_require__(4);
class CartItemResponseDto {
}
exports.CartItemResponseDto = CartItemResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CartItemResponseDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CartItemResponseDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CartItemResponseDto.prototype, "productTitle", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CartItemResponseDto.prototype, "productSlug", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartItemResponseDto.prototype, "priceSnapshot", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartItemResponseDto.prototype, "currentPrice", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartItemResponseDto.prototype, "quantity", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CartItemResponseDto.prototype, "addedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Object)
], CartItemResponseDto.prototype, "seller", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Object)
], CartItemResponseDto.prototype, "product", void 0);
class CartSummaryDto {
}
exports.CartSummaryDto = CartSummaryDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartSummaryDto.prototype, "subtotal", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartSummaryDto.prototype, "platformFeeRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartSummaryDto.prototype, "platformFee", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartSummaryDto.prototype, "totalAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CartSummaryDto.prototype, "itemCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Array)
], CartSummaryDto.prototype, "feeBreakdown", void 0);
class CartResponseDto {
}
exports.CartResponseDto = CartResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ type: [CartItemResponseDto] }),
    __metadata("design:type", Array)
], CartResponseDto.prototype, "items", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", CartSummaryDto)
], CartResponseDto.prototype, "summary", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CartResponseDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CartResponseDto.prototype, "updatedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Resultados de la sincronizaci√≥n (solo presente en respuesta de sync)',
        required: false
    }),
    __metadata("design:type", Object)
], CartResponseDto.prototype, "syncResults", void 0);


/***/ }),
/* 218 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncCartDto = exports.CartItemSyncDto = void 0;
const class_validator_1 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
const swagger_1 = __webpack_require__(4);
class CartItemSyncDto {
}
exports.CartItemSyncDto = CartItemSyncDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID del producto',
        example: 'clrk123456789'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CartItemSyncDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Cantidad del producto (siempre 1 para productos digitales)',
        example: 1
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPositive)(),
    __metadata("design:type", Number)
], CartItemSyncDto.prototype, "quantity", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Precio snapshot del producto en el momento de agregarlo',
        example: 29.99,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsPositive)(),
    __metadata("design:type", Number)
], CartItemSyncDto.prototype, "priceSnapshot", void 0);
class SyncCartDto {
}
exports.SyncCartDto = SyncCartDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Items del carrito a sincronizar desde el cliente',
        type: [CartItemSyncDto],
        example: [
            { productId: 'clrk123456789', quantity: 1, priceSnapshot: 29.99 },
            { productId: 'clrk987654321', quantity: 1, priceSnapshot: 15.50 }
        ]
    }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => CartItemSyncDto),
    __metadata("design:type", Array)
], SyncCartDto.prototype, "items", void 0);


/***/ }),
/* 219 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeesModule = void 0;
const common_1 = __webpack_require__(2);
const fees_controller_1 = __webpack_require__(220);
const fees_service_1 = __webpack_require__(214);
const prisma_module_1 = __webpack_require__(9);
let FeesModule = class FeesModule {
};
exports.FeesModule = FeesModule;
exports.FeesModule = FeesModule = __decorate([
    (0, common_1.Module)({
        imports: [prisma_module_1.PrismaModule],
        controllers: [fees_controller_1.FeesController],
        providers: [fees_service_1.FeesService],
        exports: [fees_service_1.FeesService],
    })
], FeesModule);


/***/ }),
/* 220 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeesController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const fees_service_1 = __webpack_require__(214);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const client_1 = __webpack_require__(11);
let FeesController = class FeesController {
    constructor(feesService) {
        this.feesService = feesService;
    }
    async createFeeConfig(dto) {
        return this.feesService.createFeeConfig(dto);
    }
    async getFeeConfigs(type, country, category, isActive) {
        const filters = {};
        if (type)
            filters.type = type;
        if (country)
            filters.country = country;
        if (category)
            filters.category = category;
        if (isActive !== undefined)
            filters.isActive = isActive === 'true';
        return this.feesService.getFeeConfigs(filters);
    }
    async updateFeeConfig(id, dto) {
        return this.feesService.updateFeeConfig(id, dto);
    }
    async deactivateFeeConfig(id) {
        await this.feesService.deactivateFeeConfig(id);
    }
    async calculateFees(amount, country, category, paymentMethod) {
        const numericAmount = parseFloat(amount);
        if (isNaN(numericAmount) || numericAmount <= 0) {
            throw new Error('Amount must be a positive number');
        }
        return this.feesService.calculateAdvancedFees({
            amount: numericAmount,
            country,
            category,
            paymentMethod
        });
    }
    async validateFeeConfig(dto) {
        return this.feesService.validateFeeConfig(dto);
    }
};
exports.FeesController = FeesController;
__decorate([
    (0, common_1.Post)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.CREATED),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Crear configuraci√≥n de fee',
        description: 'Crea una nueva configuraci√≥n de fee. Solo administradores.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Configuraci√≥n de fee creada exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Solo administradores pueden crear configuraciones de fee'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], FeesController.prototype, "createFeeConfig", null);
__decorate([
    (0, common_1.Get)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN, client_1.UserRole.SELLER),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener configuraciones de fee',
        description: 'Retorna las configuraciones de fee activas. Administradores ven todas, sellers solo las que les aplican.'
    }),
    (0, swagger_1.ApiQuery)({ name: 'type', required: false, description: 'Filtrar por tipo de fee' }),
    (0, swagger_1.ApiQuery)({ name: 'country', required: false, description: 'Filtrar por pa√≠s' }),
    (0, swagger_1.ApiQuery)({ name: 'category', required: false, description: 'Filtrar por categor√≠a' }),
    (0, swagger_1.ApiQuery)({ name: 'isActive', required: false, description: 'Filtrar por estado activo' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Configuraciones obtenidas exitosamente'
    }),
    __param(0, (0, common_1.Query)('type')),
    __param(1, (0, common_1.Query)('country')),
    __param(2, (0, common_1.Query)('category')),
    __param(3, (0, common_1.Query)('isActive')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], FeesController.prototype, "getFeeConfigs", null);
__decorate([
    (0, common_1.Put)(':id'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Actualizar configuraci√≥n de fee',
        description: 'Actualiza una configuraci√≥n de fee existente. Solo administradores.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID de la configuraci√≥n de fee'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Configuraci√≥n actualizada exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Configuraci√≥n no encontrada'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], FeesController.prototype, "updateFeeConfig", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Desactivar configuraci√≥n de fee',
        description: 'Desactiva una configuraci√≥n de fee. Solo administradores.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID de la configuraci√≥n de fee'
    }),
    (0, swagger_1.ApiResponse)({
        status: 204,
        description: 'Configuraci√≥n desactivada exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Configuraci√≥n no encontrada'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], FeesController.prototype, "deactivateFeeConfig", null);
__decorate([
    (0, common_1.Get)('calculate'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Calcular fees para una venta',
        description: 'Calcula los fees que se aplicar√≠an a una venta espec√≠fica'
    }),
    (0, swagger_1.ApiQuery)({ name: 'amount', required: true, description: 'Monto de la venta' }),
    (0, swagger_1.ApiQuery)({ name: 'country', required: false, description: 'Pa√≠s del comprador' }),
    (0, swagger_1.ApiQuery)({ name: 'category', required: false, description: 'Categor√≠a del producto' }),
    (0, swagger_1.ApiQuery)({ name: 'paymentMethod', required: false, description: 'M√©todo de pago' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'C√°lculo de fees realizado exitosamente'
    }),
    __param(0, (0, common_1.Query)('amount')),
    __param(1, (0, common_1.Query)('country')),
    __param(2, (0, common_1.Query)('category')),
    __param(3, (0, common_1.Query)('paymentMethod')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], FeesController.prototype, "calculateFees", null);
__decorate([
    (0, common_1.Get)('validate'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Validar configuraci√≥n de fee',
        description: 'Valida una configuraci√≥n de fee antes de crearla'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Validaci√≥n completada'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], FeesController.prototype, "validateFeeConfig", null);
exports.FeesController = FeesController = __decorate([
    (0, swagger_1.ApiTags)('Fee Configuration'),
    (0, common_1.Controller)('fees'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof fees_service_1.FeesService !== "undefined" && fees_service_1.FeesService) === "function" ? _a : Object])
], FeesController);


/***/ }),
/* 221 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrdersModule = void 0;
const common_1 = __webpack_require__(2);
const orders_controller_1 = __webpack_require__(222);
const orders_service_1 = __webpack_require__(223);
const prisma_module_1 = __webpack_require__(9);
const cart_module_1 = __webpack_require__(211);
const fees_module_1 = __webpack_require__(219);
const notifications_module_1 = __webpack_require__(235);
let OrdersModule = class OrdersModule {
};
exports.OrdersModule = OrdersModule;
exports.OrdersModule = OrdersModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            cart_module_1.CartModule,
            fees_module_1.FeesModule,
            notifications_module_1.NotificationModule
        ],
        controllers: [orders_controller_1.OrdersController],
        providers: [orders_service_1.OrdersService],
        exports: [orders_service_1.OrdersService],
    })
], OrdersModule);


/***/ }),
/* 222 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrdersController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const orders_service_1 = __webpack_require__(223);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const create_order_dto_1 = __webpack_require__(231);
const order_response_dto_1 = __webpack_require__(232);
const paginated_orders_dto_1 = __webpack_require__(233);
const order_filters_dto_1 = __webpack_require__(234);
const client_1 = __webpack_require__(11);
let OrdersController = class OrdersController {
    constructor(ordersService) {
        this.ordersService = ordersService;
    }
    async createOrder(req, dto) {
        return this.ordersService.createOrder(req.user.id, dto);
    }
    async getMyOrders(req, filters) {
        return this.ordersService.getBuyerOrders(req.user.id, filters);
    }
    async getMySales(req, filters) {
        return this.ordersService.getSellerOrders(req.user.id, filters);
    }
    async getOrderById(req, orderId) {
        return this.ordersService.getOrderById(orderId, req.user.id);
    }
    async cancelOrder(req, orderId, body) {
        return this.ordersService.cancelOrder(orderId, body.reason);
    }
};
exports.OrdersController = OrdersController;
__decorate([
    (0, common_1.Post)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.CREATED),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Crear orden desde carrito',
        description: 'Crea una nueva orden basada en los productos del carrito del usuario.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Orden creada exitosamente',
        type: order_response_dto_1.OrderResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Carrito vac√≠o o productos inv√°lidos'
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Solo compradores pueden crear √≥rdenes'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_b = typeof create_order_dto_1.CreateOrderDto !== "undefined" && create_order_dto_1.CreateOrderDto) === "function" ? _b : Object]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], OrdersController.prototype, "createOrder", null);
__decorate([
    (0, common_1.Get)('my'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener mis √≥rdenes como comprador',
        description: 'Retorna todas las √≥rdenes del usuario autenticado como comprador.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: '√ìrdenes obtenidas exitosamente',
        type: paginated_orders_dto_1.PaginatedOrdersDto
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_d = typeof order_filters_dto_1.OrderFiltersDto !== "undefined" && order_filters_dto_1.OrderFiltersDto) === "function" ? _d : Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], OrdersController.prototype, "getMyOrders", null);
__decorate([
    (0, common_1.Get)('sales'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener mis ventas como seller',
        description: 'Retorna todas las √≥rdenes donde el usuario autenticado ha vendido productos.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Ventas obtenidas exitosamente',
        type: paginated_orders_dto_1.PaginatedOrdersDto
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_f = typeof order_filters_dto_1.OrderFiltersDto !== "undefined" && order_filters_dto_1.OrderFiltersDto) === "function" ? _f : Object]),
    __metadata("design:returntype", typeof (_g = typeof Promise !== "undefined" && Promise) === "function" ? _g : Object)
], OrdersController.prototype, "getMySales", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER, client_1.UserRole.SELLER),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener orden por ID',
        description: 'Retorna los detalles de una orden espec√≠fica. Solo visible para el comprador o sellers involucrados.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID de la orden'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Orden obtenida exitosamente',
        type: order_response_dto_1.OrderResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Orden no encontrada o sin permisos'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], OrdersController.prototype, "getOrderById", null);
__decorate([
    (0, common_1.Post)(':id/cancel'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Cancelar orden',
        description: 'Cancela una orden pendiente. Solo el comprador o admin pueden cancelar.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'ID de la orden'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Orden cancelada exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Orden no encontrada'
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Orden no se puede cancelar en su estado actual'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Param)('id')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, Object]),
    __metadata("design:returntype", typeof (_j = typeof Promise !== "undefined" && Promise) === "function" ? _j : Object)
], OrdersController.prototype, "cancelOrder", null);
exports.OrdersController = OrdersController = __decorate([
    (0, swagger_1.ApiTags)('Orders'),
    (0, common_1.Controller)('orders'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof orders_service_1.OrdersService !== "undefined" && orders_service_1.OrdersService) === "function" ? _a : Object])
], OrdersController);


/***/ }),
/* 223 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrdersService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const cart_service_1 = __webpack_require__(213);
const fees_service_1 = __webpack_require__(214);
const notifications_service_1 = __webpack_require__(224);
const client_1 = __webpack_require__(11);
let OrdersService = class OrdersService {
    constructor(prisma, cartService, feesService, notificationService) {
        this.prisma = prisma;
        this.cartService = cartService;
        this.feesService = feesService;
        this.notificationService = notificationService;
    }
    async handleSuccessfulPayment(params, tx) {
        const prisma = tx || this.prisma;
        await prisma.order.update({
            where: { id: params.orderId },
            data: {
                status: 'PROCESSING',
                paidAt: new Date(),
                paymentStatus: 'succeeded',
                paymentIntentId: params.paymentIntentId,
                metadata: {
                    webhookEventId: params.webhookEventId,
                    amountPaid: params.amount,
                    currency: params.currency
                }
            }
        });
        await this.processPaymentSuccess(params.paymentIntentId);
    }
    async handleFailedPayment(params, tx) {
        const prisma = tx || this.prisma;
        await prisma.order.update({
            where: { id: params.orderId },
            data: {
                paymentStatus: 'failed',
                metadata: {
                    webhookEventId: params.webhookEventId,
                    paymentError: {
                        code: params.errorCode,
                        message: params.errorMessage
                    }
                }
            }
        });
    }
    async handleCheckoutCompleted(params, tx) {
        const prisma = tx || this.prisma;
        await prisma.order.update({
            where: { id: params.orderId },
            data: {
                paymentIntentId: params.paymentIntentId,
                paymentStatus: 'completed',
                metadata: {
                    webhookEventId: params.webhookEventId,
                    sessionId: params.sessionId,
                    checkoutStatus: params.paymentStatus
                }
            }
        });
    }
    async handleCheckoutExpired(params, tx) {
        const prisma = tx || this.prisma;
        const order = await prisma.order.findUnique({
            where: { id: params.orderId }
        });
        if (order?.status === 'PENDING') {
            await prisma.order.update({
                where: { id: params.orderId },
                data: {
                    status: 'CANCELLED',
                    cancelledAt: new Date(),
                    metadata: {
                        webhookEventId: params.webhookEventId,
                        cancelReason: 'checkout_expired'
                    }
                }
            });
        }
    }
    async findOrderByPayPalId(paypalOrderId) {
        return await this.prisma.order.findFirst({
            where: { paypalOrderId },
            include: {
                items: {
                    include: {
                        product: {
                            include: {
                                seller: true
                            }
                        }
                    }
                },
                buyer: true
            }
        });
    }
    async findOrderByPaymentId(paymentIntentId) {
        return await this.prisma.order.findFirst({
            where: { paymentIntentId },
            include: {
                items: {
                    include: {
                        product: {
                            include: {
                                seller: true
                            }
                        }
                    }
                },
                buyer: true
            }
        });
    }
    async handlePaymentCanceled(params, tx) {
        const prisma = tx || this.prisma;
        await prisma.order.update({
            where: { id: params.orderId },
            data: {
                status: 'CANCELLED',
                cancelledAt: new Date(),
                paymentStatus: 'canceled',
                metadata: {
                    webhookEventId: params.webhookEventId,
                    cancelReason: 'payment_canceled'
                }
            }
        });
    }
    async handleDispute(params, tx) {
        const prisma = tx || this.prisma;
        const order = await prisma.order.findFirst({
            where: { paymentIntentId: params.paymentIntentId }
        });
        if (order) {
            await prisma.order.update({
                where: { id: order.id },
                data: {
                    status: 'DISPUTED',
                    metadata: {
                        webhookEventId: params.webhookEventId,
                        dispute: {
                            disputeId: params.disputeId,
                            reason: params.reason,
                            amount: params.amount,
                            currency: params.currency
                        }
                    }
                }
            });
        }
    }
    async handleRefund(params, tx) {
        const prisma = tx || this.prisma;
        const order = await prisma.order.findFirst({
            where: { paymentIntentId: params.paymentIntentId }
        });
        if (order) {
            await prisma.order.update({
                where: { id: order.id },
                data: {
                    status: 'REFUNDED',
                    metadata: {
                        webhookEventId: params.webhookEventId,
                        refund: {
                            refundId: params.refundId,
                            amount: params.amount,
                            reason: params.reason
                        }
                    }
                }
            });
        }
    }
    async createOrder(userId, dto) {
        const cart = await this.cartService.getCart(userId);
        if (cart.items.length === 0) {
            throw new common_1.BadRequestException('El carrito est√° vac√≠o');
        }
        const orderNumber = await this.generateOrderNumber();
        const sellerIds = [...new Set(cart.items.map(item => item.seller.id))];
        const feeBreakdown = this.generateFeeBreakdown(cart.summary, sellerIds);
        const order = await this.prisma.order.create({
            data: {
                orderNumber,
                buyerId: userId,
                subtotal: cart.summary.subtotal,
                subtotalAmount: cart.summary.subtotal,
                platformFeeRate: cart.summary.platformFeeRate,
                platformFee: cart.summary.platformFee,
                totalAmount: cart.summary.totalAmount,
                sellerAmount: cart.summary.subtotal - cart.summary.platformFee,
                buyerEmail: dto.buyerEmail,
                billingData: dto.billingData || null,
                metadata: dto.metadata || null,
                feeBreakdown: dto.feeBreakdown || feeBreakdown,
                status: 'PENDING',
                items: {
                    create: cart.items.map(item => ({
                        productId: item.productId,
                        sellerId: item.seller.id,
                        productTitle: item.productTitle,
                        productSlug: item.productSlug,
                        price: item.currentPrice,
                        quantity: item.quantity || 1,
                        sellerName: item.seller.name,
                        storeName: item.seller.storeName || null
                    }))
                }
            },
            include: {
                items: {
                    include: {
                        product: {
                            select: {
                                id: true,
                                title: true,
                                slug: true,
                                thumbnailFileIds: true
                            }
                        },
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                        avatar: true
                                    }
                                }
                            }
                        }
                    }
                },
                buyer: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        email: true
                    }
                }
            }
        });
        await this.notificationService.sendOrderCreatedNotification(order);
        return this.mapOrderToDto(order);
    }
    generateFeeBreakdown(summary, sellerIds) {
        const breakdown = [];
        const stripeFeeAmount = (summary.totalAmount * 0.029) + 0.30;
        const sellerAmount = summary.subtotal - summary.platformFee;
        breakdown.push({
            type: 'SELLER_AMOUNT',
            description: `Amount for ${sellerIds.length} seller(s)`,
            amount: parseFloat(sellerAmount.toFixed(2)),
            percentage: parseFloat(((sellerAmount / summary.subtotal) * 100).toFixed(1)),
            sellerId: sellerIds.length === 1 ? sellerIds[0] : null
        });
        breakdown.push({
            type: 'PLATFORM_FEE',
            description: `Platform commission (${(summary.platformFeeRate * 100).toFixed(1)}%)`,
            amount: parseFloat(summary.platformFee.toFixed(2)),
            percentage: parseFloat((summary.platformFeeRate * 100).toFixed(1))
        });
        breakdown.push({
            type: 'STRIPE_FEE',
            description: 'Payment processing fee (2.9% + $0.30)',
            amount: parseFloat(stripeFeeAmount.toFixed(2)),
            percentage: 2.9
        });
        const netAmount = summary.totalAmount - stripeFeeAmount;
        breakdown.push({
            type: 'NET_AMOUNT',
            description: 'Net amount after payment processing',
            amount: parseFloat(netAmount.toFixed(2)),
            percentage: parseFloat(((netAmount / summary.totalAmount) * 100).toFixed(1))
        });
        return breakdown;
    }
    buildOrderBy(sortBy, sortOrder) {
        const order = (sortOrder === 'asc') ? 'asc' : 'desc';
        switch (sortBy) {
            case 'createdAt':
                return { createdAt: order };
            case 'updatedAt':
                return { updatedAt: order };
            case 'totalAmount':
                return { totalAmount: order };
            case 'orderNumber':
                return { orderNumber: order };
            case 'status':
                return { status: order };
            case 'paidAt':
                return { paidAt: order };
            default:
                return { createdAt: 'desc' };
        }
    }
    async getOrderById(orderId, userId) {
        const order = await this.prisma.order.findUnique({
            where: { id: orderId },
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            }
        });
        if (!order) {
            throw new common_1.NotFoundException('Orden no encontrada');
        }
        if (userId && order.buyerId !== userId && !order.items.some(item => item.sellerId === userId)) {
            throw new common_1.NotFoundException('Orden no encontrada');
        }
        return this.mapOrderToDto(order);
    }
    async getBuyerOrders(userId, filters) {
        const where = { buyerId: userId };
        if (filters.status) {
            where.status = filters.status;
        }
        if (filters.fromDate || filters.toDate) {
            where.createdAt = {};
            if (filters.fromDate) {
                where.createdAt.gte = new Date(filters.fromDate);
            }
            if (filters.toDate) {
                where.createdAt.lte = new Date(filters.toDate);
            }
        }
        if (filters.search) {
            where.OR = [
                { orderNumber: { contains: filters.search } },
                { buyerEmail: { contains: filters.search } }
            ];
        }
        const total = await this.prisma.order.count({ where });
        const totalPages = Math.ceil(total / filters.limit);
        const orders = await this.prisma.order.findMany({
            where,
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            },
            orderBy: this.buildOrderBy(filters.sortBy, filters.sortOrder),
            skip: (filters.page - 1) * filters.limit,
            take: filters.limit
        });
        return {
            data: orders.map(order => this.mapOrderToDto(order)),
            total,
            page: filters.page,
            limit: filters.limit,
            totalPages,
            hasNext: filters.page < totalPages,
            hasPrev: filters.page > 1
        };
    }
    async getSellerOrders(sellerId, filters) {
        const where = {
            sellerIds: {
                has: sellerId
            }
        };
        if (filters.status) {
            where.status = filters.status;
        }
        if (filters.fromDate || filters.toDate) {
            where.createdAt = {};
            if (filters.fromDate) {
                where.createdAt.gte = new Date(filters.fromDate);
            }
            if (filters.toDate) {
                where.createdAt.lte = new Date(filters.toDate);
            }
        }
        const total = await this.prisma.order.count({ where });
        const totalPages = Math.ceil(total / filters.limit);
        const orders = await this.prisma.order.findMany({
            where,
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            },
            orderBy: this.buildOrderBy(filters.sortBy, filters.sortOrder),
            skip: (filters.page - 1) * filters.limit,
            take: filters.limit
        });
        return {
            data: orders.map(order => this.mapOrderToDto(order)),
            total,
            page: filters.page,
            limit: filters.limit,
            totalPages,
            hasNext: filters.page < totalPages,
            hasPrev: filters.page > 1
        };
    }
    async processPaymentSuccess(paymentIntentId) {
        const order = await this.prisma.order.findFirst({
            where: { paymentIntentId },
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            }
        });
        if (!order) {
            throw new common_1.NotFoundException('Orden no encontrada');
        }
        await this.prisma.order.update({
            where: { id: order.id },
            data: {
                status: client_1.OrderStatus.PROCESSING,
                paidAt: new Date(),
                paymentStatus: 'succeeded'
            }
        });
        await this.notificationService.sendOrderPaidNotification(order);
        await this.generateDownloadTokens(order);
        await this.completeOrder(order.id);
    }
    async completeOrder(orderId) {
        const order = await this.prisma.order.update({
            where: { id: orderId },
            data: {
                status: client_1.OrderStatus.COMPLETED,
                completedAt: new Date()
            },
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            }
        });
        await this.cartService.clearCart(order.buyerId);
        await this.updateProductStatistics(order.items);
        await this.notificationService.sendOrderCompletedNotification(order);
        try {
            const { ReviewsService } = await Promise.resolve().then(() => __importStar(__webpack_require__(230)));
            const reviewsService = new ReviewsService(this.prisma, this.notificationService);
            await reviewsService.scheduleReviewReminders(order.id, order.buyerId);
            console.log(`Review reminders scheduled for order ${order.orderNumber}`);
        }
        catch (error) {
            console.error('Error scheduling review reminders:', error);
        }
    }
    async cancelOrder(orderId, reason) {
        await this.prisma.order.update({
            where: { id: orderId },
            data: {
                status: client_1.OrderStatus.CANCELLED,
                cancelledAt: new Date(),
                metadata: {
                    cancellationReason: reason
                }
            }
        });
    }
    async generateDownloadTokens(order) {
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 30);
        for (const item of order.items) {
            if (item.product.pdfFileId) {
                await this.prisma.downloadToken.create({
                    data: {
                        orderId: order.id,
                        productId: item.productId,
                        buyerId: order.buyerId,
                        downloadLimit: 5,
                        expiresAt
                    }
                });
            }
        }
    }
    async updateProductStatistics(orderItems) {
        for (const item of orderItems) {
            await this.prisma.product.update({
                where: { id: item.productId },
                data: {
                    downloadCount: {
                        increment: 1
                    }
                }
            });
            await this.prisma.sellerProfile.update({
                where: { userId: item.sellerId },
                data: {
                    totalSales: {
                        increment: 1
                    }
                }
            });
        }
    }
    async generateOrderNumber() {
        const today = new Date();
        const dateStr = today.toISOString().slice(0, 10).replace(/-/g, '');
        const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        const endOfDay = new Date(startOfDay);
        endOfDay.setDate(endOfDay.getDate() + 1);
        const ordersToday = await this.prisma.order.count({
            where: {
                createdAt: {
                    gte: startOfDay,
                    lt: endOfDay
                }
            }
        });
        const sequenceNumber = (ordersToday + 1).toString().padStart(3, '0');
        return `ORD-${dateStr}-${sequenceNumber}`;
    }
    mapOrderToDto(order) {
        return {
            id: order.id,
            orderNumber: order.orderNumber,
            status: order.status,
            subtotal: order.subtotal,
            platformFeeRate: order.platformFeeRate,
            platformFee: order.platformFee,
            totalAmount: order.totalAmount,
            sellerAmount: order.sellerAmount,
            buyerEmail: order.buyerEmail,
            paymentIntentId: order.paymentIntentId,
            paymentStatus: order.paymentStatus,
            items: order.items.map(item => ({
                id: item.id,
                productId: item.productId,
                productTitle: item.productTitle,
                productSlug: item.productSlug,
                price: item.price,
                quantity: item.quantity,
                sellerName: item.sellerName,
                storeName: item.storeName
            })),
            buyer: {
                id: order.buyer.id,
                name: `${order.buyer.firstName} ${order.buyer.lastName}`,
                email: order.buyer.email
            },
            createdAt: order.createdAt,
            paidAt: order.paidAt,
            completedAt: order.completedAt,
            feeBreakdown: order.feeBreakdown
        };
    }
    async getAllOrdersAdmin(filters) {
        const where = {};
        if (filters.status) {
            where.status = filters.status;
        }
        if (filters.fromDate || filters.toDate) {
            where.createdAt = {};
            if (filters.fromDate) {
                where.createdAt.gte = new Date(filters.fromDate);
            }
            if (filters.toDate) {
                where.createdAt.lte = new Date(filters.toDate);
            }
        }
        if (filters.search) {
            where.OR = [
                { orderNumber: { contains: filters.search } },
                { buyerEmail: { contains: filters.search } }
            ];
        }
        const total = await this.prisma.order.count({ where });
        const totalPages = Math.ceil(total / filters.limit);
        const orders = await this.prisma.order.findMany({
            where,
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            },
            orderBy: this.buildOrderBy(filters.sortBy, filters.sortOrder),
            skip: (filters.page - 1) * filters.limit,
            take: filters.limit
        });
        return {
            data: orders.map(order => this.mapOrderToDto(order)),
            total,
            page: filters.page,
            limit: filters.limit,
            totalPages,
            hasNext: filters.page < totalPages,
            hasPrev: filters.page > 1
        };
    }
    async getOrderAnalytics(filters) {
        const where = {};
        if (filters.fromDate || filters.toDate) {
            where.createdAt = {};
            if (filters.fromDate)
                where.createdAt.gte = new Date(filters.fromDate);
            if (filters.toDate)
                where.createdAt.lte = new Date(filters.toDate);
        }
        const totalOrders = await this.prisma.order.count({ where });
        const revenueStats = await this.prisma.order.aggregate({
            where: { ...where, status: 'COMPLETED' },
            _sum: { totalAmount: true },
            _avg: { totalAmount: true }
        });
        const ordersByStatus = await this.prisma.order.groupBy({
            by: ['status'],
            where,
            _count: { status: true }
        });
        const topSellers = await this.prisma.orderItem.groupBy({
            by: ['sellerId'],
            where: {
                order: where
            },
            _sum: { price: true },
            _count: { sellerId: true },
            orderBy: { _sum: { price: 'desc' } },
            take: 10
        });
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const revenueByDate = await this.prisma.order.findMany({
            where: {
                ...where,
                status: 'COMPLETED',
                createdAt: { gte: thirtyDaysAgo }
            },
            select: { totalAmount: true, createdAt: true }
        });
        const dailyRevenue = revenueByDate.reduce((acc, order) => {
            const date = order.createdAt.toISOString().split('T')[0];
            acc[date] = (acc[date] || 0) + order.totalAmount;
            return acc;
        }, {});
        return {
            totalOrders,
            totalRevenue: revenueStats._sum.totalAmount || 0,
            avgOrderValue: revenueStats._avg.totalAmount || 0,
            ordersByStatus: Object.fromEntries(ordersByStatus.map(item => [item.status, item._count.status])),
            topSellers: topSellers.map(seller => ({
                sellerId: seller.sellerId,
                totalSales: seller._count.sellerId,
                totalRevenue: seller._sum.price
            })),
            revenueByDate: Object.entries(dailyRevenue).map(([date, revenue]) => ({
                date,
                revenue
            }))
        };
    }
    async processRefund(orderId, amount, reason) {
        const order = await this.prisma.order.findUnique({
            where: { id: orderId }
        });
        if (!order) {
            throw new common_1.NotFoundException('Orden no encontrada');
        }
        if (order.status !== 'COMPLETED' && order.status !== 'PAID') {
            throw new common_1.BadRequestException('Solo se pueden reembolsar √≥rdenes completadas o pagadas');
        }
        const updatedOrder = await this.prisma.order.update({
            where: { id: orderId },
            data: {
                status: 'REFUNDED',
                metadata: {
                    ...(order.metadata || {}),
                    refund: {
                        amount: amount || order.totalAmount,
                        reason,
                        processedAt: new Date().toISOString(),
                        processedBy: 'admin'
                    }
                }
            }
        });
        return updatedOrder;
    }
    async updateOrderStatus(orderId, status, reason) {
        const order = await this.prisma.order.findUnique({
            where: { id: orderId },
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            }
        });
        if (!order) {
            throw new common_1.NotFoundException('Orden no encontrada');
        }
        const updatedOrder = await this.prisma.order.update({
            where: { id: orderId },
            data: {
                status,
                ...(status === 'COMPLETED' && { completedAt: new Date() }),
                metadata: {
                    ...(order.metadata || {}),
                    statusUpdate: {
                        previousStatus: order.status,
                        newStatus: status,
                        reason,
                        updatedAt: new Date().toISOString(),
                        updatedBy: 'admin'
                    }
                }
            },
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true
            }
        });
        if (status === 'COMPLETED' && order.status !== 'COMPLETED') {
            await this.generateDownloadTokens(updatedOrder);
            await this.notificationService.sendOrderCompletedNotification(updatedOrder);
            try {
                const { ReviewsService } = await Promise.resolve().then(() => __importStar(__webpack_require__(230)));
                const reviewsService = new ReviewsService(this.prisma, this.notificationService);
                await reviewsService.scheduleReviewReminders(updatedOrder.id, updatedOrder.buyerId);
                console.log(`Review reminders scheduled for order ${updatedOrder.orderNumber} (manual completion)`);
            }
            catch (error) {
                console.error('Error scheduling review reminders on manual completion:', error);
            }
        }
        return updatedOrder;
    }
    async cleanupPendingOrders() {
        const oneHourAgo = new Date();
        oneHourAgo.setHours(oneHourAgo.getHours() - 1);
        const result = await this.prisma.order.updateMany({
            where: {
                status: client_1.OrderStatus.PENDING,
                createdAt: {
                    lt: oneHourAgo
                }
            },
            data: {
                status: client_1.OrderStatus.CANCELLED,
                cancelledAt: new Date()
            }
        });
        return result.count;
    }
};
exports.OrdersService = OrdersService;
exports.OrdersService = OrdersService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof cart_service_1.CartService !== "undefined" && cart_service_1.CartService) === "function" ? _b : Object, typeof (_c = typeof fees_service_1.FeesService !== "undefined" && fees_service_1.FeesService) === "function" ? _c : Object, typeof (_d = typeof notifications_service_1.NotificationService !== "undefined" && notifications_service_1.NotificationService) === "function" ? _d : Object])
], OrdersService);


/***/ }),
/* 224 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const email_service_1 = __webpack_require__(225);
const websocket_gateway_1 = __webpack_require__(227);
const client_1 = __webpack_require__(11);
const schedule_1 = __webpack_require__(8);
let NotificationService = class NotificationService {
    constructor(prisma, emailService, webSocketGateway) {
        this.prisma = prisma;
        this.emailService = emailService;
        this.webSocketGateway = webSocketGateway;
    }
    getTranslation(key, lang, args) {
        const translations = {
            en: {
                'notifications.orderCreated': 'Order Created Successfully!',
                'notifications.orderCreatedMsg': 'Your order {orderNumber} has been created. Please proceed to payment to receive your files.',
                'notifications.orderPaid': 'Payment Confirmed!',
                'notifications.orderPaidMsg': 'Your payment for order {orderNumber} has been processed successfully. We are preparing your files.',
                'notifications.orderCompleted': 'Files Ready for Download!',
                'notifications.orderCompletedMsg': 'Your order {orderNumber} is complete. You can now download your files.',
                'notifications.productSold': 'New Sale!',
                'notifications.productSoldMsg': 'You sold {itemCount} product(s) for a total of ${sellerAmount}.',
                'cart.buyerOnly': 'Only buyers can add products to cart',
                'cart.limitExceeded': 'Cart limit exceeded (10 products max)',
                'cart.alreadyExists': 'Product already in cart',
                'cart.ownProduct': 'You cannot buy your own product',
                'cart.itemNotFound': 'Item not found in cart',
                'notifications.reviewReceived': 'New Review Received!',
                'notifications.reviewReceivedMsg': 'You received a {rating}-star review for "{productTitle}": "{comment}"',
                'notifications.reviewResponse': 'Response to Your Review',
                'notifications.reviewResponseMsg': 'The seller responded to your review for "{productTitle}"',
                'notifications.reviewHelpful': 'Review Marked as Helpful',
                'notifications.reviewHelpfulMsg': 'Your review for "{productTitle}" was marked as helpful by another user',
                'notifications.reviewWeeklyDigest': 'Weekly Review Summary',
                'notifications.reviewWeeklyDigestMsg': 'You received {count} new reviews this week with an average rating of {averageRating} stars',
                'notifications.reviewReminder': 'Review Reminder',
                'notifications.reviewReminderMsg': 'Don\'t forget to review "{productTitle}" from your recent purchase',
                'notifications.reviewMilestone': 'Review Milestone Reached!',
                'notifications.reviewMilestoneMsg': 'Congratulations! You\'ve reached {milestone} reviews with an average rating of {averageRating} stars',
            },
            es: {
                'notifications.orderCreated': '¬°Orden Creada Exitosamente!',
                'notifications.orderCreatedMsg': 'Tu orden {orderNumber} ha sido creada. Procede al pago para recibir tus archivos.',
                'notifications.orderPaid': '¬°Pago Confirmado!',
                'notifications.orderPaidMsg': 'Tu pago por la orden {orderNumber} ha sido procesado exitosamente. Estamos preparando tus archivos.',
                'notifications.orderCompleted': '¬°Archivos Listos para Descarga!',
                'notifications.orderCompletedMsg': 'Tu orden {orderNumber} est√° completa. Ya puedes descargar tus archivos.',
                'notifications.productSold': '¬°Nueva Venta!',
                'notifications.productSoldMsg': 'Has vendido {itemCount} producto(s) por un total de ${sellerAmount}.',
                'cart.buyerOnly': 'Solo los compradores pueden agregar productos al carrito',
                'cart.limitExceeded': 'L√≠mite de carrito excedido (m√°ximo 10 productos)',
                'cart.alreadyExists': 'El producto ya est√° en tu carrito',
                'cart.ownProduct': 'No puedes comprar tu propio producto',
                'cart.itemNotFound': 'Producto no encontrado en el carrito',
                'notifications.reviewReceived': '¬°Nueva Rese√±a Recibida!',
                'notifications.reviewReceivedMsg': 'Recibiste una rese√±a de {rating} estrellas para "{productTitle}": "{comment}"',
                'notifications.reviewResponse': 'Respuesta a Tu Rese√±a',
                'notifications.reviewResponseMsg': 'El vendedor respondi√≥ a tu rese√±a de "{productTitle}"',
                'notifications.reviewHelpful': 'Rese√±a Marcada como √ötil',
                'notifications.reviewHelpfulMsg': 'Tu rese√±a de "{productTitle}" fue marcada como √∫til por otro usuario',
                'notifications.reviewWeeklyDigest': 'Resumen Semanal de Rese√±as',
                'notifications.reviewWeeklyDigestMsg': 'Recibiste {count} nuevas rese√±as esta semana con un promedio de {averageRating} estrellas',
                'notifications.reviewReminder': 'Recordatorio de Rese√±a',
                'notifications.reviewReminderMsg': 'No olvides rese√±ar "{productTitle}" de tu compra reciente',
                'notifications.reviewMilestone': '¬°Hito de Rese√±as Alcanzado!',
                'notifications.reviewMilestoneMsg': '¬°Felicitaciones! Has alcanzado {milestone} rese√±as con un promedio de {averageRating} estrellas',
            }
        };
        let text = translations[lang]?.[key] || translations['en'][key] || key;
        if (args) {
            Object.keys(args).forEach(argKey => {
                text = text.replace(`{${argKey}}`, args[argKey]);
            });
        }
        return text;
    }
    async createNotification(dto) {
        const preferences = await this.getUserPreferences(dto.userId);
        if (!this.shouldSendNotification(dto.type, preferences)) {
            console.log(`Notification skipped due to user preferences: ${dto.type} for user ${dto.userId}`);
            return;
        }
        if (this.isInQuietHours(preferences)) {
            await this.scheduleNotification({
                ...dto,
                scheduledFor: this.getNextAvailableTime(preferences).toISOString()
            });
            return;
        }
        const notification = await this.prisma.notification.create({
            data: {
                userId: dto.userId,
                type: dto.type,
                title: dto.title,
                message: dto.message,
                data: dto.data,
                orderId: dto.orderId,
                priority: dto.priority || client_1.NotificationPriority.NORMAL,
                channel: dto.channel,
                groupKey: dto.groupKey,
                expiresAt: dto.expiresAt ? new Date(dto.expiresAt) : undefined
            }
        });
        if (preferences.inAppEnabled) {
            this.webSocketGateway.sendToUser(dto.userId, 'notification', {
                id: notification.id,
                type: notification.type,
                title: notification.title,
                message: notification.message,
                data: notification.data,
                priority: notification.priority,
                createdAt: notification.createdAt
            });
        }
        if (preferences.emailEnabled) {
            this.sendEmailNotification(notification).catch(error => {
                console.error('Error sending email notification:', error);
            });
        }
        await this.trackNotificationAnalytics(notification.id, dto.userId, dto.type, client_1.NotificationChannel.IN_APP);
    }
    async scheduleNotification(dto) {
        await this.prisma.scheduledNotification.create({
            data: {
                userId: dto.userId,
                type: dto.type,
                title: dto.title,
                message: dto.message,
                scheduledFor: new Date(dto.scheduledFor),
                data: dto.data,
                maxAttempts: dto.maxAttempts || 3,
                orderId: dto.orderId,
                productId: dto.productId,
                reviewId: dto.reviewId
            }
        });
    }
    async updateNotificationPreferences(userId, dto) {
        await this.prisma.notificationPreference.upsert({
            where: { userId },
            create: {
                userId,
                ...dto
            },
            update: dto
        });
    }
    async getUserPreferences(userId) {
        const preferences = await this.prisma.notificationPreference.findUnique({
            where: { userId }
        });
        return preferences || {
            emailEnabled: true,
            webPushEnabled: true,
            inAppEnabled: true,
            orderNotifications: true,
            paymentNotifications: true,
            reviewNotifications: true,
            marketingEmails: false,
            systemNotifications: true,
            reviewReceived: true,
            reviewResponses: true,
            reviewHelpfulVotes: true,
            reviewMilestones: true,
            reviewReminders: true,
            digestFrequency: client_1.DigestFrequency.WEEKLY,
            quietHoursEnabled: false,
            timezone: 'UTC'
        };
    }
    shouldSendNotification(type, preferences) {
        if (type.startsWith('ORDER_') && !preferences.orderNotifications)
            return false;
        if (type.startsWith('PAYMENT_') && !preferences.paymentNotifications)
            return false;
        if (type.startsWith('REVIEW_') && !preferences.reviewNotifications)
            return false;
        if (type === 'SYSTEM_NOTIFICATION' && !preferences.systemNotifications)
            return false;
        switch (type) {
            case client_1.NotificationType.REVIEW_RECEIVED:
                return preferences.reviewReceived;
            case client_1.NotificationType.REVIEW_RESPONSE_RECEIVED:
                return preferences.reviewResponses;
            case client_1.NotificationType.REVIEW_HELPFUL_VOTE:
                return preferences.reviewHelpfulVotes;
            case client_1.NotificationType.REVIEW_MILESTONE:
                return preferences.reviewMilestones;
            case client_1.NotificationType.REVIEW_PENDING_REMINDER:
                return preferences.reviewReminders;
            default:
                return true;
        }
    }
    isInQuietHours(preferences) {
        if (!preferences.quietHoursEnabled)
            return false;
        const now = new Date();
        const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        const start = preferences.quietHoursStart || '22:00';
        const end = preferences.quietHoursEnd || '08:00';
        if (start > end) {
            return currentTime >= start || currentTime <= end;
        }
        else {
            return currentTime >= start && currentTime <= end;
        }
    }
    getNextAvailableTime(preferences) {
        const now = new Date();
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        const endTime = preferences.quietHoursEnd || '08:00';
        const [hours, minutes] = endTime.split(':').map(Number);
        tomorrow.setHours(hours, minutes, 0, 0);
        return tomorrow;
    }
    async sendReviewReceivedNotification(review, lang = 'en') {
        await this.createNotification({
            userId: review.sellerId,
            type: client_1.NotificationType.REVIEW_RECEIVED,
            title: this.getTranslation('notifications.reviewReceived', lang),
            message: this.getTranslation('notifications.reviewReceivedMsg', lang, {
                rating: review.rating,
                productTitle: review.product?.title || 'Unknown Product',
                comment: review.comment?.substring(0, 100) + (review.comment?.length > 100 ? '...' : '')
            }),
            data: {
                reviewId: review.id,
                productId: review.productId,
                rating: review.rating,
                buyerName: review.buyer?.firstName + ' ' + review.buyer?.lastName
            },
            priority: client_1.NotificationPriority.HIGH,
            groupKey: `review_${review.productId}`
        });
    }
    async sendReviewResponseNotification(review, response, lang = 'en') {
        await this.createNotification({
            userId: review.buyerId,
            type: client_1.NotificationType.REVIEW_RESPONSE_RECEIVED,
            title: this.getTranslation('notifications.reviewResponse', lang),
            message: this.getTranslation('notifications.reviewResponseMsg', lang, {
                productTitle: review.product?.title || 'Unknown Product'
            }),
            data: {
                reviewId: review.id,
                responseId: response.id,
                productId: review.productId,
                sellerName: response.seller?.firstName + ' ' + response.seller?.lastName
            },
            priority: client_1.NotificationPriority.NORMAL,
            groupKey: `review_response_${review.id}`
        });
    }
    async sendReviewHelpfulNotification(review, lang = 'en') {
        await this.createNotification({
            userId: review.buyerId,
            type: client_1.NotificationType.REVIEW_HELPFUL_VOTE,
            title: this.getTranslation('notifications.reviewHelpful', lang),
            message: this.getTranslation('notifications.reviewHelpfulMsg', lang, {
                productTitle: review.product?.title || 'Unknown Product'
            }),
            data: {
                reviewId: review.id,
                productId: review.productId
            },
            priority: client_1.NotificationPriority.LOW,
            groupKey: `helpful_${review.id}`
        });
    }
    async sendReviewWeeklyDigest(dto, lang = 'en') {
        const endDate = dto.endDate ? new Date(dto.endDate) : new Date();
        const startDate = dto.startDate ? new Date(dto.startDate) : new Date(endDate.getTime() - 7 * 24 * 60 * 60 * 1000);
        const reviews = await this.prisma.review.findMany({
            where: {
                sellerId: dto.sellerId,
                createdAt: {
                    gte: startDate,
                    lte: endDate
                },
                status: 'PUBLISHED'
            },
            include: {
                product: { select: { title: true } },
                buyer: { select: { firstName: true, lastName: true } }
            }
        });
        if (reviews.length === 0 && !dto.forceGenerate) {
            return;
        }
        const averageRating = reviews.length > 0
            ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
            : 0;
        await this.createNotification({
            userId: dto.sellerId,
            type: client_1.NotificationType.REVIEW_WEEKLY_DIGEST,
            title: this.getTranslation('notifications.reviewWeeklyDigest', lang),
            message: this.getTranslation('notifications.reviewWeeklyDigestMsg', lang, {
                count: reviews.length,
                averageRating: averageRating.toFixed(1)
            }),
            data: {
                period: { startDate, endDate },
                reviewCount: reviews.length,
                averageRating,
                reviews: reviews.map(r => ({
                    id: r.id,
                    rating: r.rating,
                    productTitle: r.product?.title,
                    buyerName: r.buyer?.firstName + ' ' + r.buyer?.lastName,
                    comment: r.comment?.substring(0, 100)
                }))
            },
            priority: client_1.NotificationPriority.LOW,
            channel: client_1.NotificationChannel.EMAIL
        });
    }
    async sendWeeklyDigests() {
        const sellers = await this.prisma.user.findMany({
            where: {
                role: 'SELLER',
                isActive: true
            },
            include: {
                notificationPreferences: true
            }
        });
        for (const seller of sellers) {
            const preferences = seller.notificationPreferences;
            if (preferences?.digestFrequency === client_1.DigestFrequency.WEEKLY) {
                await this.sendReviewWeeklyDigest({
                    sellerId: seller.id,
                    frequency: client_1.DigestFrequency.WEEKLY
                });
            }
        }
    }
    async processScheduledNotifications() {
        const now = new Date();
        const scheduledNotifications = await this.prisma.scheduledNotification.findMany({
            where: {
                status: 'pending',
                scheduledFor: {
                    lte: now
                },
                OR: [
                    { nextAttemptAt: null },
                    { nextAttemptAt: { lte: now } }
                ]
            },
            take: 50
        });
        for (const scheduled of scheduledNotifications) {
            try {
                await this.createNotification({
                    userId: scheduled.userId,
                    type: scheduled.type,
                    title: scheduled.title,
                    message: scheduled.message,
                    data: scheduled.data,
                    orderId: scheduled.orderId || undefined,
                    productId: scheduled.productId || undefined
                });
                await this.prisma.scheduledNotification.update({
                    where: { id: scheduled.id },
                    data: {
                        status: 'sent',
                        processedAt: now
                    }
                });
            }
            catch (error) {
                console.error(`Error processing scheduled notification ${scheduled.id}:`, error);
                const newAttempts = scheduled.attempts + 1;
                if (newAttempts >= scheduled.maxAttempts) {
                    await this.prisma.scheduledNotification.update({
                        where: { id: scheduled.id },
                        data: {
                            status: 'failed',
                            attempts: newAttempts,
                            lastAttemptAt: now
                        }
                    });
                }
                else {
                    const nextAttempt = new Date(now.getTime() + Math.pow(2, newAttempts) * 60000);
                    await this.prisma.scheduledNotification.update({
                        where: { id: scheduled.id },
                        data: {
                            attempts: newAttempts,
                            lastAttemptAt: now,
                            nextAttemptAt: nextAttempt
                        }
                    });
                }
            }
        }
    }
    async trackEngagement(dto, userId) {
        const notification = await this.prisma.notification.findFirst({
            where: {
                id: dto.notificationId,
                userId
            }
        });
        if (!notification) {
            throw new common_1.NotFoundException('Notification not found');
        }
        const now = new Date();
        const updateData = {};
        switch (dto.action) {
            case 'read':
                if (!notification.isRead) {
                    updateData.isRead = true;
                    updateData.readAt = now;
                }
                break;
            case 'clicked':
                updateData.clickedAt = now;
                updateData.clickCount = notification.clickCount + 1;
                break;
        }
        if (Object.keys(updateData).length > 0) {
            await this.prisma.notification.update({
                where: { id: dto.notificationId },
                data: updateData
            });
        }
        await this.trackNotificationAnalytics(dto.notificationId, userId, notification.type, client_1.NotificationChannel.IN_APP, {
            action: dto.action,
            deviceType: dto.deviceType,
            platform: dto.platform,
            userAgent: dto.userAgent
        });
    }
    async trackNotificationAnalytics(notificationId, userId, type, channel, metadata) {
        await this.prisma.notificationAnalytics.create({
            data: {
                userId,
                notificationId,
                type,
                channel,
                sent: true,
                sentAt: new Date(),
                deviceType: metadata?.deviceType,
                platform: metadata?.platform,
                userAgent: metadata?.userAgent,
                delivered: channel === client_1.NotificationChannel.IN_APP,
                deliveredAt: channel === client_1.NotificationChannel.IN_APP ? new Date() : null,
                read: metadata?.action === 'read',
                readAt: metadata?.action === 'read' ? new Date() : null,
                clicked: metadata?.action === 'clicked',
                clickedAt: metadata?.action === 'clicked' ? new Date() : null
            }
        });
    }
    async getUserNotifications(userId, filters = {}) {
        const page = filters.page || 1;
        const limit = Math.min(filters.limit || 20, 100);
        const where = {
            userId,
            ...(filters.type && { type: filters.type }),
            ...(filters.priority && { priority: filters.priority }),
            ...(filters.channel && { channel: filters.channel }),
            ...(filters.isRead !== undefined && { isRead: filters.isRead }),
            ...(filters.groupKey && { groupKey: filters.groupKey }),
            ...(filters.startDate && filters.endDate && {
                createdAt: {
                    gte: new Date(filters.startDate),
                    lte: new Date(filters.endDate)
                }
            }),
            OR: [
                { expiresAt: null },
                { expiresAt: { gt: new Date() } }
            ]
        };
        const total = await this.prisma.notification.count({ where });
        const notifications = await this.prisma.notification.findMany({
            where,
            orderBy: [
                { priority: 'desc' },
                { createdAt: 'desc' }
            ],
            skip: (page - 1) * limit,
            take: limit
        });
        return {
            data: notifications,
            total,
            page,
            limit,
            unreadCount: await this.prisma.notification.count({
                where: { userId, isRead: false }
            })
        };
    }
    async sendOrderCreatedNotification(order, lang = 'en') {
        await this.createNotification({
            userId: order.buyerId,
            type: client_1.NotificationType.ORDER_CREATED,
            title: this.getTranslation('notifications.orderCreated', lang),
            message: this.getTranslation('notifications.orderCreatedMsg', lang, {
                orderNumber: order.orderNumber
            }),
            data: {
                orderId: order.id,
                orderNumber: order.orderNumber,
                totalAmount: order.totalAmount
            },
            orderId: order.id,
            priority: client_1.NotificationPriority.HIGH
        });
    }
    async sendOrderPaidNotification(order, lang = 'en') {
        await this.createNotification({
            userId: order.buyerId,
            type: client_1.NotificationType.ORDER_PAID,
            title: this.getTranslation('notifications.orderPaid', lang),
            message: this.getTranslation('notifications.orderPaidMsg', lang, {
                orderNumber: order.orderNumber
            }),
            data: {
                orderId: order.id,
                orderNumber: order.orderNumber,
                totalAmount: order.totalAmount
            },
            orderId: order.id,
            priority: client_1.NotificationPriority.HIGH
        });
        const sellerIds = [...new Set(order.items.map((item) => item.sellerId))];
        for (const currentSellerId of sellerIds) {
            const sellerItems = order.items.filter((item) => item.sellerId === currentSellerId);
            const sellerAmount = sellerItems.reduce((sum, item) => sum + item.price, 0);
            await this.createNotification({
                userId: currentSellerId,
                type: client_1.NotificationType.PRODUCT_SOLD,
                title: this.getTranslation('notifications.productSold', lang),
                message: this.getTranslation('notifications.productSoldMsg', lang, {
                    itemCount: sellerItems.length,
                    sellerAmount: sellerAmount.toFixed(2)
                }),
                data: {
                    orderId: order.id,
                    orderNumber: order.orderNumber,
                    sellerAmount,
                    itemCount: sellerItems.length,
                    items: sellerItems.map((item) => ({
                        productTitle: item.productTitle,
                        price: item.price,
                    }))
                },
                orderId: order.id,
                priority: client_1.NotificationPriority.HIGH
            });
        }
    }
    async sendOrderCompletedNotification(order, lang = 'en') {
        await this.createNotification({
            userId: order.buyerId,
            type: client_1.NotificationType.ORDER_COMPLETED,
            title: this.getTranslation('notifications.orderCompleted', lang),
            message: this.getTranslation('notifications.orderCompletedMsg', lang, {
                orderNumber: order.orderNumber
            }),
            data: {
                orderId: order.id,
                orderNumber: order.orderNumber,
                downloadUrl: `${process.env.FRONTEND_URL}/orders/${order.id}/downloads`
            },
            orderId: order.id,
            priority: client_1.NotificationPriority.HIGH
        });
    }
    async markAsRead(notificationId, userId) {
        await this.prisma.notification.updateMany({
            where: {
                id: notificationId,
                userId
            },
            data: {
                isRead: true,
                readAt: new Date()
            }
        });
    }
    async markAllAsRead(userId) {
        await this.prisma.notification.updateMany({
            where: {
                userId,
                isRead: false
            },
            data: {
                isRead: true,
                readAt: new Date()
            }
        });
    }
    async sendEmailNotification(notification) {
        const user = await this.prisma.user.findUnique({
            where: { id: notification.userId }
        });
        if (!user)
            return;
        let emailTemplate;
        let emailData = {
            userName: `${user.firstName} ${user.lastName}`,
            title: notification.title,
            message: notification.message
        };
        switch (notification.type) {
            case client_1.NotificationType.ORDER_CREATED:
                emailTemplate = 'order-created';
                emailData = {
                    ...emailData,
                    orderNumber: notification.data?.orderNumber,
                    totalAmount: notification.data?.totalAmount,
                    paymentUrl: `${process.env.FRONTEND_URL}/orders/${notification.data?.orderId}/pay`
                };
                break;
            case client_1.NotificationType.ORDER_PAID:
                emailTemplate = 'order-paid';
                emailData = {
                    ...emailData,
                    orderNumber: notification.data?.orderNumber,
                    totalAmount: notification.data?.totalAmount
                };
                break;
            case client_1.NotificationType.ORDER_COMPLETED:
                emailTemplate = 'order-completed';
                emailData = {
                    ...emailData,
                    orderNumber: notification.data?.orderNumber,
                    downloadUrl: notification.data?.downloadUrl
                };
                break;
            case client_1.NotificationType.PRODUCT_SOLD:
                emailTemplate = 'product-sold';
                emailData = {
                    ...emailData,
                    orderNumber: notification.data?.orderNumber,
                    sellerAmount: notification.data?.sellerAmount,
                    itemCount: notification.data?.itemCount,
                    items: notification.data?.items
                };
                break;
            case client_1.NotificationType.REVIEW_RECEIVED:
                emailTemplate = 'review-received';
                emailData = {
                    ...emailData,
                    rating: notification.data?.rating,
                    productTitle: notification.data?.productTitle,
                    buyerName: notification.data?.buyerName,
                    reviewUrl: `${process.env.FRONTEND_URL}/products/${notification.data?.productId}/reviews`
                };
                break;
            case client_1.NotificationType.REVIEW_RESPONSE_RECEIVED:
                emailTemplate = 'review-response';
                emailData = {
                    ...emailData,
                    productTitle: notification.data?.productTitle,
                    sellerName: notification.data?.sellerName,
                    reviewUrl: `${process.env.FRONTEND_URL}/products/${notification.data?.productId}/reviews`
                };
                break;
            case client_1.NotificationType.REVIEW_WEEKLY_DIGEST:
                emailTemplate = 'review-weekly-digest';
                emailData = {
                    ...emailData,
                    reviewCount: notification.data?.reviewCount,
                    averageRating: notification.data?.averageRating,
                    reviews: notification.data?.reviews,
                    dashboardUrl: `${process.env.FRONTEND_URL}/seller/dashboard/reviews`
                };
                break;
            case client_1.NotificationType.REVIEW_HELPFUL_VOTE:
                emailTemplate = 'review-helpful';
                emailData = {
                    ...emailData,
                    productTitle: notification.data?.productTitle,
                    reviewUrl: `${process.env.FRONTEND_URL}/products/${notification.data?.productId}/reviews`
                };
                break;
            case client_1.NotificationType.REVIEW_MILESTONE:
                emailTemplate = 'review-milestone';
                emailData = {
                    ...emailData,
                    milestone: notification.data?.milestone,
                    averageRating: notification.data?.averageRating,
                    dashboardUrl: `${process.env.FRONTEND_URL}/seller/dashboard/reviews`
                };
                break;
            default:
                emailTemplate = 'generic-notification';
        }
        try {
            await this.emailService.sendEmail({
                to: user.email,
                subject: notification.title,
                template: emailTemplate,
                data: emailData
            });
            await this.prisma.notification.update({
                where: { id: notification.id },
                data: {
                    emailSent: true,
                    sentAt: new Date()
                }
            });
            await this.trackNotificationAnalytics(notification.id, notification.userId, notification.type, client_1.NotificationChannel.EMAIL);
        }
        catch (error) {
            console.error(`Error sending email notification ${notification.id}:`, error);
        }
    }
    async getNotificationAnalytics(filters) {
        const where = {
            ...(filters.userId && { userId: filters.userId }),
            ...(filters.type && { type: filters.type }),
            ...(filters.channel && { channel: filters.channel }),
            ...(filters.startDate && filters.endDate && {
                sentAt: {
                    gte: new Date(filters.startDate),
                    lte: new Date(filters.endDate)
                }
            })
        };
        const groupBy = filters.groupBy || 'day';
        const totalSent = await this.prisma.notificationAnalytics.count({ where });
        const totalDelivered = await this.prisma.notificationAnalytics.count({
            where: { ...where, delivered: true }
        });
        const totalRead = await this.prisma.notificationAnalytics.count({
            where: { ...where, read: true }
        });
        const totalClicked = await this.prisma.notificationAnalytics.count({
            where: { ...where, clicked: true }
        });
        const deliveryRate = totalSent > 0 ? (totalDelivered / totalSent) * 100 : 0;
        const openRate = totalDelivered > 0 ? (totalRead / totalDelivered) * 100 : 0;
        const clickRate = totalDelivered > 0 ? (totalClicked / totalDelivered) * 100 : 0;
        let timeGrouping = {};
        if (groupBy === 'day') {
            const dailyStats = await this.prisma.$queryRaw `
        SELECT 
          DATE(sent_at) as date,
          COUNT(*) as sent,
          COUNT(CASE WHEN delivered = true THEN 1 END) as delivered,
          COUNT(CASE WHEN read = true THEN 1 END) as read,
          COUNT(CASE WHEN clicked = true THEN 1 END) as clicked
        FROM notification_analytics 
        WHERE ${filters.startDate ? `sent_at >= '${filters.startDate}'` : '1=1'}
          AND ${filters.endDate ? `sent_at <= '${filters.endDate}'` : '1=1'}
          ${filters.userId ? `AND user_id = '${filters.userId}'` : ''}
          ${filters.type ? `AND type = '${filters.type}'` : ''}
          ${filters.channel ? `AND channel = '${filters.channel}'` : ''}
        GROUP BY DATE(sent_at)
        ORDER BY date DESC
      `;
            timeGrouping = { daily: dailyStats };
        }
        const typeStats = await this.prisma.notificationAnalytics.groupBy({
            by: ['type'],
            where,
            _count: {
                _all: true
            }
        });
        const channelStats = await this.prisma.notificationAnalytics.groupBy({
            by: ['channel'],
            where,
            _count: {
                _all: true
            }
        });
        return {
            summary: {
                totalSent,
                totalDelivered,
                totalRead,
                totalClicked,
                deliveryRate: Math.round(deliveryRate * 100) / 100,
                openRate: Math.round(openRate * 100) / 100,
                clickRate: Math.round(clickRate * 100) / 100
            },
            timeGrouping,
            typeStats,
            channelStats
        };
    }
    async cleanupExpiredNotifications() {
        const now = new Date();
        await this.prisma.notification.updateMany({
            where: {
                expiresAt: { lt: now },
                isRead: false
            },
            data: {
                isRead: true,
                readAt: now
            }
        });
        const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        await this.prisma.notification.deleteMany({
            where: {
                createdAt: { lt: ninetyDaysAgo },
                isRead: true
            }
        });
        console.log('Expired notifications cleanup completed');
    }
    async sendReviewReminders() {
        const threeDaysAgo = new Date();
        threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
        const ordersWithoutReviews = await this.prisma.order.findMany({
            where: {
                status: 'COMPLETED',
                completedAt: {
                    gte: new Date(threeDaysAgo.getTime() - 24 * 60 * 60 * 1000),
                    lte: threeDaysAgo
                }
            },
            include: {
                items: {
                    include: {
                        product: true
                    }
                },
                buyer: true,
                reviews: true
            }
        });
        for (const order of ordersWithoutReviews) {
            const productIds = order.items.map(item => item.productId);
            const reviewedProductIds = order.reviews.map(review => review.productId);
            const unreviewed = productIds.filter(id => !reviewedProductIds.includes(id));
            if (unreviewed.length > 0) {
                const preferences = await this.getUserPreferences(order.buyerId);
                if (preferences.reviewReminders) {
                    for (const productId of unreviewed) {
                        const product = order.items.find(item => item.productId === productId)?.product;
                        await this.scheduleNotification({
                            userId: order.buyerId,
                            type: client_1.NotificationType.REVIEW_PENDING_REMINDER,
                            title: this.getTranslation('notifications.reviewReminder', 'en'),
                            message: this.getTranslation('notifications.reviewReminderMsg', 'en', {
                                productTitle: product?.title || 'Unknown Product'
                            }),
                            scheduledFor: new Date().toISOString(),
                            data: {
                                orderId: order.id,
                                productId,
                                productTitle: product?.title
                            }
                        });
                    }
                }
            }
        }
    }
    async checkReviewMilestones(sellerId) {
        const sellerRating = await this.prisma.sellerRating.findUnique({
            where: { sellerId }
        });
        if (!sellerRating)
            return;
        const milestones = [10, 25, 50, 100, 250, 500, 1000];
        const currentCount = sellerRating.totalReviews;
        const reachedMilestone = milestones.find(milestone => currentCount >= milestone && currentCount < milestone + 5);
        if (reachedMilestone) {
            await this.createNotification({
                userId: sellerId,
                type: client_1.NotificationType.REVIEW_MILESTONE,
                title: this.getTranslation('notifications.reviewMilestone', 'en'),
                message: this.getTranslation('notifications.reviewMilestoneMsg', 'en', {
                    milestone: reachedMilestone,
                    averageRating: sellerRating.averageRating.toFixed(1)
                }),
                data: {
                    milestone: reachedMilestone,
                    totalReviews: currentCount,
                    averageRating: sellerRating.averageRating
                },
                priority: client_1.NotificationPriority.HIGH
            });
        }
    }
    getTranslatedText(key, lang, args) {
        return this.getTranslation(key, lang, args);
    }
};
exports.NotificationService = NotificationService;
__decorate([
    (0, schedule_1.Cron)('0 9 * * 1'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], NotificationService.prototype, "sendWeeklyDigests", null);
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_MINUTE),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], NotificationService.prototype, "processScheduledNotifications", null);
__decorate([
    (0, schedule_1.Cron)('0 0 * * *'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], NotificationService.prototype, "cleanupExpiredNotifications", null);
exports.NotificationService = NotificationService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof email_service_1.EmailService !== "undefined" && email_service_1.EmailService) === "function" ? _b : Object, typeof (_c = typeof websocket_gateway_1.WebSocketGateway !== "undefined" && websocket_gateway_1.WebSocketGateway) === "function" ? _c : Object])
], NotificationService);


/***/ }),
/* 225 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EmailService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const nodemailer = __importStar(__webpack_require__(226));
let EmailService = EmailService_1 = class EmailService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(EmailService_1.name);
        this.createTransporter();
    }
    createTransporter() {
        const emailConfig = {
            host: this.configService.get('SMTP_HOST', 'smtp.gmail.com'),
            port: this.configService.get('SMTP_PORT', 587),
            secure: false,
            auth: {
                user: this.configService.get('SMTP_USER'),
                pass: this.configService.get('SMTP_PASS'),
            },
        };
        this.transporter = nodemailer.createTransport(emailConfig);
    }
    async sendEmail(emailData) {
        try {
            const htmlContent = this.generateEmailHTML(emailData.template, emailData.data);
            const mailOptions = {
                from: emailData.from || this.configService.get('SMTP_FROM', 'noreply@furnibles.com'),
                to: emailData.to,
                subject: emailData.subject,
                html: htmlContent,
            };
            const result = await this.transporter.sendMail(mailOptions);
            this.logger.log(`Email sent successfully to ${emailData.to}: ${result.messageId}`);
            return true;
        }
        catch (error) {
            this.logger.error(`Failed to send email to ${emailData.to}:`, error);
            return false;
        }
    }
    generateEmailHTML(template, data) {
        const templates = {
            'order-created': `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>¬°Orden Creada Exitosamente!</h2>
          <p>Hola ${data.userName},</p>
          <p>Tu orden <strong>${data.orderNumber}</strong> ha sido creada exitosamente.</p>
          <div style="background: #f5f5f5; padding: 20px; margin: 20px 0;">
            <h3>Detalles de la orden:</h3>
            <p><strong>N√∫mero de orden:</strong> ${data.orderNumber}</p>
            <p><strong>Total a pagar:</strong> ${data.totalAmount}</p>
          </div>
          <p>Para completar tu compra, haz clic en el siguiente enlace:</p>
          <a href="${data.paymentUrl}" style="background: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;">Proceder al Pago</a>
          <p>Si tienes alguna pregunta, no dudes en contactarnos.</p>
          <p>Saludos,<br>El equipo de Furnibles</p>
        </div>
      `,
            'order-paid': `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>¬°Pago Confirmado!</h2>
          <p>Hola ${data.userName},</p>
          <p>Tu pago por la orden <strong>${data.orderNumber}</strong> ha sido procesado exitosamente.</p>
          <div style="background: #d4edda; padding: 20px; margin: 20px 0; border-left: 4px solid #28a745;">
            <h3>‚úÖ Pago Confirmado</h3>
            <p><strong>Orden:</strong> ${data.orderNumber}</p>
            <p><strong>Total pagado:</strong> ${data.totalAmount}</p>
          </div>
          <p>Estamos preparando tus archivos para descarga. Te notificaremos cuando est√©n listos.</p>
          <p>Saludos,<br>El equipo de Furnibles</p>
        </div>
      `,
            'order-completed': `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>¬°Archivos Listos para Descarga!</h2>
          <p>Hola ${data.userName},</p>
          <p>Tu orden <strong>${data.orderNumber}</strong> est√° completa y tus archivos est√°n listos para descarga.</p>
          <div style="background: #d1ecf1; padding: 20px; margin: 20px 0; border-left: 4px solid #17a2b8;">
            <h3>üìÅ Descarga tus Archivos</h3>
            <p>Puedes descargar tus archivos haciendo clic en el siguiente enlace:</p>
            <a href="${data.downloadUrl}" style="background: #28a745; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;">Descargar Archivos</a>
          </div>
          <p><strong>Importante:</strong> Los enlaces de descarga son v√°lidos por 30 d√≠as y est√°n limitados a 5 descargas por archivo.</p>
          <p>¬°Gracias por tu compra!</p>
          <p>Saludos,<br>El equipo de Furnibles</p>
        </div>
      `,
            'product-sold': `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>¬°Nueva Venta Realizada! üéâ</h2>
          <p>Hola ${data.userName},</p>
          <p>¬°Felicitaciones! Has realizado una nueva venta.</p>
          <div style="background: #fff3cd; padding: 20px; margin: 20px 0; border-left: 4px solid #ffc107;">
            <h3>üí∞ Detalles de la Venta</h3>
            <p><strong>Orden:</strong> ${data.orderNumber}</p>
            <p><strong>Productos vendidos:</strong> ${data.itemCount}</p>
            <p><strong>Tu ganancia:</strong> ${data.sellerAmount}</p>
          </div>
          ${data.items ? `
            <h4>Productos vendidos:</h4>
            <ul>
              ${data.items.map(item => `<li>${item.productTitle} - ${item.price}</li>`).join('')}
            </ul>
          ` : ''}
          <p>El pago ser√° procesado seg√∫n nuestros t√©rminos y condiciones.</p>
          <p>¬°Sigue as√≠!</p>
          <p>Saludos,<br>El equipo de Furnibles</p>
        </div>
      `,
            'generic-notification': `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>${data.title}</h2>
          <p>Hola ${data.userName},</p>
          <div style="background: #f8f9fa; padding: 20px; margin: 20px 0; border-left: 4px solid #6c757d;">
            <p>${data.message}</p>
          </div>
          <p>Saludos,<br>El equipo de Furnibles</p>
        </div>
      `
        };
        return templates[template] || templates['generic-notification'];
    }
};
exports.EmailService = EmailService;
exports.EmailService = EmailService = EmailService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], EmailService);


/***/ }),
/* 226 */
/***/ ((module) => {

"use strict";
module.exports = require("nodemailer");

/***/ }),
/* 227 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var WebSocketGateway_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocketGateway = void 0;
const websockets_1 = __webpack_require__(228);
const socket_io_1 = __webpack_require__(229);
const common_1 = __webpack_require__(2);
const jwt_1 = __webpack_require__(13);
let WebSocketGateway = WebSocketGateway_1 = class WebSocketGateway {
    constructor(jwtService) {
        this.jwtService = jwtService;
        this.logger = new common_1.Logger(WebSocketGateway_1.name);
        this.userSockets = new Map();
    }
    async handleConnection(client) {
        try {
            const token = client.handshake.auth.token;
            const payload = this.jwtService.verify(token);
            const userId = payload.sub;
            this.userSockets.set(userId, client.id);
            client.data.userId = userId;
            client.join(`user:${userId}`);
            this.logger.log(`User ${userId} connected with socket ${client.id}`);
        }
        catch (error) {
            this.logger.error(`Connection rejected: ${error.message}`);
            client.disconnect();
        }
    }
    handleDisconnect(client) {
        const userId = client.data.userId;
        if (userId) {
            this.userSockets.delete(userId);
            this.logger.log(`User ${userId} disconnected`);
        }
    }
    handleJoinRoom(data, client) {
        client.join(data.room);
        this.logger.log(`Socket ${client.id} joined room: ${data.room}`);
    }
    handleLeaveRoom(data, client) {
        client.leave(data.room);
        this.logger.log(`Socket ${client.id} left room: ${data.room}`);
    }
    sendToUser(userId, event, data) {
        this.server.to(`user:${userId}`).emit(event, data);
    }
    sendToRoom(room, event, data) {
        this.server.to(room).emit(event, data);
    }
    broadcast(event, data) {
        this.server.emit(event, data);
    }
    getConnectedUsers() {
        return Array.from(this.userSockets.keys());
    }
    isUserConnected(userId) {
        return this.userSockets.has(userId);
    }
};
exports.WebSocketGateway = WebSocketGateway;
__decorate([
    (0, websockets_1.WebSocketServer)(),
    __metadata("design:type", typeof (_b = typeof socket_io_1.Server !== "undefined" && socket_io_1.Server) === "function" ? _b : Object)
], WebSocketGateway.prototype, "server", void 0);
__decorate([
    (0, websockets_1.SubscribeMessage)('join-room'),
    __param(0, (0, websockets_1.MessageBody)()),
    __param(1, (0, websockets_1.ConnectedSocket)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof socket_io_1.Socket !== "undefined" && socket_io_1.Socket) === "function" ? _c : Object]),
    __metadata("design:returntype", void 0)
], WebSocketGateway.prototype, "handleJoinRoom", null);
__decorate([
    (0, websockets_1.SubscribeMessage)('leave-room'),
    __param(0, (0, websockets_1.MessageBody)()),
    __param(1, (0, websockets_1.ConnectedSocket)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_d = typeof socket_io_1.Socket !== "undefined" && socket_io_1.Socket) === "function" ? _d : Object]),
    __metadata("design:returntype", void 0)
], WebSocketGateway.prototype, "handleLeaveRoom", null);
exports.WebSocketGateway = WebSocketGateway = WebSocketGateway_1 = __decorate([
    (0, websockets_1.WebSocketGateway)({
        cors: {
            origin: process.env.FRONTEND_URL || 'https://probable-barnacle-65wp9jg5qwxc5w6-3000.app.github.dev',
            credentials: true,
        },
        namespace: '/notifications'
    }),
    __metadata("design:paramtypes", [typeof (_a = typeof jwt_1.JwtService !== "undefined" && jwt_1.JwtService) === "function" ? _a : Object])
], WebSocketGateway);


/***/ }),
/* 228 */
/***/ ((module) => {

"use strict";
module.exports = require("@nestjs/websockets");

/***/ }),
/* 229 */
/***/ ((module) => {

"use strict";
module.exports = require("socket.io");

/***/ }),
/* 230 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReviewsService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const notifications_service_1 = __webpack_require__(224);
let ReviewsService = class ReviewsService {
    constructor(prisma, notificationService) {
        this.prisma = prisma;
        this.notificationService = notificationService;
    }
    async createReview(userId, createReviewDto) {
        const { orderId, productId, rating, title, comment, pros, cons, images } = createReviewDto;
        const order = await this.prisma.order.findFirst({
            where: {
                id: orderId,
                buyerId: userId,
                status: 'COMPLETED'
            },
            include: {
                items: {
                    where: { productId }
                }
            }
        });
        if (!order) {
            throw new common_1.NotFoundException('order.notFound');
        }
        if (!order.items.length) {
            throw new common_1.BadRequestException('product.notInOrder');
        }
        const existingReview = await this.prisma.review.findUnique({
            where: {
                orderId_productId_buyerId: {
                    orderId,
                    productId,
                    buyerId: userId
                }
            }
        });
        if (existingReview) {
            throw new common_1.ConflictException('review.alreadyExists');
        }
        const product = await this.prisma.product.findUnique({
            where: { id: productId },
            include: {
                seller: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        sellerProfile: {
                            select: {
                                storeName: true
                            }
                        }
                    }
                }
            }
        });
        if (!product) {
            throw new common_1.NotFoundException('product.notFound');
        }
        if (images && images.length > 0) {
            if (images.length > 5) {
                throw new common_1.BadRequestException('images.tooMany');
            }
            const validImages = await this.prisma.file.findMany({
                where: {
                    id: { in: images },
                    uploadedById: userId,
                    type: 'REVIEW_IMAGE',
                    status: 'ACTIVE'
                }
            });
            if (validImages.length !== images.length) {
                throw new common_1.BadRequestException('images.invalid');
            }
        }
        const review = await this.prisma.$transaction(async (tx) => {
            const newReview = await tx.review.create({
                data: {
                    orderId,
                    productId,
                    buyerId: userId,
                    sellerId: product.sellerId,
                    rating,
                    title,
                    comment,
                    pros,
                    cons,
                    status: 'PENDING_MODERATION'
                },
                include: {
                    buyer: {
                        select: {
                            firstName: true,
                            lastName: true
                        }
                    },
                    product: {
                        select: {
                            title: true
                        }
                    }
                }
            });
            if (images && images.length > 0) {
                await tx.reviewImage.createMany({
                    data: images.map((imageId, index) => ({
                        reviewId: newReview.id,
                        fileId: imageId,
                        order: index
                    }))
                });
            }
            return newReview;
        });
        const moderatedReview = await this.autoModerateReview(review.id);
        if (moderatedReview?.status === 'PUBLISHED') {
            try {
                await this.notificationService.sendReviewReceivedNotification({
                    id: review.id,
                    sellerId: product.sellerId,
                    rating: review.rating,
                    comment: review.comment,
                    product: { title: product.title },
                    buyer: review.buyer
                });
            }
            catch (error) {
                console.error('Error sending review notification:', error);
            }
        }
        await this.updateProductRating(productId);
        try {
            await this.notificationService.checkReviewMilestones(product.sellerId);
        }
        catch (error) {
            console.error('Error checking review milestones:', error);
        }
        return this.findOne(review.id);
    }
    async findAll(filters) {
        const { productId, sellerId, rating, status, sortBy, page, limit } = filters;
        const where = {
            status: status || 'PUBLISHED'
        };
        if (productId)
            where.productId = productId;
        if (sellerId)
            where.sellerId = sellerId;
        if (rating)
            where.rating = rating;
        let orderBy = {};
        switch (sortBy) {
            case 'newest':
                orderBy = { createdAt: 'desc' };
                break;
            case 'oldest':
                orderBy = { createdAt: 'asc' };
                break;
            case 'highest':
                orderBy = { rating: 'desc' };
                break;
            case 'lowest':
                orderBy = { rating: 'asc' };
                break;
            case 'helpful':
                orderBy = { helpfulCount: 'desc' };
                break;
            default:
                orderBy = { createdAt: 'desc' };
        }
        const skip = (page - 1) * limit;
        const [reviews, totalCount] = await Promise.all([
            this.prisma.review.findMany({
                where,
                include: {
                    buyer: {
                        select: {
                            firstName: true,
                            lastName: true,
                            avatar: true,
                            buyerProfile: {
                                select: {
                                    totalReviews: true
                                }
                            }
                        }
                    },
                    product: {
                        select: {
                            title: true,
                            slug: true,
                            thumbnailFileIds: true
                        }
                    },
                    images: {
                        include: {
                            file: {
                                select: {
                                    url: true,
                                    filename: true
                                }
                            }
                        },
                        orderBy: { order: 'asc' }
                    },
                    response: {
                        include: {
                            seller: {
                                select: {
                                    firstName: true,
                                    lastName: true,
                                    sellerProfile: {
                                        select: {
                                            storeName: true,
                                            avatar: true
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                orderBy,
                skip,
                take: limit
            }),
            this.prisma.review.count({ where })
        ]);
        return {
            reviews,
            pagination: {
                currentPage: page,
                totalPages: Math.ceil(totalCount / limit),
                totalItems: totalCount,
                itemsPerPage: limit
            }
        };
    }
    async findOne(id) {
        const review = await this.prisma.review.findUnique({
            where: { id },
            include: {
                buyer: {
                    select: {
                        firstName: true,
                        lastName: true,
                        avatar: true,
                        buyerProfile: {
                            select: {
                                totalReviews: true
                            }
                        }
                    }
                },
                product: {
                    select: {
                        title: true,
                        slug: true,
                        thumbnailFileIds: true
                    }
                },
                images: {
                    include: {
                        file: {
                            select: {
                                url: true,
                                filename: true
                            }
                        }
                    },
                    orderBy: { order: 'asc' }
                },
                response: {
                    include: {
                        seller: {
                            select: {
                                firstName: true,
                                lastName: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                        avatar: true
                                    }
                                }
                            }
                        }
                    }
                },
                votes: {
                    select: {
                        vote: true,
                        userId: true
                    }
                }
            }
        });
        if (!review) {
            throw new common_1.NotFoundException('review.notFound');
        }
        return review;
    }
    async updateReview(userId, reviewId, updateDto) {
        const review = await this.prisma.review.findUnique({
            where: { id: reviewId },
            include: {
                product: {
                    select: {
                        title: true,
                        sellerId: true
                    }
                },
                buyer: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true
                    }
                }
            }
        });
        if (!review) {
            throw new common_1.NotFoundException('review.notFound');
        }
        if (review.buyerId !== userId) {
            throw new common_1.ForbiddenException('review.notOwner');
        }
        if (!['PENDING_MODERATION', 'PUBLISHED'].includes(review.status)) {
            throw new common_1.BadRequestException('review.cannotEdit');
        }
        const updateData = {};
        if (updateDto.rating !== undefined)
            updateData.rating = updateDto.rating;
        if (updateDto.title !== undefined)
            updateData.title = updateDto.title;
        if (updateDto.comment !== undefined)
            updateData.comment = updateDto.comment;
        if (updateDto.pros !== undefined)
            updateData.pros = updateDto.pros;
        if (updateDto.cons !== undefined)
            updateData.cons = updateDto.cons;
        const updatedReview = await this.prisma.review.update({
            where: { id: reviewId },
            data: {
                ...updateData,
                status: 'PENDING_MODERATION'
            }
        });
        const moderatedReview = await this.autoModerateReview(reviewId);
        if (moderatedReview?.status === 'PUBLISHED' && review.status !== 'PUBLISHED') {
            try {
                await this.notificationService.sendReviewReceivedNotification({
                    id: updatedReview.id,
                    sellerId: review.product.sellerId,
                    rating: updatedReview.rating,
                    comment: updatedReview.comment,
                    product: { title: review.product.title },
                    buyer: review.buyer
                });
            }
            catch (error) {
                console.error('Error sending review update notification:', error);
            }
        }
        await this.updateProductRating(review.productId);
        return this.findOne(reviewId);
    }
    async createResponse(sellerId, reviewId, responseDto) {
        const review = await this.prisma.review.findUnique({
            where: { id: reviewId },
            include: {
                product: {
                    select: {
                        title: true
                    }
                },
                buyer: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true
                    }
                }
            }
        });
        if (!review) {
            throw new common_1.NotFoundException('review.notFound');
        }
        if (review.sellerId !== sellerId) {
            throw new common_1.ForbiddenException('review.notYourProduct');
        }
        if (review.status !== 'PUBLISHED') {
            throw new common_1.BadRequestException('review.notPublished');
        }
        const existingResponse = await this.prisma.reviewResponse.findUnique({
            where: { reviewId }
        });
        if (existingResponse) {
            throw new common_1.ConflictException('response.alreadyExists');
        }
        const response = await this.prisma.reviewResponse.create({
            data: {
                reviewId,
                sellerId,
                comment: responseDto.comment
            },
            include: {
                seller: {
                    select: {
                        firstName: true,
                        lastName: true,
                        sellerProfile: {
                            select: {
                                storeName: true,
                                avatar: true
                            }
                        }
                    }
                }
            }
        });
        try {
            await this.notificationService.sendReviewResponseNotification({
                id: reviewId,
                buyerId: review.buyerId,
                productId: review.productId,
                product: review.product,
                buyer: review.buyer
            }, {
                id: response.id,
                seller: response.seller
            });
        }
        catch (error) {
            console.error('Error sending review response notification:', error);
        }
        return response;
    }
    async voteReview(userId, reviewId, voteDto) {
        const review = await this.prisma.review.findUnique({
            where: { id: reviewId },
            include: {
                product: {
                    select: {
                        title: true
                    }
                },
                buyer: {
                    select: {
                        id: true
                    }
                }
            }
        });
        if (!review) {
            throw new common_1.NotFoundException('review.notFound');
        }
        if (review.status !== 'PUBLISHED') {
            throw new common_1.BadRequestException('review.notPublished');
        }
        if (review.buyerId === userId) {
            throw new common_1.BadRequestException('vote.ownReview');
        }
        const existingVote = await this.prisma.reviewVote.findUnique({
            where: {
                reviewId_userId: {
                    reviewId,
                    userId
                }
            }
        });
        const isNewHelpfulVote = !existingVote && voteDto.vote === 'HELPFUL';
        await this.prisma.$transaction(async (tx) => {
            await tx.reviewVote.upsert({
                where: {
                    reviewId_userId: {
                        reviewId,
                        userId
                    }
                },
                update: {
                    vote: voteDto.vote
                },
                create: {
                    reviewId,
                    userId,
                    vote: voteDto.vote
                }
            });
            const votes = await tx.reviewVote.findMany({
                where: { reviewId }
            });
            const helpfulCount = votes.filter(v => v.vote === 'HELPFUL').length;
            const notHelpfulCount = votes.filter(v => v.vote === 'NOT_HELPFUL').length;
            await tx.review.update({
                where: { id: reviewId },
                data: {
                    helpfulCount,
                    notHelpfulCount
                }
            });
        });
        if (isNewHelpfulVote) {
            try {
                await this.notificationService.sendReviewHelpfulNotification({
                    id: reviewId,
                    buyerId: review.buyer.id,
                    productId: review.productId,
                    product: review.product
                });
            }
            catch (error) {
                console.error('Error sending review helpful notification:', error);
            }
        }
        return { success: true };
    }
    async reportReview(userId, reviewId, reportDto) {
        const review = await this.prisma.review.findUnique({
            where: { id: reviewId },
            include: {
                buyer: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true
                    }
                },
                product: {
                    select: {
                        title: true
                    }
                }
            }
        });
        if (!review) {
            throw new common_1.NotFoundException('review.notFound');
        }
        const existingReport = await this.prisma.reviewReport.findFirst({
            where: {
                reviewId,
                userId
            }
        });
        if (existingReport) {
            throw new common_1.ConflictException('report.alreadyExists');
        }
        const report = await this.prisma.reviewReport.create({
            data: {
                reviewId,
                userId,
                reason: reportDto.reason,
                details: reportDto.details
            }
        });
        const reportCount = await this.prisma.reviewReport.count({
            where: { reviewId }
        });
        if (reportCount >= 3) {
            await this.prisma.review.update({
                where: { id: reviewId },
                data: { status: 'FLAGGED' }
            });
            try {
                await this.notificationService.createNotification({
                    userId: review.buyerId,
                    type: 'REVIEW_FLAGGED',
                    title: 'Review Under Review',
                    message: `Your review for "${review.product.title}" has been flagged for review due to multiple reports.`,
                    data: {
                        reviewId: review.id,
                        productTitle: review.product.title,
                        reason: 'Multiple reports received'
                    }
                });
            }
            catch (error) {
                console.error('Error sending review flagged notification:', error);
            }
        }
        return report;
    }
    async moderateReview(adminId, reviewId, moderateDto) {
        const review = await this.prisma.review.findUnique({
            where: { id: reviewId },
            include: {
                buyer: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true
                    }
                },
                product: {
                    select: {
                        title: true,
                        sellerId: true
                    }
                }
            }
        });
        if (!review) {
            throw new common_1.NotFoundException('review.notFound');
        }
        const previousStatus = review.status;
        const updatedReview = await this.prisma.review.update({
            where: { id: reviewId },
            data: {
                status: moderateDto.status,
                moderatedBy: adminId,
                moderatedAt: new Date(),
                moderationReason: moderateDto.reason
            }
        });
        try {
            if (moderateDto.status === 'PUBLISHED' && previousStatus !== 'PUBLISHED') {
                await this.notificationService.sendReviewReceivedNotification({
                    id: review.id,
                    sellerId: review.product.sellerId,
                    rating: review.rating,
                    comment: review.comment,
                    product: review.product,
                    buyer: review.buyer
                });
            }
            else if (moderateDto.status === 'REMOVED') {
                await this.notificationService.createNotification({
                    userId: review.buyerId,
                    type: 'REVIEW_REMOVED',
                    title: 'Review Removed',
                    message: `Your review for "${review.product.title}" has been removed by our moderation team.`,
                    data: {
                        reviewId: review.id,
                        productTitle: review.product.title,
                        reason: moderateDto.reason || 'Violated community guidelines'
                    }
                });
            }
        }
        catch (error) {
            console.error('Error sending moderation notification:', error);
        }
        if (['PUBLISHED', 'REMOVED'].includes(moderateDto.status)) {
            await this.updateProductRating(review.productId);
            if (moderateDto.status === 'PUBLISHED') {
                try {
                    await this.notificationService.checkReviewMilestones(review.product.sellerId);
                }
                catch (error) {
                    console.error('Error checking review milestones:', error);
                }
            }
        }
        return updatedReview;
    }
    async getProductStats(productId) {
        const rating = await this.prisma.productRating.findUnique({
            where: { productId }
        });
        return rating || {
            totalReviews: 0,
            averageRating: 0,
            oneStar: 0,
            twoStar: 0,
            threeStar: 0,
            fourStar: 0,
            fiveStar: 0,
            recommendationRate: 0
        };
    }
    async getSellerStats(sellerId) {
        const rating = await this.prisma.sellerRating.findUnique({
            where: { sellerId }
        });
        return rating || {
            totalReviews: 0,
            averageRating: 0,
            oneStar: 0,
            twoStar: 0,
            threeStar: 0,
            fourStar: 0,
            fiveStar: 0
        };
    }
    async getAdminStats() {
        const [totalReviews, pendingReviews, flaggedReviews, reportedReviews, averageRating] = await Promise.all([
            this.prisma.review.count(),
            this.prisma.review.count({ where: { status: 'PENDING_MODERATION' } }),
            this.prisma.review.count({ where: { status: 'FLAGGED' } }),
            this.prisma.reviewReport.count({ where: { resolved: false } }),
            this.prisma.review.aggregate({
                where: { status: 'PUBLISHED' },
                _avg: { rating: true }
            })
        ]);
        return {
            totalReviews,
            pendingReviews,
            flaggedReviews,
            reportedReviews,
            averageRating: Math.round((averageRating._avg.rating || 0) * 100) / 100
        };
    }
    async getPendingReviews(page = 1, limit = 20) {
        const skip = (page - 1) * limit;
        const [reviews, totalCount] = await Promise.all([
            this.prisma.review.findMany({
                where: {
                    status: { in: ['PENDING_MODERATION', 'FLAGGED'] }
                },
                include: {
                    buyer: {
                        select: {
                            firstName: true,
                            lastName: true,
                            email: true
                        }
                    },
                    product: {
                        select: {
                            title: true,
                            slug: true
                        }
                    },
                    reports: {
                        where: { resolved: false },
                        include: {
                            user: {
                                select: {
                                    firstName: true,
                                    lastName: true
                                }
                            }
                        }
                    }
                },
                orderBy: { createdAt: 'desc' },
                skip,
                take: limit
            }),
            this.prisma.review.count({
                where: {
                    status: { in: ['PENDING_MODERATION', 'FLAGGED'] }
                }
            })
        ]);
        return {
            reviews,
            pagination: {
                currentPage: page,
                totalPages: Math.ceil(totalCount / limit),
                totalItems: totalCount,
                itemsPerPage: limit
            }
        };
    }
    async deleteReview(reviewId) {
        const review = await this.prisma.review.findUnique({
            where: { id: reviewId },
            include: {
                buyer: {
                    select: {
                        id: true
                    }
                },
                product: {
                    select: {
                        title: true,
                        sellerId: true
                    }
                }
            }
        });
        if (!review) {
            throw new common_1.NotFoundException('review.notFound');
        }
        await this.prisma.$transaction(async (tx) => {
            await tx.reviewImage.deleteMany({ where: { reviewId } });
            await tx.reviewVote.deleteMany({ where: { reviewId } });
            await tx.reviewReport.deleteMany({ where: { reviewId } });
            await tx.reviewResponse.deleteMany({ where: { reviewId } });
            await tx.review.delete({ where: { id: reviewId } });
        });
        try {
            await this.notificationService.createNotification({
                userId: review.buyer.id,
                type: 'REVIEW_REMOVED',
                title: 'Review Deleted',
                message: `Your review for "${review.product.title}" has been deleted.`,
                data: {
                    reviewId: review.id,
                    productTitle: review.product.title,
                    reason: 'Review deleted by administrator'
                }
            });
        }
        catch (error) {
            console.error('Error sending review deletion notification:', error);
        }
        await this.updateProductRating(review.productId);
        return { success: true };
    }
    async autoModerateReview(reviewId) {
        const review = await this.prisma.review.findUnique({
            where: { id: reviewId }
        });
        if (!review)
            return null;
        const suspiciousWords = ['spam', 'fake', 'scam'];
        const hasSpam = suspiciousWords.some(word => review.comment.toLowerCase().includes(word.toLowerCase()));
        let newStatus = 'PUBLISHED';
        if (hasSpam || review.rating === 1) {
            newStatus = 'FLAGGED';
        }
        const updatedReview = await this.prisma.review.update({
            where: { id: reviewId },
            data: { status: newStatus }
        });
        return updatedReview;
    }
    async updateProductRating(productId) {
        const reviews = await this.prisma.review.findMany({
            where: {
                productId,
                status: 'PUBLISHED'
            },
            select: {
                rating: true
            }
        });
        if (!reviews.length) {
            await this.prisma.productRating.upsert({
                where: { productId },
                update: {
                    totalReviews: 0,
                    averageRating: 0,
                    oneStar: 0,
                    twoStar: 0,
                    threeStar: 0,
                    fourStar: 0,
                    fiveStar: 0,
                    recommendationRate: 0
                },
                create: {
                    productId,
                    totalReviews: 0,
                    averageRating: 0,
                    oneStar: 0,
                    twoStar: 0,
                    threeStar: 0,
                    fourStar: 0,
                    fiveStar: 0,
                    recommendationRate: 0
                }
            });
            await this.prisma.product.update({
                where: { id: productId },
                data: { rating: 0, reviewCount: 0 }
            });
            return;
        }
        const totalReviews = reviews.length;
        const averageRating = reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews;
        const distribution = {
            oneStar: reviews.filter(r => r.rating === 1).length,
            twoStar: reviews.filter(r => r.rating === 2).length,
            threeStar: reviews.filter(r => r.rating === 3).length,
            fourStar: reviews.filter(r => r.rating === 4).length,
            fiveStar: reviews.filter(r => r.rating === 5).length,
        };
        const recommendationRate = ((distribution.fourStar + distribution.fiveStar) / totalReviews) * 100;
        await this.prisma.productRating.upsert({
            where: { productId },
            update: {
                totalReviews,
                averageRating: Math.round(averageRating * 100) / 100,
                ...distribution,
                recommendationRate: Math.round(recommendationRate * 100) / 100
            },
            create: {
                productId,
                totalReviews,
                averageRating: Math.round(averageRating * 100) / 100,
                ...distribution,
                recommendationRate: Math.round(recommendationRate * 100) / 100
            }
        });
        await this.prisma.product.update({
            where: { id: productId },
            data: {
                rating: Math.round(averageRating * 100) / 100,
                reviewCount: totalReviews
            }
        });
        await this.updateSellerRating(productId);
    }
    async updateSellerRating(productId) {
        const product = await this.prisma.product.findUnique({
            where: { id: productId },
            select: { sellerId: true }
        });
        if (!product)
            return;
        const sellerReviews = await this.prisma.review.findMany({
            where: {
                sellerId: product.sellerId,
                status: 'PUBLISHED'
            },
            select: { rating: true }
        });
        if (!sellerReviews.length) {
            await this.prisma.sellerRating.upsert({
                where: { sellerId: product.sellerId },
                update: {
                    totalReviews: 0,
                    averageRating: 0,
                    oneStar: 0,
                    twoStar: 0,
                    threeStar: 0,
                    fourStar: 0,
                    fiveStar: 0
                },
                create: {
                    sellerId: product.sellerId,
                    totalReviews: 0,
                    averageRating: 0,
                    oneStar: 0,
                    twoStar: 0,
                    threeStar: 0,
                    fourStar: 0,
                    fiveStar: 0
                }
            });
            await this.prisma.sellerProfile.update({
                where: { userId: product.sellerId },
                data: { rating: 0, totalReviews: 0 }
            });
            return;
        }
        const totalReviews = sellerReviews.length;
        const averageRating = sellerReviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews;
        const distribution = {
            oneStar: sellerReviews.filter(r => r.rating === 1).length,
            twoStar: sellerReviews.filter(r => r.rating === 2).length,
            threeStar: sellerReviews.filter(r => r.rating === 3).length,
            fourStar: sellerReviews.filter(r => r.rating === 4).length,
            fiveStar: sellerReviews.filter(r => r.rating === 5).length,
        };
        await this.prisma.sellerRating.upsert({
            where: { sellerId: product.sellerId },
            update: {
                totalReviews,
                averageRating: Math.round(averageRating * 100) / 100,
                ...distribution
            },
            create: {
                sellerId: product.sellerId,
                totalReviews,
                averageRating: Math.round(averageRating * 100) / 100,
                ...distribution
            }
        });
        await this.prisma.sellerProfile.update({
            where: { userId: product.sellerId },
            data: {
                rating: Math.round(averageRating * 100) / 100,
                totalReviews
            }
        });
        try {
            const previousRating = await this.prisma.sellerProfile.findUnique({
                where: { userId: product.sellerId },
                select: { rating: true }
            });
            const newRating = Math.round(averageRating * 100) / 100;
            if (previousRating && newRating >= previousRating.rating + 0.5) {
                await this.notificationService.createNotification({
                    userId: product.sellerId,
                    type: 'SELLER_RATING_IMPROVED',
                    title: 'Your Rating Has Improved!',
                    message: `Great news! Your seller rating has improved to ${newRating} stars based on recent reviews.`,
                    data: {
                        previousRating: previousRating.rating,
                        newRating,
                        totalReviews,
                        improvement: newRating - previousRating.rating
                    }
                });
            }
        }
        catch (error) {
            console.error('Error sending rating improvement notification:', error);
        }
    }
    async scheduleReviewReminders(orderId, buyerId) {
        try {
            const order = await this.prisma.order.findUnique({
                where: { id: orderId },
                include: {
                    items: {
                        include: {
                            product: {
                                select: {
                                    id: true,
                                    title: true
                                }
                            }
                        }
                    }
                }
            });
            if (!order)
                return;
            const reminderDate = new Date();
            reminderDate.setDate(reminderDate.getDate() + 3);
            for (const item of order.items) {
                const existingReview = await this.prisma.review.findFirst({
                    where: {
                        orderId: order.id,
                        productId: item.productId,
                        buyerId: buyerId
                    }
                });
                if (!existingReview) {
                    await this.notificationService.scheduleNotification({
                        userId: buyerId,
                        type: 'REVIEW_PENDING_REMINDER',
                        title: 'Don\'t forget to review your purchase!',
                        message: `How was your experience with "${item.product.title}"? Your review helps other buyers.`,
                        scheduledFor: reminderDate.toISOString(),
                        data: {
                            orderId: order.id,
                            productId: item.productId,
                            productTitle: item.product.title
                        },
                        orderId: order.id,
                        productId: item.productId
                    });
                }
            }
        }
        catch (error) {
            console.error('Error scheduling review reminders:', error);
        }
    }
    async checkProductRatingMilestone(productId) {
        try {
            const productRating = await this.prisma.productRating.findUnique({
                where: { productId },
                include: {
                    product: {
                        select: {
                            title: true,
                            sellerId: true
                        }
                    }
                }
            });
            if (!productRating)
                return;
            const milestones = [
                { reviews: 10, rating: 4.5 },
                { reviews: 25, rating: 4.0 },
                { reviews: 50, rating: 4.5 },
                { reviews: 100, rating: 4.0 }
            ];
            const milestone = milestones.find(m => productRating.totalReviews >= m.reviews &&
                productRating.averageRating >= m.rating &&
                productRating.totalReviews < m.reviews + 5);
            if (milestone) {
                await this.notificationService.createNotification({
                    userId: productRating.product.sellerId,
                    type: 'PRODUCT_RATING_MILESTONE',
                    title: 'Product Milestone Reached!',
                    message: `"${productRating.product.title}" has reached ${milestone.reviews} reviews with ${productRating.averageRating} stars!`,
                    data: {
                        productId,
                        productTitle: productRating.product.title,
                        milestone: milestone.reviews,
                        averageRating: productRating.averageRating,
                        totalReviews: productRating.totalReviews
                    }
                });
            }
        }
        catch (error) {
            console.error('Error checking product rating milestone:', error);
        }
    }
};
exports.ReviewsService = ReviewsService;
exports.ReviewsService = ReviewsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof notifications_service_1.NotificationService !== "undefined" && notifications_service_1.NotificationService) === "function" ? _b : Object])
], ReviewsService);


/***/ }),
/* 231 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateOrderDto = exports.FeeBreakdownItemDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const class_validator_2 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
class FeeBreakdownItemDto {
}
exports.FeeBreakdownItemDto = FeeBreakdownItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Tipo de comisi√≥n',
        example: 'PLATFORM_FEE',
        enum: ['PLATFORM_FEE', 'STRIPE_FEE', 'SELLER_AMOUNT', 'TAX']
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FeeBreakdownItemDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Descripci√≥n de la comisi√≥n',
        example: 'Platform commission (10%)'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FeeBreakdownItemDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Monto de la comisi√≥n',
        example: 2.50
    }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], FeeBreakdownItemDto.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Porcentaje aplicado (opcional)',
        example: 10,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], FeeBreakdownItemDto.prototype, "percentage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID del vendedor (opcional)',
        example: 'seller_123',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FeeBreakdownItemDto.prototype, "sellerId", void 0);
class CreateOrderDto {
}
exports.CreateOrderDto = CreateOrderDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Email del comprador para env√≠o de archivos',
        example: 'buyer@example.com'
    }),
    (0, class_validator_1.IsEmail)(),
    __metadata("design:type", String)
], CreateOrderDto.prototype, "buyerEmail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Datos de facturaci√≥n (opcional)',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", Object)
], CreateOrderDto.prototype, "billingData", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Metadata adicional (opcional)',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", typeof (_a = typeof Record !== "undefined" && Record) === "function" ? _a : Object)
], CreateOrderDto.prototype, "metadata", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Desglose detallado de comisiones y tarifas',
        type: [FeeBreakdownItemDto],
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_2.IsArray)(),
    (0, class_validator_2.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeBreakdownItemDto),
    __metadata("design:type", Array)
], CreateOrderDto.prototype, "feeBreakdown", void 0);


/***/ }),
/* 232 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrderResponseDto = exports.OrderItemResponseDto = void 0;
const swagger_1 = __webpack_require__(4);
const client_1 = __webpack_require__(11);
class OrderItemResponseDto {
}
exports.OrderItemResponseDto = OrderItemResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderItemResponseDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderItemResponseDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderItemResponseDto.prototype, "productTitle", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderItemResponseDto.prototype, "productSlug", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderItemResponseDto.prototype, "price", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderItemResponseDto.prototype, "quantity", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderItemResponseDto.prototype, "sellerName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderItemResponseDto.prototype, "storeName", void 0);
class OrderResponseDto {
}
exports.OrderResponseDto = OrderResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderResponseDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderResponseDto.prototype, "orderNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_a = typeof client_1.OrderStatus !== "undefined" && client_1.OrderStatus) === "function" ? _a : Object)
], OrderResponseDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderResponseDto.prototype, "subtotal", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderResponseDto.prototype, "platformFeeRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderResponseDto.prototype, "platformFee", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderResponseDto.prototype, "totalAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderResponseDto.prototype, "sellerAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderResponseDto.prototype, "buyerEmail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderResponseDto.prototype, "paymentIntentId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], OrderResponseDto.prototype, "paymentStatus", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [OrderItemResponseDto] }),
    __metadata("design:type", Array)
], OrderResponseDto.prototype, "items", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Object)
], OrderResponseDto.prototype, "buyer", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], OrderResponseDto.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_c = typeof Date !== "undefined" && Date) === "function" ? _c : Object)
], OrderResponseDto.prototype, "paidAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_d = typeof Date !== "undefined" && Date) === "function" ? _d : Object)
], OrderResponseDto.prototype, "completedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Object)
], OrderResponseDto.prototype, "feeBreakdown", void 0);


/***/ }),
/* 233 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaginatedOrdersDto = void 0;
const swagger_1 = __webpack_require__(4);
const order_response_dto_1 = __webpack_require__(232);
class PaginatedOrdersDto {
}
exports.PaginatedOrdersDto = PaginatedOrdersDto;
__decorate([
    (0, swagger_1.ApiProperty)({ type: [order_response_dto_1.OrderResponseDto] }),
    __metadata("design:type", Array)
], PaginatedOrdersDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedOrdersDto.prototype, "total", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedOrdersDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedOrdersDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], PaginatedOrdersDto.prototype, "totalPages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], PaginatedOrdersDto.prototype, "hasNext", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], PaginatedOrdersDto.prototype, "hasPrev", void 0);


/***/ }),
/* 234 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrderFiltersDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const client_1 = __webpack_require__(11);
const class_transformer_1 = __webpack_require__(40);
class OrderFiltersDto {
    constructor() {
        this.sortBy = 'createdAt';
        this.sortOrder = 'desc';
        this.page = 1;
        this.limit = 10;
    }
}
exports.OrderFiltersDto = OrderFiltersDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filtrar por estado de orden',
        enum: client_1.OrderStatus,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.OrderStatus),
    __metadata("design:type", typeof (_a = typeof client_1.OrderStatus !== "undefined" && client_1.OrderStatus) === "function" ? _a : Object)
], OrderFiltersDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filtrar desde fecha (ISO string)',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], OrderFiltersDto.prototype, "fromDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filtrar hasta fecha (ISO string)',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], OrderFiltersDto.prototype, "toDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Buscar por n√∫mero de orden o email',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], OrderFiltersDto.prototype, "search", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Campo por el cual ordenar',
        enum: ['createdAt', 'updatedAt', 'totalAmount', 'status', 'orderNumber'],
        default: 'createdAt',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], OrderFiltersDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Direcci√≥n del ordenamiento',
        enum: ['asc', 'desc'],
        default: 'desc',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], OrderFiltersDto.prototype, "sortOrder", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'P√°gina',
        default: 1,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], OrderFiltersDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Elementos por p√°gina',
        default: 10,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], OrderFiltersDto.prototype, "limit", void 0);


/***/ }),
/* 235 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationModule = void 0;
const common_1 = __webpack_require__(2);
const schedule_1 = __webpack_require__(8);
const notifications_controller_1 = __webpack_require__(236);
const notifications_service_1 = __webpack_require__(224);
const prisma_module_1 = __webpack_require__(9);
const email_module_1 = __webpack_require__(238);
const websocket_module_1 = __webpack_require__(239);
let NotificationModule = class NotificationModule {
};
exports.NotificationModule = NotificationModule;
exports.NotificationModule = NotificationModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            email_module_1.EmailModule,
            websocket_module_1.WebSocketModule,
            schedule_1.ScheduleModule.forRoot()
        ],
        controllers: [notifications_controller_1.NotificationsController],
        providers: [notifications_service_1.NotificationService],
        exports: [notifications_service_1.NotificationService],
    })
], NotificationModule);


/***/ }),
/* 236 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const notifications_service_1 = __webpack_require__(224);
const notification_dto_1 = __webpack_require__(237);
const client_1 = __webpack_require__(11);
let NotificationsController = class NotificationsController {
    constructor(notificationService) {
        this.notificationService = notificationService;
    }
    async getUserNotifications(req, filters) {
        const userId = req.user.sub;
        return await this.notificationService.getUserNotifications(userId, filters);
    }
    async markAsRead(notificationId, req) {
        const userId = req.user.sub;
        await this.notificationService.markAsRead(notificationId, userId);
        return { message: 'Notification marked as read' };
    }
    async markAllAsRead(req) {
        const userId = req.user.sub;
        await this.notificationService.markAllAsRead(userId);
        return { message: 'All notifications marked as read' };
    }
    async getNotificationPreferences(req) {
        const userId = req.user.sub;
        const preferences = await this.notificationService.getUserPreferences(userId);
        return preferences;
    }
    async updateNotificationPreferences(req, dto) {
        const userId = req.user.sub;
        await this.notificationService.updateNotificationPreferences(userId, dto);
        return { message: 'Notification preferences updated successfully' };
    }
    async trackEngagement(req, dto) {
        const userId = req.user.sub;
        await this.notificationService.trackEngagement(dto, userId);
        return { message: 'Engagement tracked successfully' };
    }
    async scheduleNotification(req, dto) {
        const currentUserId = req.user.sub;
        const userRole = req.user.role;
        if (userRole !== client_1.UserRole.ADMIN && dto.userId !== currentUserId) {
            throw new common_1.ForbiddenException('You can only schedule notifications for yourself');
        }
        await this.notificationService.scheduleNotification(dto);
        return { message: 'Notification scheduled successfully' };
    }
    async sendReviewDigest(req, dto) {
        const currentUserId = req.user.sub;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER && dto.sellerId !== currentUserId) {
            throw new common_1.ForbiddenException('You can only request your own review digest');
        }
        await this.notificationService.sendReviewWeeklyDigest(dto);
        return { message: 'Review digest sent successfully' };
    }
    async getNotificationAnalytics(req, filters) {
        const userId = req.user.sub;
        const userRole = req.user.role;
        if (userRole !== client_1.UserRole.ADMIN) {
            filters.userId = userId;
        }
        return await this.notificationService.getNotificationAnalytics(filters);
    }
    async getNotification(notificationId, req) {
        const userId = req.user.sub;
        const notifications = await this.notificationService.getUserNotifications(userId, {
            page: 1,
            limit: 1
        });
        const notification = notifications.data.find(n => n.id === notificationId);
        if (!notification) {
            throw new common_1.NotFoundException('Notification not found');
        }
        return notification;
    }
    async getReviewNotifications(req, page, limit) {
        const userId = req.user.sub;
        const filters = {
            page: page || 1,
            limit: Math.min(limit || 20, 100)
        };
        const reviewTypes = [
            'REVIEW_RECEIVED',
            'REVIEW_RESPONSE_RECEIVED',
            'REVIEW_HELPFUL_VOTE',
            'REVIEW_WEEKLY_DIGEST',
            'REVIEW_FOLLOW_UP',
            'REVIEW_MILESTONE',
            'REVIEW_PENDING_REMINDER'
        ];
        const allNotifications = await this.notificationService.getUserNotifications(userId, filters);
        const reviewNotifications = allNotifications.data.filter(notification => reviewTypes.includes(notification.type));
        return {
            ...allNotifications,
            data: reviewNotifications,
            total: reviewNotifications.length
        };
    }
    async sendReviewReminders(req) {
        await this.notificationService.sendReviewReminders();
        return { message: 'Review reminders sent successfully' };
    }
    async createManualNotification(dto) {
        await this.notificationService.createNotification(dto);
        return { message: 'Notification created successfully' };
    }
    async getGlobalAnalytics(filters) {
        return await this.notificationService.getNotificationAnalytics(filters);
    }
    async getEngagementMetrics() {
        return await this.notificationService.getNotificationAnalytics({
            groupBy: 'type'
        });
    }
    async getDigestStats() {
        return await this.notificationService.getNotificationAnalytics({
            type: 'REVIEW_WEEKLY_DIGEST',
            groupBy: 'week'
        });
    }
    async forceWeeklyDigests() {
        await this.notificationService.sendWeeklyDigests();
        return { message: 'Weekly digests sent to all eligible sellers' };
    }
    async cleanupExpiredNotifications() {
        await this.notificationService.cleanupExpiredNotifications();
        return { message: 'Expired notifications cleaned up successfully' };
    }
    async getDigestConfig(req) {
        const userId = req.user.sub;
        const preferences = await this.notificationService.getUserPreferences(userId);
        return {
            digestFrequency: preferences.digestFrequency ?? null,
            digestDay: preferences.digestDay ?? null,
            digestTime: preferences.digestTime ?? null,
            timezone: preferences.timezone ?? null
        };
    }
    async sendTestNotification(req, body) {
        const targetUserId = body.userId || req.user.sub;
        await this.notificationService.createNotification({
            userId: targetUserId,
            type: body.type || 'SYSTEM_NOTIFICATION',
            title: 'Test Notification',
            message: body.message || 'This is a test notification from the system',
            data: {
                test: true,
                sentAt: new Date().toISOString(),
                sentBy: req.user.sub
            }
        });
        return { message: 'Test notification sent successfully' };
    }
    async getSystemHealth() {
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const analytics = await this.notificationService.getNotificationAnalytics({
            startDate: thirtyDaysAgo.toISOString(),
            endDate: new Date().toISOString(),
            groupBy: 'day'
        });
        return {
            status: 'healthy',
            uptime: process.uptime(),
            lastMonthSummary: analytics.summary,
            timestamp: new Date().toISOString()
        };
    }
};
exports.NotificationsController = NotificationsController;
__decorate([
    (0, common_1.Get)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get user notifications with advanced filters' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Notifications retrieved successfully',
        type: [notification_dto_1.NotificationResponseDto]
    }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number, description: 'Page number' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Items per page' }),
    (0, swagger_1.ApiQuery)({ name: 'type', required: false, description: 'Filter by notification type' }),
    (0, swagger_1.ApiQuery)({ name: 'priority', required: false, description: 'Filter by priority' }),
    (0, swagger_1.ApiQuery)({ name: 'channel', required: false, description: 'Filter by channel' }),
    (0, swagger_1.ApiQuery)({ name: 'isRead', required: false, type: Boolean, description: 'Filter by read status' }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date filter (ISO string)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date filter (ISO string)' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_b = typeof notification_dto_1.FilterNotificationsDto !== "undefined" && notification_dto_1.FilterNotificationsDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getUserNotifications", null);
__decorate([
    (0, common_1.Put)(':id/read'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Mark notification as read' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Notification ID' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Notification marked as read'
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "markAsRead", null);
__decorate([
    (0, common_1.Put)('mark-all-read'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Mark all notifications as read' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'All notifications marked as read'
    }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "markAllAsRead", null);
__decorate([
    (0, common_1.Get)('preferences'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get user notification preferences' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Notification preferences retrieved successfully',
        type: notification_dto_1.NotificationPreferencesResponseDto
    }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getNotificationPreferences", null);
__decorate([
    (0, common_1.Put)('preferences'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update user notification preferences' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Notification preferences updated successfully'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof notification_dto_1.UpdateNotificationPreferencesDto !== "undefined" && notification_dto_1.UpdateNotificationPreferencesDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "updateNotificationPreferences", null);
__decorate([
    (0, common_1.Post)('track-engagement'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Track notification engagement (read, click, dismiss)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Engagement tracked successfully'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_d = typeof notification_dto_1.TrackEngagementDto !== "undefined" && notification_dto_1.TrackEngagementDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "trackEngagement", null);
__decorate([
    (0, common_1.Post)('schedule'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN, client_1.UserRole.SELLER),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Schedule a notification for later delivery' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'Notification scheduled successfully'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_e = typeof notification_dto_1.CreateScheduledNotificationDto !== "undefined" && notification_dto_1.CreateScheduledNotificationDto) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "scheduleNotification", null);
__decorate([
    (0, common_1.Post)('review-digest'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Send manual review digest for seller' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Review digest sent successfully'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_f = typeof notification_dto_1.SendReviewDigestDto !== "undefined" && notification_dto_1.SendReviewDigestDto) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "sendReviewDigest", null);
__decorate([
    (0, common_1.Get)('analytics'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get notification analytics and engagement metrics' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Analytics retrieved successfully'
    }),
    (0, swagger_1.ApiQuery)({ name: 'type', required: false, description: 'Filter by notification type' }),
    (0, swagger_1.ApiQuery)({ name: 'channel', required: false, description: 'Filter by notification channel' }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date filter' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date filter' }),
    (0, swagger_1.ApiQuery)({ name: 'groupBy', required: false, description: 'Group by: day, week, month, type, channel' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_g = typeof notification_dto_1.NotificationAnalyticsDto !== "undefined" && notification_dto_1.NotificationAnalyticsDto) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getNotificationAnalytics", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get specific notification by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Notification ID' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Notification retrieved successfully',
        type: notification_dto_1.NotificationResponseDto
    }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getNotification", null);
__decorate([
    (0, common_1.Get)('reviews/all'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all review-related notifications' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Review notifications retrieved successfully'
    }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Query)('page')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Number, Number]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getReviewNotifications", null);
__decorate([
    (0, common_1.Post)('reviews/send-reminders'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Manually trigger review reminders (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Review reminders sent successfully'
    }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "sendReviewReminders", null);
__decorate([
    (0, common_1.Post)('admin/create'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create manual notification (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'Notification created successfully'
    }),
    __param(0, (0, common_1.Body)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_h = typeof notification_dto_1.CreateNotificationDto !== "undefined" && notification_dto_1.CreateNotificationDto) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "createManualNotification", null);
__decorate([
    (0, common_1.Get)('admin/global-analytics'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get global notification analytics (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Global analytics retrieved successfully'
    }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date filter' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date filter' }),
    (0, swagger_1.ApiQuery)({ name: 'groupBy', required: false, description: 'Group by period' }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_j = typeof notification_dto_1.NotificationAnalyticsDto !== "undefined" && notification_dto_1.NotificationAnalyticsDto) === "function" ? _j : Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getGlobalAnalytics", null);
__decorate([
    (0, common_1.Get)('admin/engagement-metrics'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get engagement metrics by notification type (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Engagement metrics retrieved successfully'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getEngagementMetrics", null);
__decorate([
    (0, common_1.Get)('admin/digest-stats'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get review digest statistics (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Digest statistics retrieved successfully'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getDigestStats", null);
__decorate([
    (0, common_1.Post)('admin/force-weekly-digests'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Force send weekly digests to all eligible sellers (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Weekly digests sent successfully'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "forceWeeklyDigests", null);
__decorate([
    (0, common_1.Post)('admin/cleanup-expired'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Manually cleanup expired notifications (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Expired notifications cleaned up successfully'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "cleanupExpiredNotifications", null);
__decorate([
    (0, common_1.Get)('digest/config'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get user digest configuration (Sellers only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Digest configuration retrieved successfully'
    }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getDigestConfig", null);
__decorate([
    (0, common_1.Post)('test/send'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Send test notification (Admin only - Development)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Test notification sent successfully'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "sendTestNotification", null);
__decorate([
    (0, common_1.Get)('admin/health'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get notification system health status (Admin only)' }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'System health retrieved successfully'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NotificationsController.prototype, "getSystemHealth", null);
exports.NotificationsController = NotificationsController = __decorate([
    (0, swagger_1.ApiTags)('Notifications'),
    (0, common_1.Controller)('notifications'),
    __metadata("design:paramtypes", [typeof (_a = typeof notifications_service_1.NotificationService !== "undefined" && notifications_service_1.NotificationService) === "function" ? _a : Object])
], NotificationsController);


/***/ }),
/* 237 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrackEngagementDto = exports.NotificationPreferencesResponseDto = exports.NotificationResponseDto = exports.NotificationAnalyticsDto = exports.SendReviewDigestDto = exports.FilterNotificationsDto = exports.UpdateNotificationPreferencesDto = exports.CreateScheduledNotificationDto = exports.CreateNotificationDto = void 0;
const swagger_1 = __webpack_require__(4);
const client_1 = __webpack_require__(11);
const class_validator_1 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
class CreateNotificationDto {
}
exports.CreateNotificationDto = CreateNotificationDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.NotificationType }),
    (0, class_validator_1.IsEnum)(client_1.NotificationType),
    __metadata("design:type", typeof (_a = typeof client_1.NotificationType !== "undefined" && client_1.NotificationType) === "function" ? _a : Object)
], CreateNotificationDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", typeof (_b = typeof Record !== "undefined" && Record) === "function" ? _b : Object)
], CreateNotificationDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.NotificationPriority, default: client_1.NotificationPriority.NORMAL }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.NotificationPriority),
    __metadata("design:type", typeof (_c = typeof client_1.NotificationPriority !== "undefined" && client_1.NotificationPriority) === "function" ? _c : Object)
], CreateNotificationDto.prototype, "priority", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.NotificationChannel }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.NotificationChannel),
    __metadata("design:type", typeof (_d = typeof client_1.NotificationChannel !== "undefined" && client_1.NotificationChannel) === "function" ? _d : Object)
], CreateNotificationDto.prototype, "channel", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "groupKey", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "expiresAt", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "reviewId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateNotificationDto.prototype, "productId", void 0);
class CreateScheduledNotificationDto {
}
exports.CreateScheduledNotificationDto = CreateScheduledNotificationDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateScheduledNotificationDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.NotificationType }),
    (0, class_validator_1.IsEnum)(client_1.NotificationType),
    __metadata("design:type", typeof (_e = typeof client_1.NotificationType !== "undefined" && client_1.NotificationType) === "function" ? _e : Object)
], CreateScheduledNotificationDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateScheduledNotificationDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateScheduledNotificationDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], CreateScheduledNotificationDto.prototype, "scheduledFor", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", typeof (_f = typeof Record !== "undefined" && Record) === "function" ? _f : Object)
], CreateScheduledNotificationDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: 3 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(5),
    __metadata("design:type", Number)
], CreateScheduledNotificationDto.prototype, "maxAttempts", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateScheduledNotificationDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateScheduledNotificationDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateScheduledNotificationDto.prototype, "reviewId", void 0);
class UpdateNotificationPreferencesDto {
}
exports.UpdateNotificationPreferencesDto = UpdateNotificationPreferencesDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "emailEnabled", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "webPushEnabled", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "inAppEnabled", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "orderNotifications", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "paymentNotifications", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "reviewNotifications", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "marketingEmails", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "systemNotifications", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "reviewReceived", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "reviewResponses", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "reviewHelpfulVotes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "reviewMilestones", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "reviewReminders", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.DigestFrequency, default: client_1.DigestFrequency.WEEKLY }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.DigestFrequency),
    __metadata("design:type", typeof (_g = typeof client_1.DigestFrequency !== "undefined" && client_1.DigestFrequency) === "function" ? _g : Object)
], UpdateNotificationPreferencesDto.prototype, "digestFrequency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ minimum: 1, maximum: 7 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(7),
    __metadata("design:type", Number)
], UpdateNotificationPreferencesDto.prototype, "digestDay", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ pattern: '^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Matches)(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, {
        message: 'digestTime must be in HH:MM format'
    }),
    __metadata("design:type", String)
], UpdateNotificationPreferencesDto.prototype, "digestTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], UpdateNotificationPreferencesDto.prototype, "quietHoursEnabled", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ pattern: '^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Matches)(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, {
        message: 'quietHoursStart must be in HH:MM format'
    }),
    __metadata("design:type", String)
], UpdateNotificationPreferencesDto.prototype, "quietHoursStart", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ pattern: '^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Matches)(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, {
        message: 'quietHoursEnd must be in HH:MM format'
    }),
    __metadata("design:type", String)
], UpdateNotificationPreferencesDto.prototype, "quietHoursEnd", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateNotificationPreferencesDto.prototype, "timezone", void 0);
class FilterNotificationsDto {
    constructor() {
        this.page = 1;
        this.limit = 20;
    }
}
exports.FilterNotificationsDto = FilterNotificationsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FilterNotificationsDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.NotificationType }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.NotificationType),
    __metadata("design:type", typeof (_h = typeof client_1.NotificationType !== "undefined" && client_1.NotificationType) === "function" ? _h : Object)
], FilterNotificationsDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.NotificationChannel }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.NotificationChannel),
    __metadata("design:type", typeof (_j = typeof client_1.NotificationChannel !== "undefined" && client_1.NotificationChannel) === "function" ? _j : Object)
], FilterNotificationsDto.prototype, "channel", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.NotificationPriority }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.NotificationPriority),
    __metadata("design:type", typeof (_k = typeof client_1.NotificationPriority !== "undefined" && client_1.NotificationPriority) === "function" ? _k : Object)
], FilterNotificationsDto.prototype, "priority", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true'),
    __metadata("design:type", Boolean)
], FilterNotificationsDto.prototype, "isRead", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], FilterNotificationsDto.prototype, "groupKey", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: 1 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], FilterNotificationsDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: 20 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(100),
    __metadata("design:type", Number)
], FilterNotificationsDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], FilterNotificationsDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], FilterNotificationsDto.prototype, "endDate", void 0);
class SendReviewDigestDto {
}
exports.SendReviewDigestDto = SendReviewDigestDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendReviewDigestDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.DigestFrequency, default: client_1.DigestFrequency.WEEKLY }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.DigestFrequency),
    __metadata("design:type", typeof (_l = typeof client_1.DigestFrequency !== "undefined" && client_1.DigestFrequency) === "function" ? _l : Object)
], SendReviewDigestDto.prototype, "frequency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], SendReviewDigestDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], SendReviewDigestDto.prototype, "endDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SendReviewDigestDto.prototype, "forceGenerate", void 0);
class NotificationAnalyticsDto {
}
exports.NotificationAnalyticsDto = NotificationAnalyticsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.NotificationType }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.NotificationType),
    __metadata("design:type", typeof (_m = typeof client_1.NotificationType !== "undefined" && client_1.NotificationType) === "function" ? _m : Object)
], NotificationAnalyticsDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: client_1.NotificationChannel }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.NotificationChannel),
    __metadata("design:type", typeof (_o = typeof client_1.NotificationChannel !== "undefined" && client_1.NotificationChannel) === "function" ? _o : Object)
], NotificationAnalyticsDto.prototype, "channel", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], NotificationAnalyticsDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], NotificationAnalyticsDto.prototype, "endDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationAnalyticsDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ default: 'day' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], NotificationAnalyticsDto.prototype, "groupBy", void 0);
class NotificationResponseDto {
}
exports.NotificationResponseDto = NotificationResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationResponseDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.NotificationType }),
    __metadata("design:type", typeof (_p = typeof client_1.NotificationType !== "undefined" && client_1.NotificationType) === "function" ? _p : Object)
], NotificationResponseDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationResponseDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationResponseDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_q = typeof Record !== "undefined" && Record) === "function" ? _q : Object)
], NotificationResponseDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationResponseDto.prototype, "isRead", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_r = typeof Date !== "undefined" && Date) === "function" ? _r : Object)
], NotificationResponseDto.prototype, "readAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_s = typeof Date !== "undefined" && Date) === "function" ? _s : Object)
], NotificationResponseDto.prototype, "sentAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationResponseDto.prototype, "emailSent", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationResponseDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_t = typeof Date !== "undefined" && Date) === "function" ? _t : Object)
], NotificationResponseDto.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.NotificationPriority }),
    __metadata("design:type", typeof (_u = typeof client_1.NotificationPriority !== "undefined" && client_1.NotificationPriority) === "function" ? _u : Object)
], NotificationResponseDto.prototype, "priority", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.NotificationChannel }),
    __metadata("design:type", typeof (_v = typeof client_1.NotificationChannel !== "undefined" && client_1.NotificationChannel) === "function" ? _v : Object)
], NotificationResponseDto.prototype, "channel", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationResponseDto.prototype, "groupKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_w = typeof Date !== "undefined" && Date) === "function" ? _w : Object)
], NotificationResponseDto.prototype, "expiresAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_x = typeof Date !== "undefined" && Date) === "function" ? _x : Object)
], NotificationResponseDto.prototype, "clickedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], NotificationResponseDto.prototype, "clickCount", void 0);
class NotificationPreferencesResponseDto {
}
exports.NotificationPreferencesResponseDto = NotificationPreferencesResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationPreferencesResponseDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationPreferencesResponseDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "emailEnabled", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "webPushEnabled", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "inAppEnabled", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "orderNotifications", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "paymentNotifications", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "reviewNotifications", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "marketingEmails", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "systemNotifications", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "reviewReceived", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "reviewResponses", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "reviewHelpfulVotes", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "reviewMilestones", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "reviewReminders", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: client_1.DigestFrequency }),
    __metadata("design:type", typeof (_y = typeof client_1.DigestFrequency !== "undefined" && client_1.DigestFrequency) === "function" ? _y : Object)
], NotificationPreferencesResponseDto.prototype, "digestFrequency", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], NotificationPreferencesResponseDto.prototype, "digestDay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationPreferencesResponseDto.prototype, "digestTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], NotificationPreferencesResponseDto.prototype, "quietHoursEnabled", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationPreferencesResponseDto.prototype, "quietHoursStart", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationPreferencesResponseDto.prototype, "quietHoursEnd", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], NotificationPreferencesResponseDto.prototype, "timezone", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_z = typeof Date !== "undefined" && Date) === "function" ? _z : Object)
], NotificationPreferencesResponseDto.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_0 = typeof Date !== "undefined" && Date) === "function" ? _0 : Object)
], NotificationPreferencesResponseDto.prototype, "updatedAt", void 0);
class TrackEngagementDto {
}
exports.TrackEngagementDto = TrackEngagementDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], TrackEngagementDto.prototype, "notificationId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: ['read', 'clicked', 'dismissed'] }),
    (0, class_validator_1.IsEnum)(['read', 'clicked', 'dismissed']),
    __metadata("design:type", String)
], TrackEngagementDto.prototype, "action", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], TrackEngagementDto.prototype, "deviceType", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], TrackEngagementDto.prototype, "platform", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], TrackEngagementDto.prototype, "userAgent", void 0);


/***/ }),
/* 238 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmailModule = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const email_service_1 = __webpack_require__(225);
let EmailModule = class EmailModule {
};
exports.EmailModule = EmailModule;
exports.EmailModule = EmailModule = __decorate([
    (0, common_1.Module)({
        imports: [config_1.ConfigModule],
        providers: [email_service_1.EmailService],
        exports: [email_service_1.EmailService],
    })
], EmailModule);


/***/ }),
/* 239 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocketModule = void 0;
const common_1 = __webpack_require__(2);
const jwt_1 = __webpack_require__(13);
const config_1 = __webpack_require__(3);
const websocket_gateway_1 = __webpack_require__(227);
let WebSocketModule = class WebSocketModule {
};
exports.WebSocketModule = WebSocketModule;
exports.WebSocketModule = WebSocketModule = __decorate([
    (0, common_1.Module)({
        imports: [
            jwt_1.JwtModule.registerAsync({
                imports: [config_1.ConfigModule],
                useFactory: async (configService) => ({
                    secret: configService.get('JWT_SECRET'),
                    signOptions: {
                        expiresIn: configService.get('JWT_EXPIRES_IN', '24h'),
                    },
                }),
                inject: [config_1.ConfigService],
            }),
        ],
        providers: [websocket_gateway_1.WebSocketGateway],
        exports: [websocket_gateway_1.WebSocketGateway],
    })
], WebSocketModule);


/***/ }),
/* 240 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckoutModule = void 0;
const common_1 = __webpack_require__(2);
const checkout_controller_1 = __webpack_require__(241);
const checkout_service_1 = __webpack_require__(242);
const prisma_module_1 = __webpack_require__(9);
const cart_module_1 = __webpack_require__(211);
const orders_module_1 = __webpack_require__(221);
const stripe_module_1 = __webpack_require__(246);
let CheckoutModule = class CheckoutModule {
};
exports.CheckoutModule = CheckoutModule;
exports.CheckoutModule = CheckoutModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            cart_module_1.CartModule,
            orders_module_1.OrdersModule,
            stripe_module_1.StripeModule
        ],
        controllers: [checkout_controller_1.CheckoutController],
        providers: [checkout_service_1.CheckoutService],
        exports: [checkout_service_1.CheckoutService],
    })
], CheckoutModule);


/***/ }),
/* 241 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckoutController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const checkout_service_1 = __webpack_require__(242);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const checkout_dto_1 = __webpack_require__(245);
const client_1 = __webpack_require__(11);
let CheckoutController = class CheckoutController {
    constructor(checkoutService) {
        this.checkoutService = checkoutService;
    }
    async createCheckoutSession(req, dto) {
        return this.checkoutService.createCheckoutSession(req.user.id, dto);
    }
    async getCheckoutDetails(req, orderId) {
        return this.checkoutService.getCheckoutDetails(orderId, req.user.id);
    }
    async reactivateCheckout(req, orderId) {
        return this.checkoutService.reactivateCheckout(orderId, req.user.id);
    }
    async cancelCheckoutSession(req, orderId) {
        return this.checkoutService.cancelCheckoutSession(orderId, req.user.id);
    }
    async getCheckoutAnalytics(req) {
        return this.checkoutService.getCheckoutAnalytics();
    }
};
exports.CheckoutController = CheckoutController;
__decorate([
    (0, common_1.Post)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Iniciar proceso de checkout',
        description: 'Crea una sesi√≥n de Stripe Checkout para procesar el pago de los productos en el carrito.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Sesi√≥n de checkout creada exitosamente',
        type: checkout_dto_1.CheckoutResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Carrito vac√≠o o productos inv√°lidos'
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Solo compradores pueden realizar checkout'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_b = typeof checkout_dto_1.CheckoutDto !== "undefined" && checkout_dto_1.CheckoutDto) === "function" ? _b : Object]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], CheckoutController.prototype, "createCheckoutSession", null);
__decorate([
    (0, common_1.Get)('orders/:orderId'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener detalles de checkout',
        description: 'Retorna los detalles de una orden en proceso de checkout.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'orderId',
        description: 'ID de la orden'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Detalles obtenidos exitosamente',
        type: checkout_dto_1.CheckoutDetailsDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Orden no encontrada'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Param)('orderId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], CheckoutController.prototype, "getCheckoutDetails", null);
__decorate([
    (0, common_1.Post)('orders/:orderId/reactivate'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Reactivar checkout',
        description: 'Reactiva una sesi√≥n de checkout para una orden pendiente.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'orderId',
        description: 'ID de la orden'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Checkout reactivado exitosamente',
        type: checkout_dto_1.CheckoutResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Orden no se puede reactivar o ha expirado'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Param)('orderId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], CheckoutController.prototype, "reactivateCheckout", null);
__decorate([
    (0, common_1.Delete)('orders/:orderId'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Cancelar checkout',
        description: 'Cancela una sesi√≥n de checkout activa.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'orderId',
        description: 'ID de la orden'
    }),
    (0, swagger_1.ApiResponse)({
        status: 204,
        description: 'Checkout cancelado exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Orden no se puede cancelar'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Param)('orderId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], CheckoutController.prototype, "cancelCheckoutSession", null);
__decorate([
    (0, common_1.Get)('analytics'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Analytics de checkout (Admin)',
        description: 'Estad√≠sticas de conversi√≥n y checkout para administradores.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Analytics obtenidos exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Solo administradores pueden ver analytics'
    }),
    __param(0, (0, common_1.Request)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], CheckoutController.prototype, "getCheckoutAnalytics", null);
exports.CheckoutController = CheckoutController = __decorate([
    (0, swagger_1.ApiTags)('Checkout'),
    (0, common_1.Controller)('checkout'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof checkout_service_1.CheckoutService !== "undefined" && checkout_service_1.CheckoutService) === "function" ? _a : Object])
], CheckoutController);


/***/ }),
/* 242 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckoutService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const cart_service_1 = __webpack_require__(213);
const orders_service_1 = __webpack_require__(223);
const stripe_service_1 = __webpack_require__(243);
let CheckoutService = class CheckoutService {
    constructor(prisma, cartService, ordersService, stripeService) {
        this.prisma = prisma;
        this.cartService = cartService;
        this.ordersService = ordersService;
        this.stripeService = stripeService;
    }
    async createCheckoutSession(userId, dto) {
        const cart = await this.cartService.getCart(userId);
        if (cart.items.length === 0) {
            throw new common_1.BadRequestException('El carrito est√° vac√≠o');
        }
        let itemsToCheckout = cart.items;
        if (dto.productIds && dto.productIds.length > 0) {
            itemsToCheckout = cart.items.filter(item => dto.productIds.includes(item.productId));
            if (itemsToCheckout.length === 0) {
                throw new common_1.BadRequestException('No se encontraron productos v√°lidos para checkout');
            }
        }
        const subtotal = itemsToCheckout.reduce((sum, item) => sum + item.currentPrice, 0);
        const platformFee = subtotal * cart.summary.platformFeeRate;
        const totalAmount = subtotal + platformFee;
        const orderDto = await this.ordersService.createOrder(userId, {
            buyerEmail: dto.buyerEmail,
            billingData: dto.billingData
        });
        const stripeSession = await this.stripeService.createCheckoutSession({
            orderId: orderDto.id,
            orderNumber: orderDto.orderNumber,
            amount: totalAmount,
            currency: 'usd',
            customerEmail: dto.buyerEmail,
            successUrl: dto.successUrl || `${process.env.FRONTEND_URL}/orders/${orderDto.id}/success`,
            cancelUrl: dto.cancelUrl || `${process.env.FRONTEND_URL}/cart`,
            metadata: {
                orderId: orderDto.id,
                userId,
                itemCount: itemsToCheckout.length.toString()
            }
        });
        await this.prisma.order.update({
            where: { id: orderDto.id },
            data: {
                paymentIntentId: stripeSession.payment_intent,
                metadata: {
                    stripeSessionId: stripeSession.id,
                    checkoutCreatedAt: new Date().toISOString()
                }
            }
        });
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + 24);
        return {
            orderId: orderDto.id,
            orderNumber: orderDto.orderNumber,
            checkoutUrl: stripeSession.url,
            paymentIntentId: stripeSession.payment_intent,
            totalAmount: totalAmount,
            expiresAt
        };
    }
    async validateCheckoutSession(sessionId) {
        try {
            const order = await this.prisma.order.findFirst({
                where: {
                    metadata: {
                        path: 'stripeSessionId',
                        equals: sessionId
                    }
                }
            });
            if (!order) {
                return false;
            }
            const expirationTime = new Date(order.createdAt);
            expirationTime.setHours(expirationTime.getHours() + 24);
            return new Date() < expirationTime && order.status === 'PENDING';
        }
        catch (error) {
            console.error('Error validating checkout session:', error);
            return false;
        }
    }
    async cancelCheckoutSession(orderId, userId) {
        const order = await this.prisma.order.findFirst({
            where: {
                id: orderId,
                buyerId: userId,
                status: 'PENDING'
            }
        });
        if (!order) {
            throw new common_1.BadRequestException('Orden no encontrada o no se puede cancelar');
        }
        await this.prisma.order.update({
            where: { id: orderId },
            data: {
                status: 'CANCELLED',
                cancelledAt: new Date(),
                metadata: {
                    ...(order.metadata || {}),
                    cancellationReason: 'Cancelled by user during checkout',
                    cancelledAt: new Date().toISOString()
                }
            }
        });
    }
    async getCheckoutDetails(orderId, userId) {
        const order = await this.prisma.order.findFirst({
            where: {
                id: orderId,
                buyerId: userId
            },
            include: {
                items: {
                    include: {
                        product: {
                            select: {
                                id: true,
                                title: true,
                                slug: true,
                                category: true,
                                imageFileIds: true
                            }
                        }
                    }
                }
            }
        });
        if (!order) {
            throw new common_1.BadRequestException('Orden no encontrada');
        }
        const getProductImageUrl = async (product) => {
            try {
                if (product.imageFileIds) {
                    const imageIds = JSON.parse(product.imageFileIds);
                    if (Array.isArray(imageIds) && imageIds.length > 0) {
                        const imageFile = await this.prisma.file.findFirst({
                            where: {
                                id: { in: imageIds },
                                type: 'IMAGE',
                                status: 'ACTIVE'
                            },
                            select: { url: true }
                        });
                        return imageFile?.url || null;
                    }
                }
            }
            catch (error) {
                console.warn('Error parsing imageFileIds:', error);
            }
            return null;
        };
        const itemsWithImages = await Promise.all(order.items.map(async (item) => {
            const imageUrl = await getProductImageUrl(item.product);
            return {
                id: item.id,
                productId: item.productId,
                productTitle: item.productTitle,
                price: item.price,
                quantity: item.quantity,
                product: {
                    id: item.product.id,
                    title: item.product.title,
                    slug: item.product.slug,
                    category: item.product.category,
                    imageUrl
                }
            };
        }));
        return {
            orderId: order.id,
            orderNumber: order.orderNumber,
            status: order.status,
            totalAmount: order.totalAmount,
            platformFee: order.platformFee,
            subtotal: order.subtotal,
            buyerEmail: order.buyerEmail,
            items: itemsWithImages,
            createdAt: order.createdAt,
            paymentIntentId: order.paymentIntentId
        };
    }
    async reactivateCheckout(orderId, userId) {
        const order = await this.prisma.order.findFirst({
            where: {
                id: orderId,
                buyerId: userId,
                status: 'PENDING'
            }
        });
        if (!order) {
            throw new common_1.BadRequestException('Orden no encontrada o no se puede reactivar');
        }
        const expirationTime = new Date(order.createdAt);
        expirationTime.setHours(expirationTime.getHours() + 24);
        if (new Date() > expirationTime) {
            await this.cancelCheckoutSession(orderId, userId);
            throw new common_1.BadRequestException('La sesi√≥n de checkout ha expirado');
        }
        const stripeSession = await this.stripeService.createCheckoutSession({
            orderId: order.id,
            orderNumber: order.orderNumber,
            amount: order.totalAmount,
            currency: 'usd',
            customerEmail: order.buyerEmail,
            successUrl: `${process.env.FRONTEND_URL}/orders/${order.id}/success`,
            cancelUrl: `${process.env.FRONTEND_URL}/cart`,
            metadata: {
                orderId: order.id,
                userId,
                reactivated: 'true'
            }
        });
        await this.prisma.order.update({
            where: { id: orderId },
            data: {
                paymentIntentId: stripeSession.payment_intent,
                metadata: {
                    ...(order.metadata || {}),
                    stripeSessionId: stripeSession.id,
                    reactivatedAt: new Date().toISOString()
                }
            }
        });
        return {
            orderId: order.id,
            orderNumber: order.orderNumber,
            checkoutUrl: stripeSession.url,
            paymentIntentId: stripeSession.payment_intent,
            totalAmount: order.totalAmount,
            expiresAt: expirationTime
        };
    }
    async getCheckoutAnalytics(fromDate, toDate) {
        const where = {};
        if (fromDate || toDate) {
            where.createdAt = {};
            if (fromDate)
                where.createdAt.gte = fromDate;
            if (toDate)
                where.createdAt.lte = toDate;
        }
        const [totalCheckouts, completedCheckouts, cancelledCheckouts, avgCheckoutValue] = await Promise.all([
            this.prisma.order.count({ where }),
            this.prisma.order.count({ where: { ...where, status: 'COMPLETED' } }),
            this.prisma.order.count({ where: { ...where, status: 'CANCELLED' } }),
            this.prisma.order.aggregate({
                where: { ...where, status: 'COMPLETED' },
                _avg: { totalAmount: true }
            })
        ]);
        const conversionRate = totalCheckouts > 0
            ? (completedCheckouts / totalCheckouts) * 100
            : 0;
        return {
            totalCheckouts,
            completedCheckouts,
            cancelledCheckouts,
            pendingCheckouts: totalCheckouts - completedCheckouts - cancelledCheckouts,
            conversionRate: Math.round(conversionRate * 100) / 100,
            avgCheckoutValue: avgCheckoutValue._avg.totalAmount || 0
        };
    }
};
exports.CheckoutService = CheckoutService;
exports.CheckoutService = CheckoutService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof cart_service_1.CartService !== "undefined" && cart_service_1.CartService) === "function" ? _b : Object, typeof (_c = typeof orders_service_1.OrdersService !== "undefined" && orders_service_1.OrdersService) === "function" ? _c : Object, typeof (_d = typeof stripe_service_1.StripeService !== "undefined" && stripe_service_1.StripeService) === "function" ? _d : Object])
], CheckoutService);


/***/ }),
/* 243 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var StripeService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StripeService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const stripe_1 = __importDefault(__webpack_require__(244));
let StripeService = StripeService_1 = class StripeService {
    constructor(stripe, configService) {
        this.stripe = stripe;
        this.configService = configService;
        this.logger = new common_1.Logger(StripeService_1.name);
    }
    async createCheckoutSession(params) {
        return this.stripe.checkout.sessions.create({
            payment_method_types: ['card'],
            line_items: [
                {
                    price_data: {
                        currency: params.currency,
                        product_data: {
                            name: `Orden ${params.orderNumber}`,
                            description: 'Productos digitales de Furnibles',
                        },
                        unit_amount: Math.round(params.amount * 100),
                    },
                    quantity: 1,
                },
            ],
            mode: 'payment',
            customer_email: params.customerEmail,
            success_url: params.successUrl,
            cancel_url: params.cancelUrl,
            metadata: {
                orderId: params.orderId,
                ...params.metadata,
            },
            payment_intent_data: {
                metadata: {
                    orderId: params.orderId,
                },
            },
        });
    }
    async retrievePaymentIntent(paymentIntentId) {
        return this.stripe.paymentIntents.retrieve(paymentIntentId);
    }
    async createRefund(paymentIntentId, amount) {
        return this.stripe.refunds.create({
            payment_intent: paymentIntentId,
            amount: amount ? Math.round(amount * 100) : undefined,
        });
    }
    verifyWebhookSignature(payload, signature) {
        const endpointSecret = this.configService.get('STRIPE_WEBHOOK_SECRET');
        return this.stripe.webhooks.constructEvent(payload, signature, endpointSecret);
    }
    async createConnectAccount(params) {
        try {
            this.logger.log(`Creating Connect account for ${params.email}`);
            return await this.stripe.accounts.create({
                type: 'express',
                country: params.country,
                email: params.email,
                business_type: params.businessType || 'individual',
                individual: {
                    first_name: params.firstName,
                    last_name: params.lastName,
                    email: params.email,
                },
                capabilities: {
                    card_payments: { requested: true },
                    transfers: { requested: true },
                },
                settings: {
                    payouts: {
                        schedule: {
                            interval: this.configService.get('PAYOUT_SCHEDULE', 'weekly'),
                        },
                    },
                },
            });
        }
        catch (error) {
            this.logger.error(`Failed to create Connect account: ${error.message}`);
            throw error;
        }
    }
    async createAccountLink(accountId) {
        try {
            const refreshUrl = this.configService.get('STRIPE_CONNECT_REFRESH_URL');
            const returnUrl = this.configService.get('STRIPE_CONNECT_RETURN_URL');
            return await this.stripe.accountLinks.create({
                account: accountId,
                refresh_url: refreshUrl,
                return_url: returnUrl,
                type: 'account_onboarding',
            });
        }
        catch (error) {
            this.logger.error(`Failed to create account link: ${error.message}`);
            throw error;
        }
    }
    async retrieveAccount(accountId) {
        try {
            return await this.stripe.accounts.retrieve(accountId);
        }
        catch (error) {
            this.logger.error(`Failed to retrieve account ${accountId}: ${error.message}`);
            throw error;
        }
    }
    async createCheckoutSessionWithSplit(params) {
        try {
            this.logger.log(`Creating split payment session for order ${params.orderNumber}`);
            return await this.stripe.checkout.sessions.create({
                payment_method_types: ['card'],
                line_items: [
                    {
                        price_data: {
                            currency: params.currency,
                            product_data: {
                                name: `Orden ${params.orderNumber}`,
                                description: 'Productos digitales de Furnibles',
                            },
                            unit_amount: Math.round(params.amount * 100),
                        },
                        quantity: 1,
                    },
                ],
                mode: 'payment',
                customer_email: params.customerEmail,
                success_url: params.successUrl,
                cancel_url: params.cancelUrl,
                metadata: {
                    orderId: params.orderId,
                    sellerId: params.sellerId,
                    splitPayment: 'true',
                    ...params.metadata,
                },
                payment_intent_data: {
                    application_fee_amount: Math.round(params.platformFeeAmount * 100),
                    transfer_data: {
                        destination: params.sellerId,
                    },
                    transfer_group: params.transferGroup,
                    metadata: {
                        orderId: params.orderId,
                        sellerId: params.sellerId,
                    },
                },
            });
        }
        catch (error) {
            this.logger.error(`Failed to create split payment session: ${error.message}`);
            throw error;
        }
    }
    async createTransfer(params) {
        try {
            this.logger.log(`Creating transfer of ${params.amount} to ${params.destination}`);
            return await this.stripe.transfers.create({
                amount: Math.round(params.amount * 100),
                currency: params.currency,
                destination: params.destination,
                transfer_group: params.transferGroup,
                metadata: params.metadata,
            });
        }
        catch (error) {
            this.logger.error(`Failed to create transfer: ${error.message}`);
            throw error;
        }
    }
    async createPayout(params) {
        try {
            this.logger.log(`Creating payout of ${params.amount} for account ${params.stripeAccountId}`);
            return await this.stripe.payouts.create({
                amount: Math.round(params.amount * 100),
                currency: params.currency,
                method: params.method || 'standard',
            }, {
                stripeAccount: params.stripeAccountId,
            });
        }
        catch (error) {
            this.logger.error(`Failed to create payout: ${error.message}`);
            throw error;
        }
    }
    async getAccountBalance(accountId) {
        try {
            return await this.stripe.balance.retrieve({
                stripeAccount: accountId,
            });
        }
        catch (error) {
            this.logger.error(`Failed to get balance for account ${accountId}: ${error.message}`);
            throw error;
        }
    }
    async listTransfers(accountId, limit = 20) {
        try {
            const params = {
                limit,
            };
            if (accountId) {
                params.destination = accountId;
            }
            return await this.stripe.transfers.list(params);
        }
        catch (error) {
            this.logger.error(`Failed to list transfers: ${error.message}`);
            throw error;
        }
    }
    async listPayouts(accountId, limit = 20) {
        try {
            return await this.stripe.payouts.list({ limit }, { stripeAccount: accountId });
        }
        catch (error) {
            this.logger.error(`Failed to list payouts for account ${accountId}: ${error.message}`);
            throw error;
        }
    }
    async createRefundWithSplit(paymentIntentId, amount, reverseTransfer = true) {
        try {
            this.logger.log(`Creating refund for payment intent ${paymentIntentId}`);
            return await this.stripe.refunds.create({
                payment_intent: paymentIntentId,
                amount: amount ? Math.round(amount * 100) : undefined,
                reverse_transfer: reverseTransfer,
            });
        }
        catch (error) {
            this.logger.error(`Failed to create refund: ${error.message}`);
            throw error;
        }
    }
    verifyConnectWebhookSignature(payload, signature) {
        const endpointSecret = this.configService.get('STRIPE_CONNECT_WEBHOOK_SECRET');
        return this.stripe.webhooks.constructEvent(payload, signature, endpointSecret);
    }
    async getAccountCapabilities(accountId) {
        try {
            return await this.stripe.accounts.retrieve(accountId);
        }
        catch (error) {
            this.logger.error(`Failed to get capabilities for account ${accountId}: ${error.message}`);
            throw error;
        }
    }
    async isAccountReadyForPayments(accountId) {
        try {
            const account = await this.retrieveAccount(accountId);
            return (account.charges_enabled &&
                account.payouts_enabled &&
                account.details_submitted);
        }
        catch (error) {
            this.logger.error(`Failed to check account readiness: ${error.message}`);
            return false;
        }
    }
    async createLoginLink(accountId) {
        try {
            return await this.stripe.accounts.createLoginLink(accountId);
        }
        catch (error) {
            this.logger.error(`Failed to create login link for account ${accountId}: ${error.message}`);
            throw error;
        }
    }
    async listAccountTransactions(accountId, options = {}) {
        try {
            return await this.stripe.balanceTransactions.list({
                limit: options.limit || 20,
                starting_after: options.starting_after,
                created: options.created,
            }, { stripeAccount: accountId });
        }
        catch (error) {
            this.logger.error(`Failed to list transactions for account ${accountId}: ${error.message}`);
            throw error;
        }
    }
    calculateStripeFees(amount, currency = 'USD') {
        const feeRate = parseFloat(this.configService.get('STRIPE_FEE_RATE', '0.029'));
        const feeFixed = parseFloat(this.configService.get('STRIPE_FEE_FIXED', '0.30'));
        const stripeFeePercentage = amount * feeRate;
        const stripeFeeFixed = feeFixed;
        const totalStripeFee = stripeFeePercentage + stripeFeeFixed;
        const netAmount = amount - totalStripeFee;
        return {
            stripeFeePercentage,
            stripeFeeFixed,
            totalStripeFee,
            netAmount,
        };
    }
    async createPaymentIntent(amount, currency, metadata) {
        try {
            this.logger.log(`Creating Payment Intent: ${amount} ${currency}`);
            return await this.stripe.paymentIntents.create({
                amount: Math.round(amount * 100),
                currency: currency.toLowerCase(),
                automatic_payment_methods: {
                    enabled: true,
                },
                metadata,
                confirmation_method: 'manual',
                confirm: false,
            });
        }
        catch (error) {
            this.logger.error(`Failed to create Payment Intent: ${error.message}`);
            throw error;
        }
    }
    async confirmPaymentIntent(paymentIntentId) {
        try {
            this.logger.log(`Confirming Payment Intent: ${paymentIntentId}`);
            return await this.stripe.paymentIntents.confirm(paymentIntentId);
        }
        catch (error) {
            this.logger.error(`Failed to confirm Payment Intent: ${error.message}`);
            throw error;
        }
    }
    constructWebhookEvent(body, signature) {
        const endpointSecret = this.configService.get('STRIPE_WEBHOOK_SECRET');
        if (!endpointSecret) {
            throw new Error('STRIPE_WEBHOOK_SECRET not configured');
        }
        return this.stripe.webhooks.constructEvent(body, signature, endpointSecret);
    }
    async getPaymentDetails(paymentIntentId) {
        try {
            const paymentIntent = await this.retrievePaymentIntent(paymentIntentId);
            return {
                paymentId: paymentIntent.id,
                amount: paymentIntent.amount / 100,
                currency: paymentIntent.currency.toUpperCase(),
                status: paymentIntent.status,
                customerEmail: paymentIntent.receipt_email || undefined,
                metadata: paymentIntent.metadata,
                createdAt: new Date(paymentIntent.created * 1000).toISOString(),
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payment details: ${error.message}`);
            throw error;
        }
    }
    async findPaymentIntentByMetadata(metadataKey, metadataValue) {
        try {
            const paymentIntents = await this.stripe.paymentIntents.list({
                limit: 100,
            });
            const found = paymentIntents.data.find(pi => pi.metadata[metadataKey] === metadataValue);
            return found || null;
        }
        catch (error) {
            this.logger.error(`Failed to find payment intent by metadata: ${error.message}`);
            return null;
        }
    }
    async createPaymentIntentWithSplit(amount, currency, sellerId, platformFeeAmount, metadata) {
        try {
            this.logger.log(`Creating split Payment Intent: ${amount} ${currency} for seller ${sellerId}`);
            return await this.stripe.paymentIntents.create({
                amount: Math.round(amount * 100),
                currency: currency.toLowerCase(),
                automatic_payment_methods: {
                    enabled: true,
                },
                application_fee_amount: Math.round(platformFeeAmount * 100),
                transfer_data: {
                    destination: sellerId,
                },
                metadata: {
                    ...metadata,
                    sellerId,
                    splitPayment: 'true',
                },
                confirmation_method: 'manual',
                confirm: false,
            });
        }
        catch (error) {
            this.logger.error(`Failed to create split Payment Intent: ${error.message}`);
            throw error;
        }
    }
    get stripeClient() {
        return this.stripe;
    }
    async testConnection() {
        try {
            const balance = await this.stripe.balance.retrieve();
            return {
                success: true,
                message: 'Stripe connection successful',
                balance: balance.available[0]?.amount || 0,
            };
        }
        catch (error) {
            this.logger.error(`Stripe connection test failed: ${error.message}`);
            return {
                success: false,
                message: `Stripe connection failed: ${error.message}`,
            };
        }
    }
    async validateAccountForPayment(accountId) {
        try {
            const account = await this.retrieveAccount(accountId);
            const reasons = [];
            if (!account.charges_enabled) {
                reasons.push('Account cannot accept charges');
            }
            if (!account.payouts_enabled) {
                reasons.push('Account cannot receive payouts');
            }
            if (!account.details_submitted) {
                reasons.push('Account setup not completed');
            }
            if (account.requirements?.currently_due?.length > 0) {
                reasons.push(`Missing requirements: ${account.requirements.currently_due.join(', ')}`);
            }
            return {
                isValid: reasons.length === 0,
                reasons,
            };
        }
        catch (error) {
            this.logger.error(`Failed to validate account: ${error.message}`);
            return {
                isValid: false,
                reasons: [`Account validation failed: ${error.message}`],
            };
        }
    }
    async getPaymentStats(options = {}) {
        try {
            const params = {
                limit: 100,
            };
            if (options.startDate) {
                params.created = { gte: Math.floor(options.startDate.getTime() / 1000) };
            }
            if (options.endDate) {
                if (!params.created)
                    params.created = {};
                params.created.lte = Math.floor(options.endDate.getTime() / 1000);
            }
            const paymentIntents = await this.stripe.paymentIntents.list(params);
            const successful = paymentIntents.data.filter(pi => pi.status === 'succeeded');
            const totalAmount = successful.reduce((sum, pi) => sum + pi.amount, 0) / 100;
            const totalTransactions = successful.length;
            const averageAmount = totalTransactions > 0 ? totalAmount / totalTransactions : 0;
            return {
                totalAmount,
                totalTransactions,
                averageAmount,
                currency: options.currency || 'USD',
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payment stats: ${error.message}`);
            throw error;
        }
    }
};
exports.StripeService = StripeService;
exports.StripeService = StripeService = StripeService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)('STRIPE_CLIENT')),
    __metadata("design:paramtypes", [typeof (_a = typeof stripe_1.default !== "undefined" && stripe_1.default) === "function" ? _a : Object, typeof (_b = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _b : Object])
], StripeService);


/***/ }),
/* 244 */
/***/ ((module) => {

"use strict";
module.exports = require("stripe");

/***/ }),
/* 245 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckoutAnalyticsDto = exports.CheckoutItemDto = exports.CheckoutDetailsDto = exports.CheckoutResponseDto = exports.CheckoutDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class CheckoutDto {
}
exports.CheckoutDto = CheckoutDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Email del comprador para recibir los archivos',
        example: 'buyer@example.com'
    }),
    (0, class_validator_1.IsEmail)(),
    __metadata("design:type", String)
], CheckoutDto.prototype, "buyerEmail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL de √©xito despu√©s del pago',
        required: false,
        default: 'https://probable-barnacle-65wp9jg5qwxc5w6-3000.app.github.dev/orders/success'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], CheckoutDto.prototype, "successUrl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL de cancelaci√≥n',
        required: false,
        default: 'https://probable-barnacle-65wp9jg5qwxc5w6-3000.app.github.dev/cart'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], CheckoutDto.prototype, "cancelUrl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Datos de facturaci√≥n',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", Object)
], CheckoutDto.prototype, "billingData", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'IDs espec√≠ficos de productos del carrito a comprar (opcional)',
        required: false,
        type: [String]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], CheckoutDto.prototype, "productIds", void 0);
class CheckoutResponseDto {
}
exports.CheckoutResponseDto = CheckoutResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID de la orden creada'
    }),
    __metadata("design:type", String)
], CheckoutResponseDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'N√∫mero √∫nico de la orden'
    }),
    __metadata("design:type", String)
], CheckoutResponseDto.prototype, "orderNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL de Stripe Checkout para proceder al pago'
    }),
    __metadata("design:type", String)
], CheckoutResponseDto.prototype, "checkoutUrl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'ID del Payment Intent de Stripe'
    }),
    __metadata("design:type", String)
], CheckoutResponseDto.prototype, "paymentIntentId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Monto total a pagar'
    }),
    __metadata("design:type", Number)
], CheckoutResponseDto.prototype, "totalAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Fecha y hora de expiraci√≥n del checkout'
    }),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], CheckoutResponseDto.prototype, "expiresAt", void 0);
class CheckoutDetailsDto {
}
exports.CheckoutDetailsDto = CheckoutDetailsDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutDetailsDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutDetailsDto.prototype, "orderNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutDetailsDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutDetailsDto.prototype, "totalAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutDetailsDto.prototype, "platformFee", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutDetailsDto.prototype, "subtotal", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutDetailsDto.prototype, "buyerEmail", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Array)
], CheckoutDetailsDto.prototype, "items", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], CheckoutDetailsDto.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutDetailsDto.prototype, "paymentIntentId", void 0);
class CheckoutItemDto {
}
exports.CheckoutItemDto = CheckoutItemDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutItemDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutItemDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CheckoutItemDto.prototype, "productTitle", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutItemDto.prototype, "price", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutItemDto.prototype, "quantity", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Object)
], CheckoutItemDto.prototype, "product", void 0);
class CheckoutAnalyticsDto {
}
exports.CheckoutAnalyticsDto = CheckoutAnalyticsDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutAnalyticsDto.prototype, "totalCheckouts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutAnalyticsDto.prototype, "completedCheckouts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutAnalyticsDto.prototype, "cancelledCheckouts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutAnalyticsDto.prototype, "pendingCheckouts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutAnalyticsDto.prototype, "conversionRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], CheckoutAnalyticsDto.prototype, "avgCheckoutValue", void 0);


/***/ }),
/* 246 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StripeModule = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const stripe_service_1 = __webpack_require__(243);
let StripeModule = class StripeModule {
};
exports.StripeModule = StripeModule;
exports.StripeModule = StripeModule = __decorate([
    (0, common_1.Module)({
        imports: [config_1.ConfigModule],
        providers: [
            {
                provide: 'STRIPE_CLIENT',
                useFactory: (configService) => {
                    const Stripe = __webpack_require__(244);
                    return new Stripe(configService.get('STRIPE_SECRET_KEY'), {
                        apiVersion: '2023-10-16',
                    });
                },
                inject: [config_1.ConfigService],
            },
            stripe_service_1.StripeService,
        ],
        exports: [stripe_service_1.StripeService],
    })
], StripeModule);


/***/ }),
/* 247 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownloadsModule = void 0;
const common_1 = __webpack_require__(2);
const downloads_controller_1 = __webpack_require__(248);
const downloads_service_1 = __webpack_require__(249);
const prisma_module_1 = __webpack_require__(9);
let DownloadsModule = class DownloadsModule {
};
exports.DownloadsModule = DownloadsModule;
exports.DownloadsModule = DownloadsModule = __decorate([
    (0, common_1.Module)({
        imports: [prisma_module_1.PrismaModule],
        controllers: [downloads_controller_1.DownloadsController],
        providers: [downloads_service_1.DownloadsService],
        exports: [downloads_service_1.DownloadsService],
    })
], DownloadsModule);


/***/ }),
/* 248 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownloadsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const downloads_service_1 = __webpack_require__(249);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const download_response_dto_1 = __webpack_require__(250);
const client_1 = __webpack_require__(11);
const express_1 = __webpack_require__(52);
let DownloadsController = class DownloadsController {
    constructor(downloadsService) {
        this.downloadsService = downloadsService;
    }
    async getOrderDownloads(req, orderId) {
        return this.downloadsService.getOrderDownloads(orderId, req.user.id);
    }
    async downloadFile(token, req, res) {
        return this.downloadsService.downloadFile(token, req, res);
    }
};
exports.DownloadsController = DownloadsController;
__decorate([
    (0, common_1.Get)('orders/:orderId'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener descargas de una orden',
        description: 'Retorna todos los tokens de descarga disponibles para una orden completada.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'orderId',
        description: 'ID de la orden'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Descargas obtenidas exitosamente',
        type: download_response_dto_1.DownloadResponseDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Orden no encontrada o no completada'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Param)('orderId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", typeof (_b = typeof Promise !== "undefined" && Promise) === "function" ? _b : Object)
], DownloadsController.prototype, "getOrderDownloads", null);
__decorate([
    (0, common_1.Get)(':token'),
    (0, swagger_1.ApiOperation)({
        summary: 'Descargar archivo por token',
        description: 'Descarga un archivo PDF usando un token de descarga v√°lido. No requiere autenticaci√≥n.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'token',
        description: 'Token de descarga √∫nico'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Archivo descargado exitosamente',
        headers: {
            'Content-Type': { description: 'Tipo MIME del archivo' },
            'Content-Disposition': { description: 'Nombre del archivo para descarga' }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Token inv√°lido o archivo no encontrado'
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Token expirado o l√≠mite de descargas excedido'
    }),
    __param(0, (0, common_1.Param)('token')),
    __param(1, (0, common_1.Request)()),
    __param(2, (0, common_1.Response)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, typeof (_c = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _c : Object]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], DownloadsController.prototype, "downloadFile", null);
exports.DownloadsController = DownloadsController = __decorate([
    (0, swagger_1.ApiTags)('Downloads'),
    (0, common_1.Controller)('downloads'),
    __metadata("design:paramtypes", [typeof (_a = typeof downloads_service_1.DownloadsService !== "undefined" && downloads_service_1.DownloadsService) === "function" ? _a : Object])
], DownloadsController);


/***/ }),
/* 249 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownloadsService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const fs = __importStar(__webpack_require__(181));
const path = __importStar(__webpack_require__(49));
let DownloadsService = class DownloadsService {
    constructor(prisma) {
        this.prisma = prisma;
    }
    async getOrderDownloads(orderId, userId) {
        const order = await this.prisma.order.findFirst({
            where: {
                id: orderId,
                buyerId: userId,
                status: 'COMPLETED'
            },
            include: {
                downloadTokens: {
                    include: {
                        product: true
                    }
                }
            }
        });
        if (!order) {
            throw new common_1.NotFoundException('Orden no encontrada o no completada');
        }
        const downloads = order.downloadTokens.map(token => ({
            id: token.id,
            token: token.token,
            productId: token.productId,
            productTitle: token.product.title,
            downloadUrl: `${process.env.API_URL}/api/downloads/${token.token}`,
            downloadLimit: token.downloadLimit,
            downloadCount: token.downloadCount,
            expiresAt: token.expiresAt,
            isActive: token.isActive && token.downloadCount < token.downloadLimit && token.expiresAt > new Date(),
            lastDownloadAt: token.lastDownloadAt
        }));
        return {
            downloads,
            orderId: order.id,
            orderNumber: order.orderNumber,
            totalDownloads: downloads.length
        };
    }
    async downloadFile(token, req, res) {
        const downloadToken = await this.prisma.downloadToken.findUnique({
            where: { token },
            include: {
                product: true,
                order: true
            }
        });
        if (!downloadToken) {
            throw new common_1.NotFoundException('Token de descarga inv√°lido');
        }
        if (!downloadToken.isActive) {
            throw new common_1.BadRequestException('Token de descarga desactivado');
        }
        if (downloadToken.expiresAt < new Date()) {
            throw new common_1.BadRequestException('Token de descarga expirado');
        }
        if (downloadToken.downloadCount >= downloadToken.downloadLimit) {
            throw new common_1.BadRequestException('L√≠mite de descargas excedido');
        }
        const pdfFile = await this.getPdfFile(downloadToken.product);
        if (!pdfFile) {
            throw new common_1.NotFoundException('Archivo no encontrado');
        }
        const filePath = path.join(process.env.STORAGE_PATH || './storage', pdfFile.key);
        if (!fs.existsSync(filePath)) {
            throw new common_1.NotFoundException('Archivo no encontrado en el servidor');
        }
        await this.prisma.downloadToken.update({
            where: { id: downloadToken.id },
            data: {
                downloadCount: downloadToken.downloadCount + 1,
                lastDownloadAt: new Date(),
                lastIpAddress: req.ip,
                lastUserAgent: req.get('User-Agent')
            }
        });
        console.log(`Download: ${pdfFile.filename} by token ${token} (${downloadToken.downloadCount + 1}/${downloadToken.downloadLimit})`);
        res.set({
            'Content-Type': pdfFile.mimeType,
            'Content-Disposition': `attachment; filename="${pdfFile.filename}"`,
            'Content-Length': pdfFile.size.toString(),
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
        });
        const fileStream = fs.createReadStream(filePath);
        return new common_1.StreamableFile(fileStream);
    }
    async getPdfFile(product) {
        try {
            if (!product.pdfFileId) {
                return null;
            }
            const pdfFile = await this.prisma.file.findUnique({
                where: {
                    id: product.pdfFileId,
                    type: 'PDF',
                    status: 'ACTIVE'
                }
            });
            return pdfFile;
        }
        catch (error) {
            console.error('Error getting PDF file:', error);
            return null;
        }
    }
    async getSellerDownloadStats(sellerId, fromDate, toDate) {
        const where = {
            product: {
                sellerId: sellerId
            }
        };
        if (fromDate || toDate) {
            where.createdAt = {};
            if (fromDate)
                where.createdAt.gte = fromDate;
            if (toDate)
                where.createdAt.lte = toDate;
        }
        const totalTokens = await this.prisma.downloadToken.count({ where });
        const totalDownloads = await this.prisma.downloadToken.aggregate({
            where,
            _sum: {
                downloadCount: true
            }
        });
        const activeTokens = await this.prisma.downloadToken.count({
            where: {
                ...where,
                isActive: true,
                expiresAt: {
                    gt: new Date()
                }
            }
        });
        return {
            totalTokens,
            totalDownloads: totalDownloads._sum.downloadCount || 0,
            activeTokens,
            expiredTokens: totalTokens - activeTokens
        };
    }
    async cleanupExpiredTokens() {
        const result = await this.prisma.downloadToken.updateMany({
            where: {
                expiresAt: {
                    lt: new Date()
                },
                isActive: true
            },
            data: {
                isActive: false
            }
        });
        return result.count;
    }
    async regenerateDownloadToken(tokenId, sellerId) {
        const existingToken = await this.prisma.downloadToken.findFirst({
            where: {
                id: tokenId,
                product: {
                    sellerId: sellerId
                }
            }
        });
        if (!existingToken) {
            throw new common_1.NotFoundException('Token no encontrado o sin permisos');
        }
        const newToken = this.generateUniqueToken();
        await this.prisma.downloadToken.update({
            where: { id: tokenId },
            data: {
                token: newToken,
                downloadCount: 0,
                isActive: true,
                lastDownloadAt: null
            }
        });
        return newToken;
    }
    generateUniqueToken() {
        const timestamp = Date.now().toString();
        const random = Math.random().toString(36).substring(2);
        return `dl_${timestamp}_${random}`;
    }
    async getTokenDetails(token, userId) {
        const downloadToken = await this.prisma.downloadToken.findUnique({
            where: { token },
            include: {
                product: {
                    select: {
                        id: true,
                        title: true,
                        slug: true,
                        category: true,
                        sellerId: true
                    }
                },
                order: {
                    select: {
                        id: true,
                        orderNumber: true,
                        createdAt: true,
                        buyerId: true
                    }
                }
            }
        });
        if (!downloadToken) {
            throw new common_1.NotFoundException('Token no encontrado');
        }
        const hasPermission = downloadToken.order.buyerId === userId ||
            downloadToken.product.sellerId === userId;
        if (!hasPermission) {
            throw new common_1.BadRequestException('Sin permisos para acceder a este token');
        }
        return {
            id: downloadToken.id,
            token: downloadToken.token,
            productTitle: downloadToken.product.title,
            productSlug: downloadToken.product.slug,
            orderNumber: downloadToken.order.orderNumber,
            downloadLimit: downloadToken.downloadLimit,
            downloadCount: downloadToken.downloadCount,
            remainingDownloads: downloadToken.downloadLimit - downloadToken.downloadCount,
            expiresAt: downloadToken.expiresAt,
            isActive: downloadToken.isActive,
            lastDownloadAt: downloadToken.lastDownloadAt,
            createdAt: downloadToken.createdAt
        };
    }
};
exports.DownloadsService = DownloadsService;
exports.DownloadsService = DownloadsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object])
], DownloadsService);


/***/ }),
/* 250 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownloadResponseDto = exports.DownloadTokenDto = void 0;
const swagger_1 = __webpack_require__(4);
class DownloadTokenDto {
}
exports.DownloadTokenDto = DownloadTokenDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], DownloadTokenDto.prototype, "id", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], DownloadTokenDto.prototype, "token", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], DownloadTokenDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], DownloadTokenDto.prototype, "productTitle", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], DownloadTokenDto.prototype, "downloadUrl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], DownloadTokenDto.prototype, "downloadLimit", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], DownloadTokenDto.prototype, "downloadCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_a = typeof Date !== "undefined" && Date) === "function" ? _a : Object)
], DownloadTokenDto.prototype, "expiresAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Boolean)
], DownloadTokenDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_b = typeof Date !== "undefined" && Date) === "function" ? _b : Object)
], DownloadTokenDto.prototype, "lastDownloadAt", void 0);
class DownloadResponseDto {
}
exports.DownloadResponseDto = DownloadResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ type: [DownloadTokenDto] }),
    __metadata("design:type", Array)
], DownloadResponseDto.prototype, "downloads", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], DownloadResponseDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], DownloadResponseDto.prototype, "orderNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], DownloadResponseDto.prototype, "totalDownloads", void 0);


/***/ }),
/* 251 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhookModule = void 0;
const common_1 = __webpack_require__(2);
const webhook_controller_1 = __webpack_require__(252);
const stripe_webhook_service_1 = __webpack_require__(253);
const stripe_module_1 = __webpack_require__(246);
const orders_module_1 = __webpack_require__(221);
const prisma_module_1 = __webpack_require__(9);
const payments_module_1 = __webpack_require__(255);
let WebhookModule = class WebhookModule {
};
exports.WebhookModule = WebhookModule;
exports.WebhookModule = WebhookModule = __decorate([
    (0, common_1.Module)({
        imports: [
            stripe_module_1.StripeModule,
            orders_module_1.OrdersModule,
            prisma_module_1.PrismaModule,
            payments_module_1.PaymentsModule
        ],
        controllers: [webhook_controller_1.WebhookController],
        providers: [stripe_webhook_service_1.StripeWebhookService],
        exports: [stripe_webhook_service_1.StripeWebhookService],
    })
], WebhookModule);


/***/ }),
/* 252 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var WebhookController_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhookController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const stripe_webhook_service_1 = __webpack_require__(253);
let WebhookController = WebhookController_1 = class WebhookController {
    constructor(stripeWebhookService) {
        this.stripeWebhookService = stripeWebhookService;
        this.logger = new common_1.Logger(WebhookController_1.name);
    }
    async handleStripeWebhook(req, signature) {
        if (!signature) {
            this.logger.error('Missing stripe-signature header');
            throw new common_1.BadRequestException('Missing stripe-signature header');
        }
        if (!req.rawBody) {
            this.logger.error('Missing request body');
            throw new common_1.BadRequestException('Missing request body');
        }
        this.logger.log('Received Stripe webhook', {
            bodySize: req.rawBody.length,
            hasSignature: !!signature
        });
        try {
            await this.stripeWebhookService.handleWebhook(req.rawBody, signature);
            this.logger.log('Webhook processed successfully');
            return { received: true };
        }
        catch (error) {
            this.logger.error('Webhook processing failed', {
                error: error.message,
                stack: error.stack
            });
            if (error.message.includes('signature')) {
                throw new common_1.BadRequestException('Invalid webhook signature');
            }
            return {
                received: false,
                error: error.message
            };
        }
    }
    async handlePayPalWebhook(req, headers) {
        if (!req.rawBody) {
            this.logger.error('Missing PayPal webhook body');
            throw new common_1.BadRequestException('Missing request body');
        }
        this.logger.log('Received PayPal webhook', {
            bodySize: req.rawBody.length,
            contentType: headers['content-type']
        });
        try {
            let webhookBody;
            try {
                const bodyString = req.rawBody.toString('utf8');
                webhookBody = JSON.parse(bodyString);
            }
            catch (parseError) {
                this.logger.error('Failed to parse PayPal webhook body', {
                    error: parseError.message,
                    bodyPreview: req.rawBody.toString('utf8').substring(0, 200)
                });
                throw new common_1.BadRequestException('Invalid JSON in webhook body');
            }
            const eventType = webhookBody.event_type;
            if (eventType) {
                this.logger.log(`Processing PayPal event: ${eventType}`);
                switch (eventType) {
                    case 'CHECKOUT.ORDER.COMPLETED':
                        this.logger.log(`PayPal order completed: ${webhookBody.resource?.id}`);
                        break;
                    case 'PAYMENT.CAPTURE.COMPLETED':
                        this.logger.log(`PayPal payment captured: ${webhookBody.resource?.id}`);
                        break;
                    case 'PAYMENT.CAPTURE.DENIED':
                        this.logger.warn(`PayPal payment denied: ${webhookBody.resource?.id}`);
                        break;
                    default:
                        this.logger.log(`Unhandled PayPal event: ${eventType}`);
                }
            }
            else {
                this.logger.warn('PayPal webhook missing event_type');
            }
            return { received: true };
        }
        catch (error) {
            this.logger.error('PayPal webhook processing failed', {
                error: error.message,
                stack: error.stack
            });
            if (error instanceof common_1.BadRequestException) {
                throw error;
            }
            return {
                received: false,
                error: error.message
            };
        }
    }
};
exports.WebhookController = WebhookController;
__decorate([
    (0, common_1.Post)('stripe'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Webhook de Stripe',
        description: 'Endpoint para recibir eventos de Stripe (pagos, reembolsos, etc.)'
    }),
    (0, swagger_1.ApiHeader)({
        name: 'stripe-signature',
        description: 'Firma de Stripe para validar el webhook'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Webhook procesado exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Firma inv√°lida o evento no v√°lido'
    }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Headers)('stripe-signature')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof common_1.RawBodyRequest !== "undefined" && common_1.RawBodyRequest) === "function" ? _b : Object, String]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], WebhookController.prototype, "handleStripeWebhook", null);
__decorate([
    (0, common_1.Post)('paypal'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'PayPal webhook endpoint',
        description: 'Handles PayPal webhook events'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Webhook processed successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid webhook' }),
    __param(0, (0, common_1.Request)()),
    __param(1, (0, common_1.Headers)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof common_1.RawBodyRequest !== "undefined" && common_1.RawBodyRequest) === "function" ? _d : Object, Object]),
    __metadata("design:returntype", typeof (_e = typeof Promise !== "undefined" && Promise) === "function" ? _e : Object)
], WebhookController.prototype, "handlePayPalWebhook", null);
exports.WebhookController = WebhookController = WebhookController_1 = __decorate([
    (0, swagger_1.ApiTags)('Webhooks'),
    (0, common_1.Controller)('webhooks'),
    __metadata("design:paramtypes", [typeof (_a = typeof stripe_webhook_service_1.StripeWebhookService !== "undefined" && stripe_webhook_service_1.StripeWebhookService) === "function" ? _a : Object])
], WebhookController);


/***/ }),
/* 253 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var StripeWebhookService_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StripeWebhookService = void 0;
const common_1 = __webpack_require__(2);
const stripe_service_1 = __webpack_require__(243);
const orders_service_1 = __webpack_require__(223);
const prisma_service_1 = __webpack_require__(10);
const payments_service_1 = __webpack_require__(254);
let StripeWebhookService = StripeWebhookService_1 = class StripeWebhookService {
    constructor(stripeService, ordersService, prisma, paymentsService) {
        this.stripeService = stripeService;
        this.ordersService = ordersService;
        this.prisma = prisma;
        this.paymentsService = paymentsService;
        this.logger = new common_1.Logger(StripeWebhookService_1.name);
        this.processedEvents = new Set();
    }
    async handleWebhook(payload, signature) {
        let event;
        try {
            event = this.stripeService.verifyWebhookSignature(payload, signature);
        }
        catch (err) {
            this.logger.error(`Webhook signature verification failed`, {
                error: err.message,
                signaturePreview: signature?.substring(0, 20) + '...'
            });
            throw new Error(`Webhook signature verification failed`);
        }
        if (this.processedEvents.has(event.id)) {
            this.logger.warn(`Event ${event.id} already processed, skipping`);
            return;
        }
        this.logger.log(`Processing Stripe webhook`, {
            eventType: event.type,
            eventId: event.id,
            livemode: event.livemode
        });
        try {
            await this.saveWebhookEvent(event);
            switch (event.type) {
                case 'payment_intent.succeeded':
                    await this.handlePaymentSucceeded(event.data.object);
                    break;
                case 'payment_intent.payment_failed':
                    await this.handlePaymentFailed(event.data.object);
                    break;
                case 'checkout.session.completed':
                    await this.handleCheckoutCompleted(event.data.object);
                    break;
                case 'checkout.session.expired':
                    await this.handleCheckoutExpired(event.data.object);
                    break;
                case 'payment_intent.canceled':
                    await this.handlePaymentCanceled(event.data.object);
                    break;
                case 'charge.dispute.created':
                    await this.handleDisputeCreated(event.data.object);
                    break;
                case 'transfer.created':
                    await this.handleTransferCreated(event.data.object);
                    break;
                case 'transfer.updated':
                    await this.handleTransferUpdated(event.data.object);
                    break;
                case 'transfer.reversed':
                    await this.handleTransferReversed(event.data.object);
                    break;
                case 'invoice.payment_succeeded':
                    this.logger.log(`Invoice payment succeeded: ${event.data.object.id}`);
                    break;
                case 'customer.subscription.created':
                case 'customer.subscription.updated':
                case 'customer.subscription.deleted':
                    this.logger.log(`Subscription event: ${event.type}`);
                    break;
                default:
                    this.logger.warn(`Unhandled event type: ${event.type}`);
            }
            this.processedEvents.add(event.id);
            this.cleanupProcessedEvents();
        }
        catch (error) {
            this.logger.error(`Error processing webhook ${event.type}`, {
                eventId: event.id,
                error: error.message,
                stack: error.stack
            });
            throw error;
        }
    }
    async handleConnectWebhook(payload, signature) {
        let event;
        try {
            event = this.stripeService.verifyConnectWebhookSignature(payload, signature);
        }
        catch (err) {
            this.logger.error(`Connect webhook signature verification failed`, {
                error: err.message,
                signaturePreview: signature?.substring(0, 20) + '...'
            });
            throw new Error(`Connect webhook signature verification failed`);
        }
        if (this.processedEvents.has(event.id)) {
            this.logger.warn(`Connect event ${event.id} already processed, skipping`);
            return;
        }
        this.logger.log(`Processing Stripe Connect webhook`, {
            eventType: event.type,
            eventId: event.id,
            account: event.account,
            livemode: event.livemode
        });
        try {
            await this.saveWebhookEvent(event, event.account);
            switch (event.type) {
                case 'account.updated':
                    await this.handleAccountUpdated(event.data.object, event.account);
                    break;
                case 'account.external_account.created':
                    await this.handleExternalAccountCreated(event.data.object, event.account);
                    break;
                case 'payout.created':
                    await this.handlePayoutCreated(event.data.object, event.account);
                    break;
                case 'payout.paid':
                    await this.handlePayoutPaid(event.data.object, event.account);
                    break;
                case 'payout.failed':
                    await this.handlePayoutFailed(event.data.object, event.account);
                    break;
                case 'payout.canceled':
                    await this.handlePayoutCanceled(event.data.object, event.account);
                    break;
                default:
                    this.logger.warn(`Unhandled Connect event type: ${event.type}`);
            }
            this.processedEvents.add(event.id);
            this.cleanupProcessedEvents();
        }
        catch (error) {
            this.logger.error(`Error processing Connect webhook ${event.type}`, {
                eventId: event.id,
                account: event.account,
                error: error.message,
                stack: error.stack
            });
            throw error;
        }
    }
    async handlePaymentSucceeded(paymentIntent) {
        try {
            this.logger.log(`Processing payment succeeded`, {
                paymentIntentId: paymentIntent.id,
                amount: paymentIntent.amount_received,
                currency: paymentIntent.currency
            });
            await this.prisma.$transaction(async (tx) => {
                const order = await tx.order.findFirst({
                    where: { paymentIntentId: paymentIntent.id },
                    include: {
                        items: {
                            include: {
                                product: {
                                    include: { seller: true }
                                }
                            }
                        },
                        buyer: true
                    }
                });
                if (!order) {
                    this.logger.warn(`Order not found for payment intent: ${paymentIntent.id}`);
                    return;
                }
                if (order.status !== 'PENDING') {
                    this.logger.warn(`Order ${order.id} is not in PENDING status: ${order.status}`);
                    return;
                }
                await tx.order.update({
                    where: { id: order.id },
                    data: {
                        status: 'PROCESSING',
                        paidAt: new Date(),
                        paymentStatus: 'succeeded'
                    }
                });
            });
            const orderId = paymentIntent.metadata?.orderId;
            if (orderId) {
                try {
                    this.logger.log(`Split payments processing deferred for order: ${orderId}`);
                }
                catch (splitError) {
                    this.logger.error(`Split payment failed for order ${orderId}:`, splitError);
                    this.logger.error(`Split payment failure for order ${orderId}: ${splitError.message}`);
                }
            }
            await this.ordersService.processPaymentSuccess(paymentIntent.id);
            this.logger.log(`Payment processed successfully for PI: ${paymentIntent.id}`);
        }
        catch (error) {
            this.logger.error(`Error processing payment success for PI ${paymentIntent.id}`, {
                error: error.message,
                stack: error.stack
            });
            throw error;
        }
    }
    async handleTransferCreated(transfer) {
        const orderId = transfer.metadata?.orderId;
        if (!orderId) {
            this.logger.warn(`Transfer created without orderId: ${transfer.id}`);
            return;
        }
        this.logger.log(`Transfer created: ${transfer.id} for order ${orderId}`);
        await this.prisma.$transaction(async (tx) => {
            await tx.transaction.updateMany({
                where: {
                    orderId,
                    stripeTransactionId: transfer.id
                },
                data: {
                    status: 'COMPLETED'
                }
            });
            if (transfer.reversed) {
                this.logger.error(`Transfer created but was already reversed: ${transfer.id}`);
                await tx.transaction.updateMany({
                    where: {
                        orderId,
                        stripeTransactionId: transfer.id
                    },
                    data: {
                        status: 'FAILED',
                        description: 'Transfer was reversed'
                    }
                });
                this.logger.error(`Transfer failure - admin should be notified: ${transfer.id} for order ${orderId}`);
            }
            else {
                this.logger.log(`Transfer completed successfully: ${transfer.id} for order ${orderId}, amount: ${transfer.amount / 100}`);
            }
        });
    }
    async handleTransferUpdated(transfer) {
        this.logger.log(`Transfer updated: ${transfer.id}, destination: ${transfer.destination || 'unknown'}`);
        if (transfer.reversed) {
            this.logger.log(`Transfer ${transfer.id} was reversed`);
        }
        const orderId = transfer.metadata?.orderId;
        if (orderId) {
            await this.prisma.transaction.updateMany({
                where: {
                    orderId,
                    stripeTransactionId: transfer.id
                },
                data: {
                    metadata: {
                        transferUpdated: true,
                        updatedAt: new Date().toISOString(),
                        reversed: transfer.reversed || false
                    }
                }
            });
        }
    }
    async handleTransferReversed(transfer) {
        const orderId = transfer.metadata?.orderId;
        if (!orderId)
            return;
        this.logger.warn(`Transfer reversed: ${transfer.id} for order ${orderId}`);
        await this.prisma.transaction.create({
            data: {
                type: 'REFUND',
                status: 'COMPLETED',
                amount: -(transfer.amount / 100),
                currency: transfer.currency.toUpperCase(),
                orderId,
                stripeTransactionId: `${transfer.id}_reversed`,
                description: `Transfer reversed for order`
            }
        });
    }
    async handleAccountUpdated(account, accountId) {
        this.logger.log(`Account updated: ${accountId}`);
        await this.prisma.user.updateMany({
            where: { stripeConnectId: accountId },
            data: {
                onboardingComplete: account.charges_enabled || false,
                payoutsEnabled: account.payouts_enabled || false,
                chargesEnabled: account.charges_enabled || false
            }
        });
    }
    async handleExternalAccountCreated(externalAccount, accountId) {
        this.logger.log(`External account created for: ${accountId}`);
        this.logger.log(`Seller ${accountId} added external account ${externalAccount.id}`);
    }
    async handlePayoutCreated(payout, accountId) {
        this.logger.log(`Payout created: ${payout.id} for account ${accountId}`);
        await this.prisma.payout.updateMany({
            where: { stripePayoutId: payout.id },
            data: { status: 'PROCESSING' }
        });
    }
    async handlePayoutPaid(payout, accountId) {
        this.logger.log(`Payout paid: ${payout.id} for account ${accountId}`);
        await this.prisma.$transaction(async (tx) => {
            await tx.payout.updateMany({
                where: { stripePayoutId: payout.id },
                data: {
                    status: 'PAID',
                    processedAt: new Date()
                }
            });
            this.logger.log(`Payout completed: ${payout.id}, amount: ${payout.amount / 100}, account: ${accountId}`);
        });
    }
    async handlePayoutFailed(payout, accountId) {
        this.logger.error(`Payout failed: ${payout.id} for account ${accountId}`);
        await this.prisma.$transaction(async (tx) => {
            await tx.payout.updateMany({
                where: { stripePayoutId: payout.id },
                data: {
                    status: 'FAILED',
                    failureReason: payout.failure_message || 'Payout failed'
                }
            });
            this.logger.error(`Payout failed for account ${accountId}: ${payout.failure_message}`);
        });
    }
    async handlePayoutCanceled(payout, accountId) {
        this.logger.log(`Payout canceled: ${payout.id} for account ${accountId}`);
        await this.prisma.payout.updateMany({
            where: { stripePayoutId: payout.id },
            data: {
                status: 'CANCELLED',
                failureReason: 'Payout was cancelled'
            }
        });
    }
    async saveWebhookEvent(event, accountId) {
        await this.prisma.webhookEvent.create({
            data: {
                stripeEventId: event.id,
                stripeAccountId: accountId || null,
                eventType: event.type,
                data: event.data.object,
                processedAt: new Date()
            }
        });
    }
    async handlePaymentFailed(paymentIntent) {
        try {
            this.logger.log(`Processing payment failed`, {
                paymentIntentId: paymentIntent.id,
                errorCode: paymentIntent.last_payment_error?.code,
                errorMessage: paymentIntent.last_payment_error?.message
            });
            await this.prisma.$transaction(async (tx) => {
                const order = await tx.order.findFirst({
                    where: { paymentIntentId: paymentIntent.id },
                    include: { buyer: true }
                });
                if (!order) {
                    this.logger.warn(`Order not found for failed payment intent: ${paymentIntent.id}`);
                    return;
                }
                await tx.order.update({
                    where: { id: order.id },
                    data: {
                        paymentStatus: 'failed',
                        metadata: {
                            ...(order.metadata || {}),
                            paymentFailure: {
                                paymentIntentId: paymentIntent.id,
                                errorCode: paymentIntent.last_payment_error?.code,
                                errorMessage: paymentIntent.last_payment_error?.message,
                                declineCode: paymentIntent.last_payment_error?.decline_code,
                                failedAt: new Date().toISOString()
                            }
                        }
                    }
                });
                this.logger.warn(`Payment failed for order ${order.orderNumber}: ${paymentIntent.last_payment_error?.message}`);
            });
        }
        catch (error) {
            this.logger.error(`Error processing payment failure for PI ${paymentIntent.id}`, {
                error: error.message,
                stack: error.stack
            });
        }
    }
    async handleCheckoutCompleted(session) {
        this.logger.log(`Checkout session completed: ${session.id}`);
    }
    async handleCheckoutExpired(session) {
        this.logger.log(`Checkout session expired: ${session.id}`);
    }
    async handlePaymentCanceled(paymentIntent) {
        this.logger.log(`Payment canceled: ${paymentIntent.id}`);
    }
    async handleDisputeCreated(dispute) {
        this.logger.warn(`Dispute created: ${dispute.id} for charge ${dispute.charge}`);
    }
    cleanupProcessedEvents() {
        if (this.processedEvents.size > 1000) {
            const eventsArray = Array.from(this.processedEvents);
            const toDelete = eventsArray.slice(0, 200);
            toDelete.forEach(id => this.processedEvents.delete(id));
            this.logger.log(`Cleaned up ${toDelete.length} old processed events`);
        }
    }
    async getWebhookStats(fromDate) {
        const startDate = fromDate || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        const orders = await this.prisma.order.findMany({
            where: {
                createdAt: { gte: startDate }
            },
            select: {
                id: true,
                status: true,
                paymentStatus: true,
                paymentIntentId: true,
                createdAt: true,
                paidAt: true
            }
        });
        const stats = {
            totalOrders: orders.length,
            pendingOrders: orders.filter(o => o.status === 'PENDING').length,
            paidOrders: orders.filter(o => o.status === 'COMPLETED' || o.status === 'PAID').length,
            failedOrders: orders.filter(o => o.paymentStatus === 'failed').length,
            disputedOrders: orders.filter(o => o.status === 'DISPUTED').length,
            cancelledOrders: orders.filter(o => o.status === 'CANCELLED').length,
            avgProcessingTime: this.calculateAvgProcessingTime(orders),
            processedEventsCount: this.processedEvents.size
        };
        return stats;
    }
    calculateAvgProcessingTime(orders) {
        const paidOrders = orders.filter(o => o.paidAt && o.createdAt);
        if (paidOrders.length === 0)
            return 0;
        const totalTime = paidOrders.reduce((sum, order) => {
            const processingTime = new Date(order.paidAt).getTime() - new Date(order.createdAt).getTime();
            return sum + processingTime;
        }, 0);
        return Math.round(totalTime / paidOrders.length / 1000 / 60);
    }
};
exports.StripeWebhookService = StripeWebhookService;
exports.StripeWebhookService = StripeWebhookService = StripeWebhookService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof stripe_service_1.StripeService !== "undefined" && stripe_service_1.StripeService) === "function" ? _a : Object, typeof (_b = typeof orders_service_1.OrdersService !== "undefined" && orders_service_1.OrdersService) === "function" ? _b : Object, typeof (_c = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _c : Object, typeof (_d = typeof payments_service_1.PaymentsService !== "undefined" && payments_service_1.PaymentsService) === "function" ? _d : Object])
], StripeWebhookService);


/***/ }),
/* 254 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PaymentsService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentsService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const prisma_service_1 = __webpack_require__(10);
const stripe_service_1 = __webpack_require__(243);
let PaymentsService = PaymentsService_1 = class PaymentsService {
    constructor(prisma, stripeService, configService) {
        this.prisma = prisma;
        this.stripeService = stripeService;
        this.configService = configService;
        this.logger = new common_1.Logger(PaymentsService_1.name);
    }
    async setupSellerPayments(userId, dto) {
        try {
            this.logger.log(`Setting up payments for seller ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                include: { sellerProfile: true },
            });
            if (!user || !user.sellerProfile) {
                throw new common_1.BadRequestException('User is not a seller');
            }
            if (user.stripeConnectId) {
                throw new common_1.BadRequestException('Seller already has Stripe Connect account');
            }
            const stripeAccount = await this.stripeService.createConnectAccount({
                email: dto.email,
                firstName: dto.firstName,
                lastName: dto.lastName,
                country: dto.country,
                businessType: dto.businessType,
                phone: dto.phone,
            });
            await this.prisma.user.update({
                where: { id: userId },
                data: {
                    stripeConnectId: stripeAccount.id,
                    onboardingComplete: false,
                    payoutsEnabled: false,
                    chargesEnabled: false,
                },
            });
            const accountLink = await this.stripeService.createAccountLink(stripeAccount.id);
            this.logger.log(`Stripe Connect account created: ${stripeAccount.id} for user ${userId}`);
            return {
                accountId: stripeAccount.id,
                onboardingUrl: accountLink.url,
                expiresAt: new Date(accountLink.expires_at * 1000),
                setupComplete: false,
            };
        }
        catch (error) {
            this.logger.error(`Failed to setup seller payments: ${error.message}`);
            throw error;
        }
    }
    async getSellerPaymentSetup(userId) {
        try {
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: {
                    stripeConnectId: true,
                    onboardingComplete: true,
                    chargesEnabled: true,
                    payoutsEnabled: true,
                },
            });
            if (!user || !user.stripeConnectId) {
                return null;
            }
            const account = await this.stripeService.retrieveAccount(user.stripeConnectId);
            return {
                stripeConnectId: user.stripeConnectId,
                onboardingComplete: account.details_submitted,
                chargesEnabled: account.charges_enabled,
                payoutsEnabled: account.payouts_enabled,
                requiresAction: account.requirements?.currently_due?.length > 0,
                nextAction: account.requirements?.currently_due?.[0] || null,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get seller payment setup: ${error.message}`);
            throw error;
        }
    }
    async configureSellerPayments(userId, dto) {
        try {
            this.logger.log(`Configuring payments for seller ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: { stripeConnectId: true },
            });
            if (!user?.stripeConnectId) {
                throw new common_1.BadRequestException('Seller does not have Stripe Connect account');
            }
            return {
                automaticPayouts: dto.automaticPayouts ?? true,
                payoutSchedule: dto.payoutSchedule ?? 'weekly',
                minimumPayoutAmount: dto.minimumPayoutAmount ?? 25,
                currency: dto.currency ?? 'USD',
                instantPayouts: dto.instantPayouts ?? false,
                emailNotifications: dto.emailNotifications ?? true,
                smsNotifications: dto.smsNotifications ?? false,
            };
        }
        catch (error) {
            this.logger.error(`Failed to configure payments: ${error.message}`);
            throw error;
        }
    }
    async getSellerBalance(userId) {
        try {
            this.logger.log(`Getting balance for seller ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: { stripeConnectId: true },
            });
            if (!user?.stripeConnectId) {
                throw new common_1.BadRequestException('Seller does not have Stripe Connect account');
            }
            const balance = await this.stripeService.getAccountBalance(user.stripeConnectId);
            const formattedBalance = {
                available: balance.available.map(b => ({
                    amount: b.amount / 100,
                    currency: b.currency.toUpperCase(),
                })),
                pending: balance.pending.map(b => ({
                    amount: b.amount / 100,
                    currency: b.currency.toUpperCase(),
                })),
                connectReserved: balance.connect_reserved?.map(b => ({
                    amount: b.amount / 100,
                    currency: b.currency.toUpperCase(),
                })) || [],
            };
            return formattedBalance;
        }
        catch (error) {
            this.logger.error(`Failed to get seller balance: ${error.message}`);
            throw error;
        }
    }
    async requestSellerPayout(userId, amount, currency = 'USD') {
        try {
            this.logger.log(`Processing payout request for seller ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: { stripeConnectId: true },
            });
            if (!user?.stripeConnectId) {
                throw new common_1.BadRequestException('Seller does not have Stripe Connect account');
            }
            const canReceivePayouts = await this.stripeService.isAccountReadyForPayments(user.stripeConnectId);
            if (!canReceivePayouts) {
                throw new common_1.BadRequestException('Account is not ready to receive payouts');
            }
            let payoutAmount = amount;
            if (!payoutAmount) {
                const balance = await this.stripeService.getAccountBalance(user.stripeConnectId);
                const availableInCurrency = balance.available.find(b => b.currency === currency.toLowerCase());
                if (!availableInCurrency || availableInCurrency.amount < 100) {
                    throw new common_1.BadRequestException('Insufficient balance for payout');
                }
                payoutAmount = availableInCurrency.amount / 100;
            }
            const payout = await this.stripeService.createPayout({
                amount: payoutAmount,
                currency,
                stripeAccountId: user.stripeConnectId,
                method: 'standard',
            });
            const payoutRecord = await this.prisma.payout.create({
                data: {
                    sellerId: userId,
                    amount: payoutAmount,
                    currency,
                    status: 'PENDING',
                    stripePayoutId: payout.id,
                    description: `Manual payout request`,
                    requestedAt: new Date(),
                },
            });
            return {
                payoutId: payoutRecord.id,
                stripePayoutId: payout.id,
                amount: payoutAmount,
                currency,
                status: payout.status,
                estimatedArrival: new Date(payout.arrival_date * 1000),
            };
        }
        catch (error) {
            this.logger.error(`Failed to request payout: ${error.message}`);
            throw error;
        }
    }
    async getSellerPayoutHistory(userId, options = {}) {
        try {
            this.logger.log(`Getting payout history for seller ${userId}`);
            const payouts = await this.prisma.payout.findMany({
                where: { sellerId: userId },
                orderBy: { createdAt: 'desc' },
                take: options.limit || 20,
                ...(options.startingAfter && {
                    cursor: { id: options.startingAfter },
                    skip: 1,
                }),
            });
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: { stripeConnectId: true },
            });
            if (user?.stripeConnectId) {
                const stripePayouts = await this.stripeService.listPayouts(user.stripeConnectId, options.limit || 20);
                const combinedData = payouts.map(payout => {
                    const stripePayout = stripePayouts.data.find(sp => sp.id === payout.stripePayoutId);
                    return {
                        id: payout.id,
                        amount: payout.amount,
                        currency: payout.currency,
                        status: payout.status,
                        requestedAt: payout.requestedAt,
                        processedAt: payout.processedAt,
                        description: payout.description,
                        stripeData: stripePayout ? {
                            arrivalDate: new Date(stripePayout.arrival_date * 1000),
                            method: stripePayout.method,
                            type: stripePayout.type,
                        } : null,
                    };
                });
                return {
                    data: combinedData,
                    hasMore: stripePayouts.has_more,
                };
            }
            return {
                data: payouts,
                hasMore: false,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payout history: ${error.message}`);
            throw error;
        }
    }
    async generateStripeDashboardLink(userId) {
        try {
            this.logger.log(`Generating dashboard link for seller ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: { stripeConnectId: true },
            });
            if (!user?.stripeConnectId) {
                throw new common_1.BadRequestException('Seller does not have Stripe Connect account');
            }
            const loginLink = await this.stripeService.createLoginLink(user.stripeConnectId);
            return {
                url: loginLink.url,
                expiresAt: new Date(Date.now() + 60 * 60 * 1000),
            };
        }
        catch (error) {
            this.logger.error(`Failed to generate dashboard link: ${error.message}`);
            throw error;
        }
    }
    async getSellerAccountStatus(userId) {
        try {
            this.logger.log(`Getting account status for seller ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: { stripeConnectId: true },
            });
            if (!user?.stripeConnectId) {
                throw new common_1.NotFoundException('Seller does not have Stripe Connect account');
            }
            const account = await this.stripeService.retrieveAccount(user.stripeConnectId);
            return {
                accountId: account.id,
                email: account.email,
                country: account.country,
                currency: account.default_currency,
                businessType: account.business_type,
                chargesEnabled: account.charges_enabled,
                payoutsEnabled: account.payouts_enabled,
                detailsSubmitted: account.details_submitted,
                capabilities: {
                    cardPayments: account.capabilities?.card_payments,
                    transfers: account.capabilities?.transfers,
                },
                requirements: {
                    currentlyDue: account.requirements?.currently_due || [],
                    eventuallyDue: account.requirements?.eventually_due || [],
                    pastDue: account.requirements?.past_due || [],
                    pendingVerification: account.requirements?.pending_verification || [],
                },
                payouts: {
                    schedule: account.settings?.payouts?.schedule,
                    statementDescriptor: account.settings?.payouts?.statement_descriptor,
                },
                created: new Date(account.created * 1000),
            };
        }
        catch (error) {
            this.logger.error(`Failed to get account status: ${error.message}`);
            throw error;
        }
    }
    async getPaymentStatistics() {
        try {
            this.logger.log('Getting payment statistics for admin');
            const totalSellers = await this.prisma.user.count({
                where: {
                    role: 'SELLER',
                    stripeConnectId: { not: null },
                },
            });
            const activeSellers = await this.prisma.user.count({
                where: {
                    role: 'SELLER',
                    stripeConnectId: { not: null },
                    payoutsEnabled: true,
                },
            });
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            const recentPayouts = await this.prisma.payout.findMany({
                where: {
                    createdAt: { gte: thirtyDaysAgo },
                },
            });
            const totalPayouts = recentPayouts.length;
            const totalPayoutAmount = recentPayouts.reduce((sum, payout) => sum + Number(payout.amount), 0);
            const recentTransactions = await this.prisma.transaction.count({
                where: {
                    createdAt: { gte: thirtyDaysAgo },
                    type: 'SALE',
                },
            });
            return {
                sellers: {
                    total: totalSellers,
                    active: activeSellers,
                    pendingOnboarding: totalSellers - activeSellers,
                },
                payouts: {
                    count: totalPayouts,
                    totalAmount: totalPayoutAmount,
                    averageAmount: totalPayouts > 0 ? totalPayoutAmount / totalPayouts : 0,
                },
                transactions: {
                    recentSales: recentTransactions,
                },
                period: {
                    from: thirtyDaysAgo,
                    to: new Date(),
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payment statistics: ${error.message}`);
            throw error;
        }
    }
    async processAccountUpdated(accountId, accountData) {
        try {
            this.logger.log(`Processing account update for ${accountId}`);
            await this.prisma.user.updateMany({
                where: { stripeConnectId: accountId },
                data: {
                    onboardingComplete: accountData.details_submitted,
                    chargesEnabled: accountData.charges_enabled,
                    payoutsEnabled: accountData.payouts_enabled,
                },
            });
            this.logger.log(`Account ${accountId} updated successfully`);
        }
        catch (error) {
            this.logger.error(`Failed to process account update: ${error.message}`);
            throw error;
        }
    }
    async processPayoutCompleted(payoutData) {
        try {
            this.logger.log(`Processing payout completion for ${payoutData.id}`);
            await this.prisma.payout.updateMany({
                where: { stripePayoutId: payoutData.id },
                data: {
                    status: 'PAID',
                    processedAt: new Date(),
                },
            });
            this.logger.log(`Payout ${payoutData.id} marked as completed`);
        }
        catch (error) {
            this.logger.error(`Failed to process payout completion: ${error.message}`);
            throw error;
        }
    }
    async processPayoutFailed(payoutData) {
        try {
            this.logger.log(`Processing payout failure for ${payoutData.id}`);
            await this.prisma.payout.updateMany({
                where: { stripePayoutId: payoutData.id },
                data: {
                    status: 'FAILED',
                    failureReason: payoutData.failure_message || 'Unknown error',
                },
            });
            this.logger.log(`Payout ${payoutData.id} marked as failed`);
        }
        catch (error) {
            this.logger.error(`Failed to process payout failure: ${error.message}`);
            throw error;
        }
    }
};
exports.PaymentsService = PaymentsService;
exports.PaymentsService = PaymentsService = PaymentsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof stripe_service_1.StripeService !== "undefined" && stripe_service_1.StripeService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], PaymentsService);


/***/ }),
/* 255 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentsModule = void 0;
const common_1 = __webpack_require__(2);
const payments_service_1 = __webpack_require__(254);
const payments_controller_1 = __webpack_require__(256);
const payment_checkout_controller_1 = __webpack_require__(260);
const paypal_service_1 = __webpack_require__(259);
const stripe_module_1 = __webpack_require__(246);
const prisma_module_1 = __webpack_require__(9);
let PaymentsModule = class PaymentsModule {
};
exports.PaymentsModule = PaymentsModule;
exports.PaymentsModule = PaymentsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            stripe_module_1.StripeModule,
            prisma_module_1.PrismaModule
        ],
        controllers: [
            payments_controller_1.PaymentsController,
            payment_checkout_controller_1.PaymentCheckoutController,
        ],
        providers: [
            payments_service_1.PaymentsService,
            paypal_service_1.PayPalService,
        ],
        exports: [
            payments_service_1.PaymentsService,
            paypal_service_1.PayPalService,
        ],
    })
], PaymentsModule);


/***/ }),
/* 256 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PaymentsController_1;
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const payments_service_1 = __webpack_require__(254);
const seller_onboarding_dto_1 = __webpack_require__(257);
const payment_setup_dto_1 = __webpack_require__(258);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const current_user_decorator_1 = __webpack_require__(26);
const client_1 = __webpack_require__(11);
const stripe_service_1 = __webpack_require__(243);
const paypal_service_1 = __webpack_require__(259);
let PaymentsController = PaymentsController_1 = class PaymentsController {
    constructor(paymentsService, stripeService, paypalService) {
        this.paymentsService = paymentsService;
        this.stripeService = stripeService;
        this.paypalService = paypalService;
        this.logger = new common_1.Logger(PaymentsController_1.name);
    }
    async createStripePaymentIntent(createIntentDto, user) {
        try {
            this.logger.log(`Creating Stripe Payment Intent for user ${user.id}, amount: ${createIntentDto.amount}`);
            if (!createIntentDto.amount || createIntentDto.amount <= 0) {
                throw new common_1.BadRequestException('Amount must be greater than 0');
            }
            if (!createIntentDto.cartItems || createIntentDto.cartItems.length === 0) {
                throw new common_1.BadRequestException('Cart items are required');
            }
            const paymentIntent = await this.stripeService.createPaymentIntent(createIntentDto.amount, createIntentDto.currency, {
                userId: user.id,
                customerEmail: createIntentDto.customerInfo.email,
                customerName: createIntentDto.customerInfo.name,
                itemCount: createIntentDto.cartItems.length.toString(),
            });
            return {
                success: true,
                clientSecret: paymentIntent.client_secret,
                paymentIntentId: paymentIntent.id,
            };
        }
        catch (error) {
            this.logger.error(`Failed to create Payment Intent: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to create payment intent: ${error.message}`);
        }
    }
    async createPayPalOrder(createOrderDto, user) {
        try {
            this.logger.log(`Creating PayPal order for user ${user.id}, amount: ${createOrderDto.amount}`);
            if (!createOrderDto.amount || createOrderDto.amount <= 0) {
                throw new common_1.BadRequestException('Amount must be greater than 0');
            }
            if (!createOrderDto.cartItems || createOrderDto.cartItems.length === 0) {
                throw new common_1.BadRequestException('Cart items are required');
            }
            const paypalItems = createOrderDto.cartItems.map(item => ({
                name: item.name || item.productTitle || 'Digital Product',
                price: item.price || item.currentPrice || 0,
                quantity: item.quantity || 1,
            }));
            const paypalOrder = await this.paypalService.createOrder({
                amount: createOrderDto.amount,
                currency: createOrderDto.currency,
                items: paypalItems,
                metadata: {
                    userId: user.id,
                    customerEmail: createOrderDto.customerInfo.email,
                    customerName: createOrderDto.customerInfo.name,
                }
            });
            return {
                success: true,
                orderId: paypalOrder.orderId,
                approvalUrl: paypalOrder.approvalUrl,
                status: paypalOrder.status,
            };
        }
        catch (error) {
            this.logger.error(`Failed to create PayPal order: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to create PayPal order: ${error.message}`);
        }
    }
    async capturePayPalOrder(captureDto, user) {
        try {
            this.logger.log(`Capturing PayPal order ${captureDto.orderId} for user ${user.id}`);
            const captureResult = await this.paypalService.captureOrder(captureDto.orderId);
            if (captureResult.status === 'COMPLETED') {
                return {
                    success: true,
                    status: 'COMPLETED',
                    paymentId: captureResult.paymentId,
                    amount: captureResult.amount,
                    currency: captureResult.currency,
                };
            }
            else {
                throw new common_1.BadRequestException('Payment capture was not completed');
            }
        }
        catch (error) {
            this.logger.error(`Failed to capture PayPal order: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to capture PayPal payment: ${error.message}`);
        }
    }
    async getPaymentDetails(paymentId, orderId, user) {
        try {
            if (!paymentId && !orderId) {
                throw new common_1.BadRequestException('Either payment_id or order_id is required');
            }
            let paymentDetails;
            if (paymentId) {
                this.logger.log(`Getting Stripe payment details for ${paymentId}`);
                paymentDetails = await this.stripeService.getPaymentDetails(paymentId);
                if (user && paymentDetails.metadata?.userId !== user.id) {
                    throw new common_1.BadRequestException('Unauthorized access to payment details');
                }
            }
            else if (orderId) {
                this.logger.log(`Getting PayPal payment details for ${orderId}`);
                const paypalDetails = await this.paypalService.getOrderDetails(orderId);
                paymentDetails = {
                    paymentId: orderId,
                    amount: parseFloat(paypalDetails.purchase_units[0]?.amount?.value || '0'),
                    currency: paypalDetails.purchase_units[0]?.amount?.currency_code || 'USD',
                    status: paypalDetails.status?.toLowerCase() || 'unknown',
                    customerEmail: paypalDetails.payer?.email_address,
                    createdAt: paypalDetails.create_time,
                };
            }
            return {
                success: true,
                data: {
                    id: paymentDetails.paymentId,
                    amount: paymentDetails.amount,
                    currency: paymentDetails.currency,
                    status: paymentDetails.status,
                    method: paymentId ? 'stripe' : 'paypal',
                    createdAt: paymentDetails.createdAt,
                    orderItems: [
                        {
                            productTitle: 'Productos digitales',
                            seller: 'Varios vendedores',
                            price: paymentDetails.amount,
                        }
                    ],
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payment details: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get payment details: ${error.message}`);
        }
    }
    async setupSeller(onboardingDto, user) {
        try {
            this.logger.log(`Setting up seller payment for user ${user.id}`);
            const existingSetup = await this.paymentsService.getSellerPaymentSetup(user.id);
            if (existingSetup && existingSetup.stripeConnectId) {
                throw new common_1.ConflictException('Seller already has payment setup configured');
            }
            const result = await this.paymentsService.setupSellerPayments(user.id, onboardingDto);
            return {
                success: true,
                message: 'Seller payment setup initiated',
                data: {
                    accountId: result.accountId,
                    onboardingUrl: result.onboardingUrl,
                    expiresAt: result.expiresAt,
                    setupComplete: result.setupComplete,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to setup seller: ${error.message}`);
            if (error instanceof common_1.ConflictException) {
                throw error;
            }
            throw new common_1.BadRequestException(`Failed to setup seller: ${error.message}`);
        }
    }
    async getSellerSetupStatus(user) {
        try {
            this.logger.log(`Getting setup status for seller ${user.id}`);
            const setup = await this.paymentsService.getSellerPaymentSetup(user.id);
            if (!setup) {
                throw new common_1.NotFoundException('No payment setup found for this seller');
            }
            return {
                success: true,
                data: {
                    hasStripeAccount: !!setup.stripeConnectId,
                    onboardingComplete: setup.onboardingComplete,
                    chargesEnabled: setup.chargesEnabled,
                    payoutsEnabled: setup.payoutsEnabled,
                    requiresAction: setup.requiresAction,
                    nextAction: setup.nextAction,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get setup status: ${error.message}`);
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.BadRequestException(`Failed to get setup status: ${error.message}`);
        }
    }
    async configurePayments(setupDto, user) {
        try {
            this.logger.log(`Configuring payments for seller ${user.id}`);
            const result = await this.paymentsService.configureSellerPayments(user.id, setupDto);
            return {
                success: true,
                message: 'Payment configuration updated successfully',
                data: result,
            };
        }
        catch (error) {
            this.logger.error(`Failed to configure payments: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to configure payments: ${error.message}`);
        }
    }
    async getSellerBalance(user) {
        try {
            this.logger.log(`Getting balance for seller ${user.id}`);
            const balance = await this.paymentsService.getSellerBalance(user.id);
            return {
                success: true,
                data: balance,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get balance: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get balance: ${error.message}`);
        }
    }
    async testPaymentsModule() {
        return {
            success: true,
            message: 'Payments module is working correctly',
            timestamp: new Date().toISOString(),
            module: 'PaymentsModule',
        };
    }
    async testConnectivity() {
        try {
            const [stripeTest, paypalTest] = await Promise.allSettled([
                this.stripeService.testConnection(),
                this.paypalService.testConnection(),
            ]);
            return {
                success: true,
                timestamp: new Date().toISOString(),
                stripe: stripeTest.status === 'fulfilled' ? stripeTest.value : { success: false, message: 'Connection failed' },
                paypal: paypalTest.status === 'fulfilled' ? paypalTest.value : { success: false, message: 'Connection failed' },
            };
        }
        catch (error) {
            return {
                success: false,
                message: 'Connectivity test failed',
                error: error.message,
            };
        }
    }
};
exports.PaymentsController = PaymentsController;
__decorate([
    (0, common_1.Post)('stripe/create-intent'),
    (0, swagger_1.ApiOperation)({
        summary: 'Create Stripe Payment Intent',
        description: 'Creates a Stripe Payment Intent for frontend checkout'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Payment Intent created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request data' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "createStripePaymentIntent", null);
__decorate([
    (0, common_1.Post)('paypal/create-order'),
    (0, swagger_1.ApiOperation)({
        summary: 'Create PayPal order',
        description: 'Creates a PayPal order for frontend checkout'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'PayPal order created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request data' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "createPayPalOrder", null);
__decorate([
    (0, common_1.Post)('paypal/capture-order'),
    (0, swagger_1.ApiOperation)({
        summary: 'Capture PayPal payment',
        description: 'Captures a PayPal payment after user approval'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'PayPal payment captured successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Capture failed' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "capturePayPalOrder", null);
__decorate([
    (0, common_1.Get)('details'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get payment details',
        description: 'Retrieves payment details for success page'
    }),
    (0, swagger_1.ApiQuery)({ name: 'payment_id', required: false, description: 'Stripe Payment Intent ID' }),
    (0, swagger_1.ApiQuery)({ name: 'order_id', required: false, description: 'PayPal Order ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payment details retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Payment not found' }),
    __param(0, (0, common_1.Query)('payment_id')),
    __param(1, (0, common_1.Query)('order_id')),
    __param(2, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "getPaymentDetails", null);
__decorate([
    (0, common_1.Post)('setup-seller'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Setup seller for payments',
        description: 'Initiates the Stripe Connect onboarding process for a seller'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Seller setup initiated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input or seller already setup' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Seller already has payment setup' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof seller_onboarding_dto_1.SellerOnboardingDto !== "undefined" && seller_onboarding_dto_1.SellerOnboardingDto) === "function" ? _d : Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "setupSeller", null);
__decorate([
    (0, common_1.Get)('seller-setup'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller payment setup status',
        description: 'Returns the current payment setup status for the authenticated seller'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Setup status retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'No payment setup found' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "getSellerSetupStatus", null);
__decorate([
    (0, common_1.Post)('configure'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Configure payment preferences',
        description: 'Configure payout settings and preferences for a seller'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payment configuration updated' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid configuration or seller not setup' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof payment_setup_dto_1.PaymentSetupDto !== "undefined" && payment_setup_dto_1.PaymentSetupDto) === "function" ? _e : Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "configurePayments", null);
__decorate([
    (0, common_1.Get)('balance'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller balance',
        description: 'Returns the current balance and pending amounts for a seller'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Balance retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "getSellerBalance", null);
__decorate([
    (0, common_1.Get)('test'),
    (0, swagger_1.ApiOperation)({
        summary: 'Test payments module',
        description: 'Simple test endpoint to verify the module is working'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Test successful' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "testPaymentsModule", null);
__decorate([
    (0, common_1.Get)('test/connectivity'),
    (0, swagger_1.ApiOperation)({
        summary: 'Test payment providers connectivity',
        description: 'Tests connectivity to Stripe and PayPal'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PaymentsController.prototype, "testConnectivity", null);
exports.PaymentsController = PaymentsController = PaymentsController_1 = __decorate([
    (0, swagger_1.ApiTags)('payments'),
    (0, common_1.Controller)('api/payments'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof payments_service_1.PaymentsService !== "undefined" && payments_service_1.PaymentsService) === "function" ? _a : Object, typeof (_b = typeof stripe_service_1.StripeService !== "undefined" && stripe_service_1.StripeService) === "function" ? _b : Object, typeof (_c = typeof paypal_service_1.PayPalService !== "undefined" && paypal_service_1.PayPalService) === "function" ? _c : Object])
], PaymentsController);


/***/ }),
/* 257 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SellerOnboardingDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class SellerOnboardingDto {
}
exports.SellerOnboardingDto = SellerOnboardingDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Seller email address',
        example: 'seller@example.com',
    }),
    (0, class_validator_1.IsEmail)({}, { message: 'email.invalid' }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "email", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'First name of the seller',
        example: 'John',
        minLength: 2,
        maxLength: 50,
    }),
    (0, class_validator_1.IsString)({ message: 'firstName.invalid' }),
    (0, class_validator_1.MinLength)(2, { message: 'firstName.tooShort' }),
    (0, class_validator_1.MaxLength)(50, { message: 'firstName.tooLong' }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Last name of the seller',
        example: 'Doe',
        minLength: 2,
        maxLength: 50,
    }),
    (0, class_validator_1.IsString)({ message: 'lastName.invalid' }),
    (0, class_validator_1.MinLength)(2, { message: 'lastName.tooShort' }),
    (0, class_validator_1.MaxLength)(50, { message: 'lastName.tooLong' }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Country code where seller operates',
        example: 'US',
        enum: ['US', 'CA', 'MX', 'AR', 'CL', 'CO', 'PE', 'BR', 'GB', 'DE', 'FR', 'ES', 'IT'],
    }),
    (0, class_validator_1.IsString)({ message: 'country.invalid' }),
    (0, class_validator_1.IsIn)(['US', 'CA', 'MX', 'AR', 'CL', 'CO', 'PE', 'BR', 'GB', 'DE', 'FR', 'ES', 'IT'], {
        message: 'country.notSupported',
    }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "country", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Store name for the seller',
        example: 'Modern Furniture Co.',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'storeName.invalid' }),
    (0, class_validator_1.MaxLength)(100, { message: 'storeName.tooLong' }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "storeName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Business website URL',
        example: 'https://modernfurniture.com',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'website.invalid' }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "website", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Phone number',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'phone.invalid' }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "phone", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Business type',
        example: 'individual',
        enum: ['individual', 'company'],
        default: 'individual',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['individual', 'company'], { message: 'businessType.invalid' }),
    __metadata("design:type", String)
], SellerOnboardingDto.prototype, "businessType", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Agree to terms and conditions',
        example: true,
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'agreeToTerms.invalid' }),
    __metadata("design:type", Boolean)
], SellerOnboardingDto.prototype, "agreeToTerms", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Enable automatic payouts',
        example: true,
        default: true,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'automaticPayouts.invalid' }),
    __metadata("design:type", Boolean)
], SellerOnboardingDto.prototype, "automaticPayouts", void 0);


/***/ }),
/* 258 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentSetupDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class PaymentSetupDto {
}
exports.PaymentSetupDto = PaymentSetupDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Stripe Connect account ID',
        example: 'acct_1234567890',
    }),
    (0, class_validator_1.IsString)({ message: 'stripeAccountId.invalid' }),
    __metadata("design:type", String)
], PaymentSetupDto.prototype, "stripeAccountId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Enable automatic payouts',
        example: true,
        default: true,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'automaticPayouts.invalid' }),
    __metadata("design:type", Boolean)
], PaymentSetupDto.prototype, "automaticPayouts", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Payout schedule frequency',
        example: 'weekly',
        enum: ['daily', 'weekly', 'monthly'],
        default: 'weekly',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['daily', 'weekly', 'monthly'], { message: 'payoutSchedule.invalid' }),
    __metadata("design:type", String)
], PaymentSetupDto.prototype, "payoutSchedule", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum payout amount (in dollars)',
        example: 25.00,
        minimum: 1,
        maximum: 10000,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'minimumPayoutAmount.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'minimumPayoutAmount.tooSmall' }),
    (0, class_validator_1.Max)(10000, { message: 'minimumPayoutAmount.tooLarge' }),
    __metadata("design:type", Number)
], PaymentSetupDto.prototype, "minimumPayoutAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Preferred currency for payouts',
        example: 'USD',
        enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'], {
        message: 'currency.notSupported',
    }),
    __metadata("design:type", String)
], PaymentSetupDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Enable instant payouts (if available)',
        example: false,
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'instantPayouts.invalid' }),
    __metadata("design:type", Boolean)
], PaymentSetupDto.prototype, "instantPayouts", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Email notifications for payouts',
        example: true,
        default: true,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'emailNotifications.invalid' }),
    __metadata("design:type", Boolean)
], PaymentSetupDto.prototype, "emailNotifications", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'SMS notifications for payouts',
        example: false,
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'smsNotifications.invalid' }),
    __metadata("design:type", Boolean)
], PaymentSetupDto.prototype, "smsNotifications", void 0);


/***/ }),
/* 259 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var PayPalService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayPalService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
let PayPalService = PayPalService_1 = class PayPalService {
    constructor(configService) {
        this.configService = configService;
        this.logger = new common_1.Logger(PayPalService_1.name);
        this.accessToken = null;
        this.tokenExpiry = null;
    }
    async getAccessToken() {
        if (this.accessToken && this.tokenExpiry && new Date() < this.tokenExpiry) {
            return this.accessToken;
        }
        try {
            const clientId = this.configService.get('PAYPAL_CLIENT_ID');
            const clientSecret = this.configService.get('PAYPAL_CLIENT_SECRET');
            const baseUrl = this.configService.get('PAYPAL_BASE_URL', 'https://api.sandbox.paypal.com');
            if (!clientId || !clientSecret) {
                throw new Error('PayPal credentials not configured');
            }
            const auth = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
            const response = await fetch(`${baseUrl}/v1/oauth2/token`, {
                method: 'POST',
                headers: {
                    'Authorization': `Basic ${auth}`,
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: 'grant_type=client_credentials'
            });
            if (!response.ok) {
                throw new Error(`PayPal auth failed: ${response.status}`);
            }
            const data = await response.json();
            this.accessToken = data.access_token;
            this.tokenExpiry = new Date(Date.now() + (data.expires_in * 1000));
            this.logger.log('PayPal access token obtained successfully');
            return this.accessToken;
        }
        catch (error) {
            this.logger.error(`Failed to get PayPal access token: ${error.message}`);
            throw new common_1.BadRequestException('Failed to authenticate with PayPal');
        }
    }
    async createOrder(orderRequest) {
        try {
            const accessToken = await this.getAccessToken();
            const baseUrl = this.configService.get('PAYPAL_BASE_URL', 'https://api.sandbox.paypal.com');
            const orderData = {
                intent: 'CAPTURE',
                purchase_units: [{
                        amount: {
                            currency_code: orderRequest.currency.toUpperCase(),
                            value: orderRequest.amount.toFixed(2),
                            breakdown: {
                                item_total: {
                                    currency_code: orderRequest.currency.toUpperCase(),
                                    value: orderRequest.amount.toFixed(2)
                                }
                            }
                        },
                        items: orderRequest.items.map(item => ({
                            name: item.name,
                            unit_amount: {
                                currency_code: orderRequest.currency.toUpperCase(),
                                value: item.price.toFixed(2)
                            },
                            quantity: (item.quantity || 1).toString(),
                            category: 'DIGITAL_GOODS'
                        }))
                    }],
                application_context: {
                    return_url: `${this.configService.get('FRONTEND_URL')}/checkout/success`,
                    cancel_url: `${this.configService.get('FRONTEND_URL')}/checkout/error`,
                    shipping_preference: 'NO_SHIPPING',
                    user_action: 'PAY_NOW',
                    brand_name: 'Furnibles'
                }
            };
            const response = await fetch(`${baseUrl}/v2/checkout/orders`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(orderData)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`PayPal order creation failed: ${JSON.stringify(errorData)}`);
            }
            const order = await response.json();
            const approvalUrl = order.links.find((link) => link.rel === 'approve')?.href;
            if (!approvalUrl) {
                throw new Error('No approval URL received from PayPal');
            }
            this.logger.log(`PayPal order created: ${order.id}`);
            return {
                orderId: order.id,
                approvalUrl,
                status: order.status
            };
        }
        catch (error) {
            this.logger.error(`Failed to create PayPal order: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to create PayPal order: ${error.message}`);
        }
    }
    async captureOrder(orderId) {
        try {
            const accessToken = await this.getAccessToken();
            const baseUrl = this.configService.get('PAYPAL_BASE_URL', 'https://api.sandbox.paypal.com');
            const response = await fetch(`${baseUrl}/v2/checkout/orders/${orderId}/capture`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                }
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`PayPal capture failed: ${JSON.stringify(errorData)}`);
            }
            const captureData = await response.json();
            const capture = captureData.purchase_units[0].payments.captures[0];
            this.logger.log(`PayPal order captured: ${orderId}`);
            return {
                paymentId: capture.id,
                status: capture.status,
                amount: parseFloat(capture.amount.value),
                currency: capture.amount.currency_code,
                payerEmail: captureData.payer.email_address
            };
        }
        catch (error) {
            this.logger.error(`Failed to capture PayPal order: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to capture PayPal payment: ${error.message}`);
        }
    }
    async getOrderDetails(orderId) {
        try {
            const accessToken = await this.getAccessToken();
            const baseUrl = this.configService.get('PAYPAL_BASE_URL', 'https://api.sandbox.paypal.com');
            const response = await fetch(`${baseUrl}/v2/checkout/orders/${orderId}`, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                }
            });
            if (!response.ok) {
                throw new Error(`Failed to get PayPal order details: ${response.status}`);
            }
            return await response.json();
        }
        catch (error) {
            this.logger.error(`Failed to get PayPal order details: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get order details: ${error.message}`);
        }
    }
    verifyWebhook(body, headers) {
        this.logger.warn('PayPal webhook verification not fully implemented');
        return true;
    }
    async testConnection() {
        try {
            await this.getAccessToken();
            return {
                success: true,
                message: 'PayPal connection successful'
            };
        }
        catch (error) {
            return {
                success: false,
                message: `PayPal connection failed: ${error.message}`
            };
        }
    }
};
exports.PayPalService = PayPalService;
exports.PayPalService = PayPalService = PayPalService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _a : Object])
], PayPalService);


/***/ }),
/* 260 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PaymentCheckoutController_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PaymentCheckoutController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const jwt_auth_guard_1 = __webpack_require__(24);
const current_user_decorator_1 = __webpack_require__(26);
const stripe_service_1 = __webpack_require__(243);
const paypal_service_1 = __webpack_require__(259);
const prisma_service_1 = __webpack_require__(10);
let PaymentCheckoutController = PaymentCheckoutController_1 = class PaymentCheckoutController {
    constructor(stripeService, paypalService, prisma) {
        this.stripeService = stripeService;
        this.paypalService = paypalService;
        this.prisma = prisma;
        this.logger = new common_1.Logger(PaymentCheckoutController_1.name);
    }
    async createStripePaymentIntent(createIntentDto, user) {
        try {
            this.logger.log(`Creating Stripe Payment Intent for user ${user.id}`);
            if (!createIntentDto.amount || createIntentDto.amount <= 0) {
                throw new common_1.BadRequestException('Amount must be greater than 0');
            }
            if (!createIntentDto.cartItems || createIntentDto.cartItems.length === 0) {
                throw new common_1.BadRequestException('Cart items are required');
            }
            const cartItems = await this.prisma.cartItem.findMany({
                where: { userId: user.id },
                include: {
                    product: {
                        include: {
                            seller: {
                                include: {
                                    sellerProfile: true
                                }
                            }
                        }
                    }
                }
            });
            if (!cartItems || cartItems.length === 0) {
                throw new common_1.BadRequestException('Cart is empty');
            }
            const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substring(2, 8).toUpperCase()}`;
            const paymentIntent = await this.stripeService.createPaymentIntent(createIntentDto.amount, createIntentDto.currency, {
                userId: user.id.toString(),
                customerEmail: createIntentDto.customerInfo.email,
                customerName: createIntentDto.customerInfo.name,
                orderNumber: orderNumber,
                itemCount: cartItems.length.toString(),
            });
            const order = await this.prisma.order.create({
                data: {
                    orderNumber: orderNumber,
                    buyerId: user.id,
                    subtotal: createIntentDto.amount,
                    subtotalAmount: createIntentDto.amount,
                    platformFeeRate: 0.10,
                    platformFee: createIntentDto.amount * 0.10,
                    totalAmount: createIntentDto.amount,
                    sellerAmount: createIntentDto.amount * 0.90,
                    status: 'PENDING',
                    paymentIntentId: paymentIntent.id,
                    paymentStatus: 'pending',
                    buyerEmail: createIntentDto.customerInfo.email,
                    billingData: createIntentDto.customerInfo,
                    metadata: {
                        customerInfo: createIntentDto.customerInfo,
                        paymentMethod: 'stripe',
                        cartItemsCount: cartItems.length,
                        createdAt: new Date().toISOString(),
                    },
                    items: {
                        create: cartItems.map(item => ({
                            productId: item.productId,
                            sellerId: item.product.sellerId,
                            productTitle: item.product.title,
                            productSlug: item.product.slug,
                            price: item.priceSnapshot,
                            quantity: item.quantity,
                            sellerName: `${item.product.seller.firstName} ${item.product.seller.lastName}`,
                            storeName: item.product.seller.sellerProfile?.storeName || 'Unknown Store',
                        }))
                    }
                },
                include: {
                    items: true,
                    buyer: true
                }
            });
            this.logger.log(`Payment Intent created: ${paymentIntent.id} for order ${order.id}`);
            return {
                success: true,
                clientSecret: paymentIntent.client_secret,
                paymentIntentId: paymentIntent.id,
                orderId: order.id,
                orderNumber: order.orderNumber,
            };
        }
        catch (error) {
            this.logger.error(`Failed to create Payment Intent: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to create payment intent: ${error.message}`);
        }
    }
    async confirmStripePayment(paymentIntentId, user) {
        try {
            this.logger.log(`Confirming Stripe payment ${paymentIntentId} for user ${user.id}`);
            const order = await this.prisma.order.findFirst({
                where: {
                    paymentIntentId: paymentIntentId,
                    buyerId: user.id
                },
                include: {
                    items: true,
                    buyer: true
                }
            });
            if (!order) {
                throw new common_1.NotFoundException('Order not found or unauthorized');
            }
            const paymentIntent = await this.stripeService.retrievePaymentIntent(paymentIntentId);
            if (paymentIntent.status !== 'succeeded') {
                throw new common_1.BadRequestException('Payment has not been completed');
            }
            const updatedOrder = await this.prisma.order.update({
                where: { id: order.id },
                data: {
                    status: 'PAID',
                    paymentStatus: 'completed',
                    paidAt: new Date(),
                    completedAt: new Date(),
                    metadata: {
                        ...order.metadata,
                        paymentId: paymentIntent.id,
                        stripeChargeId: paymentIntent.latest_charge,
                        completedAt: new Date().toISOString(),
                    }
                }
            });
            await this.prisma.cartItem.deleteMany({
                where: { userId: user.id }
            });
            const downloadTokens = [];
            for (const item of order.items) {
                const downloadToken = await this.prisma.downloadToken.create({
                    data: {
                        token: `DT-${Date.now()}-${Math.random().toString(36).substring(2, 8).toUpperCase()}`,
                        orderId: order.id,
                        productId: item.productId,
                        buyerId: user.id,
                        downloadLimit: 5,
                        downloadCount: 0,
                        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                        isActive: true,
                    }
                });
                downloadTokens.push(downloadToken);
            }
            this.logger.log(`Stripe payment completed for order ${order.id} with ${downloadTokens.length} download tokens`);
            return {
                success: true,
                status: 'COMPLETED',
                paymentId: paymentIntent.id,
                orderId: order.id,
                orderNumber: order.orderNumber,
                downloadTokensCount: downloadTokens.length,
            };
        }
        catch (error) {
            this.logger.error(`Failed to confirm Stripe payment: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to confirm payment: ${error.message}`);
        }
    }
    async createPayPalOrder(createOrderDto, user) {
        try {
            this.logger.log(`Creating PayPal order for user ${user.id}`);
            if (!createOrderDto.amount || createOrderDto.amount <= 0) {
                throw new common_1.BadRequestException('Amount must be greater than 0');
            }
            const cartItems = await this.prisma.cartItem.findMany({
                where: { userId: user.id },
                include: {
                    product: {
                        include: {
                            seller: {
                                include: {
                                    sellerProfile: true
                                }
                            }
                        }
                    }
                }
            });
            if (!cartItems || cartItems.length === 0) {
                throw new common_1.BadRequestException('Cart is empty');
            }
            const paypalItems = cartItems.map(item => ({
                name: item.product.title,
                price: item.product.price,
                quantity: item.quantity,
            }));
            const orderNumber = `PAY-${Date.now()}-${Math.random().toString(36).substring(2, 8).toUpperCase()}`;
            const paypalOrder = await this.paypalService.createOrder({
                amount: createOrderDto.amount,
                currency: createOrderDto.currency,
                items: paypalItems,
                metadata: {
                    userId: user.id.toString(),
                    orderNumber: orderNumber,
                    customerEmail: createOrderDto.customerInfo.email,
                }
            });
            const order = await this.prisma.order.create({
                data: {
                    orderNumber: orderNumber,
                    buyerId: user.id,
                    subtotal: createOrderDto.amount,
                    subtotalAmount: createOrderDto.amount,
                    platformFeeRate: 0.10,
                    platformFee: createOrderDto.amount * 0.10,
                    totalAmount: createOrderDto.amount,
                    sellerAmount: createOrderDto.amount * 0.90,
                    status: 'PENDING',
                    paymentStatus: 'pending',
                    paypalOrderId: paypalOrder.orderId,
                    buyerEmail: createOrderDto.customerInfo.email,
                    billingData: createOrderDto.customerInfo,
                    metadata: {
                        customerInfo: createOrderDto.customerInfo,
                        paymentMethod: 'paypal',
                        paypalOrderId: paypalOrder.orderId,
                        cartItemsCount: cartItems.length,
                        createdAt: new Date().toISOString(),
                    },
                    items: {
                        create: cartItems.map(item => ({
                            productId: item.productId,
                            sellerId: item.product.sellerId,
                            productTitle: item.product.title,
                            productSlug: item.product.slug,
                            price: item.priceSnapshot,
                            quantity: item.quantity,
                            sellerName: `${item.product.seller.firstName} ${item.product.seller.lastName}`,
                            storeName: item.product.seller.sellerProfile?.storeName || 'Unknown Store',
                        }))
                    }
                },
                include: {
                    items: true,
                    buyer: true
                }
            });
            this.logger.log(`PayPal order created: ${paypalOrder.orderId} for order ${order.id}`);
            return {
                success: true,
                orderId: paypalOrder.orderId,
                approvalUrl: paypalOrder.approvalUrl,
                localOrderId: order.id,
                orderNumber: order.orderNumber,
            };
        }
        catch (error) {
            this.logger.error(`Failed to create PayPal order: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to create PayPal order: ${error.message}`);
        }
    }
    async capturePayPalOrder(captureDto, user) {
        try {
            this.logger.log(`Capturing PayPal order ${captureDto.orderId} for user ${user.id}`);
            const captureResult = await this.paypalService.captureOrder(captureDto.orderId);
            if (captureResult.status !== 'COMPLETED') {
                throw new common_1.BadRequestException('PayPal payment was not completed');
            }
            const order = await this.prisma.order.findFirst({
                where: {
                    paypalOrderId: captureDto.orderId,
                    buyerId: user.id
                },
                include: {
                    items: true,
                    buyer: true
                }
            });
            if (!order) {
                throw new common_1.NotFoundException('Order not found or unauthorized');
            }
            const updatedOrder = await this.prisma.order.update({
                where: { id: order.id },
                data: {
                    status: 'PAID',
                    paymentStatus: 'completed',
                    paypalPaymentId: captureResult.paymentId,
                    paidAt: new Date(),
                    completedAt: new Date(),
                    metadata: {
                        ...order.metadata,
                        paymentId: captureResult.paymentId,
                        capturedAt: new Date().toISOString(),
                    }
                }
            });
            await this.prisma.cartItem.deleteMany({
                where: { userId: user.id }
            });
            const downloadTokens = [];
            for (const item of order.items) {
                const downloadToken = await this.prisma.downloadToken.create({
                    data: {
                        token: `DT-${Date.now()}-${Math.random().toString(36).substring(2, 8).toUpperCase()}`,
                        orderId: order.id,
                        productId: item.productId,
                        buyerId: user.id,
                        downloadLimit: 5,
                        downloadCount: 0,
                        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                        isActive: true,
                    }
                });
                downloadTokens.push(downloadToken);
            }
            this.logger.log(`PayPal payment completed for order ${order.id} with ${downloadTokens.length} download tokens`);
            return {
                success: true,
                status: 'COMPLETED',
                paymentId: captureResult.paymentId,
                orderId: order.id,
                orderNumber: order.orderNumber,
                downloadTokensCount: downloadTokens.length,
            };
        }
        catch (error) {
            this.logger.error(`Failed to capture PayPal payment: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to capture PayPal payment: ${error.message}`);
        }
    }
    async getOrderStatus(orderId, user) {
        try {
            const order = await this.prisma.order.findFirst({
                where: {
                    id: orderId,
                    buyerId: user.id
                },
                include: {
                    items: {
                        include: {
                            product: true
                        }
                    }
                }
            });
            if (!order) {
                throw new common_1.NotFoundException('Order not found or unauthorized');
            }
            return {
                success: true,
                order: {
                    id: order.id,
                    orderNumber: order.orderNumber,
                    status: order.status,
                    paymentStatus: order.paymentStatus,
                    totalAmount: order.totalAmount,
                    createdAt: order.createdAt,
                    paidAt: order.paidAt,
                    completedAt: order.completedAt,
                    itemsCount: order.items.length,
                }
            };
        }
        catch (error) {
            this.logger.error(`Failed to get order status: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get order status: ${error.message}`);
        }
    }
};
exports.PaymentCheckoutController = PaymentCheckoutController;
__decorate([
    (0, common_1.Post)('stripe/create-intent'),
    (0, swagger_1.ApiOperation)({
        summary: 'Create Stripe Payment Intent',
        description: 'Creates a payment intent for Stripe checkout'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Payment intent created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request or empty cart' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentCheckoutController.prototype, "createStripePaymentIntent", null);
__decorate([
    (0, common_1.Post)('stripe/confirm-payment/:paymentIntentId'),
    (0, swagger_1.ApiOperation)({
        summary: 'Confirm Stripe payment',
        description: 'Confirms a Stripe payment and completes the order'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payment confirmed successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Payment intent not found' }),
    __param(0, (0, common_1.Param)('paymentIntentId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PaymentCheckoutController.prototype, "confirmStripePayment", null);
__decorate([
    (0, common_1.Post)('paypal/create-order'),
    (0, swagger_1.ApiOperation)({
        summary: 'Create PayPal order',
        description: 'Creates a PayPal order for checkout'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'PayPal order created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request or empty cart' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentCheckoutController.prototype, "createPayPalOrder", null);
__decorate([
    (0, common_1.Post)('paypal/capture-order'),
    (0, swagger_1.ApiOperation)({
        summary: 'Capture PayPal payment',
        description: 'Captures a PayPal payment after user approval'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'PayPal payment captured successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Capture failed' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PaymentCheckoutController.prototype, "capturePayPalOrder", null);
__decorate([
    (0, common_1.Get)('order-status/:orderId'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get order status',
        description: 'Gets the current status of an order'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Order status retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Order not found' }),
    __param(0, (0, common_1.Param)('orderId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PaymentCheckoutController.prototype, "getOrderStatus", null);
exports.PaymentCheckoutController = PaymentCheckoutController = PaymentCheckoutController_1 = __decorate([
    (0, swagger_1.ApiTags)('payment-checkout'),
    (0, common_1.Controller)('api/payments'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof stripe_service_1.StripeService !== "undefined" && stripe_service_1.StripeService) === "function" ? _a : Object, typeof (_b = typeof paypal_service_1.PayPalService !== "undefined" && paypal_service_1.PayPalService) === "function" ? _b : Object, typeof (_c = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _c : Object])
], PaymentCheckoutController);


/***/ }),
/* 261 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CronModule = void 0;
const common_1 = __webpack_require__(2);
const schedule_1 = __webpack_require__(8);
const cron_service_1 = __webpack_require__(262);
const cart_module_1 = __webpack_require__(211);
const orders_module_1 = __webpack_require__(221);
const downloads_module_1 = __webpack_require__(247);
let CronModule = class CronModule {
};
exports.CronModule = CronModule;
exports.CronModule = CronModule = __decorate([
    (0, common_1.Module)({
        imports: [
            schedule_1.ScheduleModule.forRoot(),
            cart_module_1.CartModule,
            orders_module_1.OrdersModule,
            downloads_module_1.DownloadsModule,
        ],
        providers: [cron_service_1.CronService],
    })
], CronModule);


/***/ }),
/* 262 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var CronService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CronService = void 0;
const common_1 = __webpack_require__(2);
const schedule_1 = __webpack_require__(8);
const cart_service_1 = __webpack_require__(213);
const orders_service_1 = __webpack_require__(223);
const downloads_service_1 = __webpack_require__(249);
let CronService = CronService_1 = class CronService {
    constructor(cartService, ordersService, downloadsService) {
        this.cartService = cartService;
        this.ordersService = ordersService;
        this.downloadsService = downloadsService;
        this.logger = new common_1.Logger(CronService_1.name);
    }
    async cleanupAbandonedCarts() {
        this.logger.log('Starting cleanup of abandoned carts...');
        try {
            const deletedCount = await this.cartService.cleanupAbandonedCarts();
            this.logger.log(`Cleaned up ${deletedCount} abandoned cart items`);
        }
        catch (error) {
            this.logger.error('Failed to cleanup abandoned carts:', error);
        }
    }
    async cancelPendingOrders() {
        this.logger.log('Starting cleanup of pending orders...');
        try {
            const cancelledCount = await this.ordersService.cleanupPendingOrders();
            this.logger.log(`Cancelled ${cancelledCount} pending orders`);
        }
        catch (error) {
            this.logger.error('Failed to cleanup pending orders:', error);
        }
    }
    async deactivateExpiredTokens() {
        this.logger.log('Starting cleanup of expired download tokens...');
        try {
            const deactivatedCount = await this.downloadsService.cleanupExpiredTokens();
            this.logger.log(`Deactivated ${deactivatedCount} expired download tokens`);
        }
        catch (error) {
            this.logger.error('Failed to cleanup expired tokens:', error);
        }
    }
    async generateDailyReport() {
        this.logger.log('Generating daily activity report...');
        try {
            this.logger.log('Daily report generated successfully');
        }
        catch (error) {
            this.logger.error('Failed to generate daily report:', error);
        }
    }
};
exports.CronService = CronService;
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_2AM),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CronService.prototype, "cleanupAbandonedCarts", null);
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_HOUR),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CronService.prototype, "cancelPendingOrders", null);
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_3AM),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CronService.prototype, "deactivateExpiredTokens", null);
__decorate([
    (0, schedule_1.Cron)(schedule_1.CronExpression.EVERY_DAY_AT_6AM),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CronService.prototype, "generateDailyReport", null);
exports.CronService = CronService = CronService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof cart_service_1.CartService !== "undefined" && cart_service_1.CartService) === "function" ? _a : Object, typeof (_b = typeof orders_service_1.OrdersService !== "undefined" && orders_service_1.OrdersService) === "function" ? _b : Object, typeof (_c = typeof downloads_service_1.DownloadsService !== "undefined" && downloads_service_1.DownloadsService) === "function" ? _c : Object])
], CronService);


/***/ }),
/* 263 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminModule = void 0;
const common_1 = __webpack_require__(2);
const admin_analytics_module_1 = __webpack_require__(264);
const admin_orders_controller_1 = __webpack_require__(269);
const admin_controller_1 = __webpack_require__(270);
const admin_service_1 = __webpack_require__(271);
const orders_module_1 = __webpack_require__(221);
const users_module_1 = __webpack_require__(28);
const products_module_1 = __webpack_require__(36);
const prisma_module_1 = __webpack_require__(9);
let AdminModule = class AdminModule {
};
exports.AdminModule = AdminModule;
exports.AdminModule = AdminModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            admin_analytics_module_1.AdminAnalyticsModule,
            (0, common_1.forwardRef)(() => orders_module_1.OrdersModule),
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => products_module_1.ProductsModule),
        ],
        controllers: [
            admin_orders_controller_1.AdminOrdersController,
            admin_controller_1.AdminController,
        ],
        providers: [
            admin_service_1.AdminService,
        ],
        exports: [
            admin_analytics_module_1.AdminAnalyticsModule,
            admin_service_1.AdminService,
        ],
    })
], AdminModule);


/***/ }),
/* 264 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminAnalyticsModule = void 0;
const common_1 = __webpack_require__(2);
const admin_analytics_controller_1 = __webpack_require__(265);
const admin_analytics_service_1 = __webpack_require__(266);
const prisma_module_1 = __webpack_require__(9);
let AdminAnalyticsModule = class AdminAnalyticsModule {
};
exports.AdminAnalyticsModule = AdminAnalyticsModule;
exports.AdminAnalyticsModule = AdminAnalyticsModule = __decorate([
    (0, common_1.Module)({
        imports: [prisma_module_1.PrismaModule],
        controllers: [admin_analytics_controller_1.AdminAnalyticsController],
        providers: [admin_analytics_service_1.AdminAnalyticsService],
        exports: [admin_analytics_service_1.AdminAnalyticsService],
    })
], AdminAnalyticsModule);


/***/ }),
/* 265 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminAnalyticsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const admin_analytics_service_1 = __webpack_require__(266);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const admin_analytics_dto_1 = __webpack_require__(267);
const analytics_response_dto_1 = __webpack_require__(268);
const client_1 = __webpack_require__(11);
let AdminAnalyticsController = class AdminAnalyticsController {
    constructor(analyticsService) {
        this.analyticsService = analyticsService;
    }
    async getDashboard(filters) {
        return this.analyticsService.getDashboard(filters);
    }
    async getOrderAnalytics(filters) {
        return this.analyticsService.getOrderAnalytics(filters);
    }
    async getProductAnalytics(filters) {
        return this.analyticsService.getProductAnalytics(filters);
    }
    async getUserAnalytics(filters) {
        return this.analyticsService.getUserAnalytics(filters);
    }
    async getFinancialAnalytics(filters) {
        return this.analyticsService.getFinancialAnalytics(filters);
    }
};
exports.AdminAnalyticsController = AdminAnalyticsController;
__decorate([
    (0, common_1.Get)('dashboard'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener dashboard completo de analytics',
        description: 'Retorna todas las m√©tricas y estad√≠sticas del marketplace para administradores.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Dashboard de analytics obtenido exitosamente',
        type: analytics_response_dto_1.AdminDashboardDto
    }),
    (0, swagger_1.ApiResponse)({
        status: 403,
        description: 'Solo administradores pueden acceder a analytics'
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof admin_analytics_dto_1.AdminAnalyticsFiltersDto !== "undefined" && admin_analytics_dto_1.AdminAnalyticsFiltersDto) === "function" ? _b : Object]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], AdminAnalyticsController.prototype, "getDashboard", null);
__decorate([
    (0, common_1.Get)('orders'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Analytics espec√≠ficos de √≥rdenes',
        description: 'M√©tricas detalladas sobre √≥rdenes, ventas y conversiones.'
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof admin_analytics_dto_1.AdminAnalyticsFiltersDto !== "undefined" && admin_analytics_dto_1.AdminAnalyticsFiltersDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], AdminAnalyticsController.prototype, "getOrderAnalytics", null);
__decorate([
    (0, common_1.Get)('products'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Analytics espec√≠ficos de productos',
        description: 'M√©tricas sobre productos, descargas y ratings.'
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof admin_analytics_dto_1.AdminAnalyticsFiltersDto !== "undefined" && admin_analytics_dto_1.AdminAnalyticsFiltersDto) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], AdminAnalyticsController.prototype, "getProductAnalytics", null);
__decorate([
    (0, common_1.Get)('users'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Analytics espec√≠ficos de usuarios',
        description: 'M√©tricas sobre usuarios, sellers y buyers.'
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_f = typeof admin_analytics_dto_1.AdminAnalyticsFiltersDto !== "undefined" && admin_analytics_dto_1.AdminAnalyticsFiltersDto) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], AdminAnalyticsController.prototype, "getUserAnalytics", null);
__decorate([
    (0, common_1.Get)('financial'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Analytics financieros',
        description: 'M√©tricas sobre ingresos, fees y payouts.'
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof admin_analytics_dto_1.AdminAnalyticsFiltersDto !== "undefined" && admin_analytics_dto_1.AdminAnalyticsFiltersDto) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], AdminAnalyticsController.prototype, "getFinancialAnalytics", null);
exports.AdminAnalyticsController = AdminAnalyticsController = __decorate([
    (0, swagger_1.ApiTags)('Admin - Analytics'),
    (0, common_1.Controller)('admin/analytics'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __metadata("design:paramtypes", [typeof (_a = typeof admin_analytics_service_1.AdminAnalyticsService !== "undefined" && admin_analytics_service_1.AdminAnalyticsService) === "function" ? _a : Object])
], AdminAnalyticsController);


/***/ }),
/* 266 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminAnalyticsService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
let AdminAnalyticsService = class AdminAnalyticsService {
    constructor(prisma) {
        this.prisma = prisma;
    }
    async getDashboard(filters) {
        const [orders, products, users, financial] = await Promise.all([
            this.getOrderAnalytics(filters),
            this.getProductAnalytics(filters),
            this.getUserAnalytics(filters),
            this.getFinancialAnalytics(filters)
        ]);
        return {
            orders,
            products,
            users,
            financial,
            generatedAt: new Date()
        };
    }
    async getOrderAnalytics(filters) {
        const whereClause = this.buildWhereClause(filters);
        const orderStats = await this.prisma.order.aggregate({
            where: whereClause,
            _count: { id: true },
            _sum: { totalAmount: true, platformFee: true },
            _avg: { totalAmount: true }
        });
        const ordersByStatus = await this.prisma.order.groupBy({
            by: ['status'],
            where: whereClause,
            _count: { status: true }
        });
        const revenueByPeriod = await this.getRevenueByPeriod(filters);
        const completedOrders = await this.prisma.order.count({
            where: { ...whereClause, status: 'COMPLETED' }
        });
        return {
            totalOrders: orderStats._count.id || 0,
            totalRevenue: orderStats._sum.totalAmount || 0,
            totalPlatformFees: orderStats._sum.platformFee || 0,
            avgOrderValue: orderStats._avg.totalAmount || 0,
            conversionRate: orderStats._count.id ? (completedOrders / orderStats._count.id) * 100 : 0,
            ordersByStatus: Object.fromEntries(ordersByStatus.map(item => [item.status, item._count.status])),
            revenueByPeriod
        };
    }
    async getProductAnalytics(filters) {
        const totalProducts = await this.prisma.product.count({
            where: { status: 'APPROVED' }
        });
        const downloadStats = await this.prisma.downloadToken.aggregate({
            _sum: { downloadCount: true }
        });
        const ratingStats = await this.prisma.product.aggregate({
            where: { status: 'APPROVED', reviewCount: { gt: 0 } },
            _avg: { rating: true }
        });
        const topSellingProducts = await this.prisma.orderItem.groupBy({
            by: ['productId'],
            _count: { productId: true },
            _sum: { price: true },
            orderBy: { _count: { productId: 'desc' } },
            take: 10
        });
        const topProducts = await Promise.all(topSellingProducts.map(async (item) => {
            const product = await this.prisma.product.findUnique({
                where: { id: item.productId },
                select: { id: true, title: true }
            });
            return {
                id: item.productId,
                title: product?.title || 'Unknown',
                sales: item._count.productId,
                revenue: item._sum.price || 0
            };
        }));
        const productsByCategory = await this.prisma.product.groupBy({
            by: ['category'],
            where: { status: 'APPROVED' },
            _count: { category: true }
        });
        const productsByDifficulty = await this.prisma.product.groupBy({
            by: ['difficulty'],
            where: { status: 'APPROVED' },
            _count: { difficulty: true }
        });
        return {
            totalProducts,
            totalDownloads: downloadStats._sum.downloadCount || 0,
            avgRating: ratingStats._avg.rating || 0,
            topSellingProducts: topProducts,
            productsByCategory: Object.fromEntries(productsByCategory.map(item => [item.category, item._count.category])),
            productsByDifficulty: Object.fromEntries(productsByDifficulty.map(item => [item.difficulty, item._count.difficulty]))
        };
    }
    async getUserAnalytics(filters) {
        const totalUsers = await this.prisma.user.count();
        const totalBuyers = await this.prisma.user.count({ where: { role: 'BUYER' } });
        const totalSellers = await this.prisma.user.count({ where: { role: 'SELLER' } });
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const activeUsers = await this.prisma.user.count({
            where: { lastLoginAt: { gte: thirtyDaysAgo } }
        });
        const whereClause = this.buildWhereClause(filters);
        const newUsers = await this.prisma.user.count({
            where: {
                createdAt: {
                    gte: filters.fromDate ? new Date(filters.fromDate) : undefined,
                    lte: filters.toDate ? new Date(filters.toDate) : undefined
                }
            }
        });
        const topSellers = await this.prisma.sellerProfile.findMany({
            take: 10,
            orderBy: { totalSales: 'desc' },
            include: { user: true }
        });
        return {
            totalUsers,
            totalBuyers,
            totalSellers,
            activeUsers,
            newUsersThisPeriod: newUsers,
            topSellers: topSellers.map(seller => ({
                id: seller.userId,
                name: `${seller.user.firstName} ${seller.user.lastName}`,
                storeName: seller.storeName,
                sales: seller.totalSales,
                revenue: 0
            })),
            usersByCountry: {}
        };
    }
    async getFinancialAnalytics(filters) {
        const whereClause = this.buildWhereClause(filters);
        const financialStats = await this.prisma.order.aggregate({
            where: { ...whereClause, status: 'COMPLETED' },
            _sum: { totalAmount: true, platformFee: true, sellerAmount: true }
        });
        const revenueByCountry = {};
        const feesByType = await this.prisma.order.findMany({
            where: { ...whereClause, status: 'COMPLETED' },
            select: { feeBreakdown: true }
        });
        const monthlyGrowth = await this.getMonthlyGrowth(filters);
        return {
            totalRevenue: financialStats._sum.totalAmount || 0,
            totalPlatformFees: financialStats._sum.platformFee || 0,
            totalSellerPayouts: financialStats._sum.sellerAmount || 0,
            pendingPayouts: 0,
            revenueByCountry,
            feesByType: {},
            monthlyGrowth
        };
    }
    buildWhereClause(filters) {
        const where = {};
        if (filters.fromDate || filters.toDate) {
            where.createdAt = {};
            if (filters.fromDate)
                where.createdAt.gte = new Date(filters.fromDate);
            if (filters.toDate)
                where.createdAt.lte = new Date(filters.toDate);
        }
        return where;
    }
    async getRevenueByPeriod(filters) {
        const whereClause = this.buildWhereClause(filters);
        const orders = await this.prisma.order.findMany({
            where: { ...whereClause, status: 'COMPLETED' },
            select: { totalAmount: true, createdAt: true },
            orderBy: { createdAt: 'asc' }
        });
        const monthlyData = new Map();
        orders.forEach(order => {
            const monthKey = order.createdAt.toISOString().slice(0, 7);
            if (!monthlyData.has(monthKey)) {
                monthlyData.set(monthKey, { revenue: 0, orders: 0 });
            }
            const data = monthlyData.get(monthKey);
            data.revenue += order.totalAmount;
            data.orders += 1;
        });
        return Array.from(monthlyData.entries()).map(([period, data]) => ({
            period,
            revenue: data.revenue,
            orders: data.orders
        }));
    }
    async getMonthlyGrowth(filters) {
        return [
            { month: '2025-01', revenue: 1000, growth: 0 },
            { month: '2025-02', revenue: 1200, growth: 20 },
            { month: '2025-03', revenue: 1440, growth: 20 }
        ];
    }
};
exports.AdminAnalyticsService = AdminAnalyticsService;
exports.AdminAnalyticsService = AdminAnalyticsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object])
], AdminAnalyticsService);


/***/ }),
/* 267 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminAnalyticsFiltersDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const class_transformer_1 = __webpack_require__(40);
const client_1 = __webpack_require__(11);
class AdminAnalyticsFiltersDto {
    constructor() {
        this.limit = 100;
    }
}
exports.AdminAnalyticsFiltersDto = AdminAnalyticsFiltersDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filtrar por pa√≠s espec√≠fico',
        required: false,
        example: 'AR'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "country", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Fecha de inicio (ISO string)',
        required: false,
        example: '2025-01-01T00:00:00.000Z'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "fromDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Fecha de fin (ISO string)',
        required: false,
        example: '2025-12-31T23:59:59.999Z'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "toDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Filtrar por categor√≠a de producto',
        enum: client_1.ProductCategory,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(client_1.ProductCategory),
    __metadata("design:type", typeof (_a = typeof client_1.ProductCategory !== "undefined" && client_1.ProductCategory) === "function" ? _a : Object)
], AdminAnalyticsFiltersDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Per√≠odo de agrupaci√≥n',
        enum: ['day', 'week', 'month', 'year'],
        required: false,
        default: 'month'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "period", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'L√≠mite de resultados',
        required: false,
        default: 100
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], AdminAnalyticsFiltersDto.prototype, "limit", void 0);


/***/ }),
/* 268 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b, _c, _d, _e, _f, _g;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminDashboardDto = exports.FinancialAnalyticsDto = exports.UserAnalyticsDto = exports.ProductAnalyticsDto = exports.OrderAnalyticsDto = void 0;
const swagger_1 = __webpack_require__(4);
class OrderAnalyticsDto {
}
exports.OrderAnalyticsDto = OrderAnalyticsDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderAnalyticsDto.prototype, "totalOrders", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderAnalyticsDto.prototype, "totalRevenue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderAnalyticsDto.prototype, "totalPlatformFees", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderAnalyticsDto.prototype, "avgOrderValue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], OrderAnalyticsDto.prototype, "conversionRate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_a = typeof Record !== "undefined" && Record) === "function" ? _a : Object)
], OrderAnalyticsDto.prototype, "ordersByStatus", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Array)
], OrderAnalyticsDto.prototype, "revenueByPeriod", void 0);
class ProductAnalyticsDto {
}
exports.ProductAnalyticsDto = ProductAnalyticsDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductAnalyticsDto.prototype, "totalProducts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductAnalyticsDto.prototype, "totalDownloads", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], ProductAnalyticsDto.prototype, "avgRating", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Array)
], ProductAnalyticsDto.prototype, "topSellingProducts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_b = typeof Record !== "undefined" && Record) === "function" ? _b : Object)
], ProductAnalyticsDto.prototype, "productsByCategory", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_c = typeof Record !== "undefined" && Record) === "function" ? _c : Object)
], ProductAnalyticsDto.prototype, "productsByDifficulty", void 0);
class UserAnalyticsDto {
}
exports.UserAnalyticsDto = UserAnalyticsDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], UserAnalyticsDto.prototype, "totalUsers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], UserAnalyticsDto.prototype, "totalBuyers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], UserAnalyticsDto.prototype, "totalSellers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], UserAnalyticsDto.prototype, "activeUsers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], UserAnalyticsDto.prototype, "newUsersThisPeriod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Array)
], UserAnalyticsDto.prototype, "topSellers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_d = typeof Record !== "undefined" && Record) === "function" ? _d : Object)
], UserAnalyticsDto.prototype, "usersByCountry", void 0);
class FinancialAnalyticsDto {
}
exports.FinancialAnalyticsDto = FinancialAnalyticsDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], FinancialAnalyticsDto.prototype, "totalRevenue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], FinancialAnalyticsDto.prototype, "totalPlatformFees", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], FinancialAnalyticsDto.prototype, "totalSellerPayouts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Number)
], FinancialAnalyticsDto.prototype, "pendingPayouts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_e = typeof Record !== "undefined" && Record) === "function" ? _e : Object)
], FinancialAnalyticsDto.prototype, "revenueByCountry", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_f = typeof Record !== "undefined" && Record) === "function" ? _f : Object)
], FinancialAnalyticsDto.prototype, "feesByType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", Array)
], FinancialAnalyticsDto.prototype, "monthlyGrowth", void 0);
class AdminDashboardDto {
}
exports.AdminDashboardDto = AdminDashboardDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", OrderAnalyticsDto)
], AdminDashboardDto.prototype, "orders", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", ProductAnalyticsDto)
], AdminDashboardDto.prototype, "products", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", UserAnalyticsDto)
], AdminDashboardDto.prototype, "users", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", FinancialAnalyticsDto)
], AdminDashboardDto.prototype, "financial", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", typeof (_g = typeof Date !== "undefined" && Date) === "function" ? _g : Object)
], AdminDashboardDto.prototype, "generatedAt", void 0);


/***/ }),
/* 269 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminOrdersController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const orders_service_1 = __webpack_require__(223);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const order_filters_dto_1 = __webpack_require__(234);
const paginated_orders_dto_1 = __webpack_require__(233);
const client_1 = __webpack_require__(11);
let AdminOrdersController = class AdminOrdersController {
    constructor(ordersService) {
        this.ordersService = ordersService;
    }
    async getAllOrders(filters) {
        return this.ordersService.getAllOrdersAdmin(filters);
    }
    async getOrderAnalytics(fromDate, toDate) {
        return this.ordersService.getOrderAnalytics({
            fromDate,
            toDate
        });
    }
    async processRefund(orderId, body) {
        return this.ordersService.processRefund(orderId, body.amount, body.reason);
    }
    async updateOrderStatus(orderId, body) {
        return this.ordersService.updateOrderStatus(orderId, body.status, body.reason);
    }
    async getOrderById(orderId) {
        return this.ordersService.getOrderById(orderId);
    }
    async cancelOrder(orderId, body) {
        return this.ordersService.cancelOrder(orderId, body.reason);
    }
    async completeOrder(orderId) {
        return this.ordersService.completeOrder(orderId);
    }
};
exports.AdminOrdersController = AdminOrdersController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener todas las √≥rdenes (Admin)',
        description: 'Retorna todas las √≥rdenes del sistema con filtros avanzados. Solo administradores.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: '√ìrdenes obtenidas exitosamente',
        type: paginated_orders_dto_1.PaginatedOrdersDto
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof order_filters_dto_1.OrderFiltersDto !== "undefined" && order_filters_dto_1.OrderFiltersDto) === "function" ? _b : Object]),
    __metadata("design:returntype", typeof (_c = typeof Promise !== "undefined" && Promise) === "function" ? _c : Object)
], AdminOrdersController.prototype, "getAllOrders", null);
__decorate([
    (0, common_1.Get)('analytics'),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener analytics de √≥rdenes',
        description: 'Retorna estad√≠sticas y m√©tricas de las √≥rdenes del sistema.'
    }),
    (0, swagger_1.ApiQuery)({ name: 'fromDate', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'toDate', required: false }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Analytics obtenidos exitosamente'
    }),
    __param(0, (0, common_1.Query)('fromDate')),
    __param(1, (0, common_1.Query)('toDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], AdminOrdersController.prototype, "getOrderAnalytics", null);
__decorate([
    (0, common_1.Post)(':id/refund'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Procesar reembolso',
        description: 'Procesa un reembolso para una orden espec√≠fica.'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID de la orden' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Reembolso procesado exitosamente'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AdminOrdersController.prototype, "processRefund", null);
__decorate([
    (0, common_1.Put)(':id/status'),
    (0, swagger_1.ApiOperation)({
        summary: 'Actualizar estado de orden',
        description: 'Actualiza manualmente el estado de una orden.'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID de la orden' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Estado actualizado exitosamente'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AdminOrdersController.prototype, "updateOrderStatus", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener orden espec√≠fica (Admin)',
        description: 'Obtiene detalles completos de cualquier orden. Solo administradores.'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID de la orden' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Orden obtenida exitosamente'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AdminOrdersController.prototype, "getOrderById", null);
__decorate([
    (0, common_1.Post)(':id/cancel'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Cancelar orden (Admin)',
        description: 'Cancela una orden espec√≠fica. Solo administradores.'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID de la orden' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Orden cancelada exitosamente'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AdminOrdersController.prototype, "cancelOrder", null);
__decorate([
    (0, common_1.Post)(':id/complete'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Completar orden manualmente (Admin)',
        description: 'Marca una orden como completada manualmente. Solo administradores.'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID de la orden' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Orden completada exitosamente'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AdminOrdersController.prototype, "completeOrder", null);
exports.AdminOrdersController = AdminOrdersController = __decorate([
    (0, swagger_1.ApiTags)('Admin - Orders'),
    (0, common_1.Controller)('admin/orders'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __metadata("design:paramtypes", [typeof (_a = typeof orders_service_1.OrdersService !== "undefined" && orders_service_1.OrdersService) === "function" ? _a : Object])
], AdminOrdersController);


/***/ }),
/* 270 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const admin_service_1 = __webpack_require__(271);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const client_1 = __webpack_require__(11);
let AdminController = class AdminController {
    constructor(adminService) {
        this.adminService = adminService;
    }
    async getDashboardOverview() {
        return this.adminService.getDashboardOverview();
    }
    async getAllUsers(page, limit, role) {
        return this.adminService.getAllUsers(page, limit, role);
    }
    async updateUserStatus(userId, body) {
        return this.adminService.updateUserStatus(userId, body.status);
    }
    async getPendingProducts(page, limit) {
        return this.adminService.getPendingProducts(page, limit);
    }
    async getProductById(productId) {
        return this.adminService.getProductById(productId);
    }
    async moderateProduct(productId, body) {
        return this.adminService.moderateProduct(productId, body.status, body.reason);
    }
    async getSystemHealth() {
        return this.adminService.getSystemHealth();
    }
};
exports.AdminController = AdminController;
__decorate([
    (0, common_1.Get)('dashboard'),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener overview del dashboard administrativo',
        description: 'Retorna m√©tricas b√°sicas de la plataforma para el dashboard admin.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Dashboard overview obtenido exitosamente'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "getDashboardOverview", null);
__decorate([
    (0, common_1.Get)('users'),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener todos los usuarios',
        description: 'Lista paginada de todos los usuarios del sistema.'
    }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, example: 1 }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, example: 20 }),
    (0, swagger_1.ApiQuery)({ name: 'role', required: false, enum: client_1.UserRole }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Usuarios obtenidos exitosamente'
    }),
    __param(0, (0, common_1.Query)('page', new common_1.DefaultValuePipe(1), common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('limit', new common_1.DefaultValuePipe(20), common_1.ParseIntPipe)),
    __param(2, (0, common_1.Query)('role')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number, typeof (_b = typeof client_1.UserRole !== "undefined" && client_1.UserRole) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "getAllUsers", null);
__decorate([
    (0, common_1.Put)('users/:id/status'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Actualizar estado de usuario',
        description: 'Actualiza el estado de un usuario (activo/inactivo/suspendido).'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID del usuario' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Estado de usuario actualizado exitosamente'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "updateUserStatus", null);
__decorate([
    (0, common_1.Get)('products/pending'),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener productos pendientes de moderaci√≥n',
        description: 'Lista paginada de productos pendientes de aprobaci√≥n.'
    }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, example: 1 }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, example: 20 }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Productos pendientes obtenidos exitosamente'
    }),
    __param(0, (0, common_1.Query)('page', new common_1.DefaultValuePipe(1), common_1.ParseIntPipe)),
    __param(1, (0, common_1.Query)('limit', new common_1.DefaultValuePipe(20), common_1.ParseIntPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "getPendingProducts", null);
__decorate([
    (0, common_1.Get)('products/:id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Obtener producto espec√≠fico para moderaci√≥n',
        description: 'Retorna un producto espec√≠fico con toda su informaci√≥n para moderaci√≥n admin.'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID del producto' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto obtenido exitosamente'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Producto no encontrado'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "getProductById", null);
__decorate([
    (0, common_1.Put)('products/:id/moderate'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Moderar producto',
        description: 'Aprueba, rechaza o suspende un producto.'
    }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'ID del producto' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Producto moderado exitosamente'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "moderateProduct", null);
__decorate([
    (0, common_1.Get)('health'),
    (0, swagger_1.ApiOperation)({
        summary: 'Verificar salud del sistema',
        description: 'Retorna m√©tricas de salud y estado del sistema.'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'M√©tricas de salud obtenidas exitosamente'
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "getSystemHealth", null);
exports.AdminController = AdminController = __decorate([
    (0, swagger_1.ApiTags)('Admin - Dashboard'),
    (0, common_1.Controller)('admin'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    __metadata("design:paramtypes", [typeof (_a = typeof admin_service_1.AdminService !== "undefined" && admin_service_1.AdminService) === "function" ? _a : Object])
], AdminController);


/***/ }),
/* 271 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var AdminService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const client_1 = __webpack_require__(11);
const users_service_1 = __webpack_require__(16);
const products_service_1 = __webpack_require__(37);
let AdminService = AdminService_1 = class AdminService {
    constructor(prisma, usersService, productsService) {
        this.prisma = prisma;
        this.usersService = usersService;
        this.productsService = productsService;
        this.logger = new common_1.Logger(AdminService_1.name);
    }
    async getDashboardOverview() {
        try {
            this.logger.log('Getting admin dashboard overview');
            const [totalUsers, totalSellers, totalBuyers, totalProducts, pendingProducts, totalOrders, platformRevenue] = await Promise.all([
                this.prisma.user.count(),
                this.prisma.user.count({ where: { role: client_1.UserRole.SELLER } }),
                this.prisma.user.count({ where: { role: client_1.UserRole.BUYER } }),
                this.prisma.product.count(),
                this.prisma.product.count({ where: { status: client_1.ProductStatus.PENDING } }),
                this.prisma.order.count(),
                this.calculatePlatformRevenue()
            ]);
            return {
                success: true,
                data: {
                    users: {
                        total: totalUsers,
                        sellers: totalSellers,
                        buyers: totalBuyers
                    },
                    products: {
                        total: totalProducts,
                        pending: pendingProducts
                    },
                    orders: {
                        total: totalOrders
                    },
                    revenue: {
                        platform: platformRevenue
                    }
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting dashboard overview: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getAllUsers(page = 1, limit = 20, role) {
        try {
            this.logger.log(`Getting all users - page: ${page}, limit: ${limit}, role: ${role}`);
            const skip = (page - 1) * limit;
            const where = role ? { role } : {};
            const [users, total] = await Promise.all([
                this.prisma.user.findMany({
                    where,
                    skip,
                    take: limit,
                    include: {
                        sellerProfile: true,
                        _count: {
                            select: {
                                orders: true,
                                products: true
                            }
                        }
                    },
                    orderBy: { createdAt: 'desc' }
                }),
                this.prisma.user.count({ where })
            ]);
            return {
                success: true,
                data: users,
                meta: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit)
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting users: ${error.message}`, error.stack);
            throw error;
        }
    }
    async updateUserStatus(userId, status) {
        try {
            this.logger.log(`Updating user status: ${userId} to ${status}`);
            const user = await this.prisma.user.update({
                where: { id: userId },
                data: { status },
                include: {
                    sellerProfile: true
                }
            });
            return {
                success: true,
                data: user,
                message: `User status updated to ${status}`
            };
        }
        catch (error) {
            this.logger.error(`Error updating user status: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getPendingProducts(page = 1, limit = 20) {
        try {
            this.logger.log(`Getting pending products - page: ${page}, limit: ${limit}`);
            const skip = (page - 1) * limit;
            const [products, total] = await Promise.all([
                this.prisma.product.findMany({
                    where: { status: client_1.ProductStatus.PENDING },
                    skip,
                    take: limit,
                    include: {
                        seller: {
                            select: {
                                id: true,
                                email: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true
                                    }
                                }
                            }
                        },
                        _count: {
                            select: {
                                reviews: true
                            }
                        }
                    },
                    orderBy: { createdAt: 'asc' }
                }),
                this.prisma.product.count({ where: { status: client_1.ProductStatus.PENDING } })
            ]);
            const enrichedProducts = await Promise.all(products.map(async (product) => {
                const fileInfo = await this.getProductFileInfo(product);
                return {
                    ...product,
                    fileInfo
                };
            }));
            return {
                success: true,
                data: enrichedProducts,
                meta: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit)
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting pending products: ${error.message}`, error.stack);
            throw error;
        }
    }
    async moderateProduct(productId, status, reason) {
        try {
            this.logger.log(`Moderating product: ${productId} to ${status}`);
            const product = await this.prisma.product.update({
                where: { id: productId },
                data: {
                    status,
                    rejectionReason: reason,
                    moderatedAt: new Date()
                },
                include: {
                    seller: {
                        select: {
                            id: true,
                            email: true,
                            sellerProfile: {
                                select: {
                                    storeName: true
                                }
                            }
                        }
                    }
                }
            });
            return {
                success: true,
                data: product,
                message: `Product ${status.toLowerCase()} successfully`
            };
        }
        catch (error) {
            this.logger.error(`Error moderating product: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSystemHealth() {
        try {
            this.logger.log('Getting system health metrics');
            const [dbConnectionTest, totalUsers, totalProducts, totalOrders, errorLogs] = await Promise.all([
                this.testDatabaseConnection(),
                this.prisma.user.count(),
                this.prisma.product.count(),
                this.prisma.order.count(),
                this.getRecentErrorLogs()
            ]);
            return {
                success: true,
                data: {
                    database: {
                        connected: dbConnectionTest,
                        uptime: process.uptime()
                    },
                    counts: {
                        users: totalUsers,
                        products: totalProducts,
                        orders: totalOrders
                    },
                    errors: errorLogs,
                    timestamp: new Date().toISOString()
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting system health: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculatePlatformRevenue() {
        try {
            const transactions = await this.prisma.transaction.findMany({
                where: {
                    type: 'PLATFORM_FEE'
                }
            });
            return transactions.reduce((total, transaction) => {
                return total + Number(transaction.amount);
            }, 0);
        }
        catch (error) {
            this.logger.error(`Error calculating platform revenue: ${error.message}`);
            return 0;
        }
    }
    async testDatabaseConnection() {
        try {
            await this.prisma.$queryRaw `SELECT 1`;
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async getRecentErrorLogs() {
        return [];
    }
    async getProductFileInfo(product) {
        try {
            const fileInfo = {
                pdfFile: null,
                imageFiles: [],
                thumbnailFiles: []
            };
            if (product.pdfFileId) {
                const pdfFile = await this.prisma.file.findUnique({
                    where: { id: product.pdfFileId }
                });
                fileInfo.pdfFile = pdfFile;
            }
            if (product.imageFileIds) {
                try {
                    const imageIds = JSON.parse(product.imageFileIds);
                    if (Array.isArray(imageIds) && imageIds.length > 0) {
                        const imageFiles = await this.prisma.file.findMany({
                            where: {
                                id: { in: imageIds },
                                type: 'IMAGE'
                            }
                        });
                        fileInfo.imageFiles = imageFiles;
                    }
                }
                catch (error) {
                    this.logger.warn(`Error parsing imageFileIds for product ${product.id}:`, error);
                }
            }
            if (product.thumbnailFileIds) {
                try {
                    const thumbnailIds = JSON.parse(product.thumbnailFileIds);
                    if (Array.isArray(thumbnailIds) && thumbnailIds.length > 0) {
                        const thumbnailFiles = await this.prisma.file.findMany({
                            where: {
                                id: { in: thumbnailIds },
                                type: 'THUMBNAIL'
                            }
                        });
                        fileInfo.thumbnailFiles = thumbnailFiles;
                    }
                }
                catch (error) {
                    this.logger.warn(`Error parsing thumbnailFileIds for product ${product.id}:`, error);
                }
            }
            return fileInfo;
        }
        catch (error) {
            this.logger.error(`Error getting file info for product ${product.id}:`, error);
            return {
                pdfFile: null,
                imageFiles: [],
                thumbnailFiles: []
            };
        }
    }
    async getProductById(productId) {
        try {
            this.logger.log(`Getting product by ID: ${productId}`);
            const product = await this.prisma.product.findUnique({
                where: { id: productId },
                include: {
                    seller: {
                        include: {
                            sellerProfile: true
                        }
                    },
                    _count: {
                        select: {
                            reviews: true,
                            favorites: true,
                            orderItems: true
                        }
                    }
                }
            });
            if (!product) {
                return {
                    success: false,
                    message: 'Product not found',
                    statusCode: 404
                };
            }
            const fileInfo = await this.getProductFileInfo(product);
            return {
                success: true,
                product: {
                    ...product,
                    fileInfo
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting product by ID: ${error.message}`, error.stack);
            throw error;
        }
    }
};
exports.AdminService = AdminService;
exports.AdminService = AdminService = AdminService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => products_service_1.ProductsService))),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof users_service_1.UsersService !== "undefined" && users_service_1.UsersService) === "function" ? _b : Object, typeof (_c = typeof products_service_1.ProductsService !== "undefined" && products_service_1.ProductsService) === "function" ? _c : Object])
], AdminService);


/***/ }),
/* 272 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayoutsModule = void 0;
const common_1 = __webpack_require__(2);
const payouts_controller_1 = __webpack_require__(273);
const payouts_service_1 = __webpack_require__(274);
const prisma_module_1 = __webpack_require__(9);
const stripe_module_1 = __webpack_require__(246);
let PayoutsModule = class PayoutsModule {
};
exports.PayoutsModule = PayoutsModule;
exports.PayoutsModule = PayoutsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            (0, common_1.forwardRef)(() => stripe_module_1.StripeModule),
        ],
        controllers: [payouts_controller_1.PayoutsController],
        providers: [payouts_service_1.PayoutsService],
        exports: [payouts_service_1.PayoutsService],
    })
], PayoutsModule);


/***/ }),
/* 273 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PayoutsController_1;
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayoutsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const payouts_service_1 = __webpack_require__(274);
const request_payout_dto_1 = __webpack_require__(275);
const payout_filter_dto_1 = __webpack_require__(276);
const update_payout_dto_1 = __webpack_require__(277);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const current_user_decorator_1 = __webpack_require__(26);
let PayoutsController = PayoutsController_1 = class PayoutsController {
    constructor(payoutsService) {
        this.payoutsService = payoutsService;
        this.logger = new common_1.Logger(PayoutsController_1.name);
    }
    async requestPayout(requestDto, user) {
        try {
            this.logger.log(`Payout request from seller ${user.id}`);
            const result = await this.payoutsService.requestPayout(user.id, requestDto);
            return {
                success: true,
                message: 'Payout requested successfully',
                data: result,
            };
        }
        catch (error) {
            this.logger.error(`Failed to request payout: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to request payout: ${error.message}`);
        }
    }
    async checkEligibility(user) {
        try {
            this.logger.log(`Checking payout eligibility for seller ${user.id}`);
            const eligibility = await this.payoutsService.checkPayoutEligibility(user.id);
            return {
                success: true,
                data: eligibility,
            };
        }
        catch (error) {
            this.logger.error(`Failed to check eligibility: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to check eligibility: ${error.message}`);
        }
    }
    async getMyPayouts(user, filters) {
        try {
            this.logger.log(`Getting payouts for seller ${user.id}`);
            const result = await this.payoutsService.getSellerPayouts(user.id, filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payouts: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get payouts: ${error.message}`);
        }
    }
    async getPayoutDetails(payoutId, user) {
        try {
            this.logger.log(`Getting payout details ${payoutId} for user ${user.id}`);
            const payout = await this.payoutsService.getPayoutById(payoutId, user.id, user.role);
            return {
                success: true,
                data: payout,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payout details: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get payout details: ${error.message}`);
        }
    }
    async getAllPayouts(user, filters) {
        try {
            this.logger.log(`Admin ${user.id} getting all payouts`);
            const result = await this.payoutsService.getAllPayouts(filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
                filters: result.filters,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get all payouts: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get all payouts: ${error.message}`);
        }
    }
    async updatePayout(payoutId, updateDto, user) {
        try {
            this.logger.log(`Admin ${user.id} updating payout ${payoutId}`);
            const result = await this.payoutsService.updatePayout(payoutId, updateDto, user.id);
            return {
                success: true,
                message: 'Payout updated successfully',
                data: result,
            };
        }
        catch (error) {
            this.logger.error(`Failed to update payout: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to update payout: ${error.message}`);
        }
    }
    async executePayoutAction(payoutId, actionDto, user) {
        try {
            this.logger.log(`Admin ${user.id} executing action ${actionDto.action} on payout ${payoutId}`);
            const result = await this.payoutsService.executePayoutAction(payoutId, actionDto, user.id);
            return {
                success: true,
                message: `Action ${actionDto.action} executed successfully`,
                data: result,
            };
        }
        catch (error) {
            this.logger.error(`Failed to execute payout action: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to execute payout action: ${error.message}`);
        }
    }
    async getPayoutStatistics(user, startDate, endDate) {
        try {
            this.logger.log(`Admin ${user.id} getting payout statistics`);
            const stats = await this.payoutsService.getPayoutStatistics({ startDate, endDate });
            return {
                success: true,
                data: stats,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payout statistics: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get payout statistics: ${error.message}`);
        }
    }
};
exports.PayoutsController = PayoutsController;
__decorate([
    (0, common_1.Post)('request'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER'),
    (0, swagger_1.ApiOperation)({
        summary: 'Request individual payout',
        description: 'Request a payout of available balance for authenticated seller'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Payout requested successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request or insufficient balance' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof request_payout_dto_1.RequestPayoutDto !== "undefined" && request_payout_dto_1.RequestPayoutDto) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "requestPayout", null);
__decorate([
    (0, common_1.Get)('eligibility'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER'),
    (0, swagger_1.ApiOperation)({
        summary: 'Check payout eligibility',
        description: 'Check if seller is eligible for payouts and available balance'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Eligibility checked successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "checkEligibility", null);
__decorate([
    (0, common_1.Get)('my-payouts'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller payouts',
        description: 'Get paginated list of payouts for authenticated seller'
    }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, enum: ['PENDING', 'PROCESSING', 'PAID', 'FAILED', 'CANCELLED'] }),
    (0, swagger_1.ApiQuery)({ name: 'currency', required: false, enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'] }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, description: 'Page number' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, description: 'Items per page' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payouts retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof payout_filter_dto_1.PayoutFilterDto !== "undefined" && payout_filter_dto_1.PayoutFilterDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "getMyPayouts", null);
__decorate([
    (0, common_1.Get)(':payoutId'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get payout details',
        description: 'Get detailed information about a specific payout'
    }),
    (0, swagger_1.ApiParam)({ name: 'payoutId', description: 'Payout ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payout details retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Payout not found' }),
    __param(0, (0, common_1.Param)('payoutId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "getPayoutDetails", null);
__decorate([
    (0, common_1.Get)('admin/all'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all payouts (Admin)',
        description: 'Get paginated list of all payouts across all sellers'
    }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'currency', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'sellerId', required: false, description: 'Filter by seller ID' }),
    (0, swagger_1.ApiQuery)({ name: 'search', required: false, description: 'Search in descriptions and seller names' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'All payouts retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_d = typeof payout_filter_dto_1.PayoutFilterDto !== "undefined" && payout_filter_dto_1.PayoutFilterDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "getAllPayouts", null);
__decorate([
    (0, common_1.Put)('admin/:payoutId'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Update payout (Admin)',
        description: 'Update payout status, description, or other fields'
    }),
    (0, swagger_1.ApiParam)({ name: 'payoutId', description: 'Payout ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Payout updated successfully' }),
    __param(0, (0, common_1.Param)('payoutId')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_e = typeof update_payout_dto_1.UpdatePayoutDto !== "undefined" && update_payout_dto_1.UpdatePayoutDto) === "function" ? _e : Object, Object]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "updatePayout", null);
__decorate([
    (0, common_1.Post)('admin/:payoutId/actions'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Execute payout action (Admin)',
        description: 'Execute actions like retry, cancel, approve, or reject on a payout'
    }),
    (0, swagger_1.ApiParam)({ name: 'payoutId', description: 'Payout ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Action executed successfully' }),
    __param(0, (0, common_1.Param)('payoutId')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_f = typeof update_payout_dto_1.PayoutActionDto !== "undefined" && update_payout_dto_1.PayoutActionDto) === "function" ? _f : Object, Object]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "executePayoutAction", null);
__decorate([
    (0, common_1.Get)('admin/statistics'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get payout statistics (Admin)',
        description: 'Get comprehensive statistics about payouts across the platform'
    }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date for stats' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date for stats' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Statistics retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String]),
    __metadata("design:returntype", Promise)
], PayoutsController.prototype, "getPayoutStatistics", null);
exports.PayoutsController = PayoutsController = PayoutsController_1 = __decorate([
    (0, swagger_1.ApiTags)('payouts'),
    (0, common_1.Controller)('api/payouts'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof payouts_service_1.PayoutsService !== "undefined" && payouts_service_1.PayoutsService) === "function" ? _a : Object])
], PayoutsController);


/***/ }),
/* 274 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PayoutsService_1;
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayoutsService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const prisma_service_1 = __webpack_require__(10);
const stripe_service_1 = __webpack_require__(243);
let PayoutsService = PayoutsService_1 = class PayoutsService {
    constructor(prisma, stripeService, configService) {
        this.prisma = prisma;
        this.stripeService = stripeService;
        this.configService = configService;
        this.logger = new common_1.Logger(PayoutsService_1.name);
    }
    async requestPayout(userId, dto) {
        try {
            this.logger.log(`Processing payout request for user ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: {
                    id: true,
                    role: true,
                    stripeConnectId: true,
                    payoutsEnabled: true,
                },
            });
            if (!user || user.role !== 'SELLER') {
                throw new common_1.BadRequestException('User is not a seller');
            }
            if (!user.stripeConnectId) {
                throw new common_1.BadRequestException('Seller does not have Stripe Connect account');
            }
            if (!user.payoutsEnabled) {
                throw new common_1.BadRequestException('Payouts are not enabled for this seller');
            }
            const balance = await this.stripeService.getAccountBalance(user.stripeConnectId);
            const availableBalance = balance.available.find(b => b.currency === (dto.currency || 'usd').toLowerCase());
            if (!availableBalance || availableBalance.amount < 100) {
                throw new common_1.BadRequestException('Insufficient balance for payout');
            }
            let payoutAmount = dto.amount;
            if (!payoutAmount) {
                payoutAmount = availableBalance.amount / 100;
            }
            const minimumPayout = parseFloat(this.configService.get('MINIMUM_PAYOUT_AMOUNT', '10'));
            if (payoutAmount < minimumPayout && !dto.forceMinimum) {
                throw new common_1.BadRequestException(`Minimum payout amount is $${minimumPayout}`);
            }
            const stripePayout = await this.stripeService.createPayout({
                amount: payoutAmount,
                currency: dto.currency || 'USD',
                stripeAccountId: user.stripeConnectId,
                method: dto.method || 'standard',
            });
            const payout = await this.prisma.payout.create({
                data: {
                    sellerId: userId,
                    amount: payoutAmount,
                    currency: dto.currency || 'USD',
                    status: 'PENDING',
                    stripePayoutId: stripePayout.id,
                    description: dto.description || `${dto.method || 'Standard'} payout`,
                    requestedAt: new Date(),
                },
            });
            this.logger.log(`Payout ${payout.id} created successfully for user ${userId}`);
            return {
                id: payout.id,
                stripePayoutId: stripePayout.id,
                amount: payoutAmount,
                currency: dto.currency || 'USD',
                status: payout.status,
                estimatedArrival: new Date(stripePayout.arrival_date * 1000),
                method: dto.method || 'standard',
            };
        }
        catch (error) {
            this.logger.error(`Failed to request payout: ${error.message}`);
            throw error;
        }
    }
    async getSellerPayouts(userId, filters) {
        try {
            this.logger.log(`Getting payouts for seller ${userId}`);
            const where = {
                sellerId: userId,
            };
            if (filters.status) {
                where.status = filters.status;
            }
            if (filters.currency) {
                where.currency = filters.currency;
            }
            if (filters.startDate || filters.endDate) {
                where.createdAt = {};
                if (filters.startDate) {
                    where.createdAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.createdAt.lte = new Date(filters.endDate);
                }
            }
            if (filters.minAmount !== undefined || filters.maxAmount !== undefined) {
                where.amount = {};
                if (filters.minAmount !== undefined) {
                    where.amount.gte = filters.minAmount;
                }
                if (filters.maxAmount !== undefined) {
                    where.amount.lte = filters.maxAmount;
                }
            }
            if (filters.search) {
                where.description = {
                    contains: filters.search,
                };
            }
            const limit = filters.limit || 20;
            const page = filters.page || 1;
            const skip = (page - 1) * limit;
            const orderBy = {};
            const sortField = filters.sortBy || 'createdAt';
            orderBy[sortField] = filters.sortOrder || 'desc';
            const [payouts, total] = await Promise.all([
                this.prisma.payout.findMany({
                    where,
                    orderBy,
                    skip,
                    take: limit,
                    include: {
                        seller: {
                            select: {
                                firstName: true,
                                lastName: true,
                                email: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                    },
                                },
                            },
                        },
                    },
                }),
                this.prisma.payout.count({ where }),
            ]);
            return {
                data: payouts,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                    hasNext: page * limit < total,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get seller payouts: ${error.message}`);
            throw error;
        }
    }
    async getPayoutById(payoutId, userId, userRole) {
        try {
            this.logger.log(`Getting payout ${payoutId} for user ${userId}`);
            const where = { id: payoutId };
            const payout = await this.prisma.payout.findUnique({
                where,
                include: {
                    seller: {
                        select: {
                            firstName: true,
                            lastName: true,
                            email: true,
                            stripeConnectId: true,
                            sellerProfile: {
                                select: {
                                    storeName: true,
                                },
                            },
                        },
                    },
                    transactions: {
                        select: {
                            id: true,
                            type: true,
                            amount: true,
                            status: true,
                            createdAt: true,
                        },
                    },
                },
            });
            if (!payout) {
                throw new common_1.NotFoundException('Payout not found');
            }
            if (userRole !== 'ADMIN' && payout.sellerId !== userId) {
                throw new common_1.NotFoundException('Payout not found');
            }
            return payout;
        }
        catch (error) {
            this.logger.error(`Failed to get payout: ${error.message}`);
            throw error;
        }
    }
    async updatePayout(payoutId, dto, adminUserId) {
        try {
            this.logger.log(`Updating payout ${payoutId} by admin ${adminUserId}`);
            const updateData = {};
            if (dto.status) {
                updateData.status = dto.status;
            }
            if (dto.description) {
                updateData.description = dto.description;
            }
            if (dto.failureReason) {
                updateData.failureReason = dto.failureReason;
            }
            if (dto.processedAt) {
                updateData.processedAt = new Date(dto.processedAt);
            }
            const updatedPayout = await this.prisma.payout.update({
                where: { id: payoutId },
                data: updateData,
            });
            this.logger.log(`Payout ${payoutId} updated successfully`);
            return updatedPayout;
        }
        catch (error) {
            this.logger.error(`Failed to update payout: ${error.message}`);
            throw error;
        }
    }
    async executePayoutAction(payoutId, dto, adminUserId) {
        try {
            this.logger.log(`Executing action ${dto.action} on payout ${payoutId}`);
            const payout = await this.prisma.payout.findUnique({
                where: { id: payoutId },
                include: {
                    seller: {
                        select: {
                            stripeConnectId: true,
                        },
                    },
                },
            });
            if (!payout) {
                throw new common_1.NotFoundException('Payout not found');
            }
            switch (dto.action) {
                case 'cancel':
                    if (payout.status !== 'PENDING') {
                        throw new common_1.BadRequestException('Can only cancel pending payouts');
                    }
                    await this.prisma.payout.update({
                        where: { id: payoutId },
                        data: {
                            status: 'CANCELLED',
                            failureReason: dto.reason || 'Cancelled by admin',
                        },
                    });
                    break;
                case 'retry':
                    if (payout.status !== 'FAILED') {
                        throw new common_1.BadRequestException('Can only retry failed payouts');
                    }
                    const newStripePayout = await this.stripeService.createPayout({
                        amount: Number(payout.amount),
                        currency: payout.currency,
                        stripeAccountId: payout.seller.stripeConnectId,
                        method: 'standard',
                    });
                    await this.prisma.payout.update({
                        where: { id: payoutId },
                        data: {
                            status: 'PENDING',
                            stripePayoutId: newStripePayout.id,
                            failureReason: null,
                            requestedAt: new Date(),
                        },
                    });
                    break;
                default:
                    throw new common_1.BadRequestException(`Unknown action: ${dto.action}`);
            }
            this.logger.log(`Action ${dto.action} executed successfully on payout ${payoutId}`);
            return { success: true, action: dto.action };
        }
        catch (error) {
            this.logger.error(`Failed to execute payout action: ${error.message}`);
            throw error;
        }
    }
    async checkPayoutEligibility(userId) {
        try {
            this.logger.log(`Checking payout eligibility for user ${userId}`);
            const user = await this.prisma.user.findUnique({
                where: { id: userId },
                select: {
                    id: true,
                    role: true,
                    stripeConnectId: true,
                    payoutsEnabled: true,
                    chargesEnabled: true,
                    onboardingComplete: true,
                },
            });
            if (!user || user.role !== 'SELLER') {
                return {
                    eligible: false,
                    reasons: ['User is not a seller'],
                };
            }
            const reasons = [];
            if (!user.stripeConnectId) {
                reasons.push('No Stripe Connect account configured');
            }
            if (!user.onboardingComplete) {
                reasons.push('Stripe onboarding not completed');
            }
            if (!user.chargesEnabled) {
                reasons.push('Charges not enabled on Stripe account');
            }
            if (!user.payoutsEnabled) {
                reasons.push('Payouts not enabled on Stripe account');
            }
            let availableBalance = 0;
            if (reasons.length === 0 && user.stripeConnectId) {
                try {
                    const balance = await this.stripeService.getAccountBalance(user.stripeConnectId);
                    const usdBalance = balance.available.find(b => b.currency === 'usd');
                    availableBalance = usdBalance ? usdBalance.amount / 100 : 0;
                    const minimumPayout = parseFloat(this.configService.get('MINIMUM_PAYOUT_AMOUNT', '10'));
                    if (availableBalance < minimumPayout) {
                        reasons.push(`Insufficient balance (minimum $${minimumPayout})`);
                    }
                }
                catch (error) {
                    reasons.push('Unable to check balance');
                }
            }
            return {
                eligible: reasons.length === 0,
                reasons,
                availableBalance,
                minimumPayout: parseFloat(this.configService.get('MINIMUM_PAYOUT_AMOUNT', '10')),
            };
        }
        catch (error) {
            this.logger.error(`Failed to check payout eligibility: ${error.message}`);
            throw error;
        }
    }
    async getPayoutStatistics(filters) {
        try {
            this.logger.log('Getting payout statistics');
            const where = {};
            if (filters?.startDate || filters?.endDate) {
                where.createdAt = {};
                if (filters.startDate) {
                    where.createdAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.createdAt.lte = new Date(filters.endDate);
                }
            }
            const totalPayouts = await this.prisma.payout.count({ where });
            const payoutsByStatus = await this.prisma.payout.groupBy({
                by: ['status'],
                where,
                _count: {
                    id: true,
                },
                _sum: {
                    amount: true,
                },
            });
            const totalAmount = await this.prisma.payout.aggregate({
                where,
                _sum: {
                    amount: true,
                },
            });
            return {
                summary: {
                    totalPayouts,
                    totalAmount: Number(totalAmount._sum.amount || 0),
                    averageAmount: totalPayouts > 0 ? Number(totalAmount._sum.amount || 0) / totalPayouts : 0,
                },
                byStatus: payoutsByStatus.map(stat => ({
                    status: stat.status,
                    count: stat._count.id,
                    totalAmount: Number(stat._sum.amount || 0),
                })),
            };
        }
        catch (error) {
            this.logger.error(`Failed to get payout statistics: ${error.message}`);
            throw error;
        }
    }
    async getAllPayouts(filters) {
        try {
            this.logger.log('Getting all payouts for admin');
            const where = {};
            if (filters.status) {
                where.status = filters.status;
            }
            if (filters.currency) {
                where.currency = filters.currency;
            }
            if (filters.sellerId) {
                where.sellerId = filters.sellerId;
            }
            if (filters.startDate || filters.endDate) {
                where.createdAt = {};
                if (filters.startDate) {
                    where.createdAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.createdAt.lte = new Date(filters.endDate);
                }
            }
            if (filters.minAmount !== undefined || filters.maxAmount !== undefined) {
                where.amount = {};
                if (filters.minAmount !== undefined) {
                    where.amount.gte = filters.minAmount;
                }
                if (filters.maxAmount !== undefined) {
                    where.amount.lte = filters.maxAmount;
                }
            }
            if (filters.search) {
                where.OR = [
                    { description: { contains: filters.search } },
                    {
                        seller: {
                            OR: [
                                { firstName: { contains: filters.search } },
                                { lastName: { contains: filters.search } },
                                { email: { contains: filters.search } },
                            ],
                        },
                    },
                ];
            }
            const limit = filters.limit || 20;
            const page = filters.page || 1;
            const skip = (page - 1) * limit;
            const orderBy = {};
            const sortField = filters.sortBy || 'createdAt';
            orderBy[sortField] = filters.sortOrder || 'desc';
            const [payouts, total] = await Promise.all([
                this.prisma.payout.findMany({
                    where,
                    orderBy,
                    skip,
                    take: limit,
                    include: {
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                email: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                    },
                                },
                            },
                        },
                    },
                }),
                this.prisma.payout.count({ where }),
            ]);
            return {
                data: payouts,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                    hasNext: page * limit < total,
                    hasPrev: page > 1,
                },
                filters: {
                    applied: Object.keys(where).length > 0,
                    ...filters,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get all payouts: ${error.message}`);
            throw error;
        }
    }
};
exports.PayoutsService = PayoutsService;
exports.PayoutsService = PayoutsService = PayoutsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => stripe_service_1.StripeService))),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof stripe_service_1.StripeService !== "undefined" && stripe_service_1.StripeService) === "function" ? _b : Object, typeof (_c = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _c : Object])
], PayoutsService);


/***/ }),
/* 275 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestPayoutDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class RequestPayoutDto {
}
exports.RequestPayoutDto = RequestPayoutDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Amount to payout (if not specified, will payout all available balance)',
        example: 100.50,
        minimum: 1,
        maximum: 100000,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'amount.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'amount.tooSmall' }),
    (0, class_validator_1.Max)(100000, { message: 'amount.tooLarge' }),
    __metadata("design:type", Number)
], RequestPayoutDto.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Currency for the payout',
        example: 'USD',
        enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'],
        default: 'USD',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'], {
        message: 'currency.notSupported',
    }),
    __metadata("design:type", String)
], RequestPayoutDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Payout method (instant payouts may have additional fees)',
        example: 'standard',
        enum: ['instant', 'standard'],
        default: 'standard',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['instant', 'standard'], { message: 'method.invalid' }),
    __metadata("design:type", String)
], RequestPayoutDto.prototype, "method", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Description for the payout',
        example: 'Weekly earnings payout',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'description.invalid' }),
    __metadata("design:type", String)
], RequestPayoutDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Force payout even if below minimum threshold',
        example: false,
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'forceMinimum.invalid' }),
    __metadata("design:type", Boolean)
], RequestPayoutDto.prototype, "forceMinimum", void 0);


/***/ }),
/* 276 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayoutFilterDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const class_transformer_1 = __webpack_require__(40);
class PayoutFilterDto {
}
exports.PayoutFilterDto = PayoutFilterDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by payout status',
        example: 'PAID',
        enum: ['PENDING', 'PROCESSING', 'PAID', 'FAILED', 'CANCELLED'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['PENDING', 'PROCESSING', 'PAID', 'FAILED', 'CANCELLED'], {
        message: 'status.invalid',
    }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by currency',
        example: 'USD',
        enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'], {
        message: 'currency.invalid',
    }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start date for date range filter (ISO format)',
        example: '2024-01-01T00:00:00Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'startDate.invalid' }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End date for date range filter (ISO format)',
        example: '2024-12-31T23:59:59Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'endDate.invalid' }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "endDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum payout amount',
        example: 10.00,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'minAmount.invalid' }),
    (0, class_validator_1.Min)(0, { message: 'minAmount.tooSmall' }),
    __metadata("design:type", Number)
], PayoutFilterDto.prototype, "minAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum payout amount',
        example: 1000.00,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'maxAmount.invalid' }),
    (0, class_validator_1.Min)(0, { message: 'maxAmount.tooSmall' }),
    __metadata("design:type", Number)
], PayoutFilterDto.prototype, "maxAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by seller ID',
        example: 'user_123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'sellerId.invalid' }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of records per page',
        example: 20,
        default: 20,
        minimum: 1,
        maximum: 100,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)({}, { message: 'limit.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'limit.tooSmall' }),
    (0, class_validator_1.Max)(100, { message: 'limit.tooLarge' }),
    __metadata("design:type", Number)
], PayoutFilterDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Page number (1-based)',
        example: 1,
        default: 1,
        minimum: 1,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)({}, { message: 'page.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'page.tooSmall' }),
    __metadata("design:type", Number)
], PayoutFilterDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort field',
        example: 'createdAt',
        enum: ['createdAt', 'amount', 'status', 'processedAt'],
        default: 'createdAt',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['createdAt', 'amount', 'status', 'processedAt'], {
        message: 'sortBy.invalid',
    }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort order',
        example: 'desc',
        enum: ['asc', 'desc'],
        default: 'desc',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['asc', 'desc'], { message: 'sortOrder.invalid' }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "sortOrder", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Search by description or seller name',
        example: 'weekly payout',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'search.invalid' }),
    __metadata("design:type", String)
], PayoutFilterDto.prototype, "search", void 0);


/***/ }),
/* 277 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PayoutActionDto = exports.UpdatePayoutDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class UpdatePayoutDto {
}
exports.UpdatePayoutDto = UpdatePayoutDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Update payout status (Admin only)',
        example: 'CANCELLED',
        enum: ['PENDING', 'PROCESSING', 'PAID', 'FAILED', 'CANCELLED'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['PENDING', 'PROCESSING', 'PAID', 'FAILED', 'CANCELLED'], {
        message: 'status.invalid',
    }),
    __metadata("design:type", String)
], UpdatePayoutDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Update description',
        example: 'Updated payout description',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'description.invalid' }),
    __metadata("design:type", String)
], UpdatePayoutDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Failure reason (for failed payouts)',
        example: 'Insufficient funds in Stripe account',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'failureReason.invalid' }),
    __metadata("design:type", String)
], UpdatePayoutDto.prototype, "failureReason", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Processing date (Admin only)',
        example: '2024-06-24T10:30:00Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'processedAt.invalid' }),
    __metadata("design:type", String)
], UpdatePayoutDto.prototype, "processedAt", void 0);
class PayoutActionDto {
}
exports.PayoutActionDto = PayoutActionDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Action to perform on the payout',
        example: 'retry',
        enum: ['retry', 'cancel', 'approve', 'reject'],
    }),
    (0, class_validator_1.IsIn)(['retry', 'cancel', 'approve', 'reject'], {
        message: 'action.invalid',
    }),
    __metadata("design:type", String)
], PayoutActionDto.prototype, "action", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Reason for the action',
        example: 'Retry payout after fixing bank account information',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'reason.invalid' }),
    __metadata("design:type", String)
], PayoutActionDto.prototype, "reason", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Force action even if conditions are not met',
        example: false,
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)({ message: 'force.invalid' }),
    __metadata("design:type", Boolean)
], PayoutActionDto.prototype, "force", void 0);


/***/ }),
/* 278 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionsModule = void 0;
const common_1 = __webpack_require__(2);
const transactions_controller_1 = __webpack_require__(279);
const transactions_service_1 = __webpack_require__(280);
const prisma_module_1 = __webpack_require__(9);
const stripe_module_1 = __webpack_require__(246);
let TransactionsModule = class TransactionsModule {
};
exports.TransactionsModule = TransactionsModule;
exports.TransactionsModule = TransactionsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            (0, common_1.forwardRef)(() => stripe_module_1.StripeModule),
        ],
        controllers: [transactions_controller_1.TransactionsController],
        providers: [transactions_service_1.TransactionsService],
        exports: [transactions_service_1.TransactionsService],
    })
], TransactionsModule);


/***/ }),
/* 279 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TransactionsController_1;
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const transactions_service_1 = __webpack_require__(280);
const transaction_filter_dto_1 = __webpack_require__(281);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const current_user_decorator_1 = __webpack_require__(26);
let TransactionsController = TransactionsController_1 = class TransactionsController {
    constructor(transactionsService) {
        this.transactionsService = transactionsService;
        this.logger = new common_1.Logger(TransactionsController_1.name);
    }
    async getMyTransactions(user, filters) {
        try {
            this.logger.log(`Getting transactions for seller ${user.id}`);
            const result = await this.transactionsService.getSellerTransactions(user.id, filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get transactions: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get transactions: ${error.message}`);
        }
    }
    async getTransactionDetails(transactionId, user) {
        try {
            this.logger.log(`Getting transaction details ${transactionId} for user ${user.id}`);
            const transaction = await this.transactionsService.getTransactionById(transactionId, user.id, user.role);
            return {
                success: true,
                data: transaction,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get transaction details: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get transaction details: ${error.message}`);
        }
    }
    async getMyTransactionStatistics(user, startDate, endDate) {
        try {
            this.logger.log(`Getting transaction statistics for seller ${user.id}`);
            const stats = await this.transactionsService.getTransactionStatistics({
                startDate,
                endDate,
                sellerId: user.id
            });
            return {
                success: true,
                data: stats,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get transaction statistics: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get transaction statistics: ${error.message}`);
        }
    }
    async getAllTransactions(user, filters) {
        try {
            this.logger.log(`Admin ${user.id} getting all transactions`);
            const result = await this.transactionsService.getAllTransactions(filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
                filters: result.filters,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get all transactions: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get all transactions: ${error.message}`);
        }
    }
    async getTransactionStatistics(user, startDate, endDate, sellerId) {
        try {
            this.logger.log(`Admin ${user.id} getting transaction statistics`);
            const stats = await this.transactionsService.getTransactionStatistics({
                startDate,
                endDate,
                sellerId
            });
            return {
                success: true,
                data: stats,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get transaction statistics: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get transaction statistics: ${error.message}`);
        }
    }
    async getSellerTransactionsAdmin(sellerId, user, filters) {
        try {
            this.logger.log(`Admin ${user.id} getting transactions for seller ${sellerId}`);
            const result = await this.transactionsService.getSellerTransactions(sellerId, filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
                sellerId,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get seller transactions: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get seller transactions: ${error.message}`);
        }
    }
};
exports.TransactionsController = TransactionsController;
__decorate([
    (0, common_1.Get)('my-transactions'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller transactions',
        description: 'Get paginated list of transactions for authenticated seller'
    }),
    (0, swagger_1.ApiQuery)({ name: 'type', required: false, enum: ['SALE', 'PLATFORM_FEE', 'STRIPE_FEE', 'PAYOUT', 'REFUND', 'CHARGEBACK'] }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, enum: ['PENDING', 'COMPLETED', 'FAILED', 'CANCELLED'] }),
    (0, swagger_1.ApiQuery)({ name: 'currency', required: false, enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'] }),
    (0, swagger_1.ApiQuery)({ name: 'orderId', required: false, description: 'Filter by order ID' }),
    (0, swagger_1.ApiQuery)({ name: 'payoutId', required: false, description: 'Filter by payout ID' }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, description: 'Page number' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, description: 'Items per page' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Transactions retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_b = typeof transaction_filter_dto_1.TransactionFilterDto !== "undefined" && transaction_filter_dto_1.TransactionFilterDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getMyTransactions", null);
__decorate([
    (0, common_1.Get)(':transactionId'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get transaction details',
        description: 'Get detailed information about a specific transaction'
    }),
    (0, swagger_1.ApiParam)({ name: 'transactionId', description: 'Transaction ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Transaction details retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Transaction not found' }),
    __param(0, (0, common_1.Param)('transactionId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getTransactionDetails", null);
__decorate([
    (0, common_1.Get)('my-transactions/statistics'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller transaction statistics',
        description: 'Get transaction statistics for authenticated seller'
    }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date for stats' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date for stats' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Statistics retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getMyTransactionStatistics", null);
__decorate([
    (0, common_1.Get)('admin/all'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all transactions (Admin)',
        description: 'Get paginated list of all transactions across all sellers'
    }),
    (0, swagger_1.ApiQuery)({ name: 'type', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'currency', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'sellerId', required: false, description: 'Filter by seller ID' }),
    (0, swagger_1.ApiQuery)({ name: 'orderId', required: false, description: 'Filter by order ID' }),
    (0, swagger_1.ApiQuery)({ name: 'payoutId', required: false, description: 'Filter by payout ID' }),
    (0, swagger_1.ApiQuery)({ name: 'search', required: false, description: 'Search in descriptions and IDs' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'All transactions retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof transaction_filter_dto_1.TransactionFilterDto !== "undefined" && transaction_filter_dto_1.TransactionFilterDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getAllTransactions", null);
__decorate([
    (0, common_1.Get)('admin/statistics'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get transaction statistics (Admin)',
        description: 'Get comprehensive statistics about transactions across the platform'
    }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date for stats' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date for stats' }),
    (0, swagger_1.ApiQuery)({ name: 'sellerId', required: false, description: 'Filter by specific seller' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Statistics retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __param(3, (0, common_1.Query)('sellerId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String, String]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getTransactionStatistics", null);
__decorate([
    (0, common_1.Get)('admin/seller/:sellerId'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get transactions by seller (Admin)',
        description: 'Get all transactions for a specific seller'
    }),
    (0, swagger_1.ApiParam)({ name: 'sellerId', description: 'Seller user ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Seller transactions retrieved successfully' }),
    __param(0, (0, common_1.Param)('sellerId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __param(2, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, typeof (_d = typeof transaction_filter_dto_1.TransactionFilterDto !== "undefined" && transaction_filter_dto_1.TransactionFilterDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getSellerTransactionsAdmin", null);
exports.TransactionsController = TransactionsController = TransactionsController_1 = __decorate([
    (0, swagger_1.ApiTags)('transactions'),
    (0, common_1.Controller)('api/transactions'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof transactions_service_1.TransactionsService !== "undefined" && transactions_service_1.TransactionsService) === "function" ? _a : Object])
], TransactionsController);


/***/ }),
/* 280 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TransactionsService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionsService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const stripe_service_1 = __webpack_require__(243);
let TransactionsService = TransactionsService_1 = class TransactionsService {
    constructor(prisma, stripeService) {
        this.prisma = prisma;
        this.stripeService = stripeService;
        this.logger = new common_1.Logger(TransactionsService_1.name);
    }
    async createTransaction(data) {
        try {
            this.logger.log(`Creating transaction: ${data.type} for ${data.amount} ${data.currency}`);
            const transaction = await this.prisma.transaction.create({
                data: {
                    type: data.type,
                    status: data.status,
                    amount: data.amount,
                    currency: data.currency,
                    sellerId: data.sellerId,
                    orderId: data.orderId,
                    payoutId: data.payoutId,
                    stripeTransactionId: data.stripeTransactionId,
                    stripeChargeId: data.stripeChargeId,
                    stripePaymentIntentId: data.stripePaymentIntentId,
                    description: data.description,
                    metadata: data.metadata,
                },
            });
            this.logger.log(`Transaction ${transaction.id} created successfully`);
            return transaction;
        }
        catch (error) {
            this.logger.error(`Failed to create transaction: ${error.message}`);
            throw error;
        }
    }
    async getSellerTransactions(sellerId, filters) {
        try {
            this.logger.log(`Getting transactions for seller ${sellerId}`);
            const where = {
                sellerId,
            };
            if (filters.type) {
                where.type = filters.type;
            }
            if (filters.status) {
                where.status = filters.status;
            }
            if (filters.currency) {
                where.currency = filters.currency;
            }
            if (filters.orderId) {
                where.orderId = filters.orderId;
            }
            if (filters.payoutId) {
                where.payoutId = filters.payoutId;
            }
            if (filters.startDate || filters.endDate) {
                where.createdAt = {};
                if (filters.startDate) {
                    where.createdAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.createdAt.lte = new Date(filters.endDate);
                }
            }
            if (filters.minAmount !== undefined || filters.maxAmount !== undefined) {
                where.amount = {};
                if (filters.minAmount !== undefined) {
                    where.amount.gte = filters.minAmount;
                }
                if (filters.maxAmount !== undefined) {
                    where.amount.lte = filters.maxAmount;
                }
            }
            if (filters.search) {
                where.OR = [
                    { description: { contains: filters.search } },
                    { stripeTransactionId: { contains: filters.search } },
                    { stripeChargeId: { contains: filters.search } },
                ];
            }
            const limit = filters.limit || 20;
            const page = filters.page || 1;
            const skip = (page - 1) * limit;
            const orderBy = {};
            const sortField = filters.sortBy || 'createdAt';
            orderBy[sortField] = filters.sortOrder || 'desc';
            const [transactions, total] = await Promise.all([
                this.prisma.transaction.findMany({
                    where,
                    orderBy,
                    skip,
                    take: limit,
                    include: {
                        seller: {
                            select: {
                                firstName: true,
                                lastName: true,
                                email: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                    },
                                },
                            },
                        },
                        order: {
                            select: {
                                orderNumber: true,
                                totalAmount: true,
                                status: true,
                            },
                        },
                        payout: {
                            select: {
                                id: true,
                                amount: true,
                                status: true,
                                requestedAt: true,
                            },
                        },
                    },
                }),
                this.prisma.transaction.count({ where }),
            ]);
            return {
                data: transactions,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                    hasNext: page * limit < total,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get seller transactions: ${error.message}`);
            throw error;
        }
    }
    async getAllTransactions(filters) {
        try {
            this.logger.log('Getting all transactions for admin');
            const where = {};
            if (filters.type) {
                where.type = filters.type;
            }
            if (filters.status) {
                where.status = filters.status;
            }
            if (filters.currency) {
                where.currency = filters.currency;
            }
            if (filters.sellerId) {
                where.sellerId = filters.sellerId;
            }
            if (filters.orderId) {
                where.orderId = filters.orderId;
            }
            if (filters.payoutId) {
                where.payoutId = filters.payoutId;
            }
            if (filters.startDate || filters.endDate) {
                where.createdAt = {};
                if (filters.startDate) {
                    where.createdAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.createdAt.lte = new Date(filters.endDate);
                }
            }
            if (filters.minAmount !== undefined || filters.maxAmount !== undefined) {
                where.amount = {};
                if (filters.minAmount !== undefined) {
                    where.amount.gte = filters.minAmount;
                }
                if (filters.maxAmount !== undefined) {
                    where.amount.lte = filters.maxAmount;
                }
            }
            if (filters.search) {
                where.OR = [
                    { description: { contains: filters.search } },
                    { stripeTransactionId: { contains: filters.search } },
                    {
                        seller: {
                            OR: [
                                { firstName: { contains: filters.search } },
                                { lastName: { contains: filters.search } },
                                { email: { contains: filters.search } },
                            ],
                        },
                    },
                ];
            }
            const limit = filters.limit || 20;
            const page = filters.page || 1;
            const skip = (page - 1) * limit;
            const orderBy = {};
            const sortField = filters.sortBy || 'createdAt';
            orderBy[sortField] = filters.sortOrder || 'desc';
            const [transactions, total] = await Promise.all([
                this.prisma.transaction.findMany({
                    where,
                    orderBy,
                    skip,
                    take: limit,
                    include: {
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                email: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                    },
                                },
                            },
                        },
                        order: {
                            select: {
                                orderNumber: true,
                                totalAmount: true,
                                status: true,
                                buyerId: true,
                            },
                        },
                        payout: {
                            select: {
                                id: true,
                                amount: true,
                                status: true,
                                requestedAt: true,
                            },
                        },
                    },
                }),
                this.prisma.transaction.count({ where }),
            ]);
            return {
                data: transactions,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                    hasNext: page * limit < total,
                    hasPrev: page > 1,
                },
                filters: {
                    applied: Object.keys(where).length > 0,
                    ...filters,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get all transactions: ${error.message}`);
            throw error;
        }
    }
    async getTransactionById(transactionId, userId, userRole) {
        try {
            this.logger.log(`Getting transaction ${transactionId} for user ${userId}`);
            const where = { id: transactionId };
            const transaction = await this.prisma.transaction.findUnique({
                where,
                include: {
                    seller: {
                        select: {
                            firstName: true,
                            lastName: true,
                            email: true,
                            sellerProfile: {
                                select: {
                                    storeName: true,
                                },
                            },
                        },
                    },
                    order: {
                        select: {
                            orderNumber: true,
                            totalAmount: true,
                            status: true,
                            buyerId: true,
                            buyer: {
                                select: {
                                    firstName: true,
                                    lastName: true,
                                    email: true,
                                },
                            },
                        },
                    },
                    payout: {
                        select: {
                            id: true,
                            amount: true,
                            status: true,
                            requestedAt: true,
                            processedAt: true,
                        },
                    },
                },
            });
            if (!transaction) {
                throw new common_1.NotFoundException('Transaction not found');
            }
            if (userRole !== 'ADMIN' && transaction.sellerId !== userId) {
                throw new common_1.NotFoundException('Transaction not found');
            }
            return transaction;
        }
        catch (error) {
            this.logger.error(`Failed to get transaction: ${error.message}`);
            throw error;
        }
    }
    async getTransactionStatistics(filters) {
        try {
            this.logger.log('Getting transaction statistics');
            const where = {};
            if (filters?.sellerId) {
                where.sellerId = filters.sellerId;
            }
            if (filters?.startDate || filters?.endDate) {
                where.createdAt = {};
                if (filters.startDate) {
                    where.createdAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.createdAt.lte = new Date(filters.endDate);
                }
            }
            const typeStats = await this.prisma.transaction.groupBy({
                by: ['type'],
                where,
                _count: {
                    id: true,
                },
                _sum: {
                    amount: true,
                },
            });
            const statusStats = await this.prisma.transaction.groupBy({
                by: ['status'],
                where,
                _count: {
                    id: true,
                },
                _sum: {
                    amount: true,
                },
            });
            const currencyStats = await this.prisma.transaction.groupBy({
                by: ['currency'],
                where,
                _count: {
                    id: true,
                },
                _sum: {
                    amount: true,
                },
            });
            const totalTransactions = await this.prisma.transaction.count({ where });
            const totalAmount = await this.prisma.transaction.aggregate({
                where,
                _sum: {
                    amount: true,
                },
            });
            return {
                summary: {
                    totalTransactions,
                    totalAmount: Number(totalAmount._sum.amount || 0),
                    averageAmount: totalTransactions > 0 ? Number(totalAmount._sum.amount || 0) / totalTransactions : 0,
                },
                byType: typeStats.map(stat => ({
                    type: stat.type,
                    count: stat._count.id,
                    totalAmount: Number(stat._sum.amount || 0),
                })),
                byStatus: statusStats.map(stat => ({
                    status: stat.status,
                    count: stat._count.id,
                    totalAmount: Number(stat._sum.amount || 0),
                })),
                byCurrency: currencyStats.map(stat => ({
                    currency: stat.currency,
                    count: stat._count.id,
                    totalAmount: Number(stat._sum.amount || 0),
                })),
            };
        }
        catch (error) {
            this.logger.error(`Failed to get transaction statistics: ${error.message}`);
            throw error;
        }
    }
    async updateTransactionStatus(transactionId, status, metadata) {
        try {
            this.logger.log(`Updating transaction ${transactionId} status to ${status}`);
            const updateData = {
                status,
                updatedAt: new Date(),
            };
            if (metadata) {
                updateData.metadata = metadata;
            }
            const updatedTransaction = await this.prisma.transaction.update({
                where: { id: transactionId },
                data: updateData,
            });
            this.logger.log(`Transaction ${transactionId} status updated to ${status}`);
            return updatedTransaction;
        }
        catch (error) {
            this.logger.error(`Failed to update transaction status: ${error.message}`);
            throw error;
        }
    }
    async recordOrderTransactions(orderId, orderData) {
        try {
            this.logger.log(`Recording transactions for order ${orderId}`);
            const transactions = [];
            const saleTransaction = await this.createTransaction({
                type: 'SALE',
                status: 'COMPLETED',
                amount: orderData.totalAmount,
                currency: orderData.currency,
                sellerId: orderData.sellerId,
                orderId,
                stripePaymentIntentId: orderData.stripePaymentIntentId,
                stripeChargeId: orderData.stripeChargeId,
                description: `Sale for order ${orderId}`,
                metadata: {
                    buyerId: orderData.buyerId,
                },
            });
            transactions.push(saleTransaction);
            const platformFeeTransaction = await this.createTransaction({
                type: 'PLATFORM_FEE',
                status: 'COMPLETED',
                amount: orderData.platformFeeAmount,
                currency: orderData.currency,
                orderId,
                description: `Platform fee for order ${orderId}`,
                metadata: {
                    sellerId: orderData.sellerId,
                    buyerId: orderData.buyerId,
                },
            });
            transactions.push(platformFeeTransaction);
            if (orderData.stripeFeeAmount) {
                const stripeFeeTransaction = await this.createTransaction({
                    type: 'STRIPE_FEE',
                    status: 'COMPLETED',
                    amount: orderData.stripeFeeAmount,
                    currency: orderData.currency,
                    orderId,
                    description: `Stripe processing fee for order ${orderId}`,
                    metadata: {
                        sellerId: orderData.sellerId,
                    },
                });
                transactions.push(stripeFeeTransaction);
            }
            this.logger.log(`Recorded ${transactions.length} transactions for order ${orderId}`);
            return transactions;
        }
        catch (error) {
            this.logger.error(`Failed to record order transactions: ${error.message}`);
            throw error;
        }
    }
};
exports.TransactionsService = TransactionsService;
exports.TransactionsService = TransactionsService = TransactionsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => stripe_service_1.StripeService))),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof stripe_service_1.StripeService !== "undefined" && stripe_service_1.StripeService) === "function" ? _b : Object])
], TransactionsService);


/***/ }),
/* 281 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionFilterDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const class_transformer_1 = __webpack_require__(40);
const client_1 = __webpack_require__(11);
class TransactionFilterDto {
}
exports.TransactionFilterDto = TransactionFilterDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by transaction type',
        example: 'SALE',
        enum: ['SALE', 'PLATFORM_FEE', 'STRIPE_FEE', 'PAYOUT', 'REFUND', 'CHARGEBACK'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['SALE', 'PLATFORM_FEE', 'STRIPE_FEE', 'PAYOUT', 'REFUND', 'CHARGEBACK'], {
        message: 'type.invalid',
    }),
    __metadata("design:type", typeof (_a = typeof client_1.TransactionType !== "undefined" && client_1.TransactionType) === "function" ? _a : Object)
], TransactionFilterDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by transaction status',
        example: 'COMPLETED',
        enum: ['PENDING', 'COMPLETED', 'FAILED', 'CANCELLED'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['PENDING', 'COMPLETED', 'FAILED', 'CANCELLED'], {
        message: 'status.invalid',
    }),
    __metadata("design:type", typeof (_b = typeof client_1.TransactionStatus !== "undefined" && client_1.TransactionStatus) === "function" ? _b : Object)
], TransactionFilterDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by currency',
        example: 'USD',
        enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'], {
        message: 'currency.invalid',
    }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by seller ID',
        example: 'user_123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'sellerId.invalid' }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by order ID',
        example: 'order_123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'orderId.invalid' }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by payout ID',
        example: 'payout_123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'payoutId.invalid' }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "payoutId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start date for date range filter (ISO format)',
        example: '2024-01-01T00:00:00Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'startDate.invalid' }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End date for date range filter (ISO format)',
        example: '2024-12-31T23:59:59Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'endDate.invalid' }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "endDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum transaction amount',
        example: 1.00,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'minAmount.invalid' }),
    (0, class_validator_1.Min)(0, { message: 'minAmount.tooSmall' }),
    __metadata("design:type", Number)
], TransactionFilterDto.prototype, "minAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum transaction amount',
        example: 10000.00,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'maxAmount.invalid' }),
    (0, class_validator_1.Min)(0, { message: 'maxAmount.tooSmall' }),
    __metadata("design:type", Number)
], TransactionFilterDto.prototype, "maxAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of records per page',
        example: 20,
        default: 20,
        minimum: 1,
        maximum: 100,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)({}, { message: 'limit.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'limit.tooSmall' }),
    (0, class_validator_1.Max)(100, { message: 'limit.tooLarge' }),
    __metadata("design:type", Number)
], TransactionFilterDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Page number (1-based)',
        example: 1,
        default: 1,
        minimum: 1,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)({}, { message: 'page.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'page.tooSmall' }),
    __metadata("design:type", Number)
], TransactionFilterDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort field',
        example: 'createdAt',
        enum: ['createdAt', 'amount', 'type', 'status'],
        default: 'createdAt',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['createdAt', 'amount', 'type', 'status'], {
        message: 'sortBy.invalid',
    }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort order',
        example: 'desc',
        enum: ['asc', 'desc'],
        default: 'desc',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['asc', 'desc'], { message: 'sortOrder.invalid' }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "sortOrder", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Search in description or Stripe transaction ID',
        example: 'ch_1234567890',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'search.invalid' }),
    __metadata("design:type", String)
], TransactionFilterDto.prototype, "search", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include related data (order, seller, payout)',
        example: true,
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    __metadata("design:type", Boolean)
], TransactionFilterDto.prototype, "includeRelations", void 0);


/***/ }),
/* 282 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvoicesModule = void 0;
const common_1 = __webpack_require__(2);
const invoices_controller_1 = __webpack_require__(283);
const invoices_service_1 = __webpack_require__(284);
const prisma_module_1 = __webpack_require__(9);
const stripe_module_1 = __webpack_require__(246);
let InvoicesModule = class InvoicesModule {
};
exports.InvoicesModule = InvoicesModule;
exports.InvoicesModule = InvoicesModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            (0, common_1.forwardRef)(() => stripe_module_1.StripeModule),
        ],
        controllers: [invoices_controller_1.InvoicesController],
        providers: [invoices_service_1.InvoicesService],
        exports: [invoices_service_1.InvoicesService],
    })
], InvoicesModule);


/***/ }),
/* 283 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var InvoicesController_1;
var _a, _b, _c, _d, _e, _f;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvoicesController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const express_1 = __webpack_require__(52);
const invoices_service_1 = __webpack_require__(284);
const generate_invoice_dto_1 = __webpack_require__(285);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const current_user_decorator_1 = __webpack_require__(26);
let InvoicesController = InvoicesController_1 = class InvoicesController {
    constructor(invoicesService) {
        this.invoicesService = invoicesService;
        this.logger = new common_1.Logger(InvoicesController_1.name);
    }
    async generateInvoice(generateDto, user) {
        try {
            this.logger.log(`Generating invoice for order ${generateDto.orderId} by user ${user.id}`);
            const invoices = await this.invoicesService.generateInvoiceFromOrder(generateDto.orderId, generateDto);
            return {
                success: true,
                message: 'Invoice(s) generated successfully',
                data: invoices,
            };
        }
        catch (error) {
            this.logger.error(`Failed to generate invoice: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to generate invoice: ${error.message}`);
        }
    }
    async getMyInvoices(user, filters) {
        try {
            this.logger.log(`Getting invoices for seller ${user.id}`);
            const result = await this.invoicesService.getSellerInvoices(user.id, filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get invoices: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get invoices: ${error.message}`);
        }
    }
    async getInvoiceDetails(invoiceId, user) {
        try {
            this.logger.log(`Getting invoice details ${invoiceId} for user ${user.id}`);
            const invoice = await this.invoicesService.getInvoiceById(invoiceId, user.id, user.role);
            return {
                success: true,
                data: invoice,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get invoice details: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get invoice details: ${error.message}`);
        }
    }
    async downloadInvoicePDF(invoiceId, user, res) {
        try {
            this.logger.log(`Downloading PDF for invoice ${invoiceId} by user ${user.id}`);
            await this.invoicesService.getInvoiceById(invoiceId, user.id, user.role);
            const pdfUrl = await this.invoicesService.generateInvoicePDF(invoiceId);
            return res.json({
                success: true,
                data: {
                    pdfUrl,
                    downloadUrl: `${process.env.API_URL}${pdfUrl}`,
                },
            });
        }
        catch (error) {
            this.logger.error(`Failed to download invoice PDF: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to download invoice PDF: ${error.message}`);
        }
    }
    async getMyInvoiceStatistics(user, startDate, endDate) {
        try {
            this.logger.log(`Getting invoice statistics for seller ${user.id}`);
            const stats = await this.invoicesService.getInvoiceStatistics({
                startDate,
                endDate,
                sellerId: user.id
            });
            return {
                success: true,
                data: stats,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get invoice statistics: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get invoice statistics: ${error.message}`);
        }
    }
    async getAllInvoices(user, filters) {
        try {
            this.logger.log(`Admin ${user.id} getting all invoices`);
            const result = await this.invoicesService.getAllInvoices(filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
                filters: result.filters,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get all invoices: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get all invoices: ${error.message}`);
        }
    }
    async updateInvoiceStatus(invoiceId, body, user) {
        try {
            this.logger.log(`Admin ${user.id} updating invoice ${invoiceId} status to ${body.status}`);
            const result = await this.invoicesService.updateInvoiceStatus(invoiceId, body.status);
            return {
                success: true,
                message: 'Invoice status updated successfully',
                data: result,
            };
        }
        catch (error) {
            this.logger.error(`Failed to update invoice status: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to update invoice status: ${error.message}`);
        }
    }
    async processOverdueInvoices(user) {
        try {
            this.logger.log(`Admin ${user.id} processing overdue invoices`);
            const result = await this.invoicesService.processOverdueInvoices();
            return {
                success: true,
                message: `Processed ${result.processed} overdue invoices`,
                data: result,
            };
        }
        catch (error) {
            this.logger.error(`Failed to process overdue invoices: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to process overdue invoices: ${error.message}`);
        }
    }
    async getInvoiceStatistics(user, startDate, endDate, sellerId) {
        try {
            this.logger.log(`Admin ${user.id} getting invoice statistics`);
            const stats = await this.invoicesService.getInvoiceStatistics({
                startDate,
                endDate,
                sellerId
            });
            return {
                success: true,
                data: stats,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get invoice statistics: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get invoice statistics: ${error.message}`);
        }
    }
    async getSellerInvoicesAdmin(sellerId, user, filters) {
        try {
            this.logger.log(`Admin ${user.id} getting invoices for seller ${sellerId}`);
            const result = await this.invoicesService.getSellerInvoices(sellerId, filters);
            return {
                success: true,
                data: result.data,
                pagination: result.pagination,
                sellerId,
            };
        }
        catch (error) {
            this.logger.error(`Failed to get seller invoices: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get seller invoices: ${error.message}`);
        }
    }
};
exports.InvoicesController = InvoicesController;
__decorate([
    (0, common_1.Post)('generate'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER', 'ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Generate invoice from order',
        description: 'Generate an invoice for a completed order'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Invoice generated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid order or invoice already exists' }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof generate_invoice_dto_1.GenerateInvoiceDto !== "undefined" && generate_invoice_dto_1.GenerateInvoiceDto) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "generateInvoice", null);
__decorate([
    (0, common_1.Get)('my-invoices'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller invoices',
        description: 'Get paginated list of invoices for authenticated seller'
    }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, enum: ['PENDING', 'ISSUED', 'PAID', 'OVERDUE', 'CANCELLED'] }),
    (0, swagger_1.ApiQuery)({ name: 'currency', required: false, enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'] }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date (ISO format)' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, description: 'Page number' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, description: 'Items per page' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Invoices retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_c = typeof generate_invoice_dto_1.InvoiceFilterDto !== "undefined" && generate_invoice_dto_1.InvoiceFilterDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "getMyInvoices", null);
__decorate([
    (0, common_1.Get)(':invoiceId'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get invoice details',
        description: 'Get detailed information about a specific invoice'
    }),
    (0, swagger_1.ApiParam)({ name: 'invoiceId', description: 'Invoice ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Invoice details retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Invoice not found' }),
    __param(0, (0, common_1.Param)('invoiceId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "getInvoiceDetails", null);
__decorate([
    (0, common_1.Get)(':invoiceId/pdf'),
    (0, swagger_1.ApiOperation)({
        summary: 'Download invoice PDF',
        description: 'Download PDF version of the invoice'
    }),
    (0, swagger_1.ApiParam)({ name: 'invoiceId', description: 'Invoice ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'PDF downloaded successfully' }),
    __param(0, (0, common_1.Param)('invoiceId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __param(2, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, typeof (_d = typeof express_1.Response !== "undefined" && express_1.Response) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "downloadInvoicePDF", null);
__decorate([
    (0, common_1.Get)('my-invoices/statistics'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('SELLER'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller invoice statistics',
        description: 'Get invoice statistics for authenticated seller'
    }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date for stats' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date for stats' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Statistics retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "getMyInvoiceStatistics", null);
__decorate([
    (0, common_1.Get)('admin/all'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all invoices (Admin)',
        description: 'Get paginated list of all invoices across all sellers'
    }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'currency', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'sellerId', required: false, description: 'Filter by seller ID' }),
    (0, swagger_1.ApiQuery)({ name: 'search', required: false, description: 'Search in invoice numbers and order numbers' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'All invoices retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeof (_e = typeof generate_invoice_dto_1.InvoiceFilterDto !== "undefined" && generate_invoice_dto_1.InvoiceFilterDto) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "getAllInvoices", null);
__decorate([
    (0, common_1.Put)('admin/:invoiceId/status'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Update invoice status (Admin)',
        description: 'Update the status of an invoice'
    }),
    (0, swagger_1.ApiParam)({ name: 'invoiceId', description: 'Invoice ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Invoice status updated successfully' }),
    __param(0, (0, common_1.Param)('invoiceId')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "updateInvoiceStatus", null);
__decorate([
    (0, common_1.Post)('admin/process-overdue'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Process overdue invoices (Admin)',
        description: 'Mark overdue invoices and send notifications'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Overdue invoices processed successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "processOverdueInvoices", null);
__decorate([
    (0, common_1.Get)('admin/statistics'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get invoice statistics (Admin)',
        description: 'Get comprehensive statistics about invoices across the platform'
    }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Start date for stats' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'End date for stats' }),
    (0, swagger_1.ApiQuery)({ name: 'sellerId', required: false, description: 'Filter by specific seller' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Statistics retrieved successfully' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)()),
    __param(1, (0, common_1.Query)('startDate')),
    __param(2, (0, common_1.Query)('endDate')),
    __param(3, (0, common_1.Query)('sellerId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, String, String]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "getInvoiceStatistics", null);
__decorate([
    (0, common_1.Get)('admin/seller/:sellerId'),
    (0, common_1.UseGuards)(roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)('ADMIN'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get invoices by seller (Admin)',
        description: 'Get all invoices for a specific seller'
    }),
    (0, swagger_1.ApiParam)({ name: 'sellerId', description: 'Seller user ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Seller invoices retrieved successfully' }),
    __param(0, (0, common_1.Param)('sellerId')),
    __param(1, (0, current_user_decorator_1.CurrentUser)()),
    __param(2, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, typeof (_f = typeof generate_invoice_dto_1.InvoiceFilterDto !== "undefined" && generate_invoice_dto_1.InvoiceFilterDto) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], InvoicesController.prototype, "getSellerInvoicesAdmin", null);
exports.InvoicesController = InvoicesController = InvoicesController_1 = __decorate([
    (0, swagger_1.ApiTags)('invoices'),
    (0, common_1.Controller)('api/invoices'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof invoices_service_1.InvoicesService !== "undefined" && invoices_service_1.InvoicesService) === "function" ? _a : Object])
], InvoicesController);


/***/ }),
/* 284 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var InvoicesService_1;
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvoicesService = void 0;
const common_1 = __webpack_require__(2);
const config_1 = __webpack_require__(3);
const prisma_service_1 = __webpack_require__(10);
let InvoicesService = InvoicesService_1 = class InvoicesService {
    constructor(prisma, configService) {
        this.prisma = prisma;
        this.configService = configService;
        this.logger = new common_1.Logger(InvoicesService_1.name);
    }
    async generateInvoiceFromOrder(orderId, dto) {
        try {
            this.logger.log(`Generating invoice for order ${orderId}`);
            const order = await this.prisma.order.findUnique({
                where: { id: orderId },
                include: {
                    buyer: {
                        select: {
                            firstName: true,
                            lastName: true,
                            email: true,
                        },
                    },
                    items: {
                        include: {
                            seller: {
                                select: {
                                    id: true,
                                    firstName: true,
                                    lastName: true,
                                    email: true,
                                    sellerProfile: {
                                        select: {
                                            storeName: true,
                                        },
                                    },
                                },
                            },
                            product: {
                                select: {
                                    title: true,
                                    category: true,
                                },
                            },
                        },
                    },
                },
            });
            if (!order) {
                throw new common_1.NotFoundException('Order not found');
            }
            if (order.status !== 'COMPLETED') {
                throw new common_1.BadRequestException('Can only generate invoice for completed orders');
            }
            const existingInvoice = await this.prisma.invoice.findUnique({
                where: { orderId },
            });
            if (existingInvoice) {
                throw new common_1.BadRequestException('Invoice already exists for this order');
            }
            const sellerGroups = this.groupOrderItemsBySeller(order.items);
            const invoices = [];
            for (const [sellerId, items] of sellerGroups.entries()) {
                const seller = items[0].seller;
                const subtotal = items.reduce((sum, item) => sum + Number(item.price), 0);
                const platformFeeRate = order.platformFeeRate || 0.10;
                const platformFee = subtotal * platformFeeRate;
                const netAmount = subtotal - platformFee;
                const taxRate = dto?.taxRate || 0;
                const taxAmount = netAmount * taxRate;
                const totalAmount = netAmount + taxAmount;
                const invoiceNumber = await this.generateInvoiceNumber();
                const invoice = await this.prisma.invoice.create({
                    data: {
                        invoiceNumber,
                        sellerId,
                        orderId,
                        subtotal: subtotal,
                        platformFee: platformFee,
                        netAmount: netAmount,
                        taxAmount: taxAmount > 0 ? taxAmount : null,
                        totalAmount: totalAmount,
                        status: 'ISSUED',
                        currency: 'USD',
                        issuedAt: new Date(),
                        dueAt: dto?.dueAt ? new Date(dto.dueAt) : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                    },
                });
                invoices.push({
                    ...invoice,
                    seller: {
                        name: `${seller.firstName} ${seller.lastName}`,
                        storeName: seller.sellerProfile?.storeName,
                        email: seller.email,
                    },
                    items: items.map(item => ({
                        productTitle: item.product.title,
                        category: item.product.category,
                        price: Number(item.price),
                        quantity: item.quantity,
                    })),
                });
            }
            this.logger.log(`Generated ${invoices.length} invoices for order ${orderId}`);
            return invoices;
        }
        catch (error) {
            this.logger.error(`Failed to generate invoice: ${error.message}`);
            throw error;
        }
    }
    async getSellerInvoices(sellerId, filters) {
        try {
            this.logger.log(`Getting invoices for seller ${sellerId}`);
            const where = {
                sellerId,
            };
            if (filters.status) {
                where.status = filters.status;
            }
            if (filters.currency) {
                where.currency = filters.currency;
            }
            if (filters.startDate || filters.endDate) {
                where.issuedAt = {};
                if (filters.startDate) {
                    where.issuedAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.issuedAt.lte = new Date(filters.endDate);
                }
            }
            if (filters.minAmount !== undefined || filters.maxAmount !== undefined) {
                where.totalAmount = {};
                if (filters.minAmount !== undefined) {
                    where.totalAmount.gte = filters.minAmount;
                }
                if (filters.maxAmount !== undefined) {
                    where.totalAmount.lte = filters.maxAmount;
                }
            }
            if (filters.search) {
                where.OR = [
                    { invoiceNumber: { contains: filters.search } },
                    {
                        order: {
                            orderNumber: { contains: filters.search },
                        },
                    },
                ];
            }
            const limit = filters.limit || 20;
            const page = filters.page || 1;
            const skip = (page - 1) * limit;
            const orderBy = {};
            const sortField = filters.sortBy || 'issuedAt';
            orderBy[sortField] = filters.sortOrder || 'desc';
            const [invoices, total] = await Promise.all([
                this.prisma.invoice.findMany({
                    where,
                    orderBy,
                    skip,
                    take: limit,
                    include: {
                        seller: {
                            select: {
                                firstName: true,
                                lastName: true,
                                email: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                    },
                                },
                            },
                        },
                        order: {
                            select: {
                                orderNumber: true,
                                totalAmount: true,
                                status: true,
                                buyer: {
                                    select: {
                                        firstName: true,
                                        lastName: true,
                                        email: true,
                                    },
                                },
                            },
                        },
                    },
                }),
                this.prisma.invoice.count({ where }),
            ]);
            return {
                data: invoices,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                    hasNext: page * limit < total,
                    hasPrev: page > 1,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get seller invoices: ${error.message}`);
            throw error;
        }
    }
    async getAllInvoices(filters) {
        try {
            this.logger.log('Getting all invoices for admin');
            const where = {};
            if (filters.status) {
                where.status = filters.status;
            }
            if (filters.currency) {
                where.currency = filters.currency;
            }
            if (filters.sellerId) {
                where.sellerId = filters.sellerId;
            }
            if (filters.startDate || filters.endDate) {
                where.issuedAt = {};
                if (filters.startDate) {
                    where.issuedAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.issuedAt.lte = new Date(filters.endDate);
                }
            }
            if (filters.minAmount !== undefined || filters.maxAmount !== undefined) {
                where.totalAmount = {};
                if (filters.minAmount !== undefined) {
                    where.totalAmount.gte = filters.minAmount;
                }
                if (filters.maxAmount !== undefined) {
                    where.totalAmount.lte = filters.maxAmount;
                }
            }
            if (filters.search) {
                where.OR = [
                    { invoiceNumber: { contains: filters.search } },
                    {
                        order: {
                            orderNumber: { contains: filters.search },
                        },
                    },
                    {
                        seller: {
                            OR: [
                                { firstName: { contains: filters.search } },
                                { lastName: { contains: filters.search } },
                                { email: { contains: filters.search } },
                            ],
                        },
                    },
                ];
            }
            const limit = filters.limit || 20;
            const page = filters.page || 1;
            const skip = (page - 1) * limit;
            const orderBy = {};
            const sortField = filters.sortBy || 'issuedAt';
            orderBy[sortField] = filters.sortOrder || 'desc';
            const [invoices, total] = await Promise.all([
                this.prisma.invoice.findMany({
                    where,
                    orderBy,
                    skip,
                    take: limit,
                    include: {
                        seller: {
                            select: {
                                id: true,
                                firstName: true,
                                lastName: true,
                                email: true,
                                sellerProfile: {
                                    select: {
                                        storeName: true,
                                    },
                                },
                            },
                        },
                        order: {
                            select: {
                                orderNumber: true,
                                totalAmount: true,
                                status: true,
                                buyerId: true,
                                buyer: {
                                    select: {
                                        firstName: true,
                                        lastName: true,
                                        email: true,
                                    },
                                },
                            },
                        },
                    },
                }),
                this.prisma.invoice.count({ where }),
            ]);
            return {
                data: invoices,
                pagination: {
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                    hasNext: page * limit < total,
                    hasPrev: page > 1,
                },
                filters: {
                    applied: Object.keys(where).length > 0,
                    ...filters,
                },
            };
        }
        catch (error) {
            this.logger.error(`Failed to get all invoices: ${error.message}`);
            throw error;
        }
    }
    async getInvoiceById(invoiceId, userId, userRole) {
        try {
            this.logger.log(`Getting invoice ${invoiceId} for user ${userId}`);
            const where = { id: invoiceId };
            const invoice = await this.prisma.invoice.findUnique({
                where,
                include: {
                    seller: {
                        select: {
                            firstName: true,
                            lastName: true,
                            email: true,
                            sellerProfile: {
                                select: {
                                    storeName: true,
                                },
                            },
                        },
                    },
                    order: {
                        select: {
                            orderNumber: true,
                            totalAmount: true,
                            status: true,
                            buyerId: true,
                            buyer: {
                                select: {
                                    firstName: true,
                                    lastName: true,
                                    email: true,
                                },
                            },
                            items: {
                                include: {
                                    product: {
                                        select: {
                                            title: true,
                                            category: true,
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            });
            if (!invoice) {
                throw new common_1.NotFoundException('Invoice not found');
            }
            if (userRole !== 'ADMIN' && invoice.sellerId !== userId) {
                throw new common_1.NotFoundException('Invoice not found');
            }
            return invoice;
        }
        catch (error) {
            this.logger.error(`Failed to get invoice: ${error.message}`);
            throw error;
        }
    }
    async updateInvoiceStatus(invoiceId, status) {
        try {
            this.logger.log(`Updating invoice ${invoiceId} status to ${status}`);
            const updateData = {
                status,
                updatedAt: new Date(),
            };
            if (status === 'PAID') {
                updateData.paidAt = new Date();
            }
            const updatedInvoice = await this.prisma.invoice.update({
                where: { id: invoiceId },
                data: updateData,
            });
            this.logger.log(`Invoice ${invoiceId} status updated to ${status}`);
            return updatedInvoice;
        }
        catch (error) {
            this.logger.error(`Failed to update invoice status: ${error.message}`);
            throw error;
        }
    }
    async getInvoiceStatistics(filters) {
        try {
            this.logger.log('Getting invoice statistics');
            const where = {};
            if (filters?.sellerId) {
                where.sellerId = filters.sellerId;
            }
            if (filters?.startDate || filters?.endDate) {
                where.issuedAt = {};
                if (filters.startDate) {
                    where.issuedAt.gte = new Date(filters.startDate);
                }
                if (filters.endDate) {
                    where.issuedAt.lte = new Date(filters.endDate);
                }
            }
            const statusStats = await this.prisma.invoice.groupBy({
                by: ['status'],
                where,
                _count: {
                    id: true,
                },
                _sum: {
                    totalAmount: true,
                },
            });
            const currencyStats = await this.prisma.invoice.groupBy({
                by: ['currency'],
                where,
                _count: {
                    id: true,
                },
                _sum: {
                    totalAmount: true,
                },
            });
            const totalInvoices = await this.prisma.invoice.count({ where });
            const totalAmount = await this.prisma.invoice.aggregate({
                where,
                _sum: {
                    totalAmount: true,
                },
            });
            return {
                summary: {
                    totalInvoices,
                    totalAmount: Number(totalAmount._sum.totalAmount || 0),
                    averageAmount: totalInvoices > 0 ? Number(totalAmount._sum.totalAmount || 0) / totalInvoices : 0,
                },
                byStatus: statusStats.map(stat => ({
                    status: stat.status,
                    count: stat._count.id,
                    totalAmount: Number(stat._sum.totalAmount || 0),
                })),
                byCurrency: currencyStats.map(stat => ({
                    currency: stat.currency,
                    count: stat._count.id,
                    totalAmount: Number(stat._sum.totalAmount || 0),
                })),
            };
        }
        catch (error) {
            this.logger.error(`Failed to get invoice statistics: ${error.message}`);
            throw error;
        }
    }
    async processOverdueInvoices() {
        try {
            this.logger.log('Processing overdue invoices');
            const now = new Date();
            const overdueInvoices = await this.prisma.invoice.findMany({
                where: {
                    status: 'ISSUED',
                    dueAt: {
                        lt: now,
                    },
                },
                select: {
                    id: true,
                    invoiceNumber: true,
                    sellerId: true,
                    dueAt: true,
                },
            });
            if (overdueInvoices.length === 0) {
                this.logger.log('No overdue invoices found');
                return { processed: 0, invoices: [] };
            }
            const updateResult = await this.prisma.invoice.updateMany({
                where: {
                    id: {
                        in: overdueInvoices.map(inv => inv.id),
                    },
                },
                data: {
                    status: 'OVERDUE',
                    updatedAt: now,
                },
            });
            this.logger.log(`Marked ${updateResult.count} invoices as overdue`);
            return {
                processed: updateResult.count,
                invoices: overdueInvoices,
            };
        }
        catch (error) {
            this.logger.error(`Failed to process overdue invoices: ${error.message}`);
            throw error;
        }
    }
    async generateInvoiceNumber() {
        const prefix = this.configService.get('INVOICE_PREFIX', 'INV');
        const date = new Date();
        const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
        const lastInvoice = await this.prisma.invoice.findFirst({
            where: {
                invoiceNumber: {
                    startsWith: `${prefix}-${dateStr}`,
                },
            },
            orderBy: {
                invoiceNumber: 'desc',
            },
        });
        let sequence = 1;
        if (lastInvoice) {
            const lastSequence = parseInt(lastInvoice.invoiceNumber.split('-').pop() || '0');
            sequence = lastSequence + 1;
        }
        const sequenceStr = sequence.toString().padStart(3, '0');
        return `${prefix}-${dateStr}-${sequenceStr}`;
    }
    groupOrderItemsBySeller(orderItems) {
        const groups = new Map();
        for (const item of orderItems) {
            const sellerId = item.sellerId;
            if (!groups.has(sellerId)) {
                groups.set(sellerId, []);
            }
            groups.get(sellerId).push(item);
        }
        return groups;
    }
    async generateInvoicePDF(invoiceId) {
        try {
            this.logger.log(`Generating PDF for invoice ${invoiceId}`);
            const invoice = await this.getInvoiceById(invoiceId, 'system', 'ADMIN');
            const pdfUrl = `/invoices/${invoiceId}/pdf`;
            await this.prisma.invoice.update({
                where: { id: invoiceId },
                data: { pdfUrl },
            });
            this.logger.log(`PDF generated for invoice ${invoiceId}: ${pdfUrl}`);
            return pdfUrl;
        }
        catch (error) {
            this.logger.error(`Failed to generate PDF for invoice: ${error.message}`);
            throw error;
        }
    }
    async markInvoiceAsPaid(orderId) {
        try {
            this.logger.log(`Marking invoice as paid for order ${orderId}`);
            const updateResult = await this.prisma.invoice.updateMany({
                where: { orderId },
                data: {
                    status: 'PAID',
                    paidAt: new Date(),
                    updatedAt: new Date(),
                },
            });
            this.logger.log(`Marked ${updateResult.count} invoices as paid for order ${orderId}`);
            return updateResult;
        }
        catch (error) {
            this.logger.error(`Failed to mark invoice as paid: ${error.message}`);
            throw error;
        }
    }
};
exports.InvoicesService = InvoicesService;
exports.InvoicesService = InvoicesService = InvoicesService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object, typeof (_b = typeof config_1.ConfigService !== "undefined" && config_1.ConfigService) === "function" ? _b : Object])
], InvoicesService);


/***/ }),
/* 285 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvoiceFilterDto = exports.GenerateInvoiceDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const class_transformer_1 = __webpack_require__(40);
class GenerateInvoiceDto {
}
exports.GenerateInvoiceDto = GenerateInvoiceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Order ID to generate invoice for',
        example: 'order_123456789',
    }),
    (0, class_validator_1.IsString)({ message: 'orderId.invalid' }),
    __metadata("design:type", String)
], GenerateInvoiceDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Custom invoice notes',
        example: 'Thank you for your purchase',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'notes.invalid' }),
    __metadata("design:type", String)
], GenerateInvoiceDto.prototype, "notes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Invoice due date (ISO format)',
        example: '2024-07-24T00:00:00Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'dueAt.invalid' }),
    __metadata("design:type", String)
], GenerateInvoiceDto.prototype, "dueAt", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Tax rate to apply (as decimal, e.g., 0.08 for 8%)',
        example: 0.08,
        minimum: 0,
        maximum: 1,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'taxRate.invalid' }),
    (0, class_validator_1.Min)(0, { message: 'taxRate.tooSmall' }),
    (0, class_validator_1.Max)(1, { message: 'taxRate.tooLarge' }),
    __metadata("design:type", Number)
], GenerateInvoiceDto.prototype, "taxRate", void 0);
class InvoiceFilterDto {
}
exports.InvoiceFilterDto = InvoiceFilterDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by invoice status',
        example: 'PAID',
        enum: ['PENDING', 'ISSUED', 'PAID', 'OVERDUE', 'CANCELLED'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['PENDING', 'ISSUED', 'PAID', 'OVERDUE', 'CANCELLED'], {
        message: 'status.invalid',
    }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by currency',
        example: 'USD',
        enum: ['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['USD', 'EUR', 'MXN', 'COP', 'CLP', 'ARS'], {
        message: 'currency.invalid',
    }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "currency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by seller ID',
        example: 'user_123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'sellerId.invalid' }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start date for date range filter (ISO format)',
        example: '2024-01-01T00:00:00Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'startDate.invalid' }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End date for date range filter (ISO format)',
        example: '2024-12-31T23:59:59Z',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'endDate.invalid' }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "endDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum invoice amount',
        example: 10.00,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'minAmount.invalid' }),
    (0, class_validator_1.Min)(0, { message: 'minAmount.tooSmall' }),
    __metadata("design:type", Number)
], InvoiceFilterDto.prototype, "minAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum invoice amount',
        example: 10000.00,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)({}, { message: 'maxAmount.invalid' }),
    (0, class_validator_1.Min)(0, { message: 'maxAmount.tooSmall' }),
    __metadata("design:type", Number)
], InvoiceFilterDto.prototype, "maxAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of records per page',
        example: 20,
        default: 20,
        minimum: 1,
        maximum: 100,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)({}, { message: 'limit.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'limit.tooSmall' }),
    (0, class_validator_1.Max)(100, { message: 'limit.tooLarge' }),
    __metadata("design:type", Number)
], InvoiceFilterDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Page number (1-based)',
        example: 1,
        default: 1,
        minimum: 1,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)({}, { message: 'page.invalid' }),
    (0, class_validator_1.Min)(1, { message: 'page.tooSmall' }),
    __metadata("design:type", Number)
], InvoiceFilterDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort field',
        example: 'issuedAt',
        enum: ['issuedAt', 'totalAmount', 'status', 'dueAt'],
        default: 'issuedAt',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['issuedAt', 'totalAmount', 'status', 'dueAt'], {
        message: 'sortBy.invalid',
    }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort order',
        example: 'desc',
        enum: ['asc', 'desc'],
        default: 'desc',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['asc', 'desc'], { message: 'sortOrder.invalid' }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "sortOrder", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Search by invoice number or order number',
        example: 'INV-20240624',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'search.invalid' }),
    __metadata("design:type", String)
], InvoiceFilterDto.prototype, "search", void 0);


/***/ }),
/* 286 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyticsModule = void 0;
const common_1 = __webpack_require__(2);
const analytics_service_1 = __webpack_require__(287);
const analytics_controller_1 = __webpack_require__(290);
const prisma_module_1 = __webpack_require__(9);
const users_module_1 = __webpack_require__(28);
const orders_module_1 = __webpack_require__(221);
const reviews_module_1 = __webpack_require__(293);
const notifications_module_1 = __webpack_require__(235);
const transactions_module_1 = __webpack_require__(278);
const products_module_1 = __webpack_require__(36);
let AnalyticsModule = class AnalyticsModule {
};
exports.AnalyticsModule = AnalyticsModule;
exports.AnalyticsModule = AnalyticsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => orders_module_1.OrdersModule),
            (0, common_1.forwardRef)(() => reviews_module_1.ReviewsModule),
            (0, common_1.forwardRef)(() => notifications_module_1.NotificationModule),
            (0, common_1.forwardRef)(() => transactions_module_1.TransactionsModule),
            (0, common_1.forwardRef)(() => products_module_1.ProductsModule),
        ],
        controllers: [analytics_controller_1.AnalyticsController],
        providers: [analytics_service_1.AnalyticsService],
        exports: [analytics_service_1.AnalyticsService],
    })
], AnalyticsModule);


/***/ }),
/* 287 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AnalyticsService_1;
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyticsService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
const client_1 = __webpack_require__(11);
const export_dto_1 = __webpack_require__(288);
let AnalyticsService = AnalyticsService_1 = class AnalyticsService {
    constructor(prisma) {
        this.prisma = prisma;
        this.logger = new common_1.Logger(AnalyticsService_1.name);
    }
    async getSellerDashboard(sellerId, dto) {
        try {
            this.logger.log(`Getting seller dashboard for ${sellerId}`);
            const { startDate, endDate, includeComparison = true, includeActivity = true } = dto;
            const timeRange = this.getTimeRange(startDate, endDate);
            const seller = await this.prisma.user.findUnique({
                where: { id: sellerId, role: client_1.UserRole.SELLER },
                include: { sellerProfile: true }
            });
            if (!seller) {
                throw new common_1.NotFoundException('Seller not found');
            }
            const [revenueData, orderData, productData, reviewData, recentOrders, recentReviews] = await Promise.all([
                this.calculateSellerRevenue(sellerId, timeRange),
                this.calculateSellerOrders(sellerId, timeRange),
                this.calculateSellerProducts(sellerId, timeRange),
                this.calculateSellerReviews(sellerId, timeRange),
                includeActivity ? this.getSellerRecentOrders(sellerId, 5) : [],
                includeActivity ? this.getSellerRecentReviews(sellerId, 5) : []
            ]);
            const dashboardData = {
                totalRevenue: revenueData.total,
                monthlyRevenue: revenueData.monthly,
                averageOrderValue: revenueData.averageOrderValue,
                totalOrders: orderData.total,
                monthlyOrders: orderData.monthly,
                completionRate: orderData.completionRate,
                totalProducts: productData.total,
                activeProducts: productData.active,
                topPerformingProducts: productData.topPerforming,
                averageRating: reviewData.averageRating,
                totalReviews: reviewData.total,
                responseRate: reviewData.responseRate,
                recentOrders,
                recentReviews
            };
            return {
                success: true,
                data: dashboardData,
                meta: {
                    sellerId,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: recentOrders.length + recentReviews.length,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller dashboard: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerRevenue(sellerId, dto) {
        try {
            this.logger.log(`Getting seller revenue for ${sellerId}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const [revenueMetrics, productBreakdown, feesBreakdown, trends] = await Promise.all([
                this.calculateSellerRevenue(sellerId, timeRange),
                dto.includeProductBreakdown ? this.getRevenueByProduct(sellerId, timeRange) : null,
                dto.includeFees ? this.getSellerFeesBreakdown(sellerId, timeRange) : null,
                this.getSellerRevenueTrends(sellerId, timeRange, dto.groupBy || 'month')
            ]);
            return {
                success: true,
                data: {
                    revenue: revenueMetrics,
                    productBreakdown,
                    feesBreakdown,
                    trends
                },
                meta: {
                    sellerId,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: trends.length,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller revenue: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerProducts(sellerId, dto) {
        try {
            this.logger.log(`Getting seller products analytics for ${sellerId}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const [products, summary] = await Promise.all([
                this.getSellerProductAnalytics(sellerId, timeRange, dto),
                this.getSellerProductsSummary(sellerId, timeRange)
            ]);
            return {
                success: true,
                data: {
                    products,
                    summary
                },
                meta: {
                    sellerId,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: products.length,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller products: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerReviews(sellerId, dto) {
        try {
            this.logger.log(`Getting seller reviews analytics for ${sellerId}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const [reviewMetrics, distribution, recentReviews, responseMetrics] = await Promise.all([
                this.calculateSellerReviews(sellerId, timeRange),
                dto.includeDistribution ? this.getSellerReviewDistribution(sellerId, timeRange) : null,
                dto.includeRecentReviews ? this.getSellerRecentReviews(sellerId, 10) : [],
                dto.includeResponseMetrics ? this.getSellerResponseMetrics(sellerId, timeRange) : null
            ]);
            return {
                success: true,
                data: {
                    reviews: reviewMetrics,
                    distribution,
                    recentReviews,
                    responseMetrics
                },
                meta: {
                    sellerId,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: recentReviews.length,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller reviews: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerCustomers(sellerId, dto) {
        try {
            this.logger.log(`Getting seller customers analytics for ${sellerId}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const [customerMetrics, repeatAnalysis, lifetimeValue] = await Promise.all([
                this.calculateSellerCustomers(sellerId, timeRange),
                dto.includeRepeatAnalysis ? this.getRepeatCustomerAnalysis(sellerId, timeRange) : null,
                dto.includeLifetimeValue ? this.getCustomerLifetimeValue(sellerId, timeRange) : null
            ]);
            return {
                success: true,
                data: {
                    customers: customerMetrics,
                    repeatAnalysis,
                    lifetimeValue
                },
                meta: {
                    sellerId,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller customers: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerNotifications(sellerId, dto) {
        try {
            this.logger.log(`Getting seller notifications analytics for ${sellerId}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const [notificationMetrics, engagement, typeBreakdown] = await Promise.all([
                this.calculateSellerNotifications(sellerId, timeRange),
                dto.includeEngagement ? this.getSellerNotificationEngagement(sellerId, timeRange) : null,
                dto.includeTypeBreakdown ? this.getSellerNotificationTypeBreakdown(sellerId, timeRange) : null
            ]);
            return {
                success: true,
                data: {
                    notifications: notificationMetrics,
                    engagement,
                    typeBreakdown
                },
                meta: {
                    sellerId,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller notifications: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerConversion(sellerId, dto) {
        try {
            this.logger.log(`Getting seller conversion analytics for ${sellerId}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const [conversionMetrics, funnelData, trafficSource] = await Promise.all([
                this.calculateSellerConversion(sellerId, timeRange),
                dto.includeFunnel ? this.getSellerConversionFunnel(sellerId, timeRange) : null,
                dto.includeTrafficSource ? this.getTrafficSourceConversion(sellerId, timeRange) : null
            ]);
            return {
                success: true,
                data: {
                    conversion: conversionMetrics,
                    funnelData,
                    trafficSource
                },
                meta: {
                    sellerId,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller conversion: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getPlatformOverview(dto, requestedBy) {
        try {
            this.logger.log(`Getting platform overview requested by ${requestedBy}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const [userMetrics, revenueMetrics, orderMetrics, productMetrics, reviewMetrics, topPerformers] = await Promise.all([
                this.calculatePlatformUsers(timeRange),
                this.calculatePlatformRevenue(timeRange),
                this.calculatePlatformOrders(timeRange),
                this.calculatePlatformProducts(timeRange),
                this.calculatePlatformReviews(timeRange),
                this.getPlatformTopPerformers(timeRange)
            ]);
            const platformData = {
                ...userMetrics,
                ...revenueMetrics,
                ...orderMetrics,
                ...productMetrics,
                ...reviewMetrics,
                ...topPerformers
            };
            return {
                success: true,
                data: platformData,
                meta: {
                    requestedBy,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting platform overview: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getTopPerformers(dto, requestedBy) {
        try {
            this.logger.log(`Getting top performers: ${dto.type}`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const performers = await this.calculateTopPerformers(dto.type, timeRange, dto);
            return {
                success: true,
                data: {
                    performers,
                    type: dto.type
                },
                meta: {
                    requestedBy,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: performers.length,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting top performers: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerComparison(dto, requestedBy) {
        try {
            this.logger.log(`Getting seller comparison for ${dto.sellerIds.length} sellers`);
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const comparison = await this.calculateSellerComparison(dto.sellerIds, timeRange, dto.metrics);
            return {
                success: true,
                data: comparison,
                meta: {
                    requestedBy,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: dto.sellerIds.length,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller comparison: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getConversionFunnel(dto, requestedBy) {
        try {
            this.logger.log('Getting platform conversion funnel');
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const funnelData = await this.calculatePlatformConversionFunnel(timeRange, dto);
            return {
                success: true,
                data: funnelData,
                meta: {
                    requestedBy,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting conversion funnel: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getCohortAnalysis(dto, requestedBy) {
        try {
            this.logger.log('Getting cohort analysis');
            const cohortData = await this.calculateCohortAnalysis(dto);
            return {
                success: true,
                data: cohortData,
                meta: {
                    requestedBy,
                    timeRange: {
                        start: dto.startMonth || '2024-01',
                        end: dto.endMonth || '2024-12'
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: cohortData.cohorts?.length || 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting cohort analysis: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getNotificationAnalytics(dto, requestedBy) {
        try {
            this.logger.log('Getting platform notification analytics');
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const notificationData = await this.calculatePlatformNotificationAnalytics(timeRange, dto);
            return {
                success: true,
                data: notificationData,
                meta: {
                    requestedBy,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting notification analytics: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getUserBehavior(dto, requestedBy) {
        try {
            this.logger.log('Getting user behavior analytics');
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const behaviorData = await this.calculateUserBehavior(timeRange, dto);
            return {
                success: true,
                data: behaviorData,
                meta: {
                    requestedBy,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting user behavior: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getFinancialReport(dto, requestedBy) {
        try {
            this.logger.log('Getting financial report');
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const financialData = await this.calculateFinancialReport(timeRange, dto);
            return {
                success: true,
                data: financialData,
                meta: {
                    requestedBy,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    },
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0,
                    currency: 'USD'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting financial report: ${error.message}`, error.stack);
            throw error;
        }
    }
    async exportData(dto, requestedBy) {
        try {
            this.logger.log(`Exporting data: ${dto.type} in ${dto.format} format`);
            const filename = dto.filename || `analytics_export_${Date.now()}`;
            const data = await this.prepareExportData(dto);
            return {
                success: true,
                data: {
                    filename: `${filename}.${dto.format}`,
                    downloadUrl: `/api/analytics/exports/${filename}.${dto.format}`,
                    size: 0,
                    recordCount: Array.isArray(data) ? data.length : 0,
                    generatedAt: new Date().toISOString()
                },
                meta: {
                    type: dto.type,
                    format: dto.format,
                    requestedBy,
                    timeRange: {
                        start: dto.startDate || '',
                        end: dto.endDate || ''
                    },
                    filters: dto
                }
            };
        }
        catch (error) {
            this.logger.error(`Error exporting data: ${error.message}`, error.stack);
            throw error;
        }
    }
    async generateCustomReport(dto, requestedBy, userRole) {
        try {
            this.logger.log(`Generating custom report: ${dto.title}`);
            const reportData = await this.buildCustomReport(dto, userRole);
            const filename = `custom_report_${Date.now()}`;
            return {
                success: true,
                data: {
                    filename: `${filename}.pdf`,
                    downloadUrl: `/api/analytics/reports/${filename}.pdf`,
                    size: 0,
                    recordCount: 0,
                    generatedAt: new Date().toISOString()
                },
                meta: {
                    type: export_dto_1.ExportType.CUSTOM_REPORT,
                    format: export_dto_1.ExportFormat.PDF,
                    requestedBy,
                    timeRange: {
                        start: dto.startDate || '',
                        end: dto.endDate || ''
                    }
                }
            };
        }
        catch (error) {
            this.logger.error(`Error generating custom report: ${error.message}`, error.stack);
            throw error;
        }
    }
    async scheduleReport(dto, requestedBy) {
        try {
            this.logger.log(`Scheduling report: ${dto.name} - ${dto.frequency}`);
            const reportId = `scheduled_${Date.now()}`;
            return {
                success: true,
                message: `Report "${dto.name}" scheduled successfully for ${dto.frequency} delivery`,
                reportId
            };
        }
        catch (error) {
            this.logger.error(`Error scheduling report: ${error.message}`, error.stack);
            throw error;
        }
    }
    async downloadReport(reportId, requestedBy, userRole) {
        try {
            this.logger.log(`Downloading report: ${reportId}`);
            return {
                success: true,
                message: 'Report download initiated'
            };
        }
        catch (error) {
            this.logger.error(`Error downloading report: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerRevenueChart(sellerId, dto) {
        try {
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            const trends = await this.getSellerRevenueTrends(sellerId, timeRange, dto.groupBy || 'month');
            const chartData = {
                data: trends,
                title: 'Revenue Trends',
                primaryLabel: 'Revenue',
                color: '#3B82F6'
            };
            return {
                success: true,
                data: chartData,
                meta: {
                    title: 'Seller Revenue Chart',
                    lastUpdated: new Date().toISOString(),
                    dataPoints: trends.length,
                    timeRange: {
                        start: timeRange.start.toISOString(),
                        end: timeRange.end.toISOString()
                    }
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting seller revenue chart: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getPlatformOverviewChart(dto) {
        try {
            this.logger.log('Getting platform overview chart data');
            const timeRange = this.getTimeRange(dto.startDate, dto.endDate);
            return {
                success: true,
                data: {
                    revenue: [],
                    users: [],
                    orders: []
                },
                meta: {
                    title: 'Platform Overview Charts',
                    lastUpdated: new Date().toISOString(),
                    dataPoints: 0
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting platform overview chart: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSystemHealth() {
        try {
            const databaseHealth = await this.checkDatabaseHealth();
            const cacheHealth = await this.checkCacheHealth();
            const analyticsHealth = await this.checkAnalyticsHealth();
            const hasAnyFailure = databaseHealth.status === 'unhealthy' ||
                cacheHealth.status === 'unhealthy' ||
                analyticsHealth.status === 'unhealthy';
            const healthData = {
                status: hasAnyFailure ? 'unhealthy' : 'healthy',
                uptime: process.uptime(),
                version: '1.0.0',
                timestamp: new Date().toISOString(),
                services: {
                    database: databaseHealth,
                    cache: cacheHealth,
                    analytics: analyticsHealth
                }
            };
            if (hasAnyFailure) {
                healthData.error = 'One or more services are failing';
            }
            return healthData;
        }
        catch (error) {
            this.logger.error(`Error getting system health: ${error.message}`, error.stack);
            return {
                status: 'unhealthy',
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }
    async getCacheStatus() {
        try {
            return {
                status: 'not_implemented',
                message: 'Cache not yet implemented',
                timestamp: new Date().toISOString()
            };
        }
        catch (error) {
            this.logger.error(`Error getting cache status: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculateSellerRevenue(sellerId, timeRange) {
        try {
            const orders = await this.prisma.order.findMany({
                where: {
                    status: client_1.OrderStatus.COMPLETED,
                    createdAt: {
                        gte: timeRange.start,
                        lte: timeRange.end
                    },
                    items: {
                        some: {
                            sellerId: sellerId
                        }
                    }
                },
                include: {
                    items: {
                        where: {
                            sellerId: sellerId
                        },
                        select: {
                            price: true
                        }
                    }
                }
            });
            const totalRevenue = orders.reduce((sum, order) => {
                const sellerRevenue = order.items.reduce((itemSum, item) => itemSum + item.price, 0);
                return sum + sellerRevenue;
            }, 0);
            const prevPeriod = this.getPreviousPeriod(timeRange);
            const prevOrders = await this.prisma.order.findMany({
                where: {
                    status: client_1.OrderStatus.COMPLETED,
                    createdAt: {
                        gte: prevPeriod.start,
                        lte: prevPeriod.end
                    },
                    items: {
                        some: {
                            sellerId: sellerId
                        }
                    }
                },
                include: {
                    items: {
                        where: {
                            sellerId: sellerId
                        },
                        select: {
                            price: true
                        }
                    }
                }
            });
            const prevRevenue = prevOrders.reduce((sum, order) => {
                const sellerRevenue = order.items.reduce((itemSum, item) => itemSum + item.price, 0);
                return sum + sellerRevenue;
            }, 0);
            const revenueChange = prevRevenue > 0 ? ((totalRevenue - prevRevenue) / prevRevenue) * 100 : 0;
            const currentMonth = new Date();
            const monthStart = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
            const monthOrders = await this.prisma.order.findMany({
                where: {
                    status: client_1.OrderStatus.COMPLETED,
                    createdAt: { gte: monthStart },
                    items: {
                        some: {
                            sellerId: sellerId
                        }
                    }
                },
                include: {
                    items: {
                        where: {
                            sellerId: sellerId
                        },
                        select: {
                            price: true
                        }
                    }
                }
            });
            const monthlyRevenue = monthOrders.reduce((sum, order) => {
                const sellerRevenue = order.items.reduce((itemSum, item) => itemSum + item.price, 0);
                return sum + sellerRevenue;
            }, 0);
            const totalOrderItems = orders.reduce((sum, order) => sum + order.items.length, 0);
            const averageOrderValue = totalOrderItems > 0 ? totalRevenue / totalOrderItems : 0;
            return {
                total: {
                    value: totalRevenue,
                    change: revenueChange,
                    changeType: revenueChange > 0 ? 'increase' : revenueChange < 0 ? 'decrease' : 'neutral'
                },
                monthly: {
                    value: monthlyRevenue,
                    change: 0,
                    changeType: 'neutral'
                },
                averageOrderValue: {
                    value: averageOrderValue,
                    change: 0,
                    changeType: 'neutral'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating seller revenue: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculateSellerOrders(sellerId, timeRange) {
        try {
            const orders = await this.prisma.order.findMany({
                where: {
                    createdAt: {
                        gte: timeRange.start,
                        lte: timeRange.end
                    },
                    items: {
                        some: {
                            sellerId: sellerId
                        }
                    }
                },
                select: {
                    status: true,
                    createdAt: true
                }
            });
            const totalOrders = orders.length;
            const completedOrders = orders.filter(o => o.status === client_1.OrderStatus.COMPLETED).length;
            const completionRate = totalOrders > 0 ? (completedOrders / totalOrders) * 100 : 0;
            const currentMonth = new Date();
            const monthStart = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
            const monthlyOrdersCount = await this.prisma.order.count({
                where: {
                    createdAt: { gte: monthStart },
                    items: {
                        some: {
                            sellerId: sellerId
                        }
                    }
                }
            });
            return {
                total: {
                    value: totalOrders,
                    change: 0,
                    changeType: 'neutral'
                },
                monthly: {
                    value: monthlyOrdersCount,
                    change: 0,
                    changeType: 'neutral'
                },
                completionRate: {
                    value: completionRate,
                    change: 0,
                    changeType: 'neutral'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating seller orders: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculateSellerProducts(sellerId, timeRange) {
        try {
            const products = await this.prisma.product.findMany({
                where: { sellerId },
                select: {
                    id: true,
                    title: true,
                    status: true,
                    createdAt: true,
                    orderItems: {
                        where: {
                            order: {
                                status: client_1.OrderStatus.COMPLETED,
                                createdAt: {
                                    gte: timeRange.start,
                                    lte: timeRange.end
                                }
                            }
                        },
                        select: {
                            price: true
                        }
                    },
                    productRating: {
                        select: {
                            averageRating: true,
                            totalReviews: true
                        }
                    }
                }
            });
            const totalProducts = products.length;
            const activeProducts = products.filter(p => p.status === client_1.ProductStatus.APPROVED).length;
            const topPerforming = products
                .map(product => ({
                id: product.id,
                title: product.title,
                revenue: product.orderItems.reduce((sum, item) => sum + item.price, 0),
                orders: product.orderItems.length,
                averageRating: Number(product.productRating?.averageRating || 0),
                reviewCount: product.productRating?.totalReviews || 0,
                conversionRate: 0
            }))
                .sort((a, b) => b.revenue - a.revenue)
                .slice(0, 5);
            return {
                total: {
                    value: totalProducts
                },
                active: {
                    value: activeProducts
                },
                topPerforming
            };
        }
        catch (error) {
            this.logger.error(`Error calculating seller products: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculateSellerReviews(sellerId, timeRange) {
        try {
            const sellerRating = await this.prisma.sellerRating.findUnique({
                where: { sellerId }
            });
            const reviews = await this.prisma.review.findMany({
                where: {
                    sellerId,
                    createdAt: {
                        gte: timeRange.start,
                        lte: timeRange.end
                    }
                },
                select: {
                    id: true,
                    rating: true,
                    response: {
                        select: { id: true }
                    }
                }
            });
            const totalReviews = reviews.length;
            const reviewsWithResponse = reviews.filter(r => r.response).length;
            const responseRate = totalReviews > 0 ? (reviewsWithResponse / totalReviews) * 100 : 0;
            return {
                averageRating: {
                    value: Number(sellerRating?.averageRating || 0),
                    change: 0,
                    changeType: 'neutral'
                },
                total: {
                    value: sellerRating?.totalReviews || 0,
                    change: 0,
                    changeType: 'neutral'
                },
                responseRate: {
                    value: responseRate,
                    change: 0,
                    changeType: 'neutral'
                }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating seller reviews: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerRecentOrders(sellerId, limit) {
        try {
            const orders = await this.prisma.order.findMany({
                where: {
                    items: {
                        some: {
                            sellerId: sellerId
                        }
                    }
                },
                orderBy: { createdAt: 'desc' },
                take: limit,
                include: {
                    buyer: {
                        select: {
                            firstName: true,
                            lastName: true
                        }
                    },
                    items: {
                        where: {
                            sellerId: sellerId
                        },
                        take: 1,
                        include: {
                            product: {
                                select: {
                                    title: true
                                }
                            }
                        }
                    }
                }
            });
            return orders.map(order => ({
                id: order.id,
                buyerName: `${order.buyer.firstName} ${order.buyer.lastName}`,
                productTitle: order.items[0]?.product?.title || 'Multiple Items',
                amount: order.items.reduce((sum, item) => sum + item.price, 0),
                status: order.status,
                createdAt: order.createdAt.toISOString()
            }));
        }
        catch (error) {
            this.logger.error(`Error getting recent orders: ${error.message}`, error.stack);
            return [];
        }
    }
    async getSellerRecentReviews(sellerId, limit) {
        try {
            const reviews = await this.prisma.review.findMany({
                where: { sellerId },
                orderBy: { createdAt: 'desc' },
                take: limit,
                include: {
                    buyer: {
                        select: {
                            firstName: true,
                            lastName: true
                        }
                    },
                    product: {
                        select: {
                            title: true
                        }
                    },
                    response: {
                        select: { id: true }
                    }
                }
            });
            return reviews.map(review => ({
                id: review.id,
                buyerName: `${review.buyer.firstName} ${review.buyer.lastName}`,
                productTitle: review.product.title,
                rating: review.rating,
                comment: review.comment,
                createdAt: review.createdAt.toISOString(),
                hasResponse: !!review.response
            }));
        }
        catch (error) {
            this.logger.error(`Error getting recent reviews: ${error.message}`, error.stack);
            return [];
        }
    }
    async getRevenueByProduct(sellerId, timeRange) {
        try {
            const productRevenue = await this.prisma.product.findMany({
                where: { sellerId },
                select: {
                    id: true,
                    title: true,
                    orderItems: {
                        where: {
                            order: {
                                status: client_1.OrderStatus.COMPLETED,
                                createdAt: {
                                    gte: timeRange.start,
                                    lte: timeRange.end
                                }
                            }
                        },
                        select: {
                            price: true
                        }
                    }
                }
            });
            return productRevenue.map(product => ({
                productId: product.id,
                productTitle: product.title,
                revenue: product.orderItems.reduce((sum, item) => sum + item.price, 0),
                orders: product.orderItems.length
            })).sort((a, b) => b.revenue - a.revenue);
        }
        catch (error) {
            this.logger.error(`Error getting revenue by product: ${error.message}`, error.stack);
            return [];
        }
    }
    async getSellerFeesBreakdown(sellerId, timeRange) {
        try {
            const transactions = await this.prisma.transaction.findMany({
                where: {
                    sellerId,
                    createdAt: {
                        gte: timeRange.start,
                        lte: timeRange.end
                    }
                },
                select: {
                    type: true,
                    amount: true
                }
            });
            const platformFees = transactions
                .filter(t => t.type === 'PLATFORM_FEE')
                .reduce((sum, t) => sum + Number(t.amount), 0);
            const stripeFees = transactions
                .filter(t => t.type === 'STRIPE_FEE')
                .reduce((sum, t) => sum + Number(t.amount), 0);
            return {
                platformFees,
                stripeFees,
                totalFees: platformFees + stripeFees
            };
        }
        catch (error) {
            this.logger.error(`Error getting fees breakdown: ${error.message}`, error.stack);
            return { platformFees: 0, stripeFees: 0, totalFees: 0 };
        }
    }
    async getSellerRevenueTrends(sellerId, timeRange, groupBy) {
        try {
            const orders = await this.prisma.order.findMany({
                where: {
                    status: client_1.OrderStatus.COMPLETED,
                    createdAt: {
                        gte: timeRange.start,
                        lte: timeRange.end
                    },
                    items: {
                        some: {
                            sellerId: sellerId
                        }
                    }
                },
                select: {
                    createdAt: true,
                    items: {
                        where: {
                            sellerId: sellerId
                        },
                        select: {
                            price: true
                        }
                    }
                },
                orderBy: { createdAt: 'asc' }
            });
            const monthlyData = new Map();
            orders.forEach(order => {
                const month = order.createdAt.toISOString().substring(0, 7);
                const sellerRevenue = order.items.reduce((sum, item) => sum + item.price, 0);
                const current = monthlyData.get(month) || 0;
                monthlyData.set(month, current + sellerRevenue);
            });
            return Array.from(monthlyData.entries()).map(([date, value]) => ({
                date,
                value,
                label: date
            }));
        }
        catch (error) {
            this.logger.error(`Error getting revenue trends: ${error.message}`, error.stack);
            return [];
        }
    }
    async calculatePlatformUsers(timeRange) {
        try {
            const [totalUsers, totalSellers, totalBuyers, activeUsers] = await Promise.all([
                this.prisma.user.count(),
                this.prisma.user.count({ where: { role: client_1.UserRole.SELLER } }),
                this.prisma.user.count({ where: { role: client_1.UserRole.BUYER } }),
                this.prisma.user.count({
                    where: {
                        lastLoginAt: {
                            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
                        }
                    }
                })
            ]);
            return {
                totalUsers: { value: totalUsers, change: 0, changeType: 'neutral' },
                totalSellers: { value: totalSellers, change: 0, changeType: 'neutral' },
                totalBuyers: { value: totalBuyers, change: 0, changeType: 'neutral' },
                activeUsers: { value: activeUsers, change: 0, changeType: 'neutral' }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating platform users: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculatePlatformRevenue(timeRange) {
        try {
            const orders = await this.prisma.order.findMany({
                where: {
                    status: client_1.OrderStatus.COMPLETED,
                    createdAt: {
                        gte: timeRange.start,
                        lte: timeRange.end
                    }
                },
                select: { totalAmount: true, platformFeeRate: true }
            });
            const totalRevenue = orders.reduce((sum, order) => sum + order.totalAmount, 0);
            const platformRevenue = orders.reduce((sum, order) => {
                const fee = order.totalAmount * order.platformFeeRate;
                return sum + fee;
            }, 0);
            const currentMonth = new Date();
            const monthStart = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
            const monthlyOrders = await this.prisma.order.findMany({
                where: {
                    status: client_1.OrderStatus.COMPLETED,
                    createdAt: { gte: monthStart }
                },
                select: { totalAmount: true, platformFeeRate: true }
            });
            const monthlyPlatformRevenue = monthlyOrders.reduce((sum, order) => {
                const fee = order.totalAmount * order.platformFeeRate;
                return sum + fee;
            }, 0);
            return {
                totalPlatformRevenue: { value: platformRevenue, change: 0, changeType: 'neutral' },
                monthlyPlatformRevenue: { value: monthlyPlatformRevenue, change: 0, changeType: 'neutral' },
                averagePlatformFee: { value: orders.length > 0 ? platformRevenue / orders.length : 0, change: 0, changeType: 'neutral' }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating platform revenue: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculatePlatformOrders(timeRange) {
        try {
            const [totalOrders, monthlyOrders] = await Promise.all([
                this.prisma.order.count({
                    where: {
                        createdAt: {
                            gte: timeRange.start,
                            lte: timeRange.end
                        }
                    }
                }),
                this.prisma.order.count({
                    where: {
                        createdAt: {
                            gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1)
                        }
                    }
                })
            ]);
            const avgOrderValue = await this.prisma.order.aggregate({
                where: {
                    status: client_1.OrderStatus.COMPLETED,
                    createdAt: {
                        gte: timeRange.start,
                        lte: timeRange.end
                    }
                },
                _avg: { totalAmount: true }
            });
            return {
                totalOrders: { value: totalOrders, change: 0, changeType: 'neutral' },
                monthlyOrders: { value: monthlyOrders, change: 0, changeType: 'neutral' },
                averageOrderValue: { value: Number(avgOrderValue._avg.totalAmount) || 0, change: 0, changeType: 'neutral' }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating platform orders: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculatePlatformProducts(timeRange) {
        try {
            const [totalProducts, activeProducts, pendingModeration] = await Promise.all([
                this.prisma.product.count(),
                this.prisma.product.count({ where: { status: client_1.ProductStatus.APPROVED } }),
                this.prisma.product.count({ where: { status: client_1.ProductStatus.PENDING } })
            ]);
            return {
                totalProducts: { value: totalProducts, change: 0, changeType: 'neutral' },
                activeProducts: { value: activeProducts, change: 0, changeType: 'neutral' },
                pendingModeration: { value: pendingModeration, change: 0, changeType: 'neutral' }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating platform products: ${error.message}`, error.stack);
            throw error;
        }
    }
    async calculatePlatformReviews(timeRange) {
        try {
            const [totalReviews, avgRating, pendingModeration] = await Promise.all([
                this.prisma.review.count({
                    where: {
                        createdAt: {
                            gte: timeRange.start,
                            lte: timeRange.end
                        }
                    }
                }),
                this.prisma.review.aggregate({
                    _avg: { rating: true },
                    where: {
                        status: client_1.ReviewStatus.PUBLISHED
                    }
                }),
                this.prisma.review.count({ where: { status: client_1.ReviewStatus.PENDING_MODERATION } })
            ]);
            return {
                totalReviews: { value: totalReviews, change: 0, changeType: 'neutral' },
                averagePlatformRating: { value: Number(avgRating._avg.rating) || 0, change: 0, changeType: 'neutral' },
                pendingModeration: { value: pendingModeration, change: 0, changeType: 'neutral' }
            };
        }
        catch (error) {
            this.logger.error(`Error calculating platform reviews: ${error.message}`, error.stack);
            throw error;
        }
    }
    async getSellerProductAnalytics(sellerId, timeRange, dto) { return []; }
    async getSellerProductsSummary(sellerId, timeRange) { return {}; }
    async getSellerReviewDistribution(sellerId, timeRange) { return {}; }
    async getSellerResponseMetrics(sellerId, timeRange) { return {}; }
    async calculateSellerCustomers(sellerId, timeRange) { return {}; }
    async getRepeatCustomerAnalysis(sellerId, timeRange) { return {}; }
    async getCustomerLifetimeValue(sellerId, timeRange) { return {}; }
    async calculateSellerNotifications(sellerId, timeRange) { return {}; }
    async getSellerNotificationEngagement(sellerId, timeRange) { return {}; }
    async getSellerNotificationTypeBreakdown(sellerId, timeRange) { return {}; }
    async calculateSellerConversion(sellerId, timeRange) { return {}; }
    async getSellerConversionFunnel(sellerId, timeRange) { return {}; }
    async getTrafficSourceConversion(sellerId, timeRange) { return {}; }
    async getPlatformTopPerformers(timeRange) { return { topSellers: [], topProducts: [], topCategories: [] }; }
    async calculateTopPerformers(type, timeRange, dto) { return []; }
    async calculateSellerComparison(sellerIds, timeRange, metrics) { return {}; }
    async calculatePlatformConversionFunnel(timeRange, dto) {
        return {
            visitors: 0, productViews: 0, cartAdds: 0, checkoutStarts: 0, orders: 0, completedOrders: 0, reviews: 0,
            productViewRate: 0, cartConversionRate: 0, checkoutConversionRate: 0, orderCompletionRate: 0, reviewRate: 0,
            dropOffs: { viewToCart: 0, cartToCheckout: 0, checkoutToOrder: 0, orderToCompletion: 0, completionToReview: 0 }
        };
    }
    async calculateCohortAnalysis(dto) { return { cohorts: [] }; }
    async calculatePlatformNotificationAnalytics(timeRange, dto) {
        return { totalSent: 0, deliveryRate: 0, openRate: 0, clickRate: 0, byType: [], byChannel: [], trends: [] };
    }
    async calculateUserBehavior(timeRange, dto) { return {}; }
    async calculateFinancialReport(timeRange, dto) { return {}; }
    async prepareExportData(dto) { return []; }
    async buildCustomReport(dto, userRole) { return {}; }
    getTimeRange(startDate, endDate) {
        const end = endDate ? new Date(endDate) : new Date();
        const start = startDate ? new Date(startDate) : new Date(end.getTime() - 30 * 24 * 60 * 60 * 1000);
        return { start, end };
    }
    getPreviousPeriod(timeRange) {
        const duration = timeRange.end.getTime() - timeRange.start.getTime();
        return {
            start: new Date(timeRange.start.getTime() - duration),
            end: new Date(timeRange.start.getTime())
        };
    }
    async checkDatabaseHealth() {
        try {
            const start = Date.now();
            await this.prisma.$queryRaw `SELECT 1`;
            const responseTime = Date.now() - start;
            return { status: 'healthy', responseTime };
        }
        catch (error) {
            return { status: 'unhealthy' };
        }
    }
    async checkCacheHealth() {
        return { status: 'not_implemented' };
    }
    async checkAnalyticsHealth() {
        try {
            await this.prisma.user.count();
            return { status: 'healthy', lastCalculation: new Date().toISOString() };
        }
        catch (error) {
            return { status: 'unhealthy' };
        }
    }
};
exports.AnalyticsService = AnalyticsService;
exports.AnalyticsService = AnalyticsService = AnalyticsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object])
], AnalyticsService);


/***/ }),
/* 288 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExportResponseDto = exports.ScheduleReportDto = exports.CustomReportDto = exports.ExportDataDto = exports.Frequency = exports.ExportType = exports.ExportFormat = void 0;
const class_validator_1 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
const swagger_1 = __webpack_require__(4);
const filters_dto_1 = __webpack_require__(289);
var ExportFormat;
(function (ExportFormat) {
    ExportFormat["CSV"] = "csv";
    ExportFormat["XLSX"] = "xlsx";
    ExportFormat["PDF"] = "pdf";
    ExportFormat["JSON"] = "json";
})(ExportFormat || (exports.ExportFormat = ExportFormat = {}));
var ExportType;
(function (ExportType) {
    ExportType["SELLER_DASHBOARD"] = "seller_dashboard";
    ExportType["SELLER_REVENUE"] = "seller_revenue";
    ExportType["SELLER_PRODUCTS"] = "seller_products";
    ExportType["SELLER_REVIEWS"] = "seller_reviews";
    ExportType["SELLER_CUSTOMERS"] = "seller_customers";
    ExportType["ADMIN_PLATFORM"] = "admin_platform";
    ExportType["ADMIN_SELLERS"] = "admin_sellers";
    ExportType["ADMIN_FINANCIAL"] = "admin_financial";
    ExportType["CONVERSION_FUNNEL"] = "conversion_funnel";
    ExportType["COHORT_ANALYSIS"] = "cohort_analysis";
    ExportType["NOTIFICATION_ANALYTICS"] = "notification_analytics";
    ExportType["CUSTOM_REPORT"] = "custom_report";
})(ExportType || (exports.ExportType = ExportType = {}));
var Frequency;
(function (Frequency) {
    Frequency["DAILY"] = "daily";
    Frequency["WEEKLY"] = "weekly";
    Frequency["MONTHLY"] = "monthly";
    Frequency["QUARTERLY"] = "quarterly";
})(Frequency || (exports.Frequency = Frequency = {}));
class ExportDataDto extends filters_dto_1.BaseAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.format = ExportFormat.CSV;
        this.includeMetadata = true;
        this.includeCharts = true;
    }
}
exports.ExportDataDto = ExportDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of data to export',
        enum: ExportType
    }),
    (0, class_validator_1.IsEnum)(ExportType, { message: 'type must be a valid export type' }),
    __metadata("design:type", String)
], ExportDataDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Export format',
        enum: ExportFormat,
        default: ExportFormat.CSV
    }),
    (0, class_validator_1.IsEnum)(ExportFormat, { message: 'format must be one of: csv, xlsx, pdf, json' }),
    __metadata("design:type", String)
], ExportDataDto.prototype, "format", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Custom filename (without extension)',
        example: 'my_analytics_report'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'filename must be a string' }),
    __metadata("design:type", String)
], ExportDataDto.prototype, "filename", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Specific seller ID for seller-specific exports',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'sellerId must be a valid UUID' }),
    __metadata("design:type", String)
], ExportDataDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Specific product ID for product-specific exports',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'productId must be a valid UUID' }),
    __metadata("design:type", String)
], ExportDataDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include metadata in export',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeMetadata must be a boolean' }),
    __metadata("design:type", Boolean)
], ExportDataDto.prototype, "includeMetadata", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include charts in export (PDF only)',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeCharts must be a boolean' }),
    __metadata("design:type", Boolean)
], ExportDataDto.prototype, "includeCharts", void 0);
class CustomReportDto extends filters_dto_1.BaseAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeRawData = true;
        this.includeExecutiveSummary = true;
    }
}
exports.CustomReportDto = CustomReportDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Report title',
        example: 'Q4 2024 Sales Performance Report'
    }),
    (0, class_validator_1.IsString)({ message: 'title must be a string' }),
    __metadata("design:type", String)
], CustomReportDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Report description',
        example: 'Comprehensive analysis of sales performance for Q4 2024'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'description must be a string' }),
    __metadata("design:type", String)
], CustomReportDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Metrics to include in the report',
        type: [String],
        example: ['revenue', 'orders', 'customers', 'reviews']
    }),
    (0, class_validator_1.IsArray)({ message: 'metrics must be an array' }),
    (0, class_validator_1.IsString)({ each: true, message: 'Each metric must be a string' }),
    __metadata("design:type", Array)
], CustomReportDto.prototype, "metrics", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Chart types to include',
        type: [String],
        example: ['line', 'bar', 'pie']
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)({ message: 'chartTypes must be an array' }),
    (0, class_validator_1.IsString)({ each: true, message: 'Each chart type must be a string' }),
    __metadata("design:type", Array)
], CustomReportDto.prototype, "chartTypes", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include raw data tables',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeRawData must be a boolean' }),
    __metadata("design:type", Boolean)
], CustomReportDto.prototype, "includeRawData", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include executive summary',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeExecutiveSummary must be a boolean' }),
    __metadata("design:type", Boolean)
], CustomReportDto.prototype, "includeExecutiveSummary", void 0);
class ScheduleReportDto {
    constructor() {
        this.format = ExportFormat.PDF;
    }
}
exports.ScheduleReportDto = ScheduleReportDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Report name',
        example: 'Weekly Sales Report'
    }),
    (0, class_validator_1.IsString)({ message: 'name must be a string' }),
    __metadata("design:type", String)
], ScheduleReportDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Report type',
        enum: ExportType
    }),
    (0, class_validator_1.IsEnum)(ExportType, { message: 'type must be a valid export type' }),
    __metadata("design:type", String)
], ScheduleReportDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Schedule frequency',
        enum: Frequency,
        example: 'weekly'
    }),
    (0, class_validator_1.IsEnum)(Frequency, {
        message: 'frequency must be one of: daily, weekly, monthly, quarterly'
    }),
    __metadata("design:type", String)
], ScheduleReportDto.prototype, "frequency", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Email recipients',
        type: [String],
        example: ['admin@furnibles.com', 'analytics@furnibles.com']
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)({ message: 'recipients must be an array' }),
    (0, class_validator_1.IsString)({ each: true, message: 'Each recipient must be a valid email' }),
    __metadata("design:type", Array)
], ScheduleReportDto.prototype, "recipients", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Export format for scheduled reports',
        enum: ExportFormat,
        default: ExportFormat.PDF
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(ExportFormat, { message: 'format must be one of: csv, xlsx, pdf, json' }),
    __metadata("design:type", String)
], ScheduleReportDto.prototype, "format", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Additional filters for the scheduled report'
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", typeof (_a = typeof Record !== "undefined" && Record) === "function" ? _a : Object)
], ScheduleReportDto.prototype, "filters", void 0);
class ExportResponseDto {
}
exports.ExportResponseDto = ExportResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Success status' }),
    __metadata("design:type", Boolean)
], ExportResponseDto.prototype, "success", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Export data or download information' }),
    __metadata("design:type", Object)
], ExportResponseDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Export metadata' }),
    __metadata("design:type", Object)
], ExportResponseDto.prototype, "meta", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Error message if any' }),
    __metadata("design:type", String)
], ExportResponseDto.prototype, "error", void 0);


/***/ }),
/* 289 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationAnalyticsFiltersDto = exports.CohortAnalyticsFiltersDto = exports.ConversionAnalyticsFiltersDto = exports.AdminAnalyticsFiltersDto = exports.SellerAnalyticsFiltersDto = exports.BaseAnalyticsFiltersDto = exports.TimeRangeDto = exports.OrderStatus = exports.GroupByPeriod = void 0;
const class_validator_1 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
const swagger_1 = __webpack_require__(4);
var GroupByPeriod;
(function (GroupByPeriod) {
    GroupByPeriod["DAY"] = "day";
    GroupByPeriod["WEEK"] = "week";
    GroupByPeriod["MONTH"] = "month";
    GroupByPeriod["QUARTER"] = "quarter";
    GroupByPeriod["YEAR"] = "year";
})(GroupByPeriod || (exports.GroupByPeriod = GroupByPeriod = {}));
var OrderStatus;
(function (OrderStatus) {
    OrderStatus["PENDING"] = "PENDING";
    OrderStatus["PAID"] = "PAID";
    OrderStatus["PROCESSING"] = "PROCESSING";
    OrderStatus["COMPLETED"] = "COMPLETED";
    OrderStatus["CANCELLED"] = "CANCELLED";
    OrderStatus["REFUNDED"] = "REFUNDED";
})(OrderStatus || (exports.OrderStatus = OrderStatus = {}));
class TimeRangeDto {
}
exports.TimeRangeDto = TimeRangeDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start date in ISO format',
        example: '2024-01-01T00:00:00.000Z'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'startDate must be a valid ISO date string' }),
    __metadata("design:type", String)
], TimeRangeDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End date in ISO format',
        example: '2024-12-31T23:59:59.999Z'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)({}, { message: 'endDate must be a valid ISO date string' }),
    __metadata("design:type", String)
], TimeRangeDto.prototype, "endDate", void 0);
class BaseAnalyticsFiltersDto extends TimeRangeDto {
    constructor() {
        super(...arguments);
        this.limit = 50;
        this.offset = 0;
    }
}
exports.BaseAnalyticsFiltersDto = BaseAnalyticsFiltersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Group results by time period',
        enum: GroupByPeriod,
        example: GroupByPeriod.MONTH
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(GroupByPeriod, { message: 'groupBy must be one of: day, week, month, quarter, year' }),
    __metadata("design:type", String)
], BaseAnalyticsFiltersDto.prototype, "groupBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of results to return',
        minimum: 1,
        maximum: 1000,
        default: 50
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsInt)({ message: 'limit must be an integer' }),
    (0, class_validator_1.Min)(1, { message: 'limit must be at least 1' }),
    (0, class_validator_1.Max)(1000, { message: 'limit cannot exceed 1000' }),
    __metadata("design:type", Number)
], BaseAnalyticsFiltersDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of results to skip',
        minimum: 0,
        default: 0
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsInt)({ message: 'offset must be an integer' }),
    (0, class_validator_1.Min)(0, { message: 'offset cannot be negative' }),
    __metadata("design:type", Number)
], BaseAnalyticsFiltersDto.prototype, "offset", void 0);
class SellerAnalyticsFiltersDto extends BaseAnalyticsFiltersDto {
}
exports.SellerAnalyticsFiltersDto = SellerAnalyticsFiltersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by specific product ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'productId must be a valid UUID' }),
    __metadata("design:type", String)
], SellerAnalyticsFiltersDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by product category ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'categoryId must be a valid UUID' }),
    __metadata("design:type", String)
], SellerAnalyticsFiltersDto.prototype, "categoryId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by order status',
        enum: OrderStatus,
        example: OrderStatus.COMPLETED
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(OrderStatus, { message: 'status must be a valid order status' }),
    __metadata("design:type", String)
], SellerAnalyticsFiltersDto.prototype, "status", void 0);
class AdminAnalyticsFiltersDto extends BaseAnalyticsFiltersDto {
}
exports.AdminAnalyticsFiltersDto = AdminAnalyticsFiltersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by specific seller ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'sellerId must be a valid UUID' }),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by specific product ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'productId must be a valid UUID' }),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by product category ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'categoryId must be a valid UUID' }),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "categoryId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by user role',
        example: 'SELLER'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'userRole must be a string' }),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "userRole", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by order status',
        enum: OrderStatus,
        example: OrderStatus.COMPLETED
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(OrderStatus, { message: 'status must be a valid order status' }),
    __metadata("design:type", String)
], AdminAnalyticsFiltersDto.prototype, "status", void 0);
class ConversionAnalyticsFiltersDto extends BaseAnalyticsFiltersDto {
}
exports.ConversionAnalyticsFiltersDto = ConversionAnalyticsFiltersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by specific seller ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'sellerId must be a valid UUID' }),
    __metadata("design:type", String)
], ConversionAnalyticsFiltersDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by product category ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'categoryId must be a valid UUID' }),
    __metadata("design:type", String)
], ConversionAnalyticsFiltersDto.prototype, "categoryId", void 0);
class CohortAnalyticsFiltersDto {
    constructor() {
        this.periods = 12;
    }
}
exports.CohortAnalyticsFiltersDto = CohortAnalyticsFiltersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start month for cohort analysis (YYYY-MM format)',
        example: '2024-01'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'startMonth must be a string in YYYY-MM format' }),
    __metadata("design:type", String)
], CohortAnalyticsFiltersDto.prototype, "startMonth", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End month for cohort analysis (YYYY-MM format)',
        example: '2024-12'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'endMonth must be a string in YYYY-MM format' }),
    __metadata("design:type", String)
], CohortAnalyticsFiltersDto.prototype, "endMonth", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Number of months to analyze',
        minimum: 1,
        maximum: 24,
        default: 12
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsInt)({ message: 'periods must be an integer' }),
    (0, class_validator_1.Min)(1, { message: 'periods must be at least 1' }),
    (0, class_validator_1.Max)(24, { message: 'periods cannot exceed 24' }),
    __metadata("design:type", Number)
], CohortAnalyticsFiltersDto.prototype, "periods", void 0);
class NotificationAnalyticsFiltersDto extends BaseAnalyticsFiltersDto {
}
exports.NotificationAnalyticsFiltersDto = NotificationAnalyticsFiltersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by notification type',
        example: 'REVIEW_RECEIVED'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'notificationType must be a string' }),
    __metadata("design:type", String)
], NotificationAnalyticsFiltersDto.prototype, "notificationType", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by notification channel',
        example: 'EMAIL'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'channel must be a string' }),
    __metadata("design:type", String)
], NotificationAnalyticsFiltersDto.prototype, "channel", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by user ID',
        example: 'clp1234567890abcdef'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)(4, { message: 'userId must be a valid UUID' }),
    __metadata("design:type", String)
], NotificationAnalyticsFiltersDto.prototype, "userId", void 0);


/***/ }),
/* 290 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyticsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const public_decorator_1 = __webpack_require__(25);
const client_1 = __webpack_require__(11);
const prisma_service_1 = __webpack_require__(10);
const analytics_service_1 = __webpack_require__(287);
const seller_analytics_dto_1 = __webpack_require__(291);
const admin_analytics_dto_1 = __webpack_require__(292);
const export_dto_1 = __webpack_require__(288);
let AnalyticsController = class AnalyticsController {
    constructor(analyticsService, prisma) {
        this.analyticsService = analyticsService;
        this.prisma = prisma;
    }
    async getSellerDashboard(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            return this.analyticsService.getSellerDashboard(userId, dto);
        }
        else if (userRole === client_1.UserRole.ADMIN) {
            const sellerId = req.query?.sellerId;
            if (!sellerId) {
                throw new common_1.ForbiddenException('Seller ID required for admin users');
            }
            return this.analyticsService.getSellerDashboard(sellerId, dto);
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
    }
    async getSellerRevenue(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            return this.analyticsService.getSellerRevenue(userId, dto);
        }
        else if (userRole === client_1.UserRole.ADMIN) {
            const sellerId = req.query.sellerId;
            if (!sellerId) {
                throw new common_1.ForbiddenException('Seller ID required for admin users');
            }
            return this.analyticsService.getSellerRevenue(sellerId, dto);
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
    }
    async getSellerProducts(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            return this.analyticsService.getSellerProducts(userId, dto);
        }
        else if (userRole === client_1.UserRole.ADMIN) {
            const sellerId = req.query.sellerId;
            if (!sellerId) {
                throw new common_1.ForbiddenException('Seller ID required for admin users');
            }
            return this.analyticsService.getSellerProducts(sellerId, dto);
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
    }
    async getSellerReviews(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            return this.analyticsService.getSellerReviews(userId, dto);
        }
        else if (userRole === client_1.UserRole.ADMIN) {
            const sellerId = req.query.sellerId;
            if (!sellerId) {
                throw new common_1.ForbiddenException('Seller ID required for admin users');
            }
            return this.analyticsService.getSellerReviews(sellerId, dto);
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
    }
    async getSellerCustomers(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            return this.analyticsService.getSellerCustomers(userId, dto);
        }
        else if (userRole === client_1.UserRole.ADMIN) {
            const sellerId = req.query.sellerId;
            if (!sellerId) {
                throw new common_1.ForbiddenException('Seller ID required for admin users');
            }
            return this.analyticsService.getSellerCustomers(sellerId, dto);
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
    }
    async getSellerNotifications(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            return this.analyticsService.getSellerNotifications(userId, dto);
        }
        else if (userRole === client_1.UserRole.ADMIN) {
            const sellerId = req.query.sellerId;
            if (!sellerId) {
                throw new common_1.ForbiddenException('Seller ID required for admin users');
            }
            return this.analyticsService.getSellerNotifications(sellerId, dto);
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
    }
    async getSellerConversion(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            return this.analyticsService.getSellerConversion(userId, dto);
        }
        else if (userRole === client_1.UserRole.ADMIN) {
            const sellerId = req.query.sellerId;
            if (!sellerId) {
                throw new common_1.ForbiddenException('Seller ID required for admin users');
            }
            return this.analyticsService.getSellerConversion(sellerId, dto);
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
    }
    async getPlatformOverview(dto, req) {
        if (!req.user || req.user.role !== 'ADMIN') {
            throw new common_1.ForbiddenException('Access denied');
        }
        return this.analyticsService.getPlatformOverview(dto, req.user.id);
    }
    async getTopPerformers(dto, req) {
        return this.analyticsService.getTopPerformers(dto, req.user.id);
    }
    async getSellerComparison(dto, req) {
        return this.analyticsService.getSellerComparison(dto, req.user.id);
    }
    async getConversionFunnel(dto, req) {
        return this.analyticsService.getConversionFunnel(dto, req.user.id);
    }
    async getCohortAnalysis(dto, req) {
        return this.analyticsService.getCohortAnalysis(dto, req.user.id);
    }
    async getNotificationAnalytics(dto, req) {
        return this.analyticsService.getNotificationAnalytics(dto, req.user.id);
    }
    async getUserBehavior(dto, req) {
        return this.analyticsService.getUserBehavior(dto, req.user.id);
    }
    async getFinancialReport(dto, req) {
        return this.analyticsService.getFinancialReport(dto, req.user.id);
    }
    async exportData(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER) {
            dto.sellerId = userId;
        }
        else if (userRole === client_1.UserRole.ADMIN) {
        }
        else {
            throw new common_1.ForbiddenException('Access denied');
        }
        return this.analyticsService.exportData(dto, userId);
    }
    async generateCustomReport(dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        return this.analyticsService.generateCustomReport(dto, userId, userRole);
    }
    async scheduleReport(dto, req) {
        return this.analyticsService.scheduleReport(dto, req.user.id);
    }
    async downloadReport(reportId, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        return this.analyticsService.downloadReport(reportId, userId, userRole);
    }
    async getSellerRevenueChart(sellerId, dto, req) {
        const userId = req.user.id;
        const userRole = req.user.role;
        if (userRole === client_1.UserRole.SELLER && sellerId !== userId) {
            throw new common_1.ForbiddenException('Access denied');
        }
        return this.analyticsService.getSellerRevenueChart(sellerId, dto);
    }
    async getPlatformOverviewChart(dto, req) {
        if (req.user.role !== 'ADMIN') {
            throw new common_1.ForbiddenException('Only admin can access this endpoint');
        }
        return this.analyticsService.getPlatformOverviewChart(dto);
    }
    async getSystemHealth(req) {
        if (req.user.role !== 'ADMIN') {
            throw new common_1.ForbiddenException('Only admin can access this endpoint');
        }
        return this.analyticsService.getSystemHealth();
    }
    async getCacheStatus(req) {
        if (req.user.role !== 'ADMIN') {
            throw new common_1.ForbiddenException('Only admin can access this endpoint');
        }
        return this.analyticsService.getCacheStatus();
    }
    async getStats() {
        try {
            const [totalProducts, totalUsers, totalOrders] = await Promise.all([
                this.prisma.product.count({ where: { status: 'APPROVED' } }),
                this.prisma.user.count(),
                this.prisma.order.count({ where: { status: 'PAID' } }),
            ]);
            return {
                success: true,
                data: {
                    totalProducts,
                    totalUsers,
                    totalOrders,
                    totalRevenue: 0,
                }
            };
        }
        catch (error) {
            return {
                success: false,
                data: {
                    totalProducts: 0,
                    totalUsers: 0,
                    totalOrders: 0,
                    totalRevenue: 0,
                }
            };
        }
    }
};
exports.AnalyticsController = AnalyticsController;
__decorate([
    (0, common_1.Get)('seller/dashboard'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller dashboard analytics',
        description: 'Comprehensive dashboard metrics for sellers including revenue, orders, products, and reviews'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller dashboard analytics retrieved successfully',
        type: seller_analytics_dto_1.SellerAnalyticsResponseDto
    }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, example: '2024-01-01T00:00:00.000Z' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, example: '2024-12-31T23:59:59.999Z' }),
    (0, swagger_1.ApiQuery)({ name: 'includeComparison', required: false, type: Boolean, example: true }),
    (0, swagger_1.ApiQuery)({ name: 'includeActivity', required: false, type: Boolean, example: true }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof seller_analytics_dto_1.GetSellerDashboardDto !== "undefined" && seller_analytics_dto_1.GetSellerDashboardDto) === "function" ? _c : Object, Object]),
    __metadata("design:returntype", typeof (_d = typeof Promise !== "undefined" && Promise) === "function" ? _d : Object)
], AnalyticsController.prototype, "getSellerDashboard", null);
__decorate([
    (0, common_1.Get)('seller/revenue'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller revenue analytics',
        description: 'Detailed revenue analytics including trends, breakdowns, and fee analysis'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller revenue analytics retrieved successfully',
        type: seller_analytics_dto_1.SellerAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_e = typeof seller_analytics_dto_1.GetSellerRevenueDto !== "undefined" && seller_analytics_dto_1.GetSellerRevenueDto) === "function" ? _e : Object, Object]),
    __metadata("design:returntype", typeof (_f = typeof Promise !== "undefined" && Promise) === "function" ? _f : Object)
], AnalyticsController.prototype, "getSellerRevenue", null);
__decorate([
    (0, common_1.Get)('seller/products'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller products analytics',
        description: 'Product performance analytics including top performers, ratings, and conversion metrics'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller products analytics retrieved successfully',
        type: seller_analytics_dto_1.SellerAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_g = typeof seller_analytics_dto_1.GetSellerProductsDto !== "undefined" && seller_analytics_dto_1.GetSellerProductsDto) === "function" ? _g : Object, Object]),
    __metadata("design:returntype", typeof (_h = typeof Promise !== "undefined" && Promise) === "function" ? _h : Object)
], AnalyticsController.prototype, "getSellerProducts", null);
__decorate([
    (0, common_1.Get)('seller/reviews'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller reviews analytics',
        description: 'Review analytics including ratings distribution, response rates, and recent activity'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller reviews analytics retrieved successfully',
        type: seller_analytics_dto_1.SellerAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_j = typeof seller_analytics_dto_1.GetSellerReviewsDto !== "undefined" && seller_analytics_dto_1.GetSellerReviewsDto) === "function" ? _j : Object, Object]),
    __metadata("design:returntype", typeof (_k = typeof Promise !== "undefined" && Promise) === "function" ? _k : Object)
], AnalyticsController.prototype, "getSellerReviews", null);
__decorate([
    (0, common_1.Get)('seller/customers'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller customer analytics',
        description: 'Customer analytics including repeat buyers, lifetime value, and acquisition metrics'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller customer analytics retrieved successfully',
        type: seller_analytics_dto_1.SellerAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_l = typeof seller_analytics_dto_1.GetSellerCustomersDto !== "undefined" && seller_analytics_dto_1.GetSellerCustomersDto) === "function" ? _l : Object, Object]),
    __metadata("design:returntype", typeof (_m = typeof Promise !== "undefined" && Promise) === "function" ? _m : Object)
], AnalyticsController.prototype, "getSellerCustomers", null);
__decorate([
    (0, common_1.Get)('seller/notifications'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller notification analytics',
        description: 'Notification engagement analytics including open rates, click rates, and type breakdown'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller notification analytics retrieved successfully',
        type: seller_analytics_dto_1.SellerAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_o = typeof seller_analytics_dto_1.GetSellerNotificationsDto !== "undefined" && seller_analytics_dto_1.GetSellerNotificationsDto) === "function" ? _o : Object, Object]),
    __metadata("design:returntype", typeof (_p = typeof Promise !== "undefined" && Promise) === "function" ? _p : Object)
], AnalyticsController.prototype, "getSellerNotifications", null);
__decorate([
    (0, common_1.Get)('seller/conversion'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller conversion analytics',
        description: 'Conversion funnel analytics and optimization insights for seller products'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller conversion analytics retrieved successfully',
        type: seller_analytics_dto_1.SellerAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_q = typeof seller_analytics_dto_1.GetSellerConversionDto !== "undefined" && seller_analytics_dto_1.GetSellerConversionDto) === "function" ? _q : Object, Object]),
    __metadata("design:returntype", typeof (_r = typeof Promise !== "undefined" && Promise) === "function" ? _r : Object)
], AnalyticsController.prototype, "getSellerConversion", null);
__decorate([
    (0, common_1.Get)('admin/platform'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get platform overview analytics',
        description: 'Platform-wide analytics including users, revenue, orders, and growth metrics'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Platform analytics retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_s = typeof admin_analytics_dto_1.GetPlatformOverviewDto !== "undefined" && admin_analytics_dto_1.GetPlatformOverviewDto) === "function" ? _s : Object, Object]),
    __metadata("design:returntype", typeof (_t = typeof Promise !== "undefined" && Promise) === "function" ? _t : Object)
], AnalyticsController.prototype, "getPlatformOverview", null);
__decorate([
    (0, common_1.Get)('admin/top-performers'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get top performers analytics',
        description: 'Top performing sellers, products, categories, and buyers with detailed metrics'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Top performers analytics retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    (0, swagger_1.ApiQuery)({ name: 'type', required: true, enum: ['sellers', 'products', 'categories', 'buyers'] }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_u = typeof admin_analytics_dto_1.GetTopPerformersDto !== "undefined" && admin_analytics_dto_1.GetTopPerformersDto) === "function" ? _u : Object, Object]),
    __metadata("design:returntype", typeof (_v = typeof Promise !== "undefined" && Promise) === "function" ? _v : Object)
], AnalyticsController.prototype, "getTopPerformers", null);
__decorate([
    (0, common_1.Get)('admin/sellers/comparison'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller comparison analytics',
        description: 'Compare multiple sellers across various metrics'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Seller comparison analytics retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_w = typeof admin_analytics_dto_1.GetSellerComparisonDto !== "undefined" && admin_analytics_dto_1.GetSellerComparisonDto) === "function" ? _w : Object, Object]),
    __metadata("design:returntype", typeof (_x = typeof Promise !== "undefined" && Promise) === "function" ? _x : Object)
], AnalyticsController.prototype, "getSellerComparison", null);
__decorate([
    (0, common_1.Get)('admin/conversion-funnel'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get platform conversion funnel analytics',
        description: 'Platform-wide conversion funnel analysis with drop-off points and optimization insights'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Conversion funnel analytics retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_y = typeof admin_analytics_dto_1.GetConversionFunnelDto !== "undefined" && admin_analytics_dto_1.GetConversionFunnelDto) === "function" ? _y : Object, Object]),
    __metadata("design:returntype", typeof (_z = typeof Promise !== "undefined" && Promise) === "function" ? _z : Object)
], AnalyticsController.prototype, "getConversionFunnel", null);
__decorate([
    (0, common_1.Get)('admin/cohort-analysis'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get cohort analysis',
        description: 'User retention and revenue cohort analysis with heatmap data'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Cohort analysis retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_0 = typeof admin_analytics_dto_1.GetCohortAnalysisDto !== "undefined" && admin_analytics_dto_1.GetCohortAnalysisDto) === "function" ? _0 : Object, Object]),
    __metadata("design:returntype", typeof (_1 = typeof Promise !== "undefined" && Promise) === "function" ? _1 : Object)
], AnalyticsController.prototype, "getCohortAnalysis", null);
__decorate([
    (0, common_1.Get)('admin/notifications'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get platform notification analytics',
        description: 'Platform-wide notification engagement analytics with trends and breakdowns'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Notification analytics retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_2 = typeof admin_analytics_dto_1.GetNotificationAnalyticsDto !== "undefined" && admin_analytics_dto_1.GetNotificationAnalyticsDto) === "function" ? _2 : Object, Object]),
    __metadata("design:returntype", typeof (_3 = typeof Promise !== "undefined" && Promise) === "function" ? _3 : Object)
], AnalyticsController.prototype, "getNotificationAnalytics", null);
__decorate([
    (0, common_1.Get)('admin/user-behavior'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get user behavior analytics',
        description: 'User journey analysis, activity patterns, and engagement metrics'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'User behavior analytics retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_4 = typeof admin_analytics_dto_1.GetUserBehaviorDto !== "undefined" && admin_analytics_dto_1.GetUserBehaviorDto) === "function" ? _4 : Object, Object]),
    __metadata("design:returntype", typeof (_5 = typeof Promise !== "undefined" && Promise) === "function" ? _5 : Object)
], AnalyticsController.prototype, "getUserBehavior", null);
__decorate([
    (0, common_1.Get)('admin/financial-report'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get financial report',
        description: 'Comprehensive financial report with revenue, fees, and payment analysis'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Financial report retrieved successfully',
        type: admin_analytics_dto_1.AdminAnalyticsResponseDto
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_6 = typeof admin_analytics_dto_1.GetFinancialReportDto !== "undefined" && admin_analytics_dto_1.GetFinancialReportDto) === "function" ? _6 : Object, Object]),
    __metadata("design:returntype", typeof (_7 = typeof Promise !== "undefined" && Promise) === "function" ? _7 : Object)
], AnalyticsController.prototype, "getFinancialReport", null);
__decorate([
    (0, common_1.Post)('export'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Export analytics data',
        description: 'Export analytics data in various formats (CSV, XLSX, PDF, JSON)'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Data exported successfully',
        type: export_dto_1.ExportResponseDto
    }),
    __param(0, (0, common_1.Body)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_8 = typeof export_dto_1.ExportDataDto !== "undefined" && export_dto_1.ExportDataDto) === "function" ? _8 : Object, Object]),
    __metadata("design:returntype", typeof (_9 = typeof Promise !== "undefined" && Promise) === "function" ? _9 : Object)
], AnalyticsController.prototype, "exportData", null);
__decorate([
    (0, common_1.Post)('reports/custom'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({
        summary: 'Generate custom report',
        description: 'Generate a custom analytics report with specified metrics and visualizations'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Custom report generated successfully',
        type: export_dto_1.ExportResponseDto
    }),
    __param(0, (0, common_1.Body)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_10 = typeof export_dto_1.CustomReportDto !== "undefined" && export_dto_1.CustomReportDto) === "function" ? _10 : Object, Object]),
    __metadata("design:returntype", typeof (_11 = typeof Promise !== "undefined" && Promise) === "function" ? _11 : Object)
], AnalyticsController.prototype, "generateCustomReport", null);
__decorate([
    (0, common_1.Post)('reports/schedule'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, common_1.HttpCode)(common_1.HttpStatus.CREATED),
    (0, swagger_1.ApiOperation)({
        summary: 'Schedule automated report',
        description: 'Schedule automated report generation and delivery'
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Report scheduled successfully'
    }),
    __param(0, (0, common_1.Body)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_12 = typeof export_dto_1.ScheduleReportDto !== "undefined" && export_dto_1.ScheduleReportDto) === "function" ? _12 : Object, Object]),
    __metadata("design:returntype", typeof (_13 = typeof Promise !== "undefined" && Promise) === "function" ? _13 : Object)
], AnalyticsController.prototype, "scheduleReport", null);
__decorate([
    (0, common_1.Get)('reports/:reportId/download'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Download generated report',
        description: 'Download a previously generated report by ID'
    }),
    (0, swagger_1.ApiParam)({ name: 'reportId', description: 'Report ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Report downloaded successfully'
    }),
    __param(0, (0, common_1.Param)('reportId', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", typeof (_14 = typeof Promise !== "undefined" && Promise) === "function" ? _14 : Object)
], AnalyticsController.prototype, "downloadReport", null);
__decorate([
    (0, common_1.Get)('charts/seller/:sellerId/revenue'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER, client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get seller revenue chart data',
        description: 'Get formatted chart data for seller revenue visualization'
    }),
    (0, swagger_1.ApiParam)({ name: 'sellerId', description: 'Seller ID' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Revenue chart data retrieved successfully'
    }),
    __param(0, (0, common_1.Param)('sellerId', common_1.ParseUUIDPipe)),
    __param(1, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(2, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_15 = typeof seller_analytics_dto_1.GetSellerRevenueDto !== "undefined" && seller_analytics_dto_1.GetSellerRevenueDto) === "function" ? _15 : Object, Object]),
    __metadata("design:returntype", typeof (_16 = typeof Promise !== "undefined" && Promise) === "function" ? _16 : Object)
], AnalyticsController.prototype, "getSellerRevenueChart", null);
__decorate([
    (0, common_1.Get)('charts/admin/platform-overview'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get platform overview chart data',
        description: 'Get formatted chart data for platform overview dashboard'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Platform overview chart data retrieved successfully'
    }),
    __param(0, (0, common_1.Query)(common_1.ValidationPipe)),
    __param(1, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_17 = typeof admin_analytics_dto_1.GetPlatformOverviewDto !== "undefined" && admin_analytics_dto_1.GetPlatformOverviewDto) === "function" ? _17 : Object, Object]),
    __metadata("design:returntype", typeof (_18 = typeof Promise !== "undefined" && Promise) === "function" ? _18 : Object)
], AnalyticsController.prototype, "getPlatformOverviewChart", null);
__decorate([
    (0, common_1.Get)('health'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get analytics system health',
        description: 'Check the health and status of the analytics system'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Analytics system health retrieved successfully'
    }),
    __param(0, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_19 = typeof Promise !== "undefined" && Promise) === "function" ? _19 : Object)
], AnalyticsController.prototype, "getSystemHealth", null);
__decorate([
    (0, common_1.Get)('cache/status'),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiOperation)({
        summary: 'Get analytics cache status',
        description: 'Get status of analytics data cache and performance metrics'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Cache status retrieved successfully'
    }),
    __param(0, (0, common_1.Req)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", typeof (_20 = typeof Promise !== "undefined" && Promise) === "function" ? _20 : Object)
], AnalyticsController.prototype, "getCacheStatus", null);
__decorate([
    (0, common_1.Get)('stats'),
    (0, public_decorator_1.Public)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get general analytics stats' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AnalyticsController.prototype, "getStats", null);
exports.AnalyticsController = AnalyticsController = __decorate([
    (0, swagger_1.ApiTags)('Analytics'),
    (0, common_1.Controller)('analytics'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, swagger_1.ApiBearerAuth)(),
    __metadata("design:paramtypes", [typeof (_a = typeof analytics_service_1.AnalyticsService !== "undefined" && analytics_service_1.AnalyticsService) === "function" ? _a : Object, typeof (_b = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _b : Object])
], AnalyticsController);


/***/ }),
/* 291 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SellerAnalyticsResponseDto = exports.GetSellerConversionDto = exports.GetSellerNotificationsDto = exports.GetSellerCustomersDto = exports.GetSellerReviewsDto = exports.GetSellerProductsDto = exports.GetSellerRevenueDto = exports.GetSellerDashboardDto = exports.SortOrder = exports.SortBy = exports.DashboardMetric = void 0;
const class_validator_1 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
const swagger_1 = __webpack_require__(4);
const filters_dto_1 = __webpack_require__(289);
var DashboardMetric;
(function (DashboardMetric) {
    DashboardMetric["REVENUE"] = "revenue";
    DashboardMetric["ORDERS"] = "orders";
    DashboardMetric["PRODUCTS"] = "products";
    DashboardMetric["REVIEWS"] = "reviews";
    DashboardMetric["CUSTOMERS"] = "customers";
    DashboardMetric["CONVERSION"] = "conversion";
})(DashboardMetric || (exports.DashboardMetric = DashboardMetric = {}));
var SortBy;
(function (SortBy) {
    SortBy["REVENUE"] = "revenue";
    SortBy["ORDERS"] = "orders";
    SortBy["RATING"] = "rating";
    SortBy["REVIEWS"] = "reviews";
    SortBy["CREATED_AT"] = "createdAt";
    SortBy["UPDATED_AT"] = "updatedAt";
})(SortBy || (exports.SortBy = SortBy = {}));
var SortOrder;
(function (SortOrder) {
    SortOrder["ASC"] = "asc";
    SortOrder["DESC"] = "desc";
})(SortOrder || (exports.SortOrder = SortOrder = {}));
class GetSellerDashboardDto extends filters_dto_1.SellerAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeComparison = true;
        this.includeActivity = true;
    }
}
exports.GetSellerDashboardDto = GetSellerDashboardDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include comparison with previous period',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeComparison must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerDashboardDto.prototype, "includeComparison", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include recent activity data',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeActivity must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerDashboardDto.prototype, "includeActivity", void 0);
class GetSellerRevenueDto extends filters_dto_1.SellerAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeProductBreakdown = false;
        this.includeFees = false;
    }
}
exports.GetSellerRevenueDto = GetSellerRevenueDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include breakdown by product',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeProductBreakdown must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerRevenueDto.prototype, "includeProductBreakdown", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include platform fees breakdown',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeFees must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerRevenueDto.prototype, "includeFees", void 0);
class GetSellerProductsDto extends filters_dto_1.SellerAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.sortBy = SortBy.REVENUE;
        this.sortOrder = SortOrder.DESC;
        this.includeDetails = true;
    }
}
exports.GetSellerProductsDto = GetSellerProductsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort products by',
        enum: SortBy,
        default: SortBy.REVENUE
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(SortBy, { message: 'sortBy must be one of: revenue, orders, rating, reviews, createdAt, updatedAt' }),
    __metadata("design:type", String)
], GetSellerProductsDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort order',
        enum: SortOrder,
        default: SortOrder.DESC
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(SortOrder, { message: 'sortOrder must be either asc or desc' }),
    __metadata("design:type", String)
], GetSellerProductsDto.prototype, "sortOrder", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include detailed metrics for each product',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeDetails must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerProductsDto.prototype, "includeDetails", void 0);
class GetSellerReviewsDto extends filters_dto_1.SellerAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeDistribution = true;
        this.includeRecentReviews = true;
        this.includeResponseMetrics = true;
    }
}
exports.GetSellerReviewsDto = GetSellerReviewsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include review distribution by rating',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeDistribution must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerReviewsDto.prototype, "includeDistribution", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include recent reviews',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeRecentReviews must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerReviewsDto.prototype, "includeRecentReviews", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include response rate metrics',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeResponseMetrics must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerReviewsDto.prototype, "includeResponseMetrics", void 0);
class GetSellerCustomersDto extends filters_dto_1.SellerAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeRepeatAnalysis = true;
        this.includeLifetimeValue = false;
    }
}
exports.GetSellerCustomersDto = GetSellerCustomersDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include repeat customer analysis',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeRepeatAnalysis must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerCustomersDto.prototype, "includeRepeatAnalysis", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include customer lifetime value',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeLifetimeValue must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerCustomersDto.prototype, "includeLifetimeValue", void 0);
class GetSellerNotificationsDto extends filters_dto_1.SellerAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeEngagement = true;
        this.includeTypeBreakdown = true;
    }
}
exports.GetSellerNotificationsDto = GetSellerNotificationsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include engagement metrics',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeEngagement must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerNotificationsDto.prototype, "includeEngagement", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include breakdown by notification type',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeTypeBreakdown must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerNotificationsDto.prototype, "includeTypeBreakdown", void 0);
class GetSellerConversionDto extends filters_dto_1.SellerAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeFunnel = true;
        this.includeTrafficSource = false;
    }
}
exports.GetSellerConversionDto = GetSellerConversionDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include funnel analysis',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeFunnel must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerConversionDto.prototype, "includeFunnel", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include conversion by traffic source',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeTrafficSource must be a boolean' }),
    __metadata("design:type", Boolean)
], GetSellerConversionDto.prototype, "includeTrafficSource", void 0);
class SellerAnalyticsResponseDto {
}
exports.SellerAnalyticsResponseDto = SellerAnalyticsResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Success status' }),
    __metadata("design:type", Boolean)
], SellerAnalyticsResponseDto.prototype, "success", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Analytics data' }),
    __metadata("design:type", Object)
], SellerAnalyticsResponseDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Metadata about the response' }),
    __metadata("design:type", Object)
], SellerAnalyticsResponseDto.prototype, "meta", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Error message if any' }),
    __metadata("design:type", String)
], SellerAnalyticsResponseDto.prototype, "error", void 0);


/***/ }),
/* 292 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminAnalyticsResponseDto = exports.GetFinancialReportDto = exports.GetUserBehaviorDto = exports.GetNotificationAnalyticsDto = exports.GetCohortAnalysisDto = exports.GetConversionFunnelDto = exports.GetSellerComparisonDto = exports.GetTopPerformersDto = exports.GetPlatformOverviewDto = exports.TopPerformerType = exports.PlatformMetric = void 0;
const class_validator_1 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
const swagger_1 = __webpack_require__(4);
const filters_dto_1 = __webpack_require__(289);
const seller_analytics_dto_1 = __webpack_require__(291);
var PlatformMetric;
(function (PlatformMetric) {
    PlatformMetric["USERS"] = "users";
    PlatformMetric["REVENUE"] = "revenue";
    PlatformMetric["ORDERS"] = "orders";
    PlatformMetric["PRODUCTS"] = "products";
    PlatformMetric["REVIEWS"] = "reviews";
    PlatformMetric["NOTIFICATIONS"] = "notifications";
    PlatformMetric["CONVERSION"] = "conversion";
})(PlatformMetric || (exports.PlatformMetric = PlatformMetric = {}));
var TopPerformerType;
(function (TopPerformerType) {
    TopPerformerType["SELLERS"] = "sellers";
    TopPerformerType["PRODUCTS"] = "products";
    TopPerformerType["CATEGORIES"] = "categories";
    TopPerformerType["BUYERS"] = "buyers";
})(TopPerformerType || (exports.TopPerformerType = TopPerformerType = {}));
class GetPlatformOverviewDto extends filters_dto_1.AdminAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeComparison = true;
        this.includeTrends = true;
    }
}
exports.GetPlatformOverviewDto = GetPlatformOverviewDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include comparison with previous period',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeComparison must be a boolean' }),
    __metadata("design:type", Boolean)
], GetPlatformOverviewDto.prototype, "includeComparison", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include growth trends',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeTrends must be a boolean' }),
    __metadata("design:type", Boolean)
], GetPlatformOverviewDto.prototype, "includeTrends", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Metrics to include',
        enum: PlatformMetric,
        isArray: true,
        example: [PlatformMetric.USERS, PlatformMetric.REVENUE, PlatformMetric.ORDERS]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)({ message: 'metrics must be an array' }),
    (0, class_validator_1.IsEnum)(PlatformMetric, { each: true, message: 'Each metric must be a valid platform metric' }),
    (0, class_transformer_1.Type)(() => String),
    __metadata("design:type", Array)
], GetPlatformOverviewDto.prototype, "metrics", void 0);
class GetTopPerformersDto extends filters_dto_1.AdminAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.sortBy = seller_analytics_dto_1.SortBy.REVENUE;
        this.sortOrder = seller_analytics_dto_1.SortOrder.DESC;
        this.includeDetails = true;
    }
}
exports.GetTopPerformersDto = GetTopPerformersDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of performers to retrieve',
        enum: TopPerformerType
    }),
    (0, class_validator_1.IsEnum)(TopPerformerType, { message: 'type must be one of: sellers, products, categories, buyers' }),
    __metadata("design:type", String)
], GetTopPerformersDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort performers by',
        enum: seller_analytics_dto_1.SortBy,
        default: seller_analytics_dto_1.SortBy.REVENUE
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(seller_analytics_dto_1.SortBy, { message: 'sortBy must be one of: revenue, orders, rating, reviews, createdAt, updatedAt' }),
    __metadata("design:type", typeof (_a = typeof seller_analytics_dto_1.SortBy !== "undefined" && seller_analytics_dto_1.SortBy) === "function" ? _a : Object)
], GetTopPerformersDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort order',
        enum: seller_analytics_dto_1.SortOrder,
        default: seller_analytics_dto_1.SortOrder.DESC
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(seller_analytics_dto_1.SortOrder, { message: 'sortOrder must be either asc or desc' }),
    __metadata("design:type", typeof (_b = typeof seller_analytics_dto_1.SortOrder !== "undefined" && seller_analytics_dto_1.SortOrder) === "function" ? _b : Object)
], GetTopPerformersDto.prototype, "sortOrder", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include detailed metrics',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeDetails must be a boolean' }),
    __metadata("design:type", Boolean)
], GetTopPerformersDto.prototype, "includeDetails", void 0);
class GetSellerComparisonDto extends filters_dto_1.AdminAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.metrics = [PlatformMetric.REVENUE, PlatformMetric.ORDERS, PlatformMetric.REVIEWS];
    }
}
exports.GetSellerComparisonDto = GetSellerComparisonDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Seller IDs to compare',
        type: [String],
        example: ['seller1_id', 'seller2_id']
    }),
    (0, class_validator_1.IsArray)({ message: 'sellerIds must be an array' }),
    (0, class_validator_1.IsUUID)(4, { each: true, message: 'Each sellerId must be a valid UUID' }),
    __metadata("design:type", Array)
], GetSellerComparisonDto.prototype, "sellerIds", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Metrics to compare',
        enum: PlatformMetric,
        isArray: true,
        default: [PlatformMetric.REVENUE, PlatformMetric.ORDERS, PlatformMetric.REVIEWS]
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)({ message: 'metrics must be an array' }),
    (0, class_validator_1.IsEnum)(PlatformMetric, { each: true, message: 'Each metric must be a valid platform metric' }),
    (0, class_transformer_1.Type)(() => String),
    __metadata("design:type", Array)
], GetSellerComparisonDto.prototype, "metrics", void 0);
class GetConversionFunnelDto extends filters_dto_1.ConversionAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeBreakdown = true;
        this.includeDropOffs = true;
    }
}
exports.GetConversionFunnelDto = GetConversionFunnelDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include step-by-step breakdown',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeBreakdown must be a boolean' }),
    __metadata("design:type", Boolean)
], GetConversionFunnelDto.prototype, "includeBreakdown", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include drop-off analysis',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeDropOffs must be a boolean' }),
    __metadata("design:type", Boolean)
], GetConversionFunnelDto.prototype, "includeDropOffs", void 0);
class GetCohortAnalysisDto extends filters_dto_1.CohortAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeRevenue = true;
        this.includeHeatmap = true;
    }
}
exports.GetCohortAnalysisDto = GetCohortAnalysisDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include revenue per user analysis',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeRevenue must be a boolean' }),
    __metadata("design:type", Boolean)
], GetCohortAnalysisDto.prototype, "includeRevenue", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include retention heatmap data',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeHeatmap must be a boolean' }),
    __metadata("design:type", Boolean)
], GetCohortAnalysisDto.prototype, "includeHeatmap", void 0);
class GetNotificationAnalyticsDto extends filters_dto_1.NotificationAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeTrends = true;
        this.includeBreakdown = true;
    }
}
exports.GetNotificationAnalyticsDto = GetNotificationAnalyticsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include engagement trends',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeTrends must be a boolean' }),
    __metadata("design:type", Boolean)
], GetNotificationAnalyticsDto.prototype, "includeTrends", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include breakdown by type and channel',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeBreakdown must be a boolean' }),
    __metadata("design:type", Boolean)
], GetNotificationAnalyticsDto.prototype, "includeBreakdown", void 0);
class GetUserBehaviorDto extends filters_dto_1.AdminAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeJourney = true;
        this.includePatterns = true;
    }
}
exports.GetUserBehaviorDto = GetUserBehaviorDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include user journey analysis',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeJourney must be a boolean' }),
    __metadata("design:type", Boolean)
], GetUserBehaviorDto.prototype, "includeJourney", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include activity patterns',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includePatterns must be a boolean' }),
    __metadata("design:type", Boolean)
], GetUserBehaviorDto.prototype, "includePatterns", void 0);
class GetFinancialReportDto extends filters_dto_1.AdminAnalyticsFiltersDto {
    constructor() {
        super(...arguments);
        this.includeSellerBreakdown = false;
        this.includeFeesAnalysis = true;
        this.includePaymentMethods = true;
    }
}
exports.GetFinancialReportDto = GetFinancialReportDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include detailed breakdown by seller',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeSellerBreakdown must be a boolean' }),
    __metadata("design:type", Boolean)
], GetFinancialReportDto.prototype, "includeSellerBreakdown", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include platform fees analysis',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includeFeesAnalysis must be a boolean' }),
    __metadata("design:type", Boolean)
], GetFinancialReportDto.prototype, "includeFeesAnalysis", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Include payment method breakdown',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsBoolean)({ message: 'includePaymentMethods must be a boolean' }),
    __metadata("design:type", Boolean)
], GetFinancialReportDto.prototype, "includePaymentMethods", void 0);
class AdminAnalyticsResponseDto {
}
exports.AdminAnalyticsResponseDto = AdminAnalyticsResponseDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Success status' }),
    __metadata("design:type", Boolean)
], AdminAnalyticsResponseDto.prototype, "success", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Analytics data' }),
    __metadata("design:type", Object)
], AdminAnalyticsResponseDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Metadata about the response' }),
    __metadata("design:type", Object)
], AdminAnalyticsResponseDto.prototype, "meta", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Error message if any' }),
    __metadata("design:type", String)
], AdminAnalyticsResponseDto.prototype, "error", void 0);


/***/ }),
/* 293 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReviewsModule = void 0;
const common_1 = __webpack_require__(2);
const reviews_controller_1 = __webpack_require__(294);
const reviews_service_1 = __webpack_require__(230);
const prisma_module_1 = __webpack_require__(9);
const notifications_module_1 = __webpack_require__(235);
let ReviewsModule = class ReviewsModule {
};
exports.ReviewsModule = ReviewsModule;
exports.ReviewsModule = ReviewsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            prisma_module_1.PrismaModule,
            notifications_module_1.NotificationModule
        ],
        controllers: [reviews_controller_1.ReviewsController],
        providers: [reviews_service_1.ReviewsService],
        exports: [reviews_service_1.ReviewsService]
    })
], ReviewsModule);


/***/ }),
/* 294 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a, _b, _c, _d, _e, _f, _g, _h;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReviewsController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const reviews_service_1 = __webpack_require__(230);
const jwt_auth_guard_1 = __webpack_require__(24);
const roles_guard_1 = __webpack_require__(30);
const roles_decorator_1 = __webpack_require__(31);
const current_user_decorator_1 = __webpack_require__(26);
const client_1 = __webpack_require__(11);
const dto_1 = __webpack_require__(295);
let ReviewsController = class ReviewsController {
    constructor(reviewsService) {
        this.reviewsService = reviewsService;
    }
    async findAll(filters) {
        return this.reviewsService.findAll(filters);
    }
    async getProductStats(productId) {
        return this.reviewsService.getProductStats(productId);
    }
    async getSellerStats(sellerId) {
        return this.reviewsService.getSellerStats(sellerId);
    }
    async findOne(id) {
        return this.reviewsService.findOne(id);
    }
    async create(userId, createReviewDto) {
        return this.reviewsService.createReview(userId, createReviewDto);
    }
    async update(userId, id, updateReviewDto) {
        return this.reviewsService.updateReview(userId, id, updateReviewDto);
    }
    async createResponse(userId, reviewId, responseDto) {
        return this.reviewsService.createResponse(userId, reviewId, responseDto);
    }
    async voteReview(userId, reviewId, voteDto) {
        return this.reviewsService.voteReview(userId, reviewId, voteDto);
    }
    async reportReview(userId, reviewId, reportDto) {
        return this.reviewsService.reportReview(userId, reviewId, reportDto);
    }
    async getAdminStats() {
        return this.reviewsService.getAdminStats();
    }
    async getPendingReviews(page, limit) {
        return this.reviewsService.getPendingReviews(page, limit);
    }
    async moderateReview(adminId, reviewId, moderateDto) {
        return this.reviewsService.moderateReview(adminId, reviewId, moderateDto);
    }
    async deleteReview(reviewId) {
        return this.reviewsService.deleteReview(reviewId);
    }
};
exports.ReviewsController = ReviewsController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get reviews with filters' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Reviews retrieved successfully' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof dto_1.FilterReviewDto !== "undefined" && dto_1.FilterReviewDto) === "function" ? _b : Object]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('products/:productId/stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get product review statistics' }),
    (0, swagger_1.ApiParam)({ name: 'productId', description: 'Product ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Product stats retrieved' }),
    __param(0, (0, common_1.Param)('productId', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "getProductStats", null);
__decorate([
    (0, common_1.Get)('sellers/:sellerId/stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get seller review statistics' }),
    (0, swagger_1.ApiParam)({ name: 'sellerId', description: 'Seller ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Seller stats retrieved' }),
    __param(0, (0, common_1.Param)('sellerId', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "getSellerStats", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get review by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Review ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Review found' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Review not found' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Post)(),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.BUYER),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a review' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Review created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Review already exists' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, typeof (_c = typeof dto_1.CreateReviewDto !== "undefined" && dto_1.CreateReviewDto) === "function" ? _c : Object]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "create", null);
__decorate([
    (0, common_1.Put)(':id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update own review' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Review ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Review updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Not authorized to update this review' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Review not found' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __param(1, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, typeof (_d = typeof dto_1.UpdateReviewDto !== "undefined" && dto_1.UpdateReviewDto) === "function" ? _d : Object]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "update", null);
__decorate([
    (0, common_1.Post)(':id/response'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.SELLER),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Respond to a review' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Review ID' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Response created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 403, description: 'Not authorized to respond to this review' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Response already exists' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __param(1, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, typeof (_e = typeof dto_1.CreateReviewResponseDto !== "undefined" && dto_1.CreateReviewResponseDto) === "function" ? _e : Object]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "createResponse", null);
__decorate([
    (0, common_1.Post)(':id/vote'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Vote on review helpfulness' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Review ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Vote recorded successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Cannot vote on own review' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __param(1, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, typeof (_f = typeof dto_1.ReviewVoteDto !== "undefined" && dto_1.ReviewVoteDto) === "function" ? _f : Object]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "voteReview", null);
__decorate([
    (0, common_1.Post)(':id/report'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Report inappropriate review' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Review ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Report submitted successfully' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Already reported this review' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __param(1, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, typeof (_g = typeof dto_1.ReportReviewDto !== "undefined" && dto_1.ReportReviewDto) === "function" ? _g : Object]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "reportReview", null);
__decorate([
    (0, common_1.Get)('admin/stats'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get admin review statistics' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Admin stats retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "getAdminStats", null);
__decorate([
    (0, common_1.Get)('admin/pending'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get pending reviews for moderation' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Pending reviews retrieved successfully' }),
    __param(0, (0, common_1.Query)('page')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "getPendingReviews", null);
__decorate([
    (0, common_1.Put)('admin/:id/moderate'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, swagger_1.ApiOperation)({ summary: 'Moderate a review' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Review ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Review moderated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Review not found' }),
    __param(0, (0, current_user_decorator_1.CurrentUser)('sub')),
    __param(1, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, typeof (_h = typeof dto_1.ModerateReviewDto !== "undefined" && dto_1.ModerateReviewDto) === "function" ? _h : Object]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "moderateReview", null);
__decorate([
    (0, common_1.Delete)('admin/:id'),
    (0, common_1.UseGuards)(jwt_auth_guard_1.JwtAuthGuard, roles_guard_1.RolesGuard),
    (0, roles_decorator_1.Roles)(client_1.UserRole.ADMIN),
    (0, swagger_1.ApiBearerAuth)(),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a review' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Review ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Review deleted successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Review not found' }),
    __param(0, (0, common_1.Param)('id', common_1.ParseUUIDPipe)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ReviewsController.prototype, "deleteReview", null);
exports.ReviewsController = ReviewsController = __decorate([
    (0, swagger_1.ApiTags)('Reviews'),
    (0, common_1.Controller)('reviews'),
    __metadata("design:paramtypes", [typeof (_a = typeof reviews_service_1.ReviewsService !== "undefined" && reviews_service_1.ReviewsService) === "function" ? _a : Object])
], ReviewsController);


/***/ }),
/* 295 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModerateReviewDto = exports.FilterReviewDto = exports.ReportReviewDto = exports.ReviewVoteDto = exports.CreateReviewResponseDto = exports.UpdateReviewDto = exports.CreateReviewDto = void 0;
var create_review_dto_1 = __webpack_require__(296);
Object.defineProperty(exports, "CreateReviewDto", ({ enumerable: true, get: function () { return create_review_dto_1.CreateReviewDto; } }));
var update_review_dto_1 = __webpack_require__(297);
Object.defineProperty(exports, "UpdateReviewDto", ({ enumerable: true, get: function () { return update_review_dto_1.UpdateReviewDto; } }));
Object.defineProperty(exports, "CreateReviewResponseDto", ({ enumerable: true, get: function () { return update_review_dto_1.CreateReviewResponseDto; } }));
var review_vote_dto_1 = __webpack_require__(298);
Object.defineProperty(exports, "ReviewVoteDto", ({ enumerable: true, get: function () { return review_vote_dto_1.ReviewVoteDto; } }));
var report_review_dto_1 = __webpack_require__(299);
Object.defineProperty(exports, "ReportReviewDto", ({ enumerable: true, get: function () { return report_review_dto_1.ReportReviewDto; } }));
var filter_review_dto_1 = __webpack_require__(300);
Object.defineProperty(exports, "FilterReviewDto", ({ enumerable: true, get: function () { return filter_review_dto_1.FilterReviewDto; } }));
var moderate_review_dto_1 = __webpack_require__(301);
Object.defineProperty(exports, "ModerateReviewDto", ({ enumerable: true, get: function () { return moderate_review_dto_1.ModerateReviewDto; } }));


/***/ }),
/* 296 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateReviewDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class CreateReviewDto {
}
exports.CreateReviewDto = CreateReviewDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Order ID for verified purchase',
        example: 'clp1234567890'
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'orderId.required' }),
    (0, class_validator_1.IsUUID)('4', { message: 'orderId.invalid' }),
    __metadata("design:type", String)
], CreateReviewDto.prototype, "orderId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Product being reviewed',
        example: 'clp0987654321'
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'productId.required' }),
    (0, class_validator_1.IsUUID)('4', { message: 'productId.invalid' }),
    __metadata("design:type", String)
], CreateReviewDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Rating from 1 to 5 stars',
        minimum: 1,
        maximum: 5,
        example: 5
    }),
    (0, class_validator_1.IsInt)({ message: 'rating.mustBeInteger' }),
    (0, class_validator_1.Min)(1, { message: 'rating.tooLow' }),
    (0, class_validator_1.Max)(5, { message: 'rating.tooHigh' }),
    __metadata("design:type", Number)
], CreateReviewDto.prototype, "rating", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Review title',
        maxLength: 100,
        example: 'Great furniture design!'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'title.mustBeString' }),
    (0, class_validator_1.MaxLength)(100, { message: 'title.tooLong' }),
    __metadata("design:type", String)
], CreateReviewDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Review comment',
        minLength: 10,
        maxLength: 2000,
        example: 'This furniture design exceeded my expectations...'
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'comment.required' }),
    (0, class_validator_1.IsString)({ message: 'comment.mustBeString' }),
    (0, class_validator_1.MinLength)(10, { message: 'comment.tooShort' }),
    (0, class_validator_1.MaxLength)(2000, { message: 'comment.tooLong' }),
    __metadata("design:type", String)
], CreateReviewDto.prototype, "comment", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Positive aspects (pros)',
        maxLength: 500,
        example: 'Easy to follow instructions, beautiful result'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'pros.mustBeString' }),
    (0, class_validator_1.MaxLength)(500, { message: 'pros.tooLong' }),
    __metadata("design:type", String)
], CreateReviewDto.prototype, "pros", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Negative aspects (cons)',
        maxLength: 500,
        example: 'Some measurements could be clearer'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'cons.mustBeString' }),
    (0, class_validator_1.MaxLength)(500, { message: 'cons.tooLong' }),
    __metadata("design:type", String)
], CreateReviewDto.prototype, "cons", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Review images (file IDs)',
        type: [String],
        maxItems: 5,
        example: ['clp1111111111', 'clp2222222222']
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)({ message: 'images.mustBeArray' }),
    (0, class_validator_1.IsUUID)('4', { each: true, message: 'images.invalidId' }),
    __metadata("design:type", Array)
], CreateReviewDto.prototype, "images", void 0);


/***/ }),
/* 297 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateReviewResponseDto = exports.UpdateReviewDto = void 0;
const swagger_1 = __webpack_require__(4);
const create_review_dto_1 = __webpack_require__(296);
class UpdateReviewDto extends (0, swagger_1.PartialType)((0, swagger_1.OmitType)(create_review_dto_1.CreateReviewDto, ['orderId', 'productId'])) {
}
exports.UpdateReviewDto = UpdateReviewDto;
const class_validator_1 = __webpack_require__(23);
const swagger_2 = __webpack_require__(4);
class CreateReviewResponseDto {
}
exports.CreateReviewResponseDto = CreateReviewResponseDto;
__decorate([
    (0, swagger_2.ApiProperty)({
        description: 'Seller response to the review',
        minLength: 10,
        maxLength: 1000,
        example: 'Thank you for your feedback! We really appreciate...'
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'comment.required' }),
    (0, class_validator_1.IsString)({ message: 'comment.mustBeString' }),
    (0, class_validator_1.MinLength)(10, { message: 'comment.tooShort' }),
    (0, class_validator_1.MaxLength)(1000, { message: 'comment.tooLong' }),
    __metadata("design:type", String)
], CreateReviewResponseDto.prototype, "comment", void 0);


/***/ }),
/* 298 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReviewVoteDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const client_1 = __webpack_require__(11);
class ReviewVoteDto {
}
exports.ReviewVoteDto = ReviewVoteDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Vote type',
        enum: client_1.ReviewHelpfulness,
        example: 'HELPFUL'
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'vote.required' }),
    (0, class_validator_1.IsIn)(['HELPFUL', 'NOT_HELPFUL'], { message: 'vote.invalid' }),
    __metadata("design:type", typeof (_a = typeof client_1.ReviewHelpfulness !== "undefined" && client_1.ReviewHelpfulness) === "function" ? _a : Object)
], ReviewVoteDto.prototype, "vote", void 0);


/***/ }),
/* 299 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReportReviewDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
class ReportReviewDto {
}
exports.ReportReviewDto = ReportReviewDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Reason for reporting',
        enum: ['spam', 'inappropriate', 'fake', 'harassment', 'other'],
        example: 'inappropriate'
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'reason.required' }),
    (0, class_validator_1.IsIn)(['spam', 'inappropriate', 'fake', 'harassment', 'other'], {
        message: 'reason.invalid'
    }),
    __metadata("design:type", String)
], ReportReviewDto.prototype, "reason", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Additional details about the report',
        maxLength: 500,
        example: 'This review contains offensive language...'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'details.mustBeString' }),
    (0, class_validator_1.MaxLength)(500, { message: 'details.tooLong' }),
    __metadata("design:type", String)
], ReportReviewDto.prototype, "details", void 0);


/***/ }),
/* 300 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterReviewDto = void 0;
const class_validator_1 = __webpack_require__(23);
const class_transformer_1 = __webpack_require__(40);
const swagger_1 = __webpack_require__(4);
const client_1 = __webpack_require__(11);
class FilterReviewDto {
    constructor() {
        this.sortBy = 'newest';
        this.page = 1;
        this.limit = 12;
    }
}
exports.FilterReviewDto = FilterReviewDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Product ID to filter reviews',
        example: 'clp0987654321'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)('4', { message: 'productId.invalid' }),
    __metadata("design:type", String)
], FilterReviewDto.prototype, "productId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Seller ID to filter reviews',
        example: 'clp1234567890'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUUID)('4', { message: 'sellerId.invalid' }),
    __metadata("design:type", String)
], FilterReviewDto.prototype, "sellerId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by rating',
        minimum: 1,
        maximum: 5,
        example: 5
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsInt)({ message: 'rating.mustBeInteger' }),
    (0, class_validator_1.Min)(1, { message: 'rating.tooLow' }),
    (0, class_validator_1.Max)(5, { message: 'rating.tooHigh' }),
    __metadata("design:type", Number)
], FilterReviewDto.prototype, "rating", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by review status',
        enum: client_1.ReviewStatus,
        example: 'PUBLISHED'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['PENDING_MODERATION', 'PUBLISHED', 'FLAGGED', 'REMOVED'], {
        message: 'status.invalid'
    }),
    __metadata("design:type", typeof (_a = typeof client_1.ReviewStatus !== "undefined" && client_1.ReviewStatus) === "function" ? _a : Object)
], FilterReviewDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Sort by',
        enum: ['newest', 'oldest', 'highest', 'lowest', 'helpful'],
        example: 'newest'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsIn)(['newest', 'oldest', 'highest', 'lowest', 'helpful'], {
        message: 'sortBy.invalid'
    }),
    __metadata("design:type", String)
], FilterReviewDto.prototype, "sortBy", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Page number',
        minimum: 1,
        example: 1
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsInt)({ message: 'page.mustBeInteger' }),
    (0, class_validator_1.Min)(1, { message: 'page.tooLow' }),
    __metadata("design:type", Number)
], FilterReviewDto.prototype, "page", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Items per page',
        minimum: 1,
        maximum: 50,
        example: 12
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsInt)({ message: 'limit.mustBeInteger' }),
    (0, class_validator_1.Min)(1, { message: 'limit.tooLow' }),
    (0, class_validator_1.Max)(50, { message: 'limit.tooHigh' }),
    __metadata("design:type", Number)
], FilterReviewDto.prototype, "limit", void 0);


/***/ }),
/* 301 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModerateReviewDto = void 0;
const class_validator_1 = __webpack_require__(23);
const swagger_1 = __webpack_require__(4);
const client_1 = __webpack_require__(11);
class ModerateReviewDto {
}
exports.ModerateReviewDto = ModerateReviewDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'New review status',
        enum: client_1.ReviewStatus,
        example: 'PUBLISHED'
    }),
    (0, class_validator_1.IsNotEmpty)({ message: 'status.required' }),
    (0, class_validator_1.IsIn)(['PENDING_MODERATION', 'PUBLISHED', 'FLAGGED', 'REMOVED'], {
        message: 'status.invalid'
    }),
    __metadata("design:type", typeof (_a = typeof client_1.ReviewStatus !== "undefined" && client_1.ReviewStatus) === "function" ? _a : Object)
], ModerateReviewDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Reason for moderation action',
        maxLength: 500,
        example: 'Review contains inappropriate language'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)({ message: 'reason.mustBeString' }),
    (0, class_validator_1.MaxLength)(500, { message: 'reason.tooLong' }),
    __metadata("design:type", String)
], ModerateReviewDto.prototype, "reason", void 0);


/***/ }),
/* 302 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HealthController = void 0;
const common_1 = __webpack_require__(2);
let HealthController = class HealthController {
    check() {
        return {
            status: 'ok',
            timestamp: new Date().toISOString(),
            service: 'Furnibles API',
            environment: process.env.NODE_ENV || 'development'
        };
    }
};
exports.HealthController = HealthController;
__decorate([
    (0, common_1.Get)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], HealthController.prototype, "check", null);
exports.HealthController = HealthController = __decorate([
    (0, common_1.Controller)('health')
], HealthController);


/***/ }),
/* 303 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SellersModule = void 0;
const common_1 = __webpack_require__(2);
const sellers_controller_1 = __webpack_require__(304);
const sellers_service_1 = __webpack_require__(305);
const prisma_service_1 = __webpack_require__(17);
let SellersModule = class SellersModule {
    constructor() {
        console.log('üöÄ [DEBUG] SellersModule initialized successfully!');
    }
};
exports.SellersModule = SellersModule;
exports.SellersModule = SellersModule = __decorate([
    (0, common_1.Module)({
        controllers: [sellers_controller_1.SellersController],
        providers: [sellers_service_1.SellersService, prisma_service_1.PrismaService],
        exports: [sellers_service_1.SellersService],
    }),
    __metadata("design:paramtypes", [])
], SellersModule);


/***/ }),
/* 304 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SellersController = void 0;
const common_1 = __webpack_require__(2);
const swagger_1 = __webpack_require__(4);
const sellers_service_1 = __webpack_require__(305);
let SellersController = class SellersController {
    constructor(sellersService) {
        this.sellersService = sellersService;
        console.log('üöÄ [DEBUG] SellersController initialized successfully!');
    }
    create(createSellerDto) {
        return this.sellersService.create(createSellerDto);
    }
    findAll(page, limit, search) {
        const query = {
            page: page ? parseInt(page) : 1,
            limit: limit ? parseInt(limit) : 10,
            search,
        };
        return this.sellersService.findAll(query);
    }
    async findBySlug(slug) {
        console.log('üîç [CONTROLLER] Getting seller by slug:', slug);
        const seller = await this.sellersService.findBySlug(slug);
        if (!seller) {
            throw new common_1.NotFoundException(`Seller with slug "${slug}" not found`);
        }
        return seller;
    }
    async getSellerProducts(slug, page = '1', limit = '12', category, difficulty, priceMin, priceMax, sortBy, search) {
        console.log('üîç [CONTROLLER] Getting products for seller:', slug);
        const seller = await this.sellersService.findBySlug(slug);
        if (!seller) {
            throw new common_1.NotFoundException(`Seller with slug "${slug}" not found`);
        }
        const pageNum = Math.max(1, parseInt(page) || 1);
        const limitNum = Math.min(50, Math.max(1, parseInt(limit) || 12));
        const priceMinNum = priceMin ? parseFloat(priceMin) : undefined;
        const priceMaxNum = priceMax ? parseFloat(priceMax) : undefined;
        const validSortOptions = ['newest', 'oldest', 'price_asc', 'price_desc', 'rating', 'popular'];
        const validSortBy = validSortOptions.includes(sortBy) ? sortBy : 'newest';
        const filters = {
            page: pageNum,
            limit: limitNum,
            category,
            difficulty,
            priceMin: priceMinNum,
            priceMax: priceMaxNum,
            sortBy: validSortBy,
            search,
        };
        console.log('üîç [CONTROLLER] Filters:', filters);
        try {
            const result = await this.sellersService.getSellerProducts(seller.userId, filters);
            console.log('‚úÖ [CONTROLLER] Found products:', result.total);
            return result;
        }
        catch (error) {
            console.error('‚ùå [CONTROLLER] Error getting seller products:', error);
            throw new common_1.InternalServerErrorException('Error retrieving seller products');
        }
    }
    findOne(id) {
        return this.sellersService.findOne(id);
    }
    update(id, updateSellerDto) {
        return this.sellersService.update(id, updateSellerDto);
    }
    remove(id) {
        return this.sellersService.remove(id);
    }
};
exports.SellersController = SellersController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new seller' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Seller created successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad request' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], SellersController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all sellers with pagination and stats' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number, description: 'Page number' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Items per page' }),
    (0, swagger_1.ApiQuery)({ name: 'search', required: false, type: String, description: 'Search term' }),
    __param(0, (0, common_1.Query)('page')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('search')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", void 0)
], SellersController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':slug'),
    (0, swagger_1.ApiOperation)({ summary: 'Get seller by slug' }),
    (0, swagger_1.ApiParam)({ name: 'slug', description: 'Seller slug' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Seller found' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Seller not found' }),
    __param(0, (0, common_1.Param)('slug')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], SellersController.prototype, "findBySlug", null);
__decorate([
    (0, common_1.Get)(':slug/products'),
    (0, swagger_1.ApiOperation)({ summary: 'Get products from a specific seller' }),
    (0, swagger_1.ApiParam)({ name: 'slug', description: 'Seller slug' }),
    (0, swagger_1.ApiQuery)({ name: 'page', required: false, type: Number, description: 'Page number' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Items per page' }),
    (0, swagger_1.ApiQuery)({ name: 'category', required: false, type: String, description: 'Product category' }),
    (0, swagger_1.ApiQuery)({ name: 'difficulty', required: false, type: String, description: 'Product difficulty' }),
    (0, swagger_1.ApiQuery)({ name: 'priceMin', required: false, type: Number, description: 'Minimum price' }),
    (0, swagger_1.ApiQuery)({ name: 'priceMax', required: false, type: Number, description: 'Maximum price' }),
    (0, swagger_1.ApiQuery)({ name: 'sortBy', required: false, type: String, description: 'Sort by field' }),
    (0, swagger_1.ApiQuery)({ name: 'search', required: false, type: String, description: 'Search term' }),
    __param(0, (0, common_1.Param)('slug')),
    __param(1, (0, common_1.Query)('page')),
    __param(2, (0, common_1.Query)('limit')),
    __param(3, (0, common_1.Query)('category')),
    __param(4, (0, common_1.Query)('difficulty')),
    __param(5, (0, common_1.Query)('priceMin')),
    __param(6, (0, common_1.Query)('priceMax')),
    __param(7, (0, common_1.Query)('sortBy')),
    __param(8, (0, common_1.Query)('search')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String, String, String, String, String, String]),
    __metadata("design:returntype", Promise)
], SellersController.prototype, "getSellerProducts", null);
__decorate([
    (0, common_1.Get)('id/:id'),
    (0, swagger_1.ApiOperation)({ summary: 'Get seller by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Seller ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Seller found' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Seller not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], SellersController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Update seller by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Seller ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Seller updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Seller not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], SellersController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete seller by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'Seller ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Seller deleted successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Seller not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], SellersController.prototype, "remove", null);
exports.SellersController = SellersController = __decorate([
    (0, swagger_1.ApiTags)('sellers'),
    (0, common_1.Controller)('sellers'),
    __metadata("design:paramtypes", [typeof (_a = typeof sellers_service_1.SellersService !== "undefined" && sellers_service_1.SellersService) === "function" ? _a : Object])
], SellersController);


/***/ }),
/* 305 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SellersService = void 0;
const common_1 = __webpack_require__(2);
const prisma_service_1 = __webpack_require__(10);
let SellersService = class SellersService {
    constructor(prisma) {
        this.prisma = prisma;
    }
    async create(createSellerDto) {
        const seller = await this.prisma.sellerProfile.create({
            data: createSellerDto,
            include: {
                user: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        avatar: true,
                        isActive: true,
                        createdAt: true,
                    },
                },
            },
        });
        return seller;
    }
    async findAll(query = {}) {
        const { page = 1, limit = 10, search } = query;
        const skip = (page - 1) * limit;
        const whereConditions = {
            ...(search && {
                OR: [
                    { storeName: { contains: search } },
                    { description: { contains: search } },
                    {
                        user: {
                            OR: [
                                { firstName: { contains: search } },
                                { lastName: { contains: search } },
                            ],
                        },
                    },
                ],
            }),
        };
        const [sellers, total] = await Promise.all([
            this.prisma.sellerProfile.findMany({
                where: whereConditions,
                include: {
                    user: {
                        select: {
                            id: true,
                            firstName: true,
                            lastName: true,
                            email: true,
                            avatar: true,
                            isActive: true,
                            createdAt: true,
                        },
                    },
                },
                orderBy: { createdAt: 'desc' },
                skip,
                take: limit,
            }),
            this.prisma.sellerProfile.count({
                where: whereConditions,
            }),
        ]);
        const sellersWithStats = await Promise.all(sellers.map(async (seller) => {
            const [productCount, avgRating, totalSales, totalReviews] = await Promise.all([
                this.prisma.product.count({
                    where: { sellerId: seller.userId, status: 'APPROVED' },
                }),
                this.prisma.product.aggregate({
                    where: { sellerId: seller.userId, status: 'APPROVED' },
                    _avg: { rating: true },
                }),
                this.prisma.order.count({
                    where: {
                        items: {
                            some: {
                                product: { sellerId: seller.userId },
                            },
                        },
                        status: 'COMPLETED',
                    },
                }),
                this.prisma.review.count({
                    where: {
                        product: { sellerId: seller.userId },
                    },
                }),
            ]);
            return {
                ...seller,
                stats: {
                    totalProducts: productCount,
                    avgRating: avgRating._avg.rating || 0,
                    totalSales,
                    totalReviews,
                },
            };
        }));
        const totalPages = Math.ceil(total / limit);
        const hasNext = page < totalPages;
        const hasPrev = page > 1;
        return {
            data: sellersWithStats,
            total,
            page,
            limit,
            totalPages,
            hasNext,
            hasPrev,
        };
    }
    async findOne(id) {
        const seller = await this.prisma.sellerProfile.findUnique({
            where: { id },
            include: {
                user: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        avatar: true,
                        isActive: true,
                        createdAt: true,
                    },
                },
            },
        });
        if (!seller) {
            throw new common_1.NotFoundException(`Seller with ID "${id}" not found`);
        }
        const [productCount, avgRating, totalSales, totalReviews] = await Promise.all([
            this.prisma.product.count({
                where: { sellerId: seller.userId, status: 'APPROVED' },
            }),
            this.prisma.product.aggregate({
                where: { sellerId: seller.userId, status: 'APPROVED' },
                _avg: { rating: true },
            }),
            this.prisma.order.count({
                where: {
                    items: {
                        some: {
                            product: { sellerId: seller.userId },
                        },
                    },
                    status: 'COMPLETED',
                },
            }),
            this.prisma.review.count({
                where: {
                    product: { sellerId: seller.userId },
                },
            }),
        ]);
        return {
            ...seller,
            stats: {
                totalProducts: productCount,
                avgRating: avgRating._avg.rating || 0,
                totalSales,
                totalReviews,
            },
        };
    }
    async findBySlug(slug) {
        console.log('üîç [SERVICE] Finding seller by slug:', slug);
        const seller = await this.prisma.sellerProfile.findUnique({
            where: { slug },
            include: {
                user: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        avatar: true,
                        isActive: true,
                        createdAt: true,
                    },
                },
            },
        });
        if (!seller) {
            console.log('‚ùå [SERVICE] Seller not found with slug:', slug);
            return null;
        }
        console.log('‚úÖ [SERVICE] Found seller:', seller.storeName);
        const [productCount, avgRating, totalSales, totalReviews] = await Promise.all([
            this.prisma.product.count({
                where: { sellerId: seller.userId, status: 'APPROVED' },
            }),
            this.prisma.product.aggregate({
                where: { sellerId: seller.userId, status: 'APPROVED' },
                _avg: { rating: true },
            }),
            this.prisma.order.count({
                where: {
                    items: {
                        some: {
                            product: { sellerId: seller.userId },
                        },
                    },
                    status: 'COMPLETED',
                },
            }),
            this.prisma.review.count({
                where: {
                    product: { sellerId: seller.userId },
                },
            }),
        ]);
        return {
            ...seller,
            stats: {
                totalProducts: productCount,
                avgRating: avgRating._avg.rating || 0,
                totalSales,
                totalReviews,
            },
        };
    }
    async getSellerProducts(sellerId, filters) {
        console.log('üîç [SERVICE] Getting products for seller:', sellerId, 'with filters:', filters);
        const { page = 1, limit = 12, category, difficulty, priceMin, priceMax, sortBy = 'newest', search, } = filters;
        const whereConditions = {
            sellerId: sellerId,
            status: 'APPROVED',
            ...(category && { category }),
            ...(difficulty && { difficulty }),
            ...(priceMin && { price: { gte: priceMin } }),
            ...(priceMax && {
                price: priceMin
                    ? { gte: priceMin, lte: priceMax }
                    : { lte: priceMax }
            }),
            ...(search && {
                OR: [
                    { title: { contains: search } },
                    { description: { contains: search } },
                    { tags: { contains: search } },
                ],
            }),
        };
        let orderBy = { createdAt: 'desc' };
        switch (sortBy) {
            case 'oldest':
                orderBy = { createdAt: 'asc' };
                break;
            case 'price_asc':
                orderBy = { price: 'asc' };
                break;
            case 'price_desc':
                orderBy = { price: 'desc' };
                break;
            case 'rating':
                orderBy = { rating: 'desc' };
                break;
            case 'popular':
                orderBy = { viewCount: 'desc' };
                break;
            default:
                orderBy = { createdAt: 'desc' };
        }
        const skip = (page - 1) * limit;
        const [products, total] = await Promise.all([
            this.prisma.product.findMany({
                where: whereConditions,
                include: {
                    seller: {
                        select: {
                            id: true,
                            avatar: true,
                        },
                    },
                },
                orderBy,
                skip,
                take: limit,
            }),
            this.prisma.product.count({
                where: whereConditions,
            }),
        ]);
        console.log('‚úÖ [SERVICE] Found products:', products.length, 'of', total);
        const totalPages = Math.ceil(total / limit);
        const hasNext = page < totalPages;
        const hasPrev = page > 1;
        return {
            data: products,
            total,
            page,
            limit,
            totalPages,
            hasNext,
            hasPrev,
        };
    }
    async update(id, updateSellerDto) {
        const seller = await this.prisma.sellerProfile.findUnique({
            where: { id },
        });
        if (!seller) {
            throw new common_1.NotFoundException(`Seller with ID "${id}" not found`);
        }
        return this.prisma.sellerProfile.update({
            where: { id },
            data: updateSellerDto,
            include: {
                user: {
                    select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        avatar: true,
                        isActive: true,
                        createdAt: true,
                    },
                },
            },
        });
    }
    async remove(id) {
        const seller = await this.prisma.sellerProfile.findUnique({
            where: { id },
        });
        if (!seller) {
            throw new common_1.NotFoundException(`Seller with ID "${id}" not found`);
        }
        return this.prisma.sellerProfile.delete({
            where: { id },
        });
    }
};
exports.SellersService = SellersService;
exports.SellersService = SellersService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof prisma_service_1.PrismaService !== "undefined" && prisma_service_1.PrismaService) === "function" ? _a : Object])
], SellersService);


/***/ }),
/* 306 */
/***/ ((module) => {

"use strict";
module.exports = require("compression");

/***/ }),
/* 307 */
/***/ ((module) => {

"use strict";
module.exports = require("cookie-parser");

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(0);
/******/ 	
/******/ })()
;