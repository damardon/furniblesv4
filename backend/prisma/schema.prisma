// prisma/schema.prisma - Versión Corregida Etapa 7
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  BUYER
  SELLER
  ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum ProductStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}

enum ProductCategory {
  FURNITURE
  CHAIRS
  TABLES
  BEDS
  STORAGE
  OUTDOOR
  DECORATIVE
  KITCHEN
  OFFICE
}

enum Difficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

// 🆕 Estados de orden actualizados
enum OrderStatus {
  PENDING      // Orden creada, esperando pago
  PROCESSING   // Pago recibido, procesando archivos
  PAID         // Pago confirmado por Stripe
  COMPLETED    // Archivos enviados y disponibles
  CANCELLED    // Cancelada antes del pago
  REFUNDED     // Reembolso procesado
  DISPUTED     // En disputa
}

// 🆕 Enums para archivos
enum FileType {
  PDF
  IMAGE
  THUMBNAIL
}

enum FileStatus {
  UPLOADING
  PROCESSING
  ACTIVE
  FAILED
  DELETED
}

// 🆕 Enums para notificaciones
enum NotificationType {
  ORDER_CREATED
  ORDER_PAID
  ORDER_COMPLETED
  ORDER_CANCELLED
  ORDER_DISPUTED
  ORDER_REFUNDED
  PRODUCT_SOLD
  DOWNLOAD_READY
  SYSTEM_NOTIFICATION
}

// 🆕 Enums para configuración de fees
enum FeeType {
  PLATFORM_FEE
  PAYMENT_PROCESSING
  TAX
  REGIONAL_FEE
}

// Models
model User {
  id                     String     @id @default(cuid())
  email                  String     @unique
  password               String
  name                   String
  role                   UserRole   @default(BUYER)
  isBoth                 Boolean    @default(false)
  firstName              String
  lastName               String
  emailVerified          Boolean    @default(false)
  emailVerificationToken String?    @unique
  emailVerifiedAt        DateTime?
  resetPasswordToken     String?    @unique
  resetPasswordExpiresAt DateTime?
  lastLoginAt            DateTime?
  isActive               Boolean    @default(true)
  status                 UserStatus @default(ACTIVE)
  avatar                 String?
  createdAt              DateTime   @default(now())
  updatedAt              DateTime   @updatedAt

  // Perfiles
  sellerProfile SellerProfile?
  buyerProfile  BuyerProfile?

  // Activity Relations
  products          Product[]
  orders            Order[]
  reviews           Review[]
  favorites         Favorite[]
  chatMessages      ChatMessage[]
  supportTickets    SupportTicket[]
  notifications     Notification[]
  downloads         Download[]
  blacklistedTokens BlacklistedToken[]
  uploadedFiles     File[]

  // 🆕 Relaciones del carrito
  cartItems         CartItem[]

  // 🆕 Relaciones de órdenes
  orderItems        OrderItem[] @relation("OrderSeller")
  downloadTokens    DownloadToken[] @relation("TokenBuyer")

  // Moderation Relations
  moderatedProducts Product[] @relation("ModeratedBy")

  @@map("User")
}

model SellerProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  storeName   String   @unique
  slug        String   @unique
  description String?
  website     String?
  phone       String?
  avatar      String?
  banner      String?
  rating      Float    @default(0)
  totalSales  Int      @default(0)
  isVerified  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("SellerProfile")
}

model BuyerProfile {
  id          String    @id @default(cuid())
  userId      String    @unique
  avatar      String?
  phone       String?
  dateOfBirth DateTime?
  preferences Json?
  totalOrders Int       @default(0)
  totalSpent  Float     @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("BuyerProfile")
}

// 🆕 Configuración de fees
model feeConfig {
  id            String   @id @default(cuid())
  name          String   // "Platform Fee Argentina", "PayPal Processing Fee"
  type          FeeType
  country       String?  // "AR", "US", "MX", null para global
  region        String?  // "LATAM", "EU", null para específico
  category      ProductCategory? // Fee específico por categoría
  paymentMethod String?  // "stripe", "paypal", "mercadopago"
  
  // Configuración del fee
  isPercentage  Boolean  @default(true)
  value         Float    // 0.10 para 10% o 2.50 para $2.50 fijo
  minAmount     Float?   // Mínimo fee a cobrar
  maxAmount     Float?   // Máximo fee a cobrar
  
  // Control
  isActive      Boolean  @default(true)
  priority      Int      @default(0) // Para resolver conflictos
  description   String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([country, isActive])
  @@index([type, isActive])
  @@index([category, isActive])
  @@map("feeConfig")
}

// 🆕 Carrito de compras
model CartItem {
  id            String   @id @default(cuid())
  userId        String
  productId     String
  priceSnapshot Float    // Precio al momento de agregar al carrito
  quantity      Int      @default(1) // Siempre 1 para productos digitales
  addedAt       DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relaciones
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // Un producto por usuario en carrito
  @@index([userId])
  @@map("CartItem")
}

model File {
  id       String     @id @default(cuid())
  filename String
  key      String     @unique
  url      String
  mimeType String
  size     Int
  type     FileType
  status   FileStatus @default(UPLOADING)

  // Metadata adicional
  width    Int?
  height   Int?
  checksum String?
  metadata Json?

  // Relaciones
  uploadedById String
  uploadedBy   User   @relation(fields: [uploadedById], references: [id])

  // Relaciones con productos
  productPdfs   Product[] @relation("ProductPDF")
  productImages Product[] @relation("ProductImages")
  productThumbs Product[] @relation("ProductThumbnails")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([uploadedById])
  @@index([type, status])
  @@index([key])
  @@map("File")
}

model Product {
  id          String          @id @default(cuid())
  title       String          @db.VarChar(100)
  description String          @db.VarChar(2000)
  slug        String          @unique @db.VarChar(120)
  price       Float           @default(5.00)
  category    ProductCategory
  difficulty  Difficulty
  status      ProductStatus   @default(DRAFT)

  // Archivos
  pdfFileId        String?
  pdfFile          File?    @relation("ProductPDF", fields: [pdfFileId], references: [id])
  imageFileIds     String[] @default([])
  imageFiles       File[]   @relation("ProductImages")
  thumbnailFileIds String[] @default([])
  thumbnailFiles   File[]   @relation("ProductThumbnails")

  // Metadata del producto
  tags           String[] @default([])
  estimatedTime  String?  @db.VarChar(50)
  toolsRequired  String[] @default([])
  materials      String[] @default([])
  dimensions     String?  @db.VarChar(100)
  specifications Json?

  // Moderación
  moderatedBy     String?
  moderatedAt     DateTime?
  rejectionReason String?

  // Relaciones
  sellerId  String
  seller    User   @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  moderator User?  @relation("ModeratedBy", fields: [moderatedBy], references: [id])

  // Estadísticas
  viewCount     Int     @default(0)
  downloadCount Int     @default(0)
  favoriteCount Int     @default(0)
  featured      Boolean @default(false)
  rating        Float   @default(0)
  reviewCount   Int     @default(0)

  // Timestamps
  createdAt   DateTime  @default(now())
  publishedAt DateTime?
  updatedAt   DateTime  @updatedAt

  // 🆕 Relaciones del carrito y órdenes
  cartItems    CartItem[]
  orderItems   OrderItem[]
  downloads    Download[]
  downloadTokens DownloadToken[]

  // Relaciones existentes
  reviews      Review[]
  favorites    Favorite[]
  ProductImage ProductImage[]

  @@index([status, createdAt])
  @@index([category, difficulty])
  @@index([category, status])
  @@index([sellerId, status])
  @@index([featured, publishedAt])
  @@index([slug])
  @@map("Product")
}

model ProductImage {
  id        String   @id @default(cuid())
  productId String
  url       String
  alt       String?
  order     Int      @default(0)
  createdAt DateTime @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@map("ProductImage")
}

// 🆕 Modelo de órdenes actualizado
model Order {
  id              String      @id @default(cuid())
  orderNumber     String      @unique // ORD-20250622-001
  buyerId         String
  
  // Precios y fees
  subtotal        Float       // Suma de precios de productos
  platformFeeRate Float       @default(0.10) // Rate aplicado (10%)
  platformFee     Float       // Fee calculado
  totalAmount     Float       // Total que paga el buyer
  sellerAmount    Float       // Total que recibe el seller (subtotal - platformFee)
  
  // Estado y pago
  status          OrderStatus @default(PENDING)
  paymentIntentId String?     // Stripe Payment Intent ID
  paymentStatus   String?     // Stripe payment status
  
  // Información del comprador
  buyerEmail      String      // Email para envío (puede ser diferente al user.email)
  billingData     Json?       // Datos de facturación si es necesario
  
  // Metadata
  metadata        Json?       // Información adicional
  feeBreakdown    Json?       // Desglose detallado de fees aplicados
  
  // Timestamps
  createdAt       DateTime    @default(now())
  paidAt          DateTime?   // Cuando se confirmó el pago
  completedAt     DateTime?   // Cuando se entregaron los archivos
  cancelledAt     DateTime?   // Cuando se canceló
  updatedAt       DateTime    @updatedAt

  // Relaciones
  buyer           User         @relation(fields: [buyerId], references: [id])
  items           OrderItem[]
  downloads       Download[]
  downloadTokens  DownloadToken[]
  reviews         Review[]
  notifications   Notification[]

  @@index([status, createdAt])
  @@index([buyerId])
  @@index([orderNumber])
  @@index([paymentIntentId])
  @@map("Order")
}

// 🆕 Items de orden actualizado
model OrderItem {
  id           String @id @default(cuid())
  orderId      String
  productId    String
  sellerId     String // ID del seller de este producto específico
  
  // Snapshot de datos al momento de la compra
  productTitle String
  productSlug  String
  price        Float  // Precio del producto al momento de la compra
  quantity     Int    @default(1) // Siempre 1 para productos digitales
  
  // Datos del seller al momento de la compra
  sellerName   String
  storeName    String?
  
  createdAt    DateTime @default(now())

  // Relaciones
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])
  seller  User    @relation("OrderSeller", fields: [sellerId], references: [id])

  @@index([orderId])
  @@index([sellerId])
  @@map("OrderItem")
}

// 🆕 Tokens de descarga seguros
model DownloadToken {
  id              String    @id @default(cuid())
  token           String    @unique @default(cuid()) // Token único para la descarga
  orderId         String
  productId       String
  buyerId         String
  
  // Control de descargas
  downloadLimit   Int       @default(5)     // Límite de descargas
  downloadCount   Int       @default(0)     // Descargas realizadas
  expiresAt       DateTime  // Fecha de expiración del token
  isActive        Boolean   @default(true)  // Si el token está activo
  
  // Tracking
  createdAt       DateTime  @default(now())
  lastDownloadAt  DateTime? // Última descarga
  lastIpAddress   String?   // IP de la última descarga
  lastUserAgent   String?   // User agent de la última descarga
  
  // Relaciones
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])
  buyer   User    @relation("TokenBuyer", fields: [buyerId], references: [id])

  @@index([token])
  @@index([orderId])
  @@index([buyerId])
  @@index([expiresAt, isActive])
  @@map("DownloadToken")
}

model Download {
  id             String    @id @default(cuid())
  downloadToken  String    @unique
  orderId        String
  productId      String
  buyerId        String
  expiresAt      DateTime
  downloadCount  Int       @default(0)
  maxDownloads   Int       @default(10)
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())
  lastDownloadAt DateTime?
  ipAddress      String?
  userAgent      String?

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])
  buyer   User    @relation(fields: [buyerId], references: [id])

  @@index([downloadToken])
  @@index([buyerId])
  @@map("Download")
}

model Review {
  id         String   @id @default(cuid())
  orderId    String
  productId  String
  buyerId    String
  rating     Int
  comment    String?
  images     String[]
  isVerified Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])
  buyer   User    @relation(fields: [buyerId], references: [id])

  @@unique([orderId, productId])
  @@index([productId, rating])
  @@map("Review")
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  productId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
  @@map("Favorite")
}

model ChatRoom {
  id        String   @id @default(cuid())
  type      String
  name      String?
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages ChatMessage[]

  @@map("ChatRoom")
}

model ChatMessage {
  id       String   @id @default(cuid())
  roomId   String
  senderId String
  content  String
  type     String   @default("text")
  metadata Json?
  sentAt   DateTime @default(now())

  room   ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  sender User     @relation(fields: [senderId], references: [id])

  @@index([roomId, sentAt])
  @@map("ChatMessage")
}

model SupportTicket {
  id           String   @id @default(cuid())
  ticketNumber String   @unique
  userId       String
  subject      String
  description  String
  status       String   @default("open")
  priority     String   @default("normal")
  assignedTo   String?
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([status, priority])
  @@map("SupportTicket")
}

// 🆕 Sistema de notificaciones actualizado
model Notification {
  id          String           @id @default(cuid())
  userId      String
  type        NotificationType
  title       String
  message     String
  data        Json?            // Datos adicionales (orderId, productId, etc.)
  
  // Control de lectura y envío
  isRead      Boolean          @default(false)
  readAt      DateTime?
  sentAt      DateTime?        // Cuando se envió el email
  emailSent   Boolean          @default(false)
  
  // Relaciones opcionales
  orderId     String?
  order       Order?           @relation(fields: [orderId], references: [id])
  
  createdAt   DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([type, createdAt])
  @@index([orderId])
  @@map("Notification")
}

model Analytics {
  id        String   @id @default(cuid())
  eventType String
  userId    String?
  productId String?
  sessionId String?
  eventData Json
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@index([eventType, createdAt])
  @@index([userId])
  @@index([productId])
  @@map("Analytics")
}

model BlacklistedToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@index([userId])
  @@map("BlacklistedToken")
}